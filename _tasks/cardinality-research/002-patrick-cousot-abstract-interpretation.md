# Анализ кардинальности для оценки сложности: Перспектива абстрактной интерпретации

**Автор:** Patrick Cousot
**Дата:** 2 февраля 2026
**Контекст:** Исследовательский отчёт для проекта Grafema

---

## 1. Постановка задачи

### 1.1 Мотивация

Проблема, которую вы описываете, является классической в статическом анализе: **определение вычислительной сложности программы** на основе анализа её структуры. Конкретный случай — обнаружение ситуации, когда алгоритм O(n) применяется ко всему множеству узлов проекта (~10M), хотя должен работать только с малым подмножеством.

Это задача **анализа размерности данных** (cardinality analysis), которая тесно связана с:
- Анализом стоимости (cost analysis)
- Анализом ресурсов (resource analysis)
- Анализом завершимости (termination analysis)

### 1.2 Формализация

Пусть программа P оперирует коллекциями. Каждая коллекция c имеет кардинальность |c| — число элементов. Нас интересует:

1. **Оценка кардинальности** переменных в каждой точке программы
2. **Вычисление сложности** операций как функции от кардинальностей
3. **Обнаружение аномалий** — когда сложность превышает ожидания

---

## 2. Выбор абстрактного домена

### 2.1 Анализ вариантов

#### Вариант A: Интервальный домен [a, b]

**Преимущества:**
- Хорошо изучен, стандартные операции
- Точные границы для линейных операций

**Недостатки:**
- Быстрое расширение при умножении: [1, 10K] × [1, 10K] = [1, 100M]
- Потеря семантической информации о природе данных
- Сложности с верхней границей при фильтрации

#### Вариант B: Символьный домен (выражения)

**Преимущества:**
- Максимальная точность: O(n × m) сохраняется как есть
- Можно отслеживать зависимости

**Недостатки:**
- Экспоненциальный рост выражений
- Сложность упрощения и сравнения
- Неопределённость при условных переходах

#### Вариант C: Категориальный домен со шкалами

**Преимущества:**
- Семантически значимые категории (files, nodes, routes)
- Простое рассуждение: "итерация по nodes вложенная в итерацию по files = O(files × nodes)"
- Естественное соответствие ментальной модели разработчика

**Недостатки:**
- Грубость — теряем точные числа
- Нужны правила взаимодействия между шкалами

### 2.2 Рекомендация: Гибридный категориально-интервальный домен

Предлагаю **двухуровневый домен**:

```
Cardinality ::= (Scale, Interval, Confidence)

где:
  Scale    ∈ {constant, config, routes, files, functions, nodes, unbounded}
  Interval ∈ [lo, hi] ⊆ ℕ ∪ {∞}
  Confidence ∈ {exact, upper_bound, estimate}
```

**Порядок шкал (решётка):**
```
         unbounded
              |
           nodes (~10M)
              |
        functions (~100K)
              |
           files (~10K)
              |
          routes (~5K)
              |
          config (~100)
              |
         constant (~10)
              |
             ⊥
```

**Обоснование:** Шкала даёт семантический контекст, интервал — численную точность когда она известна, confidence — степень уверенности в оценке.

---

## 3. Правила распространения (Transfer Functions)

### 3.1 Базовые операции

#### Фильтрация: filter(c, predicate)
```
filter: Cardinality → Cardinality
filter((s, [lo, hi], conf)) = (s, [0, hi], upper_bound)
```

**Обоснование:** Фильтр сохраняет шкалу (отфильтрованные nodes остаются nodes), но верхняя граница становится оценкой сверху. Нижняя граница обнуляется (предикат может отбросить всё).

#### Плоское отображение: flatMap(c, f)
```
flatMap: Cardinality × Cardinality → Cardinality
flatMap((s1, [lo1, hi1], c1), (s2, [lo2, hi2], c2)) =
  (s1 ⊔ s2, [lo1 × lo2, hi1 × hi2], min(c1, c2))
```

где ⊔ — операция join в решётке шкал.

#### Отображение: map(c, f)
```
map: Cardinality → Cardinality
map((s, [lo, hi], conf)) = (s, [lo, hi], conf)  // сохраняет кардинальность
```

#### Объединение: union(c1, c2)
```
union: Cardinality × Cardinality → Cardinality
union((s1, [lo1, hi1], c1), (s2, [lo2, hi2], c2)) =
  (s1 ⊔ s2, [max(lo1, lo2), hi1 + hi2], min(c1, c2))
```

### 3.2 Сложные паттерны

#### Вложенный цикл
```
for x in collection1:        // |collection1| = (s1, [lo1, hi1])
  for y in collection2(x):   // |collection2| = (s2, [lo2, hi2])
    process(x, y)

Complexity = (s1 ⊔ s2, [lo1 × lo2, hi1 × hi2], ...)
```

#### Рекурсия
Рекурсивный случай требует **widening** для гарантии завершения анализа:

```
widen((s, [lo1, hi1]), (s, [lo2, hi2])) =
  (s, [min(lo1, lo2), если hi2 > hi1 то ∞ иначе hi1])
```

---

## 4. Анализ корректности

### 4.1 Soundness (Корректность)

**Теорема (Soundness):** Если анализ выдаёт оценку сложности O(f(n)), то реальная сложность ≤ c × f(n) для некоторой константы c.

**Доказательство (набросок):**
Требуется показать, что абстрактная семантика — **безопасная аппроксимация** конкретной:

```
∀ программа P, ∀ вход σ:
  concrete_complexity(P, σ) ≤ abstract_complexity(T⟦P⟧)
```

### 4.2 Completeness (Полнота)

**Полнота не гарантируется и не должна быть целью.**

Причины:
1. Проблема остановки — точное определение кардинальности неразрешимо
2. Зависимость от данных — фактическая селективность filter зависит от входа
3. Алиасинг — одни и те же данные могут быть доступны через разные пути

**Практический подход:** Оптимизировать на типичные паттерны, давать предупреждения с confidence level.

### 4.3 Трейдоффы

| Аспект | Больше Soundness | Больше Precision |
|--------|------------------|------------------|
| filter | Всегда [0, n] | Использовать аннотации selectivity |
| flatMap | Умножать верхние границы | Учитывать корреляции |
| Рекурсия | Быстрый widening к ∞ | Счётчики итераций |
| Алиасы | Считать независимыми | Alias analysis |

---

## 5. Практические рекомендации

### 5.1 Архитектура системы

```
┌─────────────────────────────────────────────────────────┐
│                    User/Plugin Layer                     │
│  - Аннотации источников: @cardinality(nodes, ~10M)      │
│  - Аннотации операций: @selectivity(0.01)               │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                    Core Analysis                         │
│  - Propagation engine (transfer functions)              │
│  - Fixpoint computation                                 │
│  - Complexity calculation                               │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                    Warning System                        │
│  - Threshold comparison                                  │
│  - Confidence-aware reporting                           │
│  - Explanation generation                               │
└─────────────────────────────────────────────────────────┘
```

### 5.2 Пошаговый план реализации

**Фаза 1: Базовый каркас**
1. Определить тип Cardinality и решётку шкал
2. Реализовать базовые transfer functions (filter, map, flatMap)
3. Добавить механизм аннотаций для источников данных

**Фаза 2: Пропагация**
1. Реализовать forward dataflow analysis
2. Добавить widening для циклов
3. Обработка условных переходов

**Фаза 3: Детектирование проблем**
1. Определить пороги для предупреждений
2. Реализовать генерацию объяснений
3. Интеграция с системой предупреждений Grafema

**Фаза 4: Уточнения**
1. Аннотации селективности для filter
2. Поддержка пользовательских шкал
3. Межпроцедурный анализ

---

## 6. Заключение

Предложенный подход к анализу кардинальности основан на солидном теоретическом фундаменте абстрактной интерпретации. Ключевые рекомендации:

1. **Гибридный домен** (категории + интервалы) даёт лучший баланс точности и семантической значимости

2. **Soundness важнее completeness** — лучше выдать ложное предупреждение, чем пропустить реальную проблему

3. **Confidence levels** позволяют пользователю понимать надёжность оценки

4. **Инкрементальная реализация** — начать с простого и добавлять точность по мере необходимости

5. **Аннотации** — критически важны для практической точности; система без аннотаций будет слишком грубой

Формально, предложенная система образует **Galois connection** между конкретным доменом (множества элементов с точными размерами) и абстрактным доменом (кардинальности со шкалами и интервалами), что гарантирует корректность анализа.

---

*Patrick Cousot*
*Февраль 2026*
