# T5.1: Enrichment Virtual Shards (Track 1, Rust)

> Milestone: M5 (Enrichment Pipeline)
> Dependencies: T4.1 (Working v2 engine)
> Estimated: ~700 LOC, ~18 tests
> Related docs: [005-orchestrator-design.md](../005-orchestrator-design.md) §3.3, [004-expert-concerns.md](../004-expert-concerns.md) I2

---

## High-Level Context

Analysis edges live in file shards (src node's file → shard). Enrichment edges need a different ownership model — they belong to the **enricher** that created them, not to the file being analyzed.

`__enrichment__/{enricher}/{file}` — composite file context for enrichment edges. This allows surgical deletion: "delete all edges ImportExportLinker created for src/app.js" without touching any other edges.

---

## Design

### Composite File Context

When orchestrator commits enrichment edges, it uses:
```
file_context = "__enrichment__/ImportExportLinker/src/app.js"
```

RFDB treats this as a shard key:
- Shard: `shards/__enrichment__/ImportExportLinker/` (or hashed to shorter name)
- Segments within: one per enrichment batch per source file

### CommitBatch with Enrichment Context

```rust
CommitBatch {
  // file_context is explicit in the request
  file_context: Option<String>,  // "__enrichment__/ImportExportLinker/src/app.js"
  tags: Option<HashMap<String, String>>,
}
```

**Wire protocol Request variant:**

```rust
// In Request enum (rfdb_server.rs):
CommitBatch {
    file_context: Option<String>,   // NEW: enrichment shard context
    tags: Option<HashMap<String, String>>,
    request_id: Option<String>,
}
```

Client sends `file_context` as part of the CommitBatch request. If present, server routes to enrichment shard instead of file-based grouping. The TS client API:

```typescript
await client.commitBatch({
  fileContext: '__enrichment__/ImportExportLinker/src/app.js',
  tags: { phase: 'enrichment' },
});
```

If `file_context` is set:
- Tombstone all existing nodes/edges with that context
- Write new nodes/edges to that context's shard
- Regular file-based grouping skipped

If `file_context` is None:
- Normal behavior (group by node.file field)

### Surgical Deletion

```
Re-enrich ImportExportLinker for src/app.js:
1. CommitBatch(file_context="__enrichment__/ImportExportLinker/src/app.js", edges=[...])
2. RFDB tombstones all old edges in that context
3. Writes new edges
4. Other enrichers' edges for src/app.js UNTOUCHED
```

---

## Critical Nuances

### 1. Enrichment Edges in Queries

Enrichment edges are stored in separate shards but must be visible in normal edge queries:
- `get_outgoing_edges(src)` → must fan-out to enrichment shards too
- Bloom filter on enrichment edge segments → efficient

### 2. Shard Naming for Enrichment

`__enrichment__/ImportExportLinker/src/app.js` is a long path. Options:
- A. Use as-is (nested directories)
- B. Hash to shorter name: `__e/xxxx` where xxxx = hash of full context

**Recommendation:** A (use as-is). File system handles deep paths fine. Readability helps debugging.

### 3. No Collision Between Analysis and Enrichment

Analysis shard: `shards/src_auth/`
Enrichment shard: `shards/__enrichment__/ImportExportLinker/`

Prefix `__enrichment__` ensures no collision with directory-based analysis shards.

---

## Test Plan

1. `enrichment_shard_created` — commit with enrichment context → shard exists
2. `enrichment_edges_queryable` — enrichment edges visible in get_outgoing_edges
3. `surgical_deletion` — re-commit enrichment → only old enrichment edges replaced
4. `analysis_edges_untouched` — enrichment commit → analysis edges still present
5. `different_enrichers_independent` — enricher A and B for same file → independent
6. `enrichment_plus_analysis_merge` — get_outgoing → both analysis and enrichment edges
7. `incremental_re_enrichment` — re-enrich = same as full re-enrich (correctness)
8-18. Additional edge cases: empty enrichment, multiple files per enricher, cross-file enrichment edges, etc.
