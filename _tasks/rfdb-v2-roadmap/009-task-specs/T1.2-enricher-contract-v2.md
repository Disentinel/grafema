# T1.2: Enricher Contract v2 (Track 2, TS)

> Milestone: M1 (Foundation)
> Dependencies: none
> Estimated: ~400 LOC, ~20 tests
> Related docs: [005-orchestrator-design.md](../005-orchestrator-design.md) §4-5, [004-expert-concerns.md](../004-expert-concerns.md) I2/I5, [002-roadmap.md](../002-roadmap.md) §2

---

## High-Level Context

Это **фундамент инкрементального enrichment**. Сейчас enrichment pipeline = "запусти все 14 enrichers на весь граф". Selective re-enrichment невозможен, потому что:

1. Enrichers не декларируют что они **потребляют** (только `dependencies` на уровне плагинов)
2. Enrichers не декларируют что они **производят** (только `creates.edges` — неполно)
3. Нет file-scoped processing — enricher получает весь граф и работает со всем
4. Оркестратор не может построить enricher dependency graph по типам рёбер
5. `IncrementalReanalyzer.ts` hardcodes 2 enrichers (ImportExportLinker, InstanceOfResolver)

T1.2 решает пункты 1-4, создавая новый контракт `EnricherV2` который:
- Декларирует `consumes: EdgeType[]` и `produces: EdgeType[]`
- Предоставляет `relevantFiles(delta)` для scoping
- Предоставляет `processFile(file, graph)` для file-scoped execution
- Позволяет оркестратору автоматически строить dependency graph

**Критически важно:** эта задача **не зависит от RFDB v2**. Всё на стороне TS, можно начинать сразу.

---

## Existing Code to Study

| File | What to learn |
|------|--------------|
| `packages/core/src/plugins/Plugin.ts` | Plugin base class, `metadata`, `execute()`, `IPlugin` interface |
| `packages/types/src/plugins.ts` | `PluginMetadata`, `PluginContext`, `PluginResult`, `FieldDeclaration` |
| `packages/core/src/Orchestrator.ts` (~1248 LOC) | 5-phase pipeline, topological sort, phase execution |
| `packages/core/src/core/IncrementalReanalyzer.ts` (~196 LOC) | Current incremental logic (hardcoded 2 enrichers) |
| `packages/core/src/core/GraphBackend.ts` | Abstract GraphBackend, `addEdge()`, `queryNodes()` |
| `packages/core/src/plugins/enrichment/ImportExportLinker.ts` | Typical enricher pattern: build index → query → add edges |
| `packages/core/src/plugins/enrichment/FunctionCallResolver.ts` | Complex enricher: import chains, resolution logic |
| `packages/core/src/plugins/enrichment/MethodCallResolver.ts` | Method call resolution |
| `packages/core/src/plugins/enrichment/ClosureCaptureEnricher.ts` | Closure capture analysis |
| `packages/core/src/plugins/enrichment/ArgumentParameterLinker.ts` | Arg→param mapping |
| `packages/core/src/plugins/enrichment/AliasTracker.ts` | Variable alias tracking |
| `packages/core/src/plugins/enrichment/ValueDomainAnalyzer.ts` | Global value analysis (cross-file!) |

---

## New & Modified Files

```
packages/types/src/plugins.ts        ← ADD: EnricherV2, EnricherMetadata, EnricherFileResult, CommitDelta
packages/core/src/plugins/Plugin.ts  ← No changes needed
packages/core/src/plugins/
  enrichment/
    V1EnricherAdapter.ts             ← NEW: wraps legacy Plugin as EnricherV2
    enricher-registry.ts             ← NEW: enricher consumes/produces audit results
    enricher-graph.ts                ← NEW: builds dependency graph from metadata
```

---

## Interfaces

### EnricherV2

```typescript
/**
 * New enricher contract for RFDB v2 incremental pipeline.
 *
 * Key differences from Plugin.execute():
 * 1. File-scoped: processFile() handles one file at a time
 * 2. Declarative I/O: consumes/produces enable automatic dependency graph
 * 3. Orchestrator owns commit: enricher returns data, doesn't write to graph directly
 * 4. Scoping: relevantFiles() tells orchestrator which files matter for this enricher
 */
interface EnricherV2 {
  metadata: EnricherMetadata;

  /**
   * Given a commit delta, which files should this enricher process?
   *
   * Default implementation: all changed files.
   * Override for smarter scoping, e.g.:
   * - ImportExportLinker: changed files + files importing changed files
   * - FunctionCallResolver: files with unresolved CALL nodes
   *
   * @param delta - What changed in the last commit
   * @param graph - Read-only graph access for queries
   * @returns File paths this enricher needs to process
   */
  relevantFiles(delta: CommitDelta, graph: GraphBackend): Promise<string[]>;

  /**
   * Process one file. Returns edges (and optionally nodes) to commit.
   *
   * Enricher MUST NOT call graph.addEdge() directly.
   * Orchestrator will commit returned edges to __enrichment__/{name}/{file}.
   *
   * @param file - File path to process
   * @param graph - Read-only graph access for queries
   * @returns Edges and optional nodes produced for this file
   */
  processFile(file: string, graph: GraphBackend): Promise<EnricherFileResult>;
}
```

### EnricherMetadata

```typescript
interface EnricherMetadata extends PluginMetadata {
  /**
   * Edge types this enricher READS from the graph.
   * Used to build dependency graph: if enricher A produces X,
   * and enricher B consumes X, then B depends on A.
   *
   * "Consumes" also includes node types queried. But since analysis
   * creates all node types before enrichment, only edge types matter
   * for enricher-to-enricher dependencies.
   */
  consumes: EdgeType[];

  /**
   * Edge types this enricher WRITES to the graph.
   * Must match creates.edges (but creates.edges is optional in PluginMetadata).
   * This field is REQUIRED for EnricherV2.
   */
  produces: EdgeType[];
}
```

**Nuance:** `consumes` только для edge types, не для node types. Причина: все node types создаются в ANALYSIS фазе (до enrichment). Enricher-to-enricher зависимости определяются только edge types — enricher A создаёт IMPORTS_FROM, enricher B читает IMPORTS_FROM → B зависит от A.

### EnricherFileResult

```typescript
interface EnricherFileResult {
  /** Edges produced for this file. Orchestrator commits them. */
  edges: InputEdge[];

  /** Optional: nodes to create (ISSUE, EXTERNAL_MODULE, synthetic) */
  nodes?: InputNode[];

  /** Diagnostic info */
  warnings?: string[];
}
```

### CommitDelta (placeholder)

```typescript
/**
 * Delta from RFDB CommitBatch response.
 * Full type defined in T3.2 (Client Batch API).
 * For T1.2, we define a minimal interface sufficient for relevantFiles().
 */
interface CommitDelta {
  /** Files that had nodes added/removed/modified */
  changedFiles: string[];

  /** Node IDs that were removed (tombstoned) */
  removedNodeIds?: string[];

  /** Node types present in changed nodes */
  changedNodeTypes?: string[];

  /** Edge types present in changed edges */
  changedEdgeTypes?: string[];

  /** Nodes modified (same semantic_id, different content_hash) */
  nodesModified?: number;
}
```

---

## Enricher Audit: consumes/produces

Полный аудит всех 14 enrichers. Для каждого определяем:
- Какие edge types он **читает** из графа (consumes)
- Какие edge types он **пишет** в граф (produces)
- Какие node types он **запрашивает** (для документации, не для dependency graph)

### Enricher Dependency Table

| # | Enricher | Consumes (edges read) | Produces (edges written) | Queries (node types) |
|---|----------|----------------------|--------------------------|---------------------|
| 1 | ImportExportLinker | — (reads analysis nodes only) | IMPORTS, IMPORTS_FROM | IMPORT, EXPORT, MODULE |
| 2 | FunctionCallResolver | IMPORTS_FROM | CALLS | CALL, FUNCTION, IMPORT |
| 3 | InstanceOfResolver | — | INSTANCE_OF | CLASS, VARIABLE |
| 4 | MethodCallResolver | IMPORTS_FROM | CALLS | CALL, FUNCTION, CLASS |
| 5 | CallbackCallResolver | CALLS | CALLS (callback resolution) | CALL, FUNCTION |
| 6 | NodejsBuiltinsResolver | — | CALLS | CALL |
| 7 | ExternalCallResolver | IMPORTS_FROM | CALLS | CALL, IMPORT, EXTERNAL_MODULE |
| 8 | ExpressHandlerLinker | — | HANDLED_BY | http:route, FUNCTION |
| 9 | HTTPConnectionEnricher | HANDLED_BY, CALLS | MAKES_REQUEST | http:request, http:route |
| 10 | RejectionPropagationEnricher | CALLS | HAS_REJECTION_HANDLER | FUNCTION, CALL |
| 11 | RustFFIEnricher | — | CALLS | CALL, FUNCTION |
| 12 | AliasTracker | ASSIGNED_FROM | ALIAS_OF | VARIABLE, CONSTANT |
| 13 | ClosureCaptureEnricher | CONTAINS | CAPTURES | FUNCTION, VARIABLE, SCOPE |
| 14 | ArgumentParameterLinker | CALLS | PASSES_ARGUMENT | CALL, FUNCTION, PARAMETER |
| 15 | MountPointResolver | — | MOUNTED_AT | http:route |
| 16 | PrefixEvaluator | MOUNTED_AT | HAS_PREFIX | http:route |
| 17 | ValueDomainAnalyzer | CALLS, ASSIGNED_FROM | VALUE_DOMAIN | VARIABLE, CALL, FUNCTION |

**Dependency Graph (derived from consumes/produces):**

```
Analysis Phase → all nodes + CONTAINS, ASSIGNED_FROM, etc.
                    │
    ┌───────────────┼────────────────────────────┐
    ▼               ▼                            ▼
ImportExportLinker  InstanceOfResolver   NodejsBuiltinsResolver
(→ IMPORTS_FROM)   (→ INSTANCE_OF)      (→ CALLS)
    │                                            │
    ├──────────┬──────────┐                      │
    ▼          ▼          ▼                      │
FunctionCall  MethodCall  ExternalCall           │
Resolver      Resolver    Resolver               │
(→ CALLS)     (→ CALLS)   (→ CALLS)             │
    │                                            │
    ├──────────┬──────────┬─────────┐            │
    ▼          ▼          ▼         ▼            ▼
Callback    Rejection   ArgParam  HTTPConn    AliasTracker
CallRes     PropEnrich  Linker    Enricher    (→ ALIAS_OF)
(→ CALLS)   (→ HAS_REJ) (→PASSES) (→MAKES)       │
                                                   ▼
                                              ValueDomain
                                              Analyzer
                                              (→ VALUE_DOMAIN)

ExpressHandlerLinker (no edge deps, → HANDLED_BY)
    │
    ▼
MountPointResolver (→ MOUNTED_AT)
    │
    ▼
PrefixEvaluator (→ HAS_PREFIX)
```

### Verification Criteria for Audit

Для каждого enricher:
1. Grep для `getOutgoingEdges` / `getIncomingEdges` вызовов — это **consumes**
2. Grep для `addEdge` вызовов — это **produces**
3. Grep для `queryNodes` с типами — это **queries**
4. Убедиться что `consumes` покрывает ВСЕ edge types, а не только очевидные

---

## V1EnricherAdapter

```typescript
/**
 * Wraps a v1 Plugin (with execute()) as EnricherV2.
 *
 * Behavior:
 * - relevantFiles() returns all changed files (conservative)
 * - processFile() delegates to legacy execute() but captures edges for ONE file
 *
 * This is a TRANSITIONAL wrapper. Each enricher should eventually
 * implement EnricherV2 natively. The adapter exists so we can:
 * 1. Use both v1 and v2 enrichers in the same pipeline
 * 2. Migrate enrichers one at a time (not big-bang)
 * 3. Validate v2 infrastructure with existing enricher logic
 */
class V1EnricherAdapter implements EnricherV2 {
  metadata: EnricherMetadata;

  constructor(
    private legacy: Plugin,
    private consumesEdges: EdgeType[],
    private producesEdges: EdgeType[]
  ) {
    this.metadata = {
      ...legacy.metadata,
      consumes: consumesEdges,
      produces: producesEdges,
    };
  }

  async relevantFiles(delta: CommitDelta, _graph: GraphBackend): Promise<string[]> {
    // Conservative: all changed files
    return delta.changedFiles;
  }

  async processFile(file: string, graph: GraphBackend): Promise<EnricherFileResult> {
    // Problem: legacy execute() processes ALL files at once.
    // Solution: run execute() and filter edges by file.
    // This is inefficient but correct for transition period.
    //
    // Implementation approach:
    // 1. Create a recording GraphBackend proxy that captures addEdge() calls
    // 2. Run legacy.execute() with the proxy
    // 3. Filter captured edges where src OR dst belongs to target file
    // 4. Return filtered edges
    //
    // IMPORTANT: legacy execute() may be called multiple times (once per file).
    // To avoid redundant work, adapter should cache results from first execute()
    // and just filter for subsequent files.

    // ... implementation details below
  }
}
```

### Adapter Nuance: Recording Proxy

Для V1EnricherAdapter нужен `RecordingGraphBackend` — прокси, который:
- Перехватывает `addEdge()` → записывает в массив
- Перехватывает `addNode()` → записывает в массив
- Делегирует все **read** операции на реальный graph
- **НЕ пишет** в реальный граф (orchestrator сделает это сам)

```typescript
class RecordingGraphBackend extends GraphBackendProxy {
  capturedEdges: InputEdge[] = [];
  capturedNodes: InputNode[] = [];

  addEdge(edge: InputEdge): void {
    this.capturedEdges.push(edge);
  }

  addNode(node: InputNode): void {
    this.capturedNodes.push(node);
  }

  // All read methods delegate to real graph
  getNode(id: string) { return this.real.getNode(id); }
  queryNodes(filter: NodeFilter) { return this.real.queryNodes(filter); }
  // ... etc
}
```

### Adapter Caching Strategy

Legacy enricher's `execute()` processes ALL files. Calling it once per file = O(N²).

Solution: **run once, filter many**:

```typescript
class V1EnricherAdapter {
  private cachedEdges: InputEdge[] | null = null;
  private cachedNodes: InputNode[] | null = null;

  async processFile(file: string, graph: GraphBackend): Promise<EnricherFileResult> {
    if (!this.cachedEdges) {
      // Run legacy execute() once
      const recording = new RecordingGraphBackend(graph);
      await this.legacy.execute({ graph: recording, ... });
      this.cachedEdges = recording.capturedEdges;
      this.cachedNodes = recording.capturedNodes;
    }

    // Filter edges: src or dst node belongs to this file
    const fileEdges = this.cachedEdges.filter(edge =>
      this.edgeBelongsToFile(edge, file, graph)
    );

    return { edges: fileEdges };
  }

  // Reset cache between batches
  resetCache(): void {
    this.cachedEdges = null;
    this.cachedNodes = null;
  }
}
```

**Nuance:** `edgeBelongsToFile()` нужен getNode для src/dst чтобы определить file. Это дорого. Альтернатива: хранить edges в Map<file, edges[]> после первого execute(). Нужен getNode() один раз per edge, не per file.

---

## Enricher Dependency Graph Builder

```typescript
/**
 * Builds a dependency graph between enrichers based on
 * consumes/produces edge type declarations.
 *
 * Uses Kahn's algorithm (already exists in Orchestrator for plugin deps).
 * This extends it with EDGE TYPE based dependencies.
 */
function buildEnricherDependencyGraph(
  enrichers: EnricherV2[]
): EnricherDependencyGraph {
  // 1. Build produces index: EdgeType → enricher name
  const producedBy = new Map<EdgeType, string>();
  for (const enricher of enrichers) {
    for (const edgeType of enricher.metadata.produces) {
      producedBy.set(edgeType, enricher.metadata.name);
    }
  }

  // 2. Build dependency edges: for each consumer, find producer
  const edges: Array<{ from: string; to: string }> = [];
  for (const enricher of enrichers) {
    for (const consumed of enricher.metadata.consumes) {
      const producer = producedBy.get(consumed);
      if (producer) {
        edges.push({ from: producer, to: enricher.metadata.name });
      }
      // If no producer: consumed edge type comes from ANALYSIS phase → no enricher dep
    }
  }

  // 3. Topological sort (Kahn's)
  // Returns execution order + detects cycles

  return { order, edges, levels };
}
```

### EnricherDependencyGraph Type

```typescript
interface EnricherDependencyGraph {
  /** Topologically sorted enricher names */
  order: string[];

  /** Dependency edges (producer → consumer) */
  edges: Array<{ from: string; to: string }>;

  /**
   * Parallel execution levels. Enrichers in same level can run concurrently.
   * Level 0: no enricher dependencies (e.g., ImportExportLinker, InstanceOfResolver)
   * Level 1: depends on level 0 outputs
   * etc.
   */
  levels: string[][];

  /** Get enrichers that depend on a given enricher's output */
  getDependents(enricherName: string): string[];

  /**
   * Get enrichers affected by a set of changed edge types.
   * Used for selective re-enrichment: delta.changedEdgeTypes → affected enrichers.
   */
  getAffectedEnrichers(changedEdgeTypes: EdgeType[]): string[];
}
```

---

## Critical Nuances

### 1. Global vs File-Scoped Enrichers

Some enrichers are inherently **global** — they need cross-file context:

- `ValueDomainAnalyzer`: analyzes value flow across function calls between files
- `HTTPConnectionEnricher`: connects frontend fetch() to backend route handlers
- `FunctionCallResolver`: follows import chains across files

`processFile(file)` is a constraint that doesn't map naturally to global enrichers.

**Solution:** Global enrichers CAN read any node/edge from the graph. They just PRODUCE edges scoped to the given file. "processFile(file)" means "produce edges whose source is in file", not "only look at file".

For global enrichers, `relevantFiles()` returns the broader set (changed files + their dependents).

### 2. consumes = Analysis Edge Types

Some enrichers consume edge types created by ANALYSIS, not by other enrichers (e.g., CONTAINS, ASSIGNED_FROM). These are NOT enricher-to-enricher dependencies. The dependency graph should treat them as "provided by analysis phase" — always available.

`consumes` should list ALL edge types read, including analysis-phase ones. But the dependency graph builder only creates edges for enricher-produced types. Analysis-produced types are "free".

### 3. Enricher That Both Reads and Writes Same Type

`CallbackCallResolver` consumes CALLS (from FunctionCallResolver) and produces CALLS (callback resolution). This is a legitimate enricher that EXTENDS an edge type.

**Risk:** Circular dependency if another enricher also consumes CALLS and is consumed by CallbackCallResolver.

**Mitigation:** Kahn's algorithm detects cycles. If cycle found → build error. Currently no cycles exist (verified in dependency graph above).

### 4. Multiple Producers for Same Edge Type

`FunctionCallResolver`, `MethodCallResolver`, `ExternalCallResolver`, `CallbackCallResolver`, `NodejsBuiltinsResolver` all produce CALLS edges.

**Question:** If enricher X consumes CALLS, which producer does it depend on?

**Answer:** ALL of them. The dependency graph builder must handle multi-producer edge types:

```typescript
// When building dependencies, if multiple enrichers produce EdgeType X:
// Consumer of X depends on ALL producers of X
for (const consumed of enricher.metadata.consumes) {
  const producers = producedByAll.get(consumed);  // Returns string[]
  for (const producer of producers) {
    edges.push({ from: producer, to: enricher.metadata.name });
  }
}
```

This means `ArgumentParameterLinker` (consumes CALLS) depends on ALL CALLS-producing enrichers. It runs last in the CALLS chain.

### 5. Backward Compatibility During Migration

During transition period, Orchestrator must support BOTH:
- v1 enrichers (extend `Plugin`, have `execute()`)
- v2 enrichers (implement `EnricherV2`, have `processFile()`)

Strategy: wrap ALL enrichers as `EnricherV2` at pipeline start:
```typescript
const enrichersV2 = enrichers.map(enricher =>
  isEnricherV2(enricher) ? enricher : new V1EnricherAdapter(enricher, ...)
);
```

Detection: check for `processFile` method existence (duck typing) or explicit marker.

### 6. Default relevantFiles() Implementations

```typescript
// Conservative (default for V1EnricherAdapter):
async relevantFiles(delta: CommitDelta): Promise<string[]> {
  return delta.changedFiles;
}

// Smarter (for enrichers that only care about specific node types):
async relevantFiles(delta: CommitDelta): Promise<string[]> {
  if (delta.changedNodeTypes &&
      !delta.changedNodeTypes.some(t => this.relevantNodeTypes.includes(t))) {
    return []; // No relevant changes
  }
  return delta.changedFiles;
}
```

For T1.2, all enrichers use the conservative default. Smart `relevantFiles()` can be added per-enricher later.

### 7. processFile() Must Not Mutate Graph

This is a CONTRACT violation if broken:

```typescript
// WRONG - v1 pattern:
async processFile(file: string, graph: GraphBackend) {
  await graph.addEdge({ src, dst, type: 'CALLS' });  // ← NO!
}

// RIGHT - v2 pattern:
async processFile(file: string, graph: GraphBackend) {
  return {
    edges: [{ src, dst, type: 'CALLS' }]  // ← return, don't write
  };
}
```

The orchestrator is responsible for committing edges to the correct shard (`__enrichment__/{enricher}/{file}`). If enricher writes directly, the shard model breaks.

**Enforcement:** In T1.2, this is by convention. In T5.2 (Orchestrator Batch Protocol), the `RecordingGraphBackend` will enforce it.

---

## Test Plan

### Interface & Types

1. `enricher_metadata_has_consumes_produces` — EnricherMetadata requires both fields
2. `commit_delta_minimal_interface` — CommitDelta has changedFiles at minimum
3. `enricher_file_result_has_edges` — EnricherFileResult always has edges array

### Enricher Audit Validation

4. `all_enrichers_have_consumes` — every enricher in registry has consumes declared
5. `all_enrichers_have_produces` — every enricher has produces declared
6. `produces_matches_creates_edges` — produces ⊇ creates.edges (superset or equal)
7. `no_unknown_edge_types_consumed` — all consumed types either come from analysis or another enricher
8. `no_unknown_edge_types_produced` — all produced types are valid EdgeType values

### Dependency Graph

9. `dependency_graph_no_cycles` — Kahn's algorithm completes (no cycle)
10. `dependency_graph_respects_consumes_produces` — enricher consuming IMPORTS_FROM depends on ImportExportLinker
11. `dependency_graph_levels_correct` — level 0 has no enricher deps, level N depends on level <N
12. `multi_producer_edge_type` — consumer of CALLS depends on ALL CALLS producers
13. `get_dependents_correct` — ImportExportLinker dependents include FunctionCallResolver, MethodCallResolver
14. `get_affected_enrichers_correct` — changedEdgeTypes=[IMPORTS_FROM] → FunctionCallResolver affected

### V1EnricherAdapter

15. `adapter_wraps_legacy_metadata` — name, phase preserved from legacy plugin
16. `adapter_adds_consumes_produces` — consumes/produces added from constructor args
17. `adapter_relevant_files_conservative` — returns all changed files
18. `adapter_recording_proxy_captures_edges` — RecordingGraphBackend captures addEdge calls
19. `adapter_recording_proxy_delegates_reads` — queryNodes, getNode delegated to real graph
20. `adapter_process_file_filters_by_file` — only edges belonging to file returned

### Edge Cases

21. `empty_delta` — delta with 0 changed files → relevantFiles returns []
22. `enricher_with_no_consumes` — valid (depends only on analysis output)
23. `enricher_with_no_produces` — invalid (enricher must produce something) → error
24. `circular_dependency_detected` — two enrichers consuming each other's output → error

---

## Performance Considerations

T1.2 is pure type definitions and metadata — no performance-critical code. However:

- **Dependency graph construction:** O(E × P) where E = enrichers, P = max produces/consumes per enricher. With 17 enrichers and max 3 edge types each → ~51 operations. Trivial.
- **V1EnricherAdapter caching:** Running legacy execute() once and filtering is O(all_edges) per processFile call. For transition period this is acceptable. Native v2 enrichers avoid this overhead.

---

## Dependencies (npm)

No new dependencies. All types defined in existing `packages/types/`.

---

## Migration Notes

### Order of Migration (enrichers → native v2)

Priority: most impactful enrichers first.

1. **ImportExportLinker** — simplest, already file-scoped in logic
2. **FunctionCallResolver** — most important for call graph
3. **InstanceOfResolver** — already scoped to CLASS nodes
4. **MethodCallResolver** — similar to FunctionCallResolver
5. **ArgumentParameterLinker** — depends on CALLS, natural file scope

Lower priority (migrate when needed):
6-17. Remaining enrichers — use V1EnricherAdapter until migration needed

**This migration happens AFTER T1.2.** T1.2 only defines the contract + adapter + audit. Actual migration of individual enrichers is part of T5.2 (Orchestrator Batch Protocol) or can be done incrementally.
