# T5.2: Orchestrator Batch Protocol (Track 2, TS)

> Milestone: M5 (Enrichment Pipeline)
> Dependencies: T4.1 (Rust v2), T3.2 (Client Batch), T1.2 (Enricher Contract)
> Estimated: ~500 LOC, ~20 tests
> Related docs: [005-orchestrator-design.md](../005-orchestrator-design.md) §3, [T1.2 spec](./T1.2-enricher-contract-v2.md)

---

## High-Level Context

Orchestrator переходит с `addEdge()` на CommitBatch. Enrichers больше не пишут в граф напрямую — orchestrator коммитит их результаты в правильные шарды.

**Новый pipeline:**
1. Analysis → CommitBatch(file) → delta
2. Pre-commit blast radius (C4) → dependent files
3. For each enricher (toposorted): enricher.processFile(file) → CommitBatch(enrichment context) → enricher delta
4. Delta-driven enricher selection: changedNodeTypes ∩ enricher.consumes

---

## Changes to Orchestrator.ts

### Analysis Phase

```typescript
// Old:
await plugin.execute(context);  // Writes directly to graph

// New:
await client.beginBatch();
await plugin.execute(context);  // Still writes via graph backend
const analysisDelta = await client.commitBatch({ phase: 'analysis' });
```

### Blast Radius (C4)

```typescript
// BEFORE analysis commit (while old edges are still visible)
const blastRadius = await client.findDependentFiles(changedFiles);
const reEnrichFiles = new Set([...changedFiles, ...blastRadius]);
```

### Selective Enrichment

```typescript
const enricherGraph = buildEnricherDependencyGraph(enrichersV2);
const sortedEnrichers = enricherGraph.order;

for (const enricherName of sortedEnrichers) {
  const enricher = enrichersByName.get(enricherName)!;

  // Delta-driven selection: does this enricher care about what changed?
  // Level-0 enrichers (consumes analysis nodes) always run on changed files.
  // Level-1+ enrichers use changedEdgeTypes from upstream enricher deltas.
  const isLevel0 = enricher.metadata.level === 0;
  if (isLevel0) {
    // Level-0: check changedNodeTypes (analysis produces nodes, not edges)
    if (!analysisDelta.changedNodeTypes.some(t =>
      enricher.metadata.nodeInterest?.includes(t) ?? true)) {
      continue;
    }
  } else {
    // Level-1+: check changedEdgeTypes from upstream enricher deltas
    if (!enricher.metadata.consumes.some(t =>
      accumulatedDelta.changedEdgeTypes.includes(t))) {
      continue;  // Skip — no relevant edge types changed upstream
    }
  }

  const affectedFiles = await enricher.relevantFiles(analysisDelta, graph);
  const filesToProcess = affectedFiles.filter(f => reEnrichFiles.has(f));

  for (const file of filesToProcess) {
    const result = await enricher.processFile(file, graph);

    // Commit to enrichment shard
    await client.beginBatch();
    if (result.nodes) await client.addNodes(result.nodes);
    await client.addEdges(result.edges);
    const enricherDelta = await client.commitBatch({
      fileContext: `__enrichment__/${enricherName}/${file}`,
    });

    // Propagate if output changed
    if (enricherDelta.changedEdgeTypes.length > 0) {
      const downstream = enricherGraph.getDependents(enricherName);
      // Mark downstream enrichers for re-run
    }
  }
}
```

---

## Critical Nuances

### 1. RecordingGraphBackend

For enrichers using processFile() (v2 contract), orchestrator passes a read-only graph. For V1EnricherAdapter, uses RecordingGraphBackend that captures writes.

### 2. Enricher Delta Propagation

When enricher A changes edges → downstream enrichers (consuming A's edge types) re-run. This can cascade through the dependency chain. Termination guaranteed by DAG property.

### 3. consumes = Edge Types, Not Node Types

`enricher.metadata.consumes` is `EdgeType[]`, NOT node types. This creates a type mismatch for level-0 enrichers:
- **Level-0 enrichers** (ImportExportLinker, TypeResolver, etc.) consume analysis output — but analysis produces *nodes*, not edges. These enrichers should always run on changed files. Use optional `nodeInterest` metadata for filtering, or default to running on all changed files.
- **Level-1+ enrichers** consume edges produced by other enrichers. Selection uses `changedEdgeTypes ∩ consumes` — this works correctly since both are `EdgeType[]`.

Both `changedNodeTypes` and `changedEdgeTypes` are in the CommitDelta.

---

## Test Plan

1. `batch_commit_in_analysis` — analysis uses CommitBatch, returns delta
2. `blast_radius_finds_dependents` — change B → A (imports B) detected
3. `selective_enrichment` — change FUNCTION → only FUNCTION-consuming enrichers run
4. `enrichment_shard_commit` — enrichment edges committed to correct context
5. `enricher_propagation` — enricher A output changed → enricher B re-runs
6. `full_pipeline` — analysis → blast radius → selective enrichment → correct graph
7. `v1_adapter_compatibility` — V1EnricherAdapter works in new pipeline
8. `no_enrichment_for_irrelevant_changes` — add LITERAL node → no enrichers triggered
9. `multiple_files_batch` — batch with 3 files → all processed
10-20. Integration tests with real enrichers
