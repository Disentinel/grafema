# T4.1: Wire Protocol v3 Integration (Track 1, Rust)

> Milestone: M4 (Integration Gate)
> Dependencies: T2.3 (Multi-Shard), T3.1 (Batch Commit)
> Estimated: ~500 LOC refactor, ~20 new tests + ~120 adapted
> Related docs: [002-roadmap.md](../002-roadmap.md), [006-client-spec.md](../006-client-spec.md), all T1-T3 specs

---

## High-Level Context

THE GATE. После T4.1 v2 engine полностью заменяет v1 за тем же wire protocol. **Все ~120 существующих тестов должны пройти.**

T4.1 интегрирует все предыдущие компоненты:
- `engine_v2.rs` (multi-shard, T2.3) implements `GraphEngine` trait
- Wire protocol handlers switch from v1 engine to v2 engine
- `DatabaseManager` creates v2 engines
- New protocol commands: BeginBatch, CommitBatch, AbortBatch, DiffSnapshots, streaming, version handshake
- Removed/changed commands for v2 semantics

---

## Existing Code to Study

| File | What to learn |
|------|--------------|
| `src/bin/rfdb_server.rs` (~800 LOC) | All protocol handlers, Request/Response enums |
| `src/database_manager.rs` | Database creation/opening |
| `src/graph/engine.rs` | v1 engine (reference for trait implementation) |
| `src/graph/engine_v2.rs` | v2 engine from T2.2/T2.3 |

---

## Changes

### 1. GraphEngine Trait Completion

Ensure v2 engine implements ALL methods of `GraphEngine` trait. Every handler in `rfdb_server.rs` should work through the trait, not directly on v1 engine.

### 2. DatabaseManager Switch

```rust
// Old: creates v1 engines
fn create_database(&mut self, name: &str, ephemeral: bool) -> Result<()> {
    let engine = GraphEngine::create(&path);  // v1
}

// New: creates v2 engines
fn create_database(&mut self, name: &str, ephemeral: bool) -> Result<()> {
    let engine = GraphEngineV2::create(&path);  // v2
}
```

### 3. New Protocol Handlers

| Command | Handler Logic |
|---------|--------------|
| `BeginBatch` | `engine.begin_batch()` → `Ok {}` |
| `CommitBatch { tags }` | `engine.commit_batch(tags)` → `CommitDeltaResponse { delta }` |
| `AbortBatch` | `engine.abort_batch()` → `Ok {}` |
| `DiffSnapshots { from, to }` | `engine.diff_snapshots(from, to)` → `DiffResponse { diff }` |
| `TagSnapshot { version, tags }` | `engine.tag_snapshot(version, tags)` → `Ok {}` |
| `FindSnapshot { tag_key, tag_value }` | `engine.find_snapshot(key, val)` → `VersionResponse { version }` |
| `ListSnapshots { filter }` | `engine.list_snapshots(filter)` → `SnapshotsResponse { snapshots }` |
| `FindDependentFiles { files }` | Server-side blast radius query → `IdsResponse { ids }` |

### 4. Request ID Echo

From T1.3: extract `requestId` from request, echo in response. The "extract before dispatch" pattern — centralized, no changes to individual handlers.

### 5. Version Handshake

```rust
Hello { protocol_version } => {
    Response::HelloOk {
        ok: true,
        protocol_version: 3,  // v3
        server_version: env!("CARGO_PKG_VERSION"),
        features: vec![
            "requestId".to_string(),
            "batch".to_string(),
            "snapshots".to_string(),
            "semanticId".to_string(),
        ],
    }
}
```

### 6. Streaming Response (foundation)

For large query results (>1000 nodes), server sends chunked responses:

```rust
// Instead of one large Nodes { nodes: Vec<WireNode> }:
// Send multiple chunks:
NodesChunk { nodes: Vec<WireNode>, done: false, request_id }
NodesChunk { nodes: Vec<WireNode>, done: true, request_id }
```

**requestId is critical for streaming** — client needs to know which query a chunk belongs to.

### 7. Removed/Changed Commands

| v2 Command | v3 Status | Notes |
|------------|-----------|-------|
| `GetAllEdges` | Removed → `QueryEdges` | Streaming-based, not bulk |
| `UpdateNodeVersion` | No-op | Version = snapshot number, not per-node |
| `DeleteNode` / `DeleteEdge` | Via batch | CommitBatch with tombstones |

**Backward compat:** Keep old command names, emit deprecation warning in logs, proxy to new implementation.

### 8. Ephemeral Databases

Ephemeral databases (test databases): in-memory write buffers, no segments, no manifest files.

```rust
fn create_database(&mut self, name: &str, ephemeral: bool) -> Result<()> {
    if ephemeral {
        GraphEngineV2::create_ephemeral()
    } else {
        GraphEngineV2::create(&self.resolve_path(name))
    }
}
```

---

## Critical Nuances

### 1. Test Adaptation Strategy

~120 existing tests use v1 behavior. Most should pass unchanged because v2 engine implements the same trait. Expected adaptations:

- Tests using `UpdateNodeVersion` → no-op or remove
- Tests using `GetAllEdges` → switch to `QueryEdges`
- Tests checking exact response format → may need updates for new fields (requestId)
- Tests that rely on v1 internal state (HashMap) → rewrite against trait interface

### 2. Semantic ID in Wire Format

v1 wire nodes have `id: String` = legacy format. v3 adds `semanticId: String` field (the v2 semantic ID). For backward compat:
- `id` field continues to work (maps to u128 via BLAKE3)
- `semanticId` is additional field (for clients that understand it)
- Full switchover in T4.2

### 3. Batch State per Connection

Each client connection has its own batch state. Multiple clients can have independent batches. This requires per-connection state in the server loop:

```rust
struct ConnectionState {
    batch: BatchState,
    // ...
}
```

### 4. Error Responses for New Commands

```rust
CommitBatch without BeginBatch → Error { error: "No active batch" }
BeginBatch while batch active → Error { error: "Batch already active" }
AbortBatch without BeginBatch → Ok {} (idempotent, no error)
```

### 5. QueryEdges — Replacement for GetAllEdges

`GetAllEdges` is removed (returns entire edge set — unbounded, no streaming). Replaced by `QueryEdges` with filters:

```rust
QueryEdges {
    edge_type: Option<String>,       // filter by edge type
    src: Option<u128>,               // filter by src node ID
    dst: Option<u128>,               // filter by dst node ID
    file_context: Option<String>,    // filter by file context (shard)
    limit: Option<u32>,              // max results (default: 1000)
    request_id: Option<String>,
}
```

**Response:** Uses streaming (`EdgesChunk { edges, done, request_id }`).

**Query plan:**
- `src` set → use src bloom filter on edge segments
- `dst` set → use dst bloom filter on edge segments
- `file_context` set → restrict to specific shard
- `edge_type` set → zone map pruning on edge type column
- No filters → fan-out to all shards (equivalent to old GetAllEdges but streamed + limited)

**Migration path:** Existing code using `GetAllEdges` should be updated to use `QueryEdges` with appropriate filters. Server logs deprecation warning if old command received.

---

## Sub-Task Decomposition

T4.1 is the highest-risk task. Decompose into 5 sub-tasks to be executed sequentially:

### T4.1a — GraphEngine Trait Implementation + Unit Tests
Implement all `GraphEngine` trait methods for `GraphEngineV2`. Unit-test each method in isolation against the trait interface. ~15 tests.

### T4.1b — Protocol Handler Switchover + Adapted Tests (batches of ~30)
Switch `rfdb_server.rs` handlers from v1 to v2 engine. Adapt existing tests in batches of ~30. Expected: most pass unchanged; some need adaptation for removed commands or new response fields. ~120 adapted tests.

### T4.1c — New Protocol Commands (Batch, Diff, Streaming, QueryEdges)
Implement `BeginBatch`, `CommitBatch`, `AbortBatch`, `DiffSnapshots`, `TagSnapshot`, `FindSnapshot`, `ListSnapshots`, `QueryEdges`, `FindDependentFiles`. Streaming response support. Version handshake. ~12 new tests.

**IMPORTANT:** `FindDependentFiles` MUST be a server-side command using dst bloom filters. The client-side fallback (T3.2) is acceptable for integration testing only. Server-side implementation: for each changed file's nodes, check dst bloom on edge segments → collect src nodes → resolve files.

### T4.1d — Ephemeral Database Support
`GraphEngineV2::create_ephemeral()` — in-memory write buffers, no segments on disk, no manifest files. Used by test infrastructure. ~3 tests.

### T4.1e — Test Adaptation for Removed Commands
Tests using `GetAllEdges` → `QueryEdges`. Tests using `UpdateNodeVersion` → remove or no-op. Tests using `DeleteNode`/`DeleteEdge` → batch tombstone. ~5 tests.

---

## Test Plan (20 new + ~120 adapted)

### New Tests

1. `batch_begin_commit` — full batch cycle
2. `batch_abort` — abort discards
3. `batch_delta_response` — CommitBatch returns correct delta
4. `batch_with_tags` — tags stored in snapshot
5. `diff_snapshots` — diff between versions
6. `find_snapshot_by_tag` — tag → find → correct
7. `list_snapshots` — list all versions
8. `tag_snapshot` — add tags to existing version
9. `request_id_echo` — requestId echoed in response
10. `streaming_large_result` — >1000 nodes → chunked response
11. `version_handshake` — hello → protocol_version: 3
12. `find_dependent_files` — server-side blast radius
13. `ephemeral_database_v2` — ephemeral works with v2 engine
14. `concurrent_batch_different_clients` — two clients, independent batches
15. `deprecated_commands_logged` — GetAllEdges → warning in log
16-20. Performance baselines (v2 vs v1 comparison for key operations)

### Adapted Existing Tests (~120)

All existing Rust + TS integration tests adapted to work with v2 engine. Detailed adaptation plan created during implementation.

---

## Performance Targets

| Metric | v2 Target | v1 Baseline |
|--------|-----------|-------------|
| Point lookup | <50µs | <1µs |
| Attribute query | <5ms (10K nodes) | <5ms |
| Neighbor query | <100µs | <10µs |
| Write throughput | >500K nodes/sec | >1M nodes/sec |
| CommitBatch (1 file) | <10ms | N/A |

**Note:** v2 pre-compaction is expected slower for point lookups. This is acceptable — compaction (T6.1) will improve to <10µs.
