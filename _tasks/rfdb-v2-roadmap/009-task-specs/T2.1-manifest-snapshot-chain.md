# T2.1: Manifest + Snapshot Chain (Track 1, Rust)

> Milestone: M2 (Storage Engine)
> Dependencies: T1.1 (Segment Format)
> Estimated: ~500 LOC, ~25 tests
> Related docs: [002-roadmap.md](../002-roadmap.md) §2 (Batch Commit), [004-expert-concerns.md](../004-expert-concerns.md) C3/N7, [T1.1 spec](./T1.1-segment-format.md)

---

## High-Level Context

Текущая RFDB v1 хранит данные в трёх файлах: `nodes.bin`, `edges.bin`, `metadata.json`. При flush все данные перезаписываются целиком. Нет версионирования, нет атомарности (перебой между записями файлов → рассинхрон), нет snapshot'ов.

**Что добавляет T2.1:**

1. **Manifest** — JSON-файл, описывающий набор активных сегментов. Единый source of truth.
2. **Manifest chain** — серия иммутабельных манифестов с последовательными номерами (v1, v2, v3...). Каждый описывает полный набор сегментов для своей версии.
3. **Snapshot = manifest version** — любой манифест можно использовать как snapshot (иммутабельный view).
4. **Tags** — key-value метки на snapshot'ах (e.g., `{commit: "abc123"}`, `{phase: "analysis"}`).
5. **Atomic pointer** — `current.json` указывает на текущий манифест. Atomic rename/symlink.
6. **Diff** — сравнение двух манифестов → added/removed сегменты.

Это **фундамент для batch commit** (T3.1): каждый commit создаёт новый манифест, readers видят предыдущий snapshot до swap.

---

## Existing Code to Study

| File | What to learn |
|------|--------------|
| `src/graph/engine.rs` (lines 1073-1265) | Current flush logic: merge delta + segment → overwrite |
| `src/storage/writer.rs` (~402 LOC) | Segment serialization, file I/O |
| `src/storage/mod.rs` (~161 LOC) | `GraphMetadata` struct, `NodeRecord`, `EdgeRecord` |
| `src/database_manager.rs` | Database creation, path normalization |
| `src/storage/segment.rs` (~490 LOC) | Current segment format, mmap pattern |

### Current Filesystem Layout (v1)

```
<name>.rfdb/
├── nodes.bin          ← single mmap segment (overwritten on flush)
├── edges.bin          ← single mmap segment (overwritten on flush)
└── metadata.json      ← counts, field_declarations, timestamps
```

**Problems:**
- No versioning — flush overwrites everything
- Not atomic — crash between writing nodes.bin and edges.bin → corruption
- No rollback — previous state lost after flush
- `metadata.json` mixes concerns (counts + field declarations + timestamps)

---

## New Filesystem Layout (v2)

```
<name>.rfdb/
├── current.json                      ← atomic pointer: {"version": 5}
├── manifests/
│   ├── 000001.json                   ← manifest v1 (immutable after creation)
│   ├── 000002.json                   ← manifest v2
│   ├── 000003.json                   ← manifest v3
│   ├── 000004.json                   ← manifest v4
│   └── 000005.json                   ← manifest v5 (current)
├── segments/
│   ├── seg_000001_nodes.bin          ← immutable node segment
│   ├── seg_000001_edges.bin          ← immutable edge segment
│   ├── seg_000002_nodes.bin          ← another node segment
│   ├── seg_000003_edges.bin          ← edge segment
│   └── ...
├── gc/                               ← segments pending garbage collection
│   └── seg_000001_nodes.bin          ← no longer referenced by any live manifest
└── field_declarations.json           ← persisted field declarations (separated from manifest)
```

### Naming Conventions

- **Manifest:** `manifests/{version:06}.json` — zero-padded 6 digits, sequential
- **Segment:** `segments/seg_{segment_id:06}_{type}.bin` where type = `nodes` | `edges`
- **Segment IDs** are globally unique, monotonically increasing (never reused)

---

## Data Structures

### Manifest

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct Manifest {
    /// Manifest version number. Sequential, never gaps.
    pub version: u64,

    /// Timestamp of creation (Unix epoch seconds)
    pub created_at: u64,

    /// Active node segments (list of segment descriptors)
    pub node_segments: Vec<SegmentDescriptor>,

    /// Active edge segments
    pub edge_segments: Vec<SegmentDescriptor>,

    /// Optional key-value tags for this snapshot
    pub tags: HashMap<String, String>,

    /// Stats snapshot
    pub stats: ManifestStats,

    /// Previous manifest version (for chain traversal). None for first manifest.
    pub parent_version: Option<u64>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SegmentDescriptor {
    /// Unique segment ID
    pub segment_id: u64,

    /// Relative file path within database directory
    pub file_name: String,

    /// Number of records in this segment
    pub record_count: u64,

    /// Byte size on disk
    pub byte_size: u64,

    /// Set of distinct node types (zone map summary)
    pub node_types: Vec<String>,

    /// Set of distinct file paths (zone map summary)
    pub file_paths: Vec<String>,

    /// Set of distinct edge types (edge segments only)
    pub edge_types: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ManifestStats {
    /// Total nodes across all node segments
    pub total_nodes: u64,

    /// Total edges across all edge segments
    pub total_edges: u64,

    /// Number of node segments
    pub node_segment_count: u32,

    /// Number of edge segments
    pub edge_segment_count: u32,
}
```

**Nuances:**
- `SegmentDescriptor` includes zone map summaries (`node_types`, `file_paths`, `edge_types`). This allows manifest-level query planning without opening segments.
- `parent_version` enables chain traversal for diff computation.
- `tags` is optional — most manifests won't have tags. Empty HashMap = no tags.
- Stats are pre-computed at manifest creation time (sum of segment record counts). Avoids scanning segments for counts.

### Current Pointer

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct CurrentPointer {
    /// Version number of the current active manifest
    pub version: u64,
}
```

`current.json` is tiny (~20 bytes). Written atomically via rename.

---

## Core Operations

### 1. Create Manifest

```rust
impl ManifestStore {
    /// Create a new manifest with given segments and optional tags.
    /// Increments version from current, writes to manifests/ dir.
    /// Does NOT update current pointer — caller must call commit().
    pub fn create_manifest(
        &mut self,
        node_segments: Vec<SegmentDescriptor>,
        edge_segments: Vec<SegmentDescriptor>,
        tags: Option<HashMap<String, String>>,
    ) -> Result<Manifest> {
        let version = self.next_version();
        let manifest = Manifest {
            version,
            created_at: now_unix_secs(),
            node_segments,
            edge_segments,
            tags: tags.unwrap_or_default(),
            stats: compute_stats(&node_segments, &edge_segments),
            parent_version: Some(self.current_version()),
        };

        self.write_manifest(&manifest)?;
        Ok(manifest)
    }

    /// Atomically update current pointer to given manifest version.
    /// This is the "commit" operation — readers will see new snapshot.
    pub fn commit(&self, version: u64) -> Result<()> {
        let pointer = CurrentPointer { version };
        atomic_write_json(&self.current_path(), &pointer)?;
        Ok(())
    }
}
```

### 2. Atomic Pointer Update

```rust
/// Write JSON to file atomically using rename.
/// 1. Write to temp file in same directory
/// 2. fsync temp file
/// 3. rename temp → target (atomic on POSIX)
fn atomic_write_json<T: Serialize>(path: &Path, data: &T) -> Result<()> {
    let temp_path = path.with_extension("tmp");
    let file = File::create(&temp_path)?;
    serde_json::to_writer(&file, data)?;
    file.sync_all()?;                    // fsync before rename
    std::fs::rename(&temp_path, path)?;  // atomic on same filesystem
    Ok(())
}
```

**Nuance:** `rename()` is atomic on POSIX if source and target are on the same filesystem. Since temp file is in same directory (`.rfdb/`), this is guaranteed.

### 3. Open Database (Read Current Snapshot)

```rust
impl ManifestStore {
    /// Open database: read current pointer → load manifest → return.
    pub fn open(db_path: &Path) -> Result<Self> {
        let current = read_json::<CurrentPointer>(&db_path.join("current.json"))?;
        let manifest = read_manifest(db_path, current.version)?;

        Ok(ManifestStore {
            db_path: db_path.to_path_buf(),
            current: manifest,
            next_segment_id: compute_next_segment_id(&manifest),
        })
    }

    /// Get current active manifest
    pub fn current_manifest(&self) -> &Manifest { &self.current }

    /// Get current version number
    pub fn current_version(&self) -> u64 { self.current.version }
}
```

### 4. Snapshot Operations

```rust
impl ManifestStore {
    /// Find manifest by tag.
    /// Searches from current back through parent chain.
    pub fn find_snapshot(&self, tag_key: &str, tag_value: &str) -> Result<Option<u64>> {
        let mut version = self.current_version();
        loop {
            let manifest = self.load_manifest(version)?;
            if manifest.tags.get(tag_key).map(|v| v == tag_value).unwrap_or(false) {
                return Ok(Some(version));
            }
            match manifest.parent_version {
                Some(parent) => version = parent,
                None => return Ok(None),
            }
        }
    }

    /// List snapshots with optional tag filter.
    pub fn list_snapshots(
        &self,
        filter: Option<&str>,  // tag key to filter by
    ) -> Result<Vec<SnapshotInfo>> {
        // Read all manifest files from manifests/ directory
        // Filter by tag if provided
        // Return sorted by version
    }

    /// Tag an existing snapshot.
    /// Rewrites the manifest file with added tags.
    pub fn tag_snapshot(
        &self,
        version: u64,
        tags: HashMap<String, String>,
    ) -> Result<()> {
        let mut manifest = self.load_manifest(version)?;
        manifest.tags.extend(tags);
        self.write_manifest(&manifest)?;  // Safe: same version, same file
        Ok(())
    }
}

#[derive(Debug, Serialize)]
pub struct SnapshotInfo {
    pub version: u64,
    pub created_at: u64,
    pub tags: HashMap<String, String>,
    pub stats: ManifestStats,
}
```

### 5. Diff Computation

```rust
impl ManifestStore {
    /// Compute diff between two manifest versions.
    /// Returns segments added, removed, and unchanged.
    pub fn diff_snapshots(
        &self,
        from_version: u64,
        to_version: u64,
    ) -> Result<SnapshotDiff> {
        let from = self.load_manifest(from_version)?;
        let to = self.load_manifest(to_version)?;

        let from_node_ids: HashSet<u64> = from.node_segments.iter().map(|s| s.segment_id).collect();
        let to_node_ids: HashSet<u64> = to.node_segments.iter().map(|s| s.segment_id).collect();

        let from_edge_ids: HashSet<u64> = from.edge_segments.iter().map(|s| s.segment_id).collect();
        let to_edge_ids: HashSet<u64> = to.edge_segments.iter().map(|s| s.segment_id).collect();

        Ok(SnapshotDiff {
            from_version,
            to_version,
            added_node_segments: to.node_segments.iter()
                .filter(|s| !from_node_ids.contains(&s.segment_id))
                .cloned().collect(),
            removed_node_segments: from.node_segments.iter()
                .filter(|s| !to_node_ids.contains(&s.segment_id))
                .cloned().collect(),
            added_edge_segments: to.edge_segments.iter()
                .filter(|s| !from_edge_ids.contains(&s.segment_id))
                .cloned().collect(),
            removed_edge_segments: from.edge_segments.iter()
                .filter(|s| !to_edge_ids.contains(&s.segment_id))
                .cloned().collect(),
            stats_from: from.stats.clone(),
            stats_to: to.stats.clone(),
        })
    }
}

#[derive(Debug, Serialize)]
pub struct SnapshotDiff {
    pub from_version: u64,
    pub to_version: u64,
    pub added_node_segments: Vec<SegmentDescriptor>,
    pub removed_node_segments: Vec<SegmentDescriptor>,
    pub added_edge_segments: Vec<SegmentDescriptor>,
    pub removed_edge_segments: Vec<SegmentDescriptor>,
    pub stats_from: ManifestStats,
    pub stats_to: ManifestStats,
}
```

### 6. GC Bookkeeping

```rust
impl ManifestStore {
    /// Move unreferenced segments to gc/ directory.
    /// A segment is unreferenced if no manifest from (current - retention) to current references it.
    pub fn gc_collect(&self, retention_versions: u64) -> Result<Vec<String>> {
        let min_version = self.current_version().saturating_sub(retention_versions);

        // Collect all segment IDs referenced by manifests in [min_version, current]
        let referenced: HashSet<u64> = self.collect_referenced_segments(min_version)?;

        // Find segment files not in referenced set
        let all_segments = list_segment_files(&self.db_path.join("segments"))?;
        let unreferenced: Vec<_> = all_segments.iter()
            .filter(|s| !referenced.contains(&s.segment_id))
            .collect();

        // Move to gc/
        for seg in &unreferenced {
            let src = self.db_path.join("segments").join(&seg.file_name);
            let dst = self.db_path.join("gc").join(&seg.file_name);
            std::fs::rename(&src, &dst)?;
        }

        Ok(unreferenced.iter().map(|s| s.file_name.clone()).collect())
    }

    /// Delete files in gc/ directory.
    /// Safe to call at any time — gc/ files are already unreferenced.
    pub fn gc_purge(&self) -> Result<usize> {
        let gc_dir = self.db_path.join("gc");
        let mut count = 0;
        for entry in std::fs::read_dir(&gc_dir)? {
            std::fs::remove_file(entry?.path())?;
            count += 1;
        }
        Ok(count)
    }
}
```

**Nuance:** GC has two phases:
1. **collect** → move to gc/ (safe — segments are unreferenced)
2. **purge** → delete from gc/ (destructive but safe — no references)

Two-phase allows recovery: if collect was wrong, move files back from gc/.

---

## Critical Nuances

### 1. Crash Safety

The atomic pointer pattern guarantees:
- **Before commit:** old manifest is current. New manifest + segments exist but are unreferenced.
- **After commit:** new manifest is current. Old segments are still on disk (GC handles cleanup).
- **During commit (rename):** atomic on POSIX. Either old or new pointer, never partial.

**Corner case:** Crash after writing new segments but before creating manifest. On restart:
- `current.json` points to old manifest → old segments used
- Orphan segments in `segments/` dir → next GC cleans them up
- **No data corruption.** At worst, unused segment files.

### 2. Concurrent Readers During Swap

Readers hold mmap references to old segments. After manifest swap:
- New readers open new segments
- Old readers continue with old mmaps (OS keeps file data alive until all mmaps released)
- **No locking needed.** mmap reference counting handles this.

**Caveat:** On Linux, `unlink()` of an mmap'd file doesn't free data until all mappings closed. On macOS, same behavior. So GC should NOT delete files that might be mmap'd. Solution: GC moves to gc/ first, actual purge is deferred (or manual).

### 3. Manifest File Size

Each manifest is a small JSON (~1-5 KB for typical databases). 1000 manifests = ~5 MB. Acceptable.

For very long-running databases (100K+ manifests), old manifests can be purged alongside their GC'd segments.

### 4. Version Monotonicity

Version numbers MUST be strictly monotonic (never reuse, never gap under normal operation). Gaps can happen after crash recovery (partially written manifest file → skip that version).

```rust
fn next_version(&self) -> u64 {
    // Read all manifest files, find max version, add 1
    // OR: simply use current_version + 1 (cheaper, but gaps possible after crash)
    self.current.version + 1
}
```

**Recommendation:** Use `current_version + 1`. If a manifest file exists for that version (from a previous failed write), overwrite it (it was never committed).

### 5. field_declarations Separation

v1 stored `field_declarations` in `metadata.json`. v2 separates them to `field_declarations.json` — they're NOT per-snapshot (declarations are additive, never removed).

```rust
// field_declarations.json persists across all manifests
// Updated by declareFields() command, not by manifest creation
pub fn load_field_declarations(db_path: &Path) -> Result<Vec<FieldDeclaration>> {
    let path = db_path.join("field_declarations.json");
    if path.exists() {
        Ok(read_json(&path)?)
    } else {
        Ok(vec![])
    }
}
```

### 6. Manifest Chain Length

`parent_version` creates a linked list. `find_snapshot()` walks this list. For 1000 manifests, this is O(1000) disk reads in worst case.

**Optimization (not in T2.1):** Cache loaded manifests. Or: `list_snapshots()` reads directory listing (filesystem-level, no chain walking).

### 7. Ephemeral Databases

Ephemeral databases (created with `ephemeral: true`) don't write to disk. ManifestStore for ephemeral DBs should be in-memory only — no files, no manifests, no GC. Use a flag:

```rust
pub struct ManifestStore {
    db_path: Option<PathBuf>,  // None for ephemeral
    current: Manifest,
    // ...
}
```

### 8. Migration from v1

First open of a v1 database:
1. Detect: `nodes.bin` exists but `manifests/` doesn't
2. Create `manifests/` and `segments/` directories
3. Move `nodes.bin` → `segments/seg_000001_nodes.bin`
4. Move `edges.bin` → `segments/seg_000001_edges.bin`
5. Create manifest v1 with single node + edge segment
6. Write `current.json`
7. Move `metadata.json` → extract `field_declarations` to separate file

**This migration is one-time and automatic on open.** After migration, v1 layout is gone.

---

## Test Plan

### Manifest CRUD

1. `create_first_manifest` — empty DB → first manifest (version 1, no parent)
2. `create_sequential_manifests` — create 3 manifests → versions 1, 2, 3
3. `manifest_has_correct_stats` — stats match sum of segment record counts
4. `manifest_has_parent` — manifest N has parent_version = N-1
5. `manifest_persisted` — write → reload → identical

### Atomic Pointer

6. `commit_updates_current` — commit(3) → current.json reads version 3
7. `crash_simulation_pre_commit` — write manifest but don't commit → current still old
8. `crash_simulation_mid_rename` — simulated crash during rename → current.json valid (old or new)
9. `concurrent_reads` — one thread reads current, another commits new → no torn reads

### Snapshot Tags

10. `tag_snapshot` — add tags → persisted in manifest
11. `find_snapshot_by_tag` — tag with commit hash → correct version found
12. `find_snapshot_not_found` — search for nonexistent tag → None
13. `list_snapshots` — list all → sorted by version
14. `list_snapshots_filtered` — filter by tag key → correct subset

### Diff

15. `diff_empty_to_populated` — v1 (empty) → v2 (3 segments) → 3 added, 0 removed
16. `diff_same_version` — diff(N, N) → no changes
17. `diff_add_segments` — v2 has 2 new segments → diff shows them as added
18. `diff_remove_segments` — v3 removes 1 segment → diff shows it as removed
19. `diff_mixed` — add 2 segments, remove 1 → correct diff

### GC

20. `gc_collects_unreferenced` — segment in v1 not in v3 → moved to gc/
21. `gc_preserves_referenced` — segment in current manifest → NOT moved
22. `gc_purge_deletes` — gc/ files deleted
23. `gc_retention` — with retention=2, segments in v(N-1) preserved

### Edge Cases

24. `empty_database` — no segments → valid manifest with empty lists
25. `version_monotonicity` — versions always increase, no gaps

---

## Performance Considerations

- Manifest JSON read: ~0.1ms (small file)
- Manifest JSON write + fsync: ~1-5ms (SSD)
- Atomic rename: ~0.01ms
- Diff computation: O(S) where S = number of segments in both manifests. Typically <100 segments.
- GC collect: O(S × M) where S = total segment files, M = manifests in retention window. Infrequent operation.

---

## Dependencies (Cargo)

```toml
serde = { version = "1", features = ["derive"] }     # Already in project
serde_json = "1"                                       # Already in project
```

No new dependencies.
