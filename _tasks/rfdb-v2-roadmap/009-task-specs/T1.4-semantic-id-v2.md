# T1.4: Semantic ID v2 (Analyzer, TS)

> Milestone: M1 (Foundation)
> Dependencies: none
> Estimated: ~600 LOC changes, ~30 tests
> Related docs: [007-semantic-id-stability-research.md](../007-semantic-id-stability-research.md), [004-expert-concerns.md](../004-expert-concerns.md) I6

---

## High-Level Context

Текущий Semantic ID v1 содержит **scope path** — полный путь через анонимные скопы:

```
src/app.js->handler->if#0->CALL->console.log#0
```

**Проблема:** scope path содержит позиционные дискриминаторы (`if#0`, `for#1`). Добавление if-блока сдвигает `if#0` → `if#1`, что **каскадирует на ВСЕ дочерние узлы** — включая именованные сущности внутри скопа. Это обнуляет заявленную стабильность "именованные сущности стабильны".

```
Before:                                  After adding if-block above:
handler->if#0->FUNCTION->helper   →     handler->if#1->FUNCTION->helper
handler->if#0->CALL->fetch#0      →     handler->if#1->CALL->fetch#0
```

Именованная функция `helper` поменяла ID несмотря на отсутствие семантических изменений.

**Решение (TRIZ: разделение идентичности и адреса):**

Новый формат v2:
```
file->TYPE->name[in:namedParent]                    // базовый
file->TYPE->name[in:namedParent,h:xxxx]             // + content hash при коллизии
file->TYPE->name[in:namedParent,h:xxxx]#N           // + counter при полном дубликате
```

Scope path полностью убран из ID. Вместо него — `namedParent` (ближайший именованный предок). Анонимные скопы (if, for, try) не участвуют в ID → добавление/удаление блоков не каскадирует.

**Полное обоснование:** см. [007-semantic-id-stability-research.md](../007-semantic-id-stability-research.md)

---

## Existing Code to Study

| File | What to learn |
|------|--------------|
| `packages/core/src/core/SemanticId.ts` | `computeSemanticId()`, `parseSemanticId()`, `computeDiscriminator()`, format parsing |
| `packages/core/src/plugins/analysis/ast/IdGenerator.ts` | `generate()`, `generateSimple()`, `generateScope()`, `generateLegacy()`, dual ID system |
| `packages/core/src/core/ScopeTracker.ts` | Scope stack, `enterScope()`, `enterCountedScope()`, `getContext()`, `getItemCounter()`, `getSiblingIndex()` |
| `packages/core/src/plugins/analysis/ast/visitors/FunctionVisitor.ts` | Named/anonymous/arrow function ID generation, scope entry |
| `packages/core/src/plugins/analysis/ast/visitors/CallExpressionVisitor.ts` | CALL ID with discriminators, method calls, constructor calls |
| `packages/core/src/plugins/analysis/ast/visitors/VariableVisitor.ts` | VARIABLE/CONSTANT, loop variables, destructuring |
| `packages/core/src/plugins/analysis/ast/visitors/ClassVisitor.ts` | CLASS, METHOD, private methods, static blocks, getters/setters |
| `packages/core/src/plugins/analysis/ast/visitors/PropertyAccessVisitor.ts` | PROPERTY_ACCESS IDs |
| `packages/core/src/plugins/analysis/ast/visitors/TypeScriptVisitor.ts` | INTERFACE, TYPE, ENUM |
| `packages/core/src/plugins/analysis/ast/visitors/ImportExportVisitor.ts` | IMPORT, EXPORT IDs |

---

## Changed Files

```
packages/core/src/core/SemanticId.ts              ← ADD: computeSemanticIdV2(), parseSemanticIdV2()
packages/core/src/core/ScopeTracker.ts            ← ADD: getNamedParent()
packages/core/src/plugins/analysis/ast/
  IdGenerator.ts                                   ← MODIFY: generate(), generateSimple() use v2 format
  CollisionResolver.ts                             ← NEW: per-file collision detection + resolution
  ContentHasher.ts                                 ← NEW: per-node-type AST content hashing
  visitors/FunctionVisitor.ts                      ← MODIFY: arrow→ObjectProperty naming, content hash
  visitors/CallExpressionVisitor.ts                ← MODIFY: content hash for CALL disambiguation
  visitors/VariableVisitor.ts                      ← MODIFY: content hash for VARIABLE
  visitors/ClassVisitor.ts                         ← MODIFY: static blocks, computed properties
  visitors/PropertyAccessVisitor.ts                ← MODIFY: content hash
  visitors/TypeScriptVisitor.ts                    ← minor (already unique by name)
```

---

## New ID Format

### Grammar

```
semantic_id_v2 = file "->" TYPE "->" name "[in:" named_parent qualifiers "]" counter?

file          = string (relative path)
TYPE          = "FUNCTION" | "CLASS" | "CALL" | "VARIABLE" | "CONSTANT" | "SCOPE"
               | "IMPORT" | "EXPORT" | "PARAMETER" | "INTERFACE" | "TYPE" | "ENUM"
               | "PROPERTY_ACCESS" | "ARRAY_MUTATION" | "OBJECT_MUTATION"
               | "EVENT_LISTENER" | "EXTERNAL_MODULE" | ...
name          = string (entity name)
named_parent  = string ("global" | function/class name)
qualifiers    = ("," "h:" hex4)?     // content hash if collision
hex4          = [0-9a-f]{4}
counter       = "#" digit+            // only for identical-content duplicates
```

### Examples

```
// Category A: always unique
src/app.js->FUNCTION->processData[in:global]
src/app.js->CLASS->UserService[in:global]
src/app.js->FUNCTION->login[in:UserService]
src/app.js->FUNCTION->get:name[in:User]
src/app.js->FUNCTION->#validate[in:User]
src/app.js->FUNCTION->constructor[in:User]
src/app.ts->INTERFACE->IUser[in:global]
src/app.ts->TYPE->UserId[in:global]
src/app.ts->ENUM->Status[in:global]
src/app.js->IMPORT->./db:connection[in:global]
src/app.js->EXPORT->processData[in:global]
src/app.js->SCOPE->body[in:processData]
src/app.js->PARAMETER->userId#0[in:login]
EXTERNAL_MODULE->lodash

// Category B: usually unique, collision resolved by hash
src/app.js->VARIABLE->x[in:process]
src/app.js->VARIABLE->x[in:process,h:a3f2]       // shadowing collision

// Category C: frequently collide — hash resolves
src/app.js->CALL->console.log[in:process,h:a3f2]
src/app.js->CALL->console.log[in:process,h:b1c4]
src/app.js->FUNCTION->anonymous[in:handler,h:c3d1]
src/app.js->FUNCTION->anonymous[in:handler,h:e5f3]

// Counter fallback (identical content duplicates)
src/app.js->FUNCTION->anonymous[in:retry,h:same]#0
src/app.js->FUNCTION->anonymous[in:retry,h:same]#1
```

---

## Implementation: Step by Step

### Step 1: `ScopeTracker.getNamedParent()`

Add method to ScopeTracker:

```typescript
getNamedParent(): string {
  // Walk scope stack from top, find nearest non-anonymous FUNCTION/CLASS/METHOD
  for (let i = this.scopeStack.length - 1; i >= 0; i--) {
    const scope = this.scopeStack[i];
    if ((scope.type === 'FUNCTION' || scope.type === 'CLASS' || scope.type === 'METHOD') &&
        scope.name !== 'anonymous' &&
        !scope.name.startsWith('anonymous[')) {
      return scope.name;
    }
  }
  return 'global';
}
```

**Nuances:**
- Skip anonymous functions — take next named ancestor
- Skip `anonymous[0]` etc. (sibling-indexed anonymous)
- Arrow functions assigned to variables: `const handler = () => {}` — scope name is `handler` (named), not skipped
- `'global'` when no named ancestor found (top-level code)
- METHOD type added — methods inside classes are named parents for their contents

### Step 2: `computeSemanticIdV2()` in SemanticId.ts

```typescript
export function computeSemanticIdV2(
  type: string,
  name: string,
  context: { file: string; namedParent: string },
  options?: { contentHash?: string; discriminator?: number }
): string {
  const { file, namedParent } = context;

  let qualifiers = `in:${namedParent}`;
  if (options?.contentHash) {
    qualifiers += `,h:${options.contentHash}`;
  }

  let id = `${file}->${type}->${name}[${qualifiers}]`;

  if (options?.discriminator !== undefined && options.discriminator >= 0) {
    id += `#${options.discriminator}`;
  }

  return id;
}
```

**Special cases:**
- `EXTERNAL_MODULE` nodes: no file prefix, no `[in:]` → `EXTERNAL_MODULE->lodash` (unchanged)
- Singleton nodes (`net:stdio`, `net:request`): keep as-is (no scope path anyway)
- `PARAMETER` nodes: `#N` is parameter position in signature (semantic!), not collision counter

### Step 3: `parseSemanticIdV2()` in SemanticId.ts

```typescript
export interface ParsedSemanticIdV2 {
  file: string;
  type: string;
  name: string;
  namedParent: string;
  contentHash?: string;      // 4 hex chars
  discriminator?: number;    // #N counter
}

export function parseSemanticIdV2(id: string): ParsedSemanticIdV2 | null {
  // Handle special cases: EXTERNAL_MODULE, singletons
  if (id.startsWith('EXTERNAL_MODULE->')) {
    return {
      file: '', type: 'EXTERNAL_MODULE',
      name: id.slice('EXTERNAL_MODULE->'.length),
      namedParent: 'global'
    };
  }

  // Parse: file->TYPE->name[in:parent,h:xxxx]#N
  const arrowParts = id.split('->');
  if (arrowParts.length < 3) return null;

  const file = arrowParts[0];
  const type = arrowParts[1];
  let nameWithQualifiers = arrowParts.slice(2).join('->');  // name may contain ->

  // Extract #N counter
  let discriminator: number | undefined;
  const hashMatch = nameWithQualifiers.match(/#(\d+)$/);
  if (hashMatch) {
    discriminator = parseInt(hashMatch[1], 10);
    nameWithQualifiers = nameWithQualifiers.slice(0, -hashMatch[0].length);
  }

  // Extract [in:parent,h:xxxx]
  const bracketMatch = nameWithQualifiers.match(/\[(.+)\]$/);
  if (!bracketMatch) return null;

  const name = nameWithQualifiers.slice(0, bracketMatch.index);
  const qualifiersStr = bracketMatch[1];

  // Parse qualifiers
  const qualifiers = qualifiersStr.split(',').reduce((acc, part) => {
    const [key, value] = part.split(':');
    acc[key.trim()] = value?.trim();
    return acc;
  }, {} as Record<string, string>);

  return {
    file, type, name,
    namedParent: qualifiers['in'] || 'global',
    contentHash: qualifiers['h'],
    discriminator
  };
}
```

### Step 4: ContentHasher (NEW)

```typescript
/**
 * Computes content hash for AST subtrees.
 * Used for disambiguation of same-named nodes in same named scope.
 *
 * Hash = first 4 hex chars of xxHash64 of stringified AST subtree.
 * "Stringified" = JSON.stringify of relevant AST sub-tree with location info stripped.
 */
export class ContentHasher {
  /**
   * Hash for CALL/METHOD_CALL disambiguation.
   * Source: arguments AST (what is passed to the function).
   */
  static hashCallArguments(argsNode: BabelNode[]): string {
    return this.computeHash(this.stripLocations(argsNode));
  }

  /**
   * Hash for anonymous FUNCTION disambiguation.
   * Source: function body AST.
   */
  static hashFunctionBody(bodyNode: BabelNode): string {
    return this.computeHash(this.stripLocations(bodyNode));
  }

  /**
   * Hash for VARIABLE/CONSTANT disambiguation.
   * Source: initializer expression AST.
   */
  static hashInitializer(initNode: BabelNode | null): string {
    if (!initNode) return '0000';
    return this.computeHash(this.stripLocations(initNode));
  }

  /**
   * Hash for SCOPE (static_block) disambiguation.
   * Source: block body AST.
   */
  static hashBlockBody(bodyNode: BabelNode[]): string {
    return this.computeHash(this.stripLocations(bodyNode));
  }

  /**
   * Hash for PROPERTY_ACCESS disambiguation.
   * Source: surrounding statement AST.
   */
  static hashSurroundingStatement(stmtNode: BabelNode): string {
    return this.computeHash(this.stripLocations(stmtNode));
  }

  private static stripLocations(node: unknown): unknown {
    // Deep clone AST subtree removing start/end/loc/leadingComments/trailingComments
    // This ensures hash is content-based, not position-based
  }

  private static computeHash(data: unknown): string {
    const json = JSON.stringify(data);
    // xxHash64 → first 4 hex chars
    const hash = xxHash64(json);
    return hash.toString(16).padStart(16, '0').slice(0, 4);
  }
}
```

**Nuance: Why JSON.stringify + xxHash64?**
- JSON.stringify is deterministic for same AST structure
- xxHash64 is fast (10x faster than SHA/BLAKE3 for small inputs)
- 4 hex chars = 16 bits = 65536 values → <1% collision rate for typical scope sizes
- Stripping locations ensures hash depends on CONTENT, not POSITION

**Dependency:** Need `xxhash-wasm` or similar npm package for xxHash64 in TS. Alternatively, use a simple FNV-1a hash (good enough for 4 chars).

### Step 5: CollisionResolver (NEW)

```typescript
/**
 * Per-file collision resolver for Semantic ID v2.
 *
 * During AST traversal, all nodes are initially assigned base IDs
 * (file->TYPE->name[in:parent]). After traversal completes, collision
 * resolver promotes colliding IDs through the disambiguation chain:
 * base → +hash → +counter.
 *
 * IMPORTANT: When base ID collides, ALL nodes sharing that base must
 * be promoted to hash level (not just the second one). This ensures
 * deterministic IDs regardless of traversal order.
 */
export class CollisionResolver {
  // Map: baseId → list of {nodeRef, contentHash}
  private groups: Map<string, Array<{ nodeRef: NodeRef; contentHash: string }>>;

  constructor() {
    this.groups = new Map();
  }

  /**
   * Register a node with its base ID and content hash.
   * Called during AST traversal for every node.
   */
  register(baseId: string, contentHash: string, nodeRef: NodeRef): void {
    if (!this.groups.has(baseId)) {
      this.groups.set(baseId, []);
    }
    this.groups.get(baseId)!.push({ nodeRef, contentHash });
  }

  /**
   * Resolve all collisions and assign final IDs.
   * Called AFTER all nodes in a file are registered.
   *
   * Returns: Map<NodeRef, finalId>
   */
  resolve(): Map<NodeRef, string> {
    const result = new Map<NodeRef, string>();

    for (const [baseId, nodes] of this.groups) {
      if (nodes.length === 1) {
        // No collision — use base ID as-is
        result.set(nodes[0].nodeRef, baseId);
        continue;
      }

      // Collision on base ID — promote ALL to hash level
      const hashGroups = new Map<string, Array<{ nodeRef: NodeRef }>>();
      for (const node of nodes) {
        const hashId = this.addHash(baseId, node.contentHash);
        if (!hashGroups.has(hashId)) {
          hashGroups.set(hashId, []);
        }
        hashGroups.get(hashId)!.push(node);
      }

      for (const [hashId, hashNodes] of hashGroups) {
        if (hashNodes.length === 1) {
          // Hash resolved collision
          result.set(hashNodes[0].nodeRef, hashId);
        } else {
          // Same hash — use counter (extremely rare)
          hashNodes.forEach((node, i) => {
            result.set(node.nodeRef, `${hashId}#${i}`);
          });
        }
      }
    }

    return result;
  }

  private addHash(baseId: string, contentHash: string): string {
    // file->TYPE->name[in:parent] → file->TYPE->name[in:parent,h:xxxx]
    const bracketIdx = baseId.lastIndexOf(']');
    return baseId.slice(0, bracketIdx) + `,h:${contentHash}]`;
  }
}
```

**Critical design decision: Deferred Finalization**

Collision detection requires seeing ALL nodes before assigning final IDs. This means:
1. During AST traversal: compute base ID + content hash, register with CollisionResolver
2. After traversal: call `resolve()` to get final IDs
3. Update node records with final IDs

This is a **two-pass approach for ID assignment** (but single-pass for AST traversal). The second "pass" is just Map lookups — O(n) with tiny constant.

**NodeRef can be:** index into the nodes array, or the node object itself.

**Integration with GraphBuilder pipeline:**

`resolveCollisions()` is called AFTER all visitors have completed processing a file, but BEFORE edges are sent to RFDB. The sequence:
1. Visitors traverse AST → call `idGenerator.generateV2()` for each node → provisional base IDs
2. All visitors complete for the file
3. `idGenerator.resolveCollisions()` → final ID map
4. Fixup pass: update node IDs and edge src/dst references using the final ID map
5. Nodes + edges committed to RFDB (via batch or direct write)

Cross-file edge references work correctly because: src file is fully resolved (step 3-4) before edges are committed (step 5). Dst references use semantic IDs that are already stable (the dst file was resolved in its own analysis pass).

### Step 6: Update IdGenerator

```typescript
class IdGenerator {
  private collisionResolver: CollisionResolver;

  constructor(scopeTracker?: ScopeTracker) {
    this.collisionResolver = new CollisionResolver();
  }

  /**
   * Generate a v2 semantic ID.
   * Returns a PROVISIONAL base ID. Final ID assigned after collision resolution.
   */
  generateV2(
    type: string,
    name: string,
    file: string,
    contentHash: string,
    nodeRef: NodeRef
  ): string {
    const namedParent = this.scopeTracker!.getNamedParent();
    const baseId = computeSemanticIdV2(type, name, { file, namedParent });

    this.collisionResolver.register(baseId, contentHash, nodeRef);

    return baseId;  // Provisional — may change after resolve()
  }

  /**
   * Call after all nodes in file are generated.
   * Returns final ID map.
   */
  resolveCollisions(): Map<NodeRef, string> {
    return this.collisionResolver.resolve();
  }
}
```

**Nuance:** During traversal, nodes use provisional base IDs. Edges reference these provisional IDs. After collision resolution, a fixup pass updates both node IDs and edge src/dst references.

Alternative: keep nodes in a mutable array, assign final IDs before any edges are created. This depends on the visitor architecture (can edges be deferred?).

### Step 7: Update Visitors

#### FunctionVisitor Changes

1. **Named functions:** Use `generateV2('FUNCTION', name, file, hash, ref)`. Content hash = '0000' (no hash needed for unique names).

2. **Anonymous functions:** Content hash = `ContentHasher.hashFunctionBody(body)`. Name = 'anonymous'.

3. **Arrow → variable:** Name = variable name (already implemented). Content hash = '0000' if name is unique.

4. **Arrow → ObjectProperty (NEW — edge case 4.7):**
   ```typescript
   // Currently: both arrows become 'anonymous'
   // Fix: check if parent is ObjectProperty → use key name
   if (path.parentPath?.isObjectProperty()) {
     functionName = path.parentPath.node.key.name || path.parentPath.node.key.value;
   }
   ```
   This gives `onClick`, `onHover` instead of `anonymous` for object method arrows.

5. **Getter/Setter:** Name = `get:propName` / `set:propName` (already implemented in ClassVisitor, may need adding to FunctionVisitor for standalone getters).

#### CallExpressionVisitor Changes

1. **Remove `useDiscriminator: true`** — no more counter-based discriminators
2. **Add content hash:** `ContentHasher.hashCallArguments(node.arguments)`
3. **Constructor calls:** Name = `new:ClassName` (unchanged), hash from arguments
4. **Method calls:** Name = `obj.method` (unchanged), hash from arguments

#### VariableVisitor Changes

1. **Remove loop scope counting** — `for-of#0` etc. no longer in ID
2. **Add content hash:** `ContentHasher.hashInitializer(init)`
3. **CONSTANT vs VARIABLE:** type determination unchanged

#### ClassVisitor Changes

1. **Static blocks:** Remove `static_block#N` discriminator → use content hash
2. **Computed properties:** Name = `<computed>`, content hash = body hash
3. **Private methods:** Name = `#methodName` (unchanged, unique per class)

---

## Critical Nuances

### 1. Two-Pass ID Assignment

The CollisionResolver requires ALL nodes before assigning final IDs. This changes the current single-pass model where IDs are final at creation time.

**Impact on edges:** Edges created during traversal reference node IDs. If node IDs change during collision resolution, edge src/dst must be updated too.

**Approaches:**
- **A. Deferred edges:** Collect edges in a buffer, resolve node IDs first, then fixup edge references. Requires buffering but clean.
- **B. Symbolic references:** Edges use provisional base IDs. After resolution, walk edges and replace. Requires a lookup map.
- **C. Resolve per scope:** After exiting each named scope, resolve collisions for that scope's nodes. This limits deferred resolution to a small scope.

**Recommendation:** Approach A (deferred edges) — already used in GraphBuilder for batching addNode/addEdge calls.

### 2. PARAMETER Node Discriminator

`PARAMETER->userId#0[in:login]` — the `#0` is parameter **position** in function signature, NOT collision counter.

This is semantically meaningful: position changes when signature changes (which IS a semantic change — callers need update).

**Implementation:** PARAMETER uses `#N` suffix directly, NOT through CollisionResolver. Parameters are always unique within a function (no collision possible for different positions).

### 3. IMPORT Node Format

```
file->IMPORT->./db:connection[in:global]
```

Import name = `source:specifier`. Already unique per file (can't import same specifier from same source twice). No collision possible.

### 4. SCOPE Node Format

```
file->SCOPE->body[in:processData]
```

One `body` scope per function. No collision. Static blocks: `SCOPE->static_block[in:Foo,h:xxxx]` with content hash.

### 5. Named Parent for Deep Nesting

```javascript
function outer() {
  const inner = () => {     // named (arrow→variable), parent=outer
    if (true) {
      for (const x of y) {
        console.log(x);     // namedParent = inner (skip if, for)
      }
    }
  };
}
```

Rule: skip if/for/try/while/switch scopes (they have type !== FUNCTION/CLASS). Skip anonymous functions. Take nearest named FUNCTION/CLASS.

### 6. File Rename = Different ID

File path is in the ID. File rename = all IDs change. This is BY DESIGN — file identity is part of node identity. Handled by C4 blast radius: pre-commit query finds dependents, re-enrichment updates edges.

### 7. xxHash vs FNV-1a for Content Hash

xxHash64 is ideal but requires a dependency. FNV-1a is trivial to implement (~10 LOC) and sufficient for 4 hex chars (collision resistance doesn't need to be cryptographic).

**Recommendation:** Use FNV-1a for simplicity. Switch to xxHash if collision rate is unacceptable (unlikely for <100 same-named nodes per scope).

```typescript
function fnv1a32(str: string): number {
  let hash = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    hash ^= str.charCodeAt(i);
    hash = (hash * 0x01000193) >>> 0;
  }
  return hash;
}

function contentHash4(str: string): string {
  return (fnv1a32(str) >>> 0).toString(16).padStart(8, '0').slice(0, 4);
}
```

No new dependencies needed.

### 8. Backward Compatibility

v1 → v2 is a **breaking change**. All IDs change format. Entire graph must be re-analyzed.

During development:
- `computeSemanticId()` (v1) stays untouched
- `computeSemanticIdV2()` added alongside
- `generateLegacy()` continues to work
- IdGenerator gets a `version` flag to switch between v1/v2
- Tests can compare v1 and v2 outputs for same AST

### 9. `stability_tier` Metadata Removed

v1 had stability tiers (1-3) in metadata. v2 makes ALL nodes effectively tier 1-2 (scope path removed). The `stability_tier` field can be removed from NodeFactory/visitors.

---

## Test Plan

### Format & Parsing

1. `compute_v2_basic` — `computeSemanticIdV2('FUNCTION', 'foo', {file: 'a.js', namedParent: 'global'})` → `a.js->FUNCTION->foo[in:global]`
2. `compute_v2_with_hash` — with contentHash → `[in:global,h:a3f2]`
3. `compute_v2_with_counter` — with discriminator → `[in:global,h:a3f2]#0`
4. `parse_v2_basic` — roundtrip: compute → parse → same components
5. `parse_v2_with_hash` — hash extracted correctly
6. `parse_v2_with_counter` — discriminator extracted correctly
7. `parse_v2_external_module` — `EXTERNAL_MODULE->lodash` → special case
8. `parse_v2_parameter` — `PARAMETER->x#0[in:foo]` → position discriminator

### Named Parent

9. `named_parent_global` — top-level code → 'global'
10. `named_parent_function` — inside function → function name
11. `named_parent_class` — inside class → class name
12. `named_parent_method` — inside method → method name
13. `named_parent_skip_anonymous` — inside anonymous function → skip to named ancestor
14. `named_parent_skip_arrow_anonymous` — `anonymous[0]` skipped
15. `named_parent_deep_nesting` — function → if → for → arrow → CALL → namedParent = function

### Content Hash

16. `content_hash_call_arguments` — different args → different hash
17. `content_hash_function_body` — different body → different hash
18. `content_hash_initializer` — different init → different hash
19. `content_hash_null_init` — null initializer → '0000'
20. `content_hash_position_independent` — same content at different lines → same hash

### Collision Resolution

21. `no_collision_unique_names` — N unique names → N base IDs unchanged
22. `collision_same_name_different_hash` — 2 `console.log` with different args → hash-disambiguated
23. `collision_same_name_same_hash` — identical calls → counter-disambiguated
24. `collision_first_promoted` — when collision detected, FIRST node also gets hash (not just second)
25. `collision_three_way` — 3 same-name nodes: 2 different hashes + 1 duplicate → correct resolution

### Stability (Critical)

26. `add_lines_above_no_change` — add empty lines → ID unchanged
27. `add_if_block_no_cascade` — add if-block above → child IDs unchanged (THE KEY TEST)
28. `rename_parent_changes_children` — rename function → children's `[in:]` changes (correct — semantic change)
29. `move_between_functions_changes` — move code to different function → `[in:]` changes (correct)
30. `add_new_function_no_change` — add function → existing IDs unchanged

### Full Analysis Integration

31. `analysis_fixture_no_duplicate_ids` — analyze test fixture → no duplicate IDs within any file
32. `analysis_v1_vs_v2_mapping` — analyze fixture → compare v1 and v2 IDs, document all differences
33. `analysis_real_project_no_duplicates` — analyze real project folder → zero duplicate IDs

---

## Performance Considerations

- Content hash computation: JSON.stringify + FNV-1a per node. ~1µs per node. For 10K nodes = 10ms. Negligible vs parse time.
- CollisionResolver: two Map lookups per node. O(n) total. Negligible.
- Two-pass ID assignment: O(n) fixup pass. Negligible.
- **No regression** vs v1 — v1 also does string operations per node.

---

## Dependencies (npm)

No new dependencies. FNV-1a implemented inline (~10 LOC).
