# T3.2: Client Batch API (Track 3, TS)

> Milestone: M3 (Incremental Core)
> Dependencies: T3.1 (Rust Batch), T1.3 (Client Request IDs)
> Estimated: ~200 LOC, ~15 tests
> Related docs: [006-client-spec.md](../006-client-spec.md), [002-roadmap.md](../002-roadmap.md) §2, [T3.1 spec](./T3.1-tombstones-batch-commit.md)

---

## High-Level Context

T3.1 добавляет batch commit в Rust сервер. T3.2 — клиентская обёртка: `beginBatch()`, `commitBatch()`, `abortBatch()` + `CommitDelta` type + `findDependentFiles()` для blast radius (C4).

Клиент не знает про шарды, tombstones, сегменты. Он видит простой API: начать batch → добавить данные → commit → получить delta.

---

## Existing Code to Study

| File | What to learn |
|------|--------------|
| `packages/rfdb/ts/client.ts` | `_send()` method, all existing public methods pattern |
| `packages/types/src/plugins.ts` | Existing types for graph operations |

---

## Changed Files

```
packages/rfdb/ts/client.ts        ← ADD: beginBatch(), commitBatch(), abortBatch(), findDependentFiles()
packages/rfdb/ts/types.ts         ← ADD: CommitDelta, BatchTags types (or create if doesn't exist)
```

---

## New Methods

### beginBatch()

```typescript
async beginBatch(): Promise<void> {
  await this._send('beginBatch');
}
```

### commitBatch()

```typescript
async commitBatch(tags?: Record<string, string>): Promise<CommitDelta> {
  const response = await this._send('commitBatch', { tags });
  return response.delta as CommitDelta;
}
```

### abortBatch()

```typescript
async abortBatch(): Promise<void> {
  await this._send('abortBatch');
}
```

### findDependentFiles() (C4 Blast Radius)

```typescript
/**
 * Find files that depend on the given files.
 * Used for pre-commit blast radius query.
 *
 * "Depends on" = has edges where dst is a node in one of the given files.
 * Returns src.file values that are NOT in the input set.
 *
 * MUST be called BEFORE commitBatch — after commit, tombstones hide old edges (C3).
 */
async findDependentFiles(changedFiles: string[]): Promise<string[]> {
  // Implementation via Datalog query or targeted edge query
  const query = `dependent_file(SrcFile) :-
    edge(Src, Dst, _),
    node(Dst, _, _, DstFile, _),
    node(Src, _, _, SrcFile, _),
    member(DstFile, ChangedFiles),
    not_member(SrcFile, ChangedFiles).`;

  // Or simpler: iterate changedFiles, get incoming edges, collect src files
  const dependentFiles = new Set<string>();
  for (const file of changedFiles) {
    const nodesInFile = await this.getAllNodes({ file });
    for (const node of nodesInFile) {
      const incoming = await this.getIncomingEdges(node.id);
      for (const edge of incoming) {
        const srcNode = await this.getNode(edge.src);
        if (srcNode && srcNode.file && !changedFiles.includes(srcNode.file)) {
          dependentFiles.add(srcNode.file);
        }
      }
    }
  }
  return [...dependentFiles];
}
```

**Nuance:** The naive implementation above is O(nodes_in_file × incoming_edges). For large files this is expensive. A server-side command (custom query) would be much more efficient. Options:

1. **Server-side command** (recommended for T4.1): Add `FindDependentFiles { files: Vec<String> }` to Request enum
2. **Datalog query** (if available): Single query, server handles optimization
3. **Client-side iteration** (T3.2 fallback): Works but slow for large graphs

For T3.2, implement client-side iteration as fallback. T4.1 adds server-side command.

---

## CommitDelta Type

```typescript
export interface CommitDelta {
  /** Files that had nodes added/removed/modified */
  changedFiles: string[];

  /** Total nodes added */
  nodesAdded: number;

  /** Total nodes removed (tombstoned) */
  nodesRemoved: number;

  /** Nodes modified (same ID, different content_hash) */
  nodesModified: number;

  /** Semantic IDs of removed nodes */
  removedNodeIds: string[];

  /** Node types in changed nodes */
  changedNodeTypes: string[];

  /** Edge types in changed edges */
  changedEdgeTypes: string[];
}
```

---

## Critical Nuances

### 1. Auto-Commit Detection

AddNodes/AddEdges without BeginBatch → auto-commit (v1 behavior). Client should NOT break existing code that doesn't use batches.

```typescript
// Old code (works unchanged):
await client.addNodes(nodes);  // Immediate, no delta

// New code (batch):
await client.beginBatch();
await client.addNodes(nodes);
const delta = await client.commitBatch();  // Atomic, returns delta
```

### 2. Batch State is Server-Side

Client doesn't track batch state locally. Server rejects double-begin or commit-without-begin.

```typescript
await client.beginBatch();
await client.beginBatch();  // → server error: "Batch already active"
```

### 3. Request IDs During Batch

With T1.3 request IDs, batch operations are safe even with pipelined requests. Each addNodes/addEdges within batch gets its own requestId.

### 4. Timeout During Batch

If a request times out during an active batch, the batch state is undefined. Client should abort on timeout:

```typescript
try {
  await client.addNodes(nodes);
} catch (e) {
  if (e.message.includes('timed out')) {
    await client.abortBatch().catch(() => {}); // Best effort abort
  }
  throw e;
}
```

---

## Test Plan

### Basic Batch

1. `begin_commit` — begin → addNodes → commit → data visible, delta returned
2. `begin_abort` — begin → addNodes → abort → data NOT visible
3. `commit_returns_delta` — delta has changedFiles, nodesAdded, etc.
4. `commit_with_tags` — tags passed → stored in snapshot

### Auto-Commit

5. `add_without_batch` — addNodes without begin → immediate, no delta
6. `auto_commit_backward_compat` — existing code works unchanged

### Error Handling

7. `double_begin_error` — begin → begin → error
8. `commit_without_begin_error` — commit without begin → error
9. `abort_without_begin_error` — abort without begin → error (or no-op)

### CommitDelta Accuracy

10. `delta_added_nodes` — new file → nodesAdded > 0
11. `delta_removed_nodes` — re-analyze with fewer nodes → nodesRemoved > 0
12. `delta_modified_nodes` — same ids, different content → nodesModified > 0
13. `delta_changed_files` — commit 2 files → changedFiles = [file1, file2]

### Integration

14. `integration_batch_roundtrip` — TS client → Rust server → batch → delta → correct
15. `find_dependent_files` — file A imports B, change B → A in dependents

---

## Performance Considerations

- Batch operations are same latency as non-batch (just accumulation on server)
- CommitBatch may be slower than individual addNodes (tombstone + delta computation)
- findDependentFiles client-side is O(n × m) — server-side command needed for production
