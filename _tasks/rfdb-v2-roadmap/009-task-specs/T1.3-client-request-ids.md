# T1.3: Client Request IDs (Track 3, TS + Rust)

> Milestone: M1 (Foundation)
> Dependencies: none
> Estimated: ~150 LOC (TS) + ~30 LOC (Rust)
> Related docs: [006-client-spec.md](../006-client-spec.md), [002-roadmap.md](../002-roadmap.md) §2

---

## High-Level Context

Текущий RFDBClient использует **FIFO matching** — ответы сервера сопоставляются с запросами в порядке отправки. Это работает только при строго последовательных запросах.

Проблемы:
1. **Нет multiplex:** нельзя безопасно послать 5 запросов параллельно — если сервер ответит в другом порядке, ответы попадут не тем запросам
2. **Streaming невозможен:** без ID нельзя понять, к какому запросу относится chunk
3. **Timeout hazard:** если один запрос timeout'ит, FIFO map сдвигается — все последующие ответы попадают не тем запросам

T1.3 добавляет `requestId` в wire protocol:
- Клиент отправляет `requestId` в каждом запросе
- Сервер echo'ит `requestId` в ответе
- Клиент матчит по `requestId`, FIFO как fallback для backward compat

Это **тривиальное изменение** в обоих кодовых базах, но оно — фундамент для streaming (T4.3) и concurrent batch (T3.2).

---

## Existing Code to Study

| File | What to learn |
|------|--------------|
| `packages/rfdb/ts/client.ts` (~748 LOC) | `_send()` method (line ~185), `_handleResponse()` (line ~160), `pending` Map, `reqId` counter |
| `packages/rfdb-server/src/bin/rfdb_server.rs` | `Request` enum, `Response` enum, `handle_request()` function |
| `test/unit/rfdb-client.test.js` | Integration tests for client ↔ server |

---

## Current Implementation Details

### Client: `_send()` (TS)

```typescript
private async _send(cmd, payload, timeoutMs): Promise<RFDBResponse> {
  const request = { cmd, ...payload };
  const msgBytes = encode(request);               // MessagePack encode
  const id = this.reqId++;                         // Local counter
  // ...timeout setup...
  this.pending.set(id, { resolve, reject });       // Store by LOCAL id
  // Write [4-byte length][msgpack] to socket
}
```

**Key observation:** `reqId` is used ONLY as key in the local `pending` Map. It is **never sent** to the server. The wire request is `{ cmd, ...payload }` — no id field.

### Client: `_handleResponse()` (TS)

```typescript
private _handleResponse(response: RFDBResponse): void {
  const [id, { resolve, reject }] = this.pending.entries().next().value;  // FIFO!
  this.pending.delete(id);
  if (response.error) reject(new Error(response.error));
  else resolve(response);
}
```

**FIFO:** Always takes the OLDEST pending request, regardless of response content.

### Server: Request handling (Rust)

```rust
#[derive(Debug, Deserialize)]
#[serde(tag = "cmd", rename_all = "camelCase")]
pub enum Request {
  AddNodes { nodes: Vec<WireNode> },
  // ... no requestId field anywhere
}
```

Server processes requests sequentially per connection. One request → one response → next request.

---

## Changes

### 1. Wire Protocol: Add `requestId` Field

#### Client Side (TS)

**In `_send()`:** include `requestId` in the wire message.

```typescript
private async _send(cmd, payload, timeoutMs): Promise<RFDBResponse> {
  const requestId = `r${this.reqId++}`;  // String ID: "r0", "r1", "r2", ...
  const request = { cmd, requestId, ...payload };
  // ...
  this.pending.set(requestId, { resolve, reject, timer });
}
```

**Changes to pending map:**
- Key changes from `number` to `string` (requestId)
- Type: `Map<string, PendingRequest>`

**In `_handleResponse()`:** match by `requestId` if present, FIFO fallback otherwise.

```typescript
private _handleResponse(response: RFDBResponse): void {
  let pending: PendingRequest | undefined;
  let pendingKey: string;

  if (response.requestId && this.pending.has(response.requestId)) {
    // Match by requestId (v2+ server)
    pendingKey = response.requestId;
    pending = this.pending.get(pendingKey);
  } else {
    // FIFO fallback (v1 server without requestId echo)
    const first = this.pending.entries().next().value;
    if (!first) {
      this.emit('error', new Error('Received response with no pending request'));
      return;
    }
    [pendingKey, pending] = first;
  }

  this.pending.delete(pendingKey);
  // Clear timeout timer
  if (pending.timer) clearTimeout(pending.timer);

  if (response.error) {
    pending.reject(new Error(response.error));
  } else {
    pending.resolve(response);
  }
}
```

#### Server Side (Rust)

**In Request parsing:** add optional `request_id` field.

```rust
#[derive(Debug, Deserialize)]
#[serde(tag = "cmd", rename_all = "camelCase")]
pub enum Request {
  AddNodes {
    nodes: Vec<WireNode>,
    #[serde(default)]
    request_id: Option<String>,
  },
  GetNode {
    id: String,
    #[serde(default)]
    request_id: Option<String>,
  },
  // ... same for ALL variants
}
```

**Alternative (cleaner):** Extract `request_id` before command dispatch.

```rust
// Instead of adding request_id to every variant:
// Parse raw message, extract request_id, then parse command

fn handle_message(raw: &[u8]) -> Vec<u8> {
  let value: serde_json::Value = rmp_serde::from_slice(raw)?;
  let request_id = value.get("requestId").and_then(|v| v.as_str()).map(String::from);

  let request: Request = rmp_serde::from_slice(raw)?;  // serde ignores unknown fields
  let mut response = handle_request(request);

  // Echo requestId if present
  if let Some(rid) = request_id {
    inject_request_id(&mut response, &rid);
  }

  rmp_serde::to_vec(&response)?
}
```

**Recommendation:** Use the "extract before dispatch" approach. Reasons:
1. No changes to any Request variant (no risk of breaking existing parsing)
2. Centralized — one place handles requestId
3. Works automatically for ALL commands (existing and future)

**In Response serialization:** add `requestId` to response.

```rust
fn inject_request_id(response: &mut Response, request_id: &str) {
  // Option A: Add requestId field to Response enum variants
  // Option B: Serialize response, inject field into MessagePack map, re-serialize
  // Option C: Use a wrapper struct

  // Recommended: Option C
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct WireResponse {
  #[serde(skip_serializing_if = "Option::is_none")]
  request_id: Option<String>,
  #[serde(flatten)]
  inner: Response,
}
```

---

### 2. Timeout: Per-Request Cancellation

Currently, timeout deletes from pending by local id. With requestId:

```typescript
// Timeout handler:
const timer = setTimeout(() => {
  this.pending.delete(requestId);
  reject(new Error(`RFDB ${cmd} timed out after ${timeoutMs}ms...`));
}, timeoutMs);
```

**Nuance:** If a timed-out request's response arrives later, `requestId` won't be in pending → response is silently dropped (correct behavior). In FIFO mode, a late response would match the WRONG request — requestId fixes this.

---

### 3. PendingRequest Type Update

```typescript
interface PendingRequest {
  resolve: (value: RFDBResponse) => void;
  reject: (error: Error) => void;
  timer: ReturnType<typeof setTimeout>;
  cmd: string;  // For debugging/logging
}
```

Add `timer` and `cmd` to enable proper cleanup.

---

## Critical Nuances

### 1. requestId Format

`r${counter}` — string, not number. Reasons:
- MessagePack handles strings uniformly across languages
- Avoids u64 overflow concerns (not realistic, but defensive)
- Prefix `r` distinguishes from other numeric fields in the wire message
- Streaming chunks (T4.3) will use same requestId — string is more natural

### 2. FIFO Fallback is Essential

Client MUST work with v1 server (no requestId echo). This enables:
- Gradual rollout: update client first, server later
- Testing: client tests against both v1 and v2 servers
- Production safety: if v2 server rolls back to v1, client still works

### 3. `serde(flatten)` + MessagePack Compatibility

Rust's `#[serde(flatten)]` with MessagePack can cause issues — MessagePack uses integer keys for struct fields, but flatten requires string keys.

**Mitigation:** Test this combination explicitly. If flatten doesn't work with rmp-serde, use the "inject into raw Value" approach instead:

```rust
fn wrap_response(response: Response, request_id: Option<&str>) -> Vec<u8> {
  let mut value = rmp_serde::to_value(&response)?;
  if let (Some(rid), rmpv::Value::Map(ref mut map)) = (request_id, &mut value) {
    map.push((
      rmpv::Value::String("requestId".into()),
      rmpv::Value::String(rid.into()),
    ));
  }
  rmp_serde::to_vec(&value)?
}
```

### 4. Concurrent Request Safety

With requestId matching, multiple in-flight requests are safe:

```
Client sends: r0:GetNode, r1:QueryNodes, r2:NodeCount
Server responds: r2:Count, r0:Node, r1:Nodes
Client matches: r2→Count, r0→Node, r1→Nodes  ✓
```

Without requestId (FIFO): responses matched as r0→Count, r1→Node, r2→Nodes ✗

**Current server is sequential**, so responses ARE in order. But T4.1 (Wire Protocol v3) will add parallelism and streaming, where order is NOT guaranteed.

### 5. Connection Reset Handling

On socket close/error, ALL pending requests are rejected (existing behavior, line 81-84):

```typescript
this.socket.on('close', () => {
  for (const [_id, { reject }] of this.pending) {
    reject(new Error('Connection closed'));
  }
  this.pending.clear();
});
```

This continues to work with requestId — pending map is cleared entirely.

### 6. Memory Safety: Abandoned requestIds

If client sends request but never gets response (server hangs), the pending entry leaks memory. Current timeout mechanism handles this (60s default). No change needed.

### 7. Backward-Compatible Server Detection

Client can detect v2 server via `hello` command response:

```typescript
const hello = await this.hello(2);
// hello.features may include 'requestId'
this.serverSupportsRequestId = hello.features?.includes('requestId') ?? false;
```

**However:** For T1.3, this detection is NOT needed. Client always sends requestId. Server either echoes it (v2) or ignores it (v1 — serde ignores unknown fields). Client falls back to FIFO when response has no requestId.

---

## Test Plan

### Request ID Echo

1. `request_id_echoed` — send request with requestId → response contains same requestId
2. `request_id_format` — requestId is string starting with "r" followed by number
3. `request_id_unique` — each request gets unique requestId (monotonic counter)

### FIFO Fallback

4. `fifo_fallback_no_request_id` — response without requestId → matched to oldest pending
5. `fifo_fallback_v1_server` — simulate v1 server (no echo) → all requests work correctly
6. `mixed_responses` — some with requestId, some without → correct matching

### Concurrent Requests

7. `concurrent_10_requests` — send 10 requests without awaiting → all responses matched correctly
8. `out_of_order_responses` — simulate out-of-order responses (mock server) → correct matching by requestId
9. `concurrent_different_commands` — GetNode + QueryNodes + NodeCount in parallel → each gets correct response type

### Timeout

10. `timeout_request_id_cleanup` — request times out → pending entry removed → late response silently dropped
11. `timeout_no_cascade` — one timeout → other pending requests unaffected
12. `timeout_fifo_no_mismatch` — after timeout, FIFO matching still works correctly for remaining requests

### Integration

13. `existing_operations_unchanged` — addNodes, getNode, queryNodes, etc. all work with requestId
14. `all_existing_tests_pass` — full test suite passes (FIFO mode with v1 server, requestId mode with v2 server)

### Rust Server

15. `unknown_field_ignored` — v1 server ignores requestId in request (serde default behavior)
16. `request_id_echoed_rust` — v2 server echoes requestId for all command types
17. `no_request_id_no_echo` — request without requestId → response without requestId (backward compat)

---

## Performance Considerations

- requestId adds ~5-10 bytes per wire message (string "r" + number + MessagePack overhead)
- Map lookup by string key vs FIFO iterator: O(1) vs O(1) — no difference
- No measurable impact on throughput or latency

---

## Dependencies (npm/Cargo)

No new dependencies. Uses existing:
- `@msgpack/msgpack` (TS, already in project)
- `rmp-serde` / `rmpv` (Rust, already in project)
