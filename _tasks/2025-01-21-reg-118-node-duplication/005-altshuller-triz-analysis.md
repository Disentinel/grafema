# ТРИЗ-анализ: REG-118 Дублирование нод при повторном анализе

**Автор:** Генрих Альтшуллер (ТРИЗ-анализ)
**Дата:** 2025-01-21

---

## 1. Формулировка противоречий

### 1.1 Техническое противоречие (ТП)

**ТП-1: Если делать UPSERT в storage layer:**
- **Плюсы:**
  - Повторный анализ не создаёт дубликатов
  - График остаётся консистентным
  - Простота: одна операция вместо проверки + вставки
- **Минусы:**
  - Storage layer становится "умным" — знает о семантике ID
  - Нарушается разделение ответственности: storage не должен понимать бизнес-логику
  - Потеря информации о версиях: старая нода просто перезаписывается
  - Производительность: каждая вставка требует проверки существования

**ТП-2: Если НЕ делать UPSERT:**
- **Плюсы:**
  - Storage остаётся "тупым" — просто хранит данные
  - Чистое разделение ответственности
  - Быстрые вставки (append-only)
  - Возможность хранить историю версий
- **Минусы:**
  - Дублирование нод при повторном анализе
  - "Загрязнение" графа
  - Некорректные результаты запросов

### 1.2 Физическое противоречие (ФП)

**Нода должна быть УНИКАЛЬНОЙ** (по semantic ID), чтобы:
- Граф был консистентным
- Запросы возвращали корректные результаты
- Рёбра указывали на одну сущность

**Нода должна быть МНОЖЕСТВЕННОЙ**, чтобы:
- Хранить историю версий (main, __local, branch)
- Отслеживать изменения во времени
- Сравнивать состояния до/после

---

## 2. Анализ существующей системы

### 2.1 Компоненты системы

```
GraphBuilder._bufferNode() → _nodeBuffer[] → _flushNodes() → graph.addNodes() → RFDBClient.addNodes()
```

**Ключевые точки:**
1. `_bufferNode()` — просто добавляет в массив, без проверки
2. `_flushNodes()` — batch-запись без проверки дубликатов
3. `RFDBClient.addNodes()` — INSERT without check

### 2.2 Semantic ID (уже реализован)

Файл `ImportNode.ts` показывает, что semantic ID **уже есть**:
```typescript
id: `${file}:IMPORT:${source}:${name}`,  // SEMANTIC ID: no line number
```

Это означает:
- ID НЕ содержит номер строки
- Один и тот же импорт ВСЕГДА имеет один ID
- Проблема не в генерации ID, а в отсутствии проверки при записи

### 2.3 Существующие механизмы

1. **IncrementalAnalysisPlugin** — есть, но работает для другой задачи (версии main/__local)
2. **deleteNode()** — метод существует в backend
3. **getNode(id)** — метод существует в backend

---

## 3. Применение приёмов разрешения противоречий

### 3.1 Разделение во времени

**Принцип:** Нода уникальна в момент запроса, но множественна в момент хранения.

**Реализация: "Snapshot + Merge"**
- Хранить все версии нод с timestamp
- При запросе — возвращать последнюю версию
- При анализе — просто добавлять (append-only)
- Периодически — garbage collection устаревших версий

**Оценка:** Сложно, требует изменения всей модели данных.

### 3.2 Разделение в пространстве

**Принцип:** Ноды уникальны в "активном" пространстве, но могут дублироваться в "staging".

**Реализация: "Staging + Commit"**
- Staging area для новых нод
- Commit operation делает upsert в основной граф
- Анализ всегда пишет в staging

**Оценка:** Добавляет сложность, требует двух хранилищ.

### 3.3 Разделение по условию

**Принцип:** Нода уникальна, если semantic ID совпадает; новая, если отличается.

**Реализация: "Check + Insert/Update"**
- Перед вставкой проверить существование по semantic ID
- Если существует — обновить
- Если нет — вставить

**Оценка:** Просто, но медленно для batch-операций.

### 3.4 Переход в надсистему

**Принцип:** Не менять storage — изменить того, кто в него пишет.

**Реализация: "Clear Before Write"**
- Перед анализом файла — удалить все ноды с `file = X`
- Затем вставить новые
- Storage остаётся "тупым"

**Оценка:** Просто, эффективно, но теряет историю.

### 3.5 Переход в подсистему (САМЫЙ ИНТЕРЕСНЫЙ)

**Принцип:** Сделать ID самодостаточным для upsert.

**Реализация: "ID as Primary Key in Backend"**
- RFDB сервер: если `id` совпадает — UPDATE вместо INSERT
- Это стандартное поведение баз данных (ON CONFLICT)
- Node ID уже semantic — просто нужно использовать его как PK

**Оценка:** Минимальные изменения, максимальный эффект.

---

## 4. Идеальный конечный результат (ИКР)

> "Система САМА предотвращает дублирование, используя уникальность ID как ресурс"

**ИКР в деталях:**
- Не нужен отдельный шаг проверки
- Не нужен отдельный шаг удаления
- Storage АВТОМАТИЧЕСКИ обновляет при конфликте ID
- Затраты: O(1) дополнительно к INSERT

**Формула ИКР:**
```
X-элемент (storage) САМ, в течение ОФ (операции вставки),
обеспечивает СД (уникальность), сохраняя СС (скорость вставки)
```

---

## 5. Вепольный анализ

### 5.1 Исходная система

```
           addNodes()
GraphBuilder ───────────→ Storage
     (В1)                   (В2)
```

**Проблема:** Связь есть, но нет ПОЛЯ (П) управления.

### 5.2 Недостающее поле

```
           addNodes()
GraphBuilder ───────────→ Storage
     (В1)        ↑          (В2)
                 │
              ID как PK
               (Поле)
```

**Решение:** Добавить ПОЛЕ — механизм, который использует ID для управления поведением storage.

### 5.3 Веполь решения

```
           upsertNodes()
GraphBuilder ─────────────→ Storage
     (В1)         ↑          (В2)
                  │
             semantic ID
             (unique key)
```

Storage использует semantic ID как primary key, что АВТОМАТИЧЕСКИ обеспечивает upsert.

---

## 6. Рекомендация

### 6.1 Основное решение: UPSERT на уровне RFDB сервера

**Почему:**
1. Semantic ID уже существует и стабилен
2. Минимальные изменения в коде
3. Стандартный паттерн баз данных
4. Не нарушает существующую логику

**Изменения:**
1. `RFDBClient.addNodes()` → использовать `INSERT OR REPLACE` / `ON CONFLICT UPDATE`
2. Rust engine: добавить upsert семантику в `add_nodes()`

### 6.2 Альтернативное решение: Clear Before Write

**Для случая, если RFDB изменить нельзя:**
1. Добавить метод `clearNodesByFile(file: string)`
2. В `GraphBuilder.build()` вызывать `clearNodesByFile()` перед flush

**Минусы:**
- Теряется атомарность (окно между clear и insert)
- Теряются рёбра к этим нодам (нужно удалять тоже)

### 6.3 НЕ рекомендуется

**Check + Insert/Update на уровне GraphBuilder:**
- Каждая нода требует запрос к базе
- Убивает batch-оптимизацию
- Противоречит текущей архитектуре buffered writes

---

## 7. Матрица выбора решения

| Критерий | UPSERT в RFDB | Clear Before | Check+Insert |
|----------|---------------|--------------|--------------|
| Производительность | +++ | ++ | - |
| Простота реализации | ++ | +++ | + |
| Сохранение истории | + (если нужно) | - | + |
| Атомарность | +++ | - | ++ |
| Изменения в коде | + (только RFDB) | ++ (GraphBuilder) | -- (везде) |

**Победитель: UPSERT на уровне RFDB**

---

## 8. План реализации

1. **Rust Engine:** Модифицировать `add_nodes()` для использования upsert
2. **RFDB Protocol:** Можно добавить флаг `upsert: true` или сделать default behavior
3. **RFDBClient:** Передавать флаг или полагаться на новое поведение
4. **Тесты:** Добавить тест "анализ дважды → количество нод не меняется"

---

## 9. Выводы

ТРИЗ-анализ показал, что:

1. **Противоречие разрешимо** через разделение по условию (ID как PK)
2. **ИКР достижим** — storage сам обеспечивает уникальность
3. **Ресурс уже есть** — semantic ID, его просто нужно использовать правильно
4. **Минимальные изменения** — только в RFDB backend

Ключевой инсайт: **проблема не в отсутствии решения, а в том, что существующий ресурс (semantic ID) не используется для своего прямого назначения.**

---

*"Идеальная система — та, которой нет, но её функция выполняется"*
— Г.С. Альтшуллер
