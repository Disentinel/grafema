# Don Exploration: REG-491 — CONTAINS Edges for CONSTRUCTOR_CALL Nodes

## Summary

CONSTRUCTOR_CALL nodes are created for all `new ClassName()` expressions but currently receive **no CONTAINS edge** from their parent scope. This is unlike CALL_SITE and METHOD_CALL nodes, which both get `SCOPE -> CONTAINS -> CALL_SITE/METHOD_CALL` edges. The fix is straightforward: add `parentScopeId` to `ConstructorCallInfo` (type) and populate it in `NewExpressionHandler.ts`, then create the CONTAINS edge in `GraphBuilder.ts` at step 4.5.

---

## 1. Where CONSTRUCTOR_CALL nodes are created

**File:** `packages/core/src/plugins/analysis/ast/handlers/NewExpressionHandler.ts`

The `NewExpressionHandler` fires on every `NewExpression` node during AST traversal (lines 20-87). When a `className` is determinable:

- A `ConstructorCallInfo` object is pushed to `ctx.constructorCalls` (lines 43-51):
  ```typescript
  ctx.constructorCalls.push({
    id: constructorCallId,
    type: 'CONSTRUCTOR_CALL',
    className,
    isBuiltin,
    file: ctx.module.file,
    line,
    column
  });
  ```

**Critical observation:** `parentScopeId` is NOT captured here, even though `ctx.getCurrentScopeId()` is available on the context (line 207 of `FunctionBodyContext.ts`). The CALL_SITE counterpart **does** capture it (line 112 and 151 of `NewExpressionHandler.ts`):
  ```typescript
  parentScopeId: ctx.getCurrentScopeId(),  // present for CALL nodes
  ```

**ID format:** Generated by `ConstructorCallNode.generateId()`:
  ```
  {file}:CONSTRUCTOR_CALL:{className}:{line}:{column}
  ```
  Example: `src/app.js:CONSTRUCTOR_CALL:Date:42:10`

---

## 2. Is `parentScopeId` available during CONSTRUCTOR_CALL creation?

**Yes.** The `FunctionBodyContext` interface (`packages/core/src/plugins/analysis/ast/FunctionBodyContext.ts:70`) exposes:
```typescript
getCurrentScopeId: () => string;
```

This is the same mechanism used by CALL_SITE nodes (both `new Identifier()` path at line 112 and `new ns.Constructor()` path at line 151 in `NewExpressionHandler.ts`). The CONSTRUCTOR_CALL block (lines 33-87) runs **before** the CALL_SITE blocks (lines 89-155), so `ctx.getCurrentScopeId()` returns the correct scope at that point.

---

## 3. How CALL_SITE nodes get their CONTAINS edge

**File:** `packages/core/src/plugins/analysis/ast/builders/CoreBuilder.ts`

Method `bufferCallSiteEdges()` (lines 134-157):
```typescript
private bufferCallSiteEdges(callSites: CallSiteInfo[], functions: FunctionInfo[]): void {
  for (const callSite of callSites) {
    const { parentScopeId, targetFunctionName, ...callData } = callSite;

    // SCOPE -> CONTAINS -> CALL_SITE
    this.ctx.bufferEdge({
      type: 'CONTAINS',
      src: parentScopeId as string,
      dst: callData.id
    });
    // ... also CALL_SITE -> CALLS -> FUNCTION
  }
}
```

**METHOD_CALL** follows the identical pattern in `bufferMethodCalls()` (lines 164-209):
```typescript
// SCOPE -> CONTAINS -> METHOD_CALL
this.ctx.bufferEdge({
  type: 'CONTAINS',
  src: methodCall.parentScopeId as string,
  dst: methodCall.id
});
```

**PROPERTY_ACCESS** also uses `parentScopeId` for CONTAINS edges (lines 218-241 in `CoreBuilder.ts`).

The pattern is consistent across all "call-like" nodes.

---

## 4. Where CONSTRUCTOR_CALL nodes are buffered in GraphBuilder

**File:** `packages/core/src/plugins/analysis/ast/GraphBuilder.ts`

Step 4.5 (lines 302-314):
```typescript
// 4.5 Buffer CONSTRUCTOR_CALL nodes
for (const constructorCall of constructorCalls) {
  this._bufferNode({
    id: constructorCall.id,
    type: constructorCall.type,
    name: `new ${constructorCall.className}()`,
    className: constructorCall.className,
    isBuiltin: constructorCall.isBuiltin,
    file: constructorCall.file,
    line: constructorCall.line,
    column: constructorCall.column
  } as GraphNode);
}
```

**No CONTAINS edge is created.** This is the gap. The node is buffered but never connected to its parent scope via CONTAINS.

---

## 5. Are there any existing CONTAINS edges for CONSTRUCTOR_CALL nodes?

**No.** A full-text search across `packages/core/src` for `CONSTRUCTOR_CALL.*CONTAINS` or `CONTAINS.*CONSTRUCTOR_CALL` returns zero matches. Confirmed also in the test file (`test/unit/ConstructorCallTracking.test.js`) — there are zero assertions about CONTAINS edges; all tests only check `ASSIGNED_FROM` edges.

The `AssignmentBuilder.ts` (lines 77-96) handles `ASSIGNED_FROM` edges for assigned constructor calls only (when variable is assigned via `new`). Unassigned constructor calls (e.g., `new ErrorClass()` thrown directly, or `new SideEffect()` for side effects only) get no graph connections at all beyond the node itself.

---

## 6. The `ConstructorCallInfo` type has no `parentScopeId`

**File:** `packages/core/src/plugins/analysis/ast/types.ts`, lines 333-341:
```typescript
export interface ConstructorCallInfo {
  id: string;
  type: 'CONSTRUCTOR_CALL';
  className: string;
  isBuiltin: boolean;
  file: string;
  line: number;
  column: number;
  // NO parentScopeId field
}
```

Compare with `CallSiteInfo` (lines 262-280), which has:
```typescript
export interface CallSiteInfo {
  // ...
  parentScopeId?: string;
  // ...
}
```

---

## 7. Simplest fix location

The fix requires changes in exactly 3 places:

### Place 1: `types.ts` — add `parentScopeId` to `ConstructorCallInfo`
`packages/core/src/plugins/analysis/ast/types.ts:341` — add `parentScopeId?: string;` to the interface.

### Place 2: `NewExpressionHandler.ts` — capture `parentScopeId` when creating CONSTRUCTOR_CALL
`packages/core/src/plugins/analysis/ast/handlers/NewExpressionHandler.ts:43-51` — add `parentScopeId: ctx.getCurrentScopeId()` to the push object.

### Place 3: `GraphBuilder.ts` — create CONTAINS edge at step 4.5
`packages/core/src/plugins/analysis/ast/GraphBuilder.ts:302-314` — after `this._bufferNode(...)`, add:
```typescript
if (constructorCall.parentScopeId) {
  this._bufferEdge({
    type: 'CONTAINS',
    src: constructorCall.parentScopeId,
    dst: constructorCall.id
  });
}
```

No changes needed in `CoreBuilder.ts`, `AssignmentBuilder.ts`, or any other builder — the CONSTRUCTOR_CALL node buffering happens directly in `GraphBuilder.build()`, not in a domain builder.

---

## 8. Scope of the unassigned constructor call problem

The `NewExpressionHandler` creates CONSTRUCTOR_CALL nodes for ALL `new` expressions (line 32: `// Create CONSTRUCTOR_CALL node (always, for all NewExpressions)`), not just assigned ones. However:

- Assigned case (`const x = new Foo()`): gets `VARIABLE --ASSIGNED_FROM--> CONSTRUCTOR_CALL` edge via `AssignmentBuilder`
- Unassigned case (`new SideEffect()`, `throw new Error()`): gets **no edges at all** — the node floats in the graph with no connections

With CONTAINS edges, both cases would be anchored to their parent scope, making them queryable by scope context.

---

## 9. Test coverage gap

`test/unit/ConstructorCallTracking.test.js` has comprehensive coverage for ASSIGNED_FROM edges and node attributes but **zero tests for CONTAINS edges**. The new test cases needed:

1. Module-level `new Foo()` → scope (MODULE node) CONTAINS CONSTRUCTOR_CALL
2. `new Foo()` inside a function → function scope CONTAINS CONSTRUCTOR_CALL
3. `new Foo()` inside an if/for/try block → nested scope CONTAINS CONSTRUCTOR_CALL
4. Unassigned `new Foo()` (not stored in variable) → scope still CONTAINS CONSTRUCTOR_CALL

---

## Key Code References

| Location | File:Line | Description |
|----------|-----------|-------------|
| CONSTRUCTOR_CALL creation | `NewExpressionHandler.ts:43-51` | Pushes to `ctx.constructorCalls`, no `parentScopeId` |
| `getCurrentScopeId` available | `NewExpressionHandler.ts:112,151` | Used for CALL nodes in same handler |
| `ConstructorCallInfo` type | `types.ts:333-341` | Missing `parentScopeId` field |
| Step 4.5 node buffering | `GraphBuilder.ts:302-314` | Nodes buffered, no CONTAINS edge |
| CALL_SITE CONTAINS pattern | `CoreBuilder.ts:134-157` | Exact pattern to replicate |
| METHOD_CALL CONTAINS pattern | `CoreBuilder.ts:164-209` | Same pattern |
| `ConstructorCallNode.generateId` | `ConstructorCallNode.ts:148-157` | ID format: `{file}:CONSTRUCTOR_CALL:{className}:{line}:{column}` |
| Existing tests (no CONTAINS) | `test/unit/ConstructorCallTracking.test.js` | No CONTAINS assertions |
