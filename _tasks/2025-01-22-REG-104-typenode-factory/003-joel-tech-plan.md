# Joel Spolsky - Technical Specification: REG-104

## Summary

REG-104 migrates TYPE node creation in `GraphBuilder.bufferTypeAliasNodes()` from inline object literals to use `NodeFactory.createType()` factory method. This is a straightforward migration requiring only **single location change** in GraphBuilder.ts (lines 1131-1142). No ID format changes needed—TypeNode.create() already generates correct format `{file}:TYPE:{name}:{line}`. Unlike REG-103 (InterfaceNode), TYPE nodes require no two-pass approach since they have no same-file relations to handle.

## Files to Modify

1. **Primary**: `/Users/vadimr/grafema/packages/core/src/plugins/analysis/ast/GraphBuilder.ts`
   - Method: `bufferTypeAliasNodes()` (lines 1131-1142)
   - Change: Replace inline TYPE object with `NodeFactory.createType()` call

## Code Changes

### 1. GraphBuilder.ts - bufferTypeAliasNodes() Method

#### BEFORE (Current - lines 1131-1142):
```typescript
private bufferTypeAliasNodes(module: ModuleNode, typeAliases: TypeAliasInfo[]): void {
  for (const typeAlias of typeAliases) {
    // Buffer TYPE node
    this._bufferNode({
      id: typeAlias.id,
      type: 'TYPE',
      name: typeAlias.name,
      file: typeAlias.file,
      line: typeAlias.line,
      column: typeAlias.column,
      aliasOf: typeAlias.aliasOf
    });

    // MODULE -> CONTAINS -> TYPE
    this._bufferEdge({
      type: 'CONTAINS',
      src: module.id,
      dst: typeAlias.id
    });
  }
}
```

#### AFTER (New - with factory method):
```typescript
private bufferTypeAliasNodes(module: ModuleNode, typeAliases: TypeAliasInfo[]): void {
  for (const typeAlias of typeAliases) {
    // Create TYPE node using factory
    const typeNode = NodeFactory.createType(
      typeAlias.name,
      typeAlias.file,
      typeAlias.line,
      typeAlias.column || 0,
      { aliasOf: typeAlias.aliasOf }
    );
    this._bufferNode(typeNode as unknown as GraphNode);

    // MODULE -> CONTAINS -> TYPE
    this._bufferEdge({
      type: 'CONTAINS',
      src: module.id,
      dst: typeNode.id
    });
  }
}
```

#### Migration Details:
- **Why single-pass?** TYPE nodes have no internal relations (unlike INTERFACE with EXTENDS edges). No Map needed.
- **Column handling:** `typeAlias.column || 0` - TypeAliasInfo.column is optional, but TypeNode.create() requires it; default to 0
- **Type safety:** Cast `typeNode as unknown as GraphNode` to match the _bufferNode signature expectation
- **ID generation:** ID is now generated by `TypeNode.create()` instead of pre-generated in TypeScriptVisitor
- **Edge reference:** Use `typeNode.id` instead of `typeAlias.id` to ensure consistency with factory-generated ID

## Test Plan

### Unit Tests to Write

#### Test 1: TypeNode.create() ID format
```javascript
it('should generate TYPE node ID with colon separator format', () => {
  const node = TypeNode.create(
    'UserId',
    '/project/src/types.ts',
    10,
    0
  );

  assert.strictEqual(
    node.id,
    '/project/src/types.ts:TYPE:UserId:10',
    'ID format should be {file}:TYPE:{name}:{line}'
  );
});
```

#### Test 2: TypeNode.create() with aliasOf
```javascript
it('should include aliasOf field when provided', () => {
  const node = TypeNode.create(
    'UserId',
    '/project/src/types.ts',
    10,
    5,
    { aliasOf: 'string' }
  );

  assert.strictEqual(node.aliasOf, 'string');
  assert.strictEqual(node.column, 5);
});
```

#### Test 3: NodeFactory.createType() delegates correctly
```javascript
it('should delegate to TypeNode.create() correctly', () => {
  const node = NodeFactory.createType(
    'ProductId',
    '/src/models.ts',
    42,
    10,
    { aliasOf: 'number' }
  );

  assert.strictEqual(node.type, 'TYPE');
  assert.strictEqual(node.name, 'ProductId');
  assert.strictEqual(node.aliasOf, 'number');
  assert.ok(node.id.includes(':TYPE:'));
});
```

#### Test 4: Column defaults to 0 when missing
```javascript
it('should default column to 0 when not provided', () => {
  const typeAlias = {
    name: 'MyType',
    file: '/src/types.ts',
    line: 5
    // column is undefined
  };

  const node = NodeFactory.createType(
    typeAlias.name,
    typeAlias.file,
    typeAlias.line,
    typeAlias.column || 0
  );

  assert.strictEqual(node.column, 0);
});
```

#### Test 5: TypeNode validation passes
```javascript
it('should pass TypeNode.validate() after factory creation', () => {
  const node = NodeFactory.createType(
    'UserId',
    '/src/types.ts',
    10,
    0,
    { aliasOf: 'string' }
  );

  const errors = TypeNode.validate(node);
  assert.strictEqual(errors.length, 0, `Should have no validation errors, got: ${errors.join(', ')}`);
});
```

### Validation Steps

1. **Code review checklist:**
   - [ ] TypeAliasInfo fields map correctly to TypeNode.create() parameters
   - [ ] Column field handles undefined (defaults to 0)
   - [ ] aliasOf field passed through options object correctly
   - [ ] Edge still references `typeNode.id` (factory-generated, not pre-generated)
   - [ ] No inline type object literals remain

2. **Runtime validation:**
   ```bash
   node --test test/unit/TypeNodeMigration.test.js
   ```

3. **Integration validation:**
   ```bash
   npm test
   ```

4. **ID format verification:**
   - Verify TYPE node IDs unchanged: `{file}:TYPE:{name}:{line}`
   - Confirm no format changes
   - Check edge destinations match generated node IDs

## Edge Cases

1. **Missing column in TypeAliasInfo:**
   - TypeAliasInfo.column is optional
   - Solution: Use `typeAlias.column || 0` before passing to factory
   - Result: TYPE node always has column value (defaults to 0)

2. **Complex aliasOf types:**
   - Some type aliases use complex expressions (unions, intersections, etc.)
   - Solution: Store as string (already done in TypeAliasInfo)
   - No parsing needed—just pass through

3. **Duplicate TYPE names in same file:**
   - TypeScript allows duplicate type names on different lines
   - Solution: ID includes line number for uniqueness
   - Format: `{file}:TYPE:{name}:{line}` ensures uniqueness

4. **TYPE nodes with no aliasOf:**
   - Some type aliases might not capture aliasOf value
   - Solution: aliasOf is optional field in TypeNodeOptions
   - Result: Node created without aliasOf field if not provided

## Acceptance Criteria Checklist

- [ ] **Code Change**: `GraphBuilder.bufferTypeAliasNodes()` uses `NodeFactory.createType()` instead of inline object
- [ ] **ID Format**: TYPE node IDs remain: `{file}:TYPE:{name}:{line}` (unchanged)
- [ ] **Edge Creation**: MODULE → CONTAINS → TYPE edges reference factory-generated IDs
- [ ] **Optional Fields**: column and aliasOf fields handled correctly
- [ ] **Tests Pass**: All new tests pass
- [ ] **No Regressions**: Existing tests pass, no behavioral changes
- [ ] **Pattern Match**: Implementation matches REG-103 pattern for consistency
