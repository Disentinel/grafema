{
  "language": "unknown",
  "version": "",
  "generatedAt": "2026-02-24T00:45:42.126Z",
  "totalCases": 644,
  "cases": [
    {
      "constructId": "aliasing::alias-method-extraction",
      "category": "aliasing",
      "code": "const log = console.log;\nlog('extracted');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<log>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        },
        {
          "type": "CALL",
          "id": "<log('extracted')>",
          "metadata": {
            "callee": "log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'extracted'>",
          "metadata": {
            "value": "extracted",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<log('extracted')>",
            "dst": "<'extracted'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<log>",
            "dst": "<console.log>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log>",
            "dst": "<console>",
            "type": "READS_FROM"
          },
          {
            "src": "<log('extracted')>",
            "dst": "<log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-reassign-function",
      "category": "aliasing",
      "code": "let handler = function first() { return 1; };\nhandler();\n\nhandler = function second() { return 2; };\nhandler();",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<handler>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<first>",
          "metadata": {
            "name": "first"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<handler()_1>",
          "metadata": {
            "callSite": 1
          }
        },
        {
          "type": "FUNCTION",
          "id": "<second>",
          "metadata": {
            "name": "second"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<handler()_2>",
          "metadata": {
            "callSite": 2
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<first>",
            "dst": "<1>",
            "type": "RETURNS"
          },
          {
            "src": "<second>",
            "dst": "<2>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<handler>",
            "dst": "<first>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<handler>",
            "dst": "<second>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<handler()_1>",
            "dst": "<handler>",
            "type": "CALLS"
          },
          {
            "src": "<handler()_2>",
            "dst": "<handler>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-destructured-method",
      "category": "aliasing",
      "code": "const { parse, stringify } = JSON;\nconst parsed = parse('{\"a\":1}');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<parse>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<stringify>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.parse>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "parse"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.stringify>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "stringify"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<parsed>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<parse('{\"a\":1}')>",
          "metadata": {
            "callee": "parse"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'{\"a\":1}'>",
          "metadata": {
            "value": "{\"a\":1}",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<parse('{\"a\":1}')>",
            "dst": "<'{\"a\":1}'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<parsed>",
            "dst": "<parse('{\"a\":1}')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<parse>",
            "dst": "<JSON.parse>",
            "type": "ALIASES"
          },
          {
            "src": "<stringify>",
            "dst": "<JSON.stringify>",
            "type": "ALIASES"
          },
          {
            "src": "<parse('{\"a\":1}')>",
            "dst": "<parse>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-bind-partial",
      "category": "aliasing",
      "code": "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<multiply>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a * b>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<doubleIt>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<multiply.bind(null, 2)>",
          "metadata": {
            "callee": "multiply.bind"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<doubleIt:bound>",
          "metadata": {
            "boundFunction": true,
            "partiallyApplied": true
          }
        },
        {
          "type": "CALL",
          "id": "<doubleIt(5)>",
          "metadata": {
            "callee": "doubleIt"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<multiply>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<multiply>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<multiply>",
            "dst": "<a * b>",
            "type": "RETURNS"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<null>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<doubleIt:bound>",
            "type": "RETURNS"
          },
          {
            "src": "<doubleIt(5)>",
            "dst": "<5>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<doubleIt>",
            "dst": "<multiply.bind(null, 2)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<doubleIt:bound>",
            "dst": "<2>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<a * b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a * b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<multiply>",
            "type": "CALLS"
          },
          {
            "src": "<doubleIt:bound>",
            "dst": "<multiply>",
            "type": "DERIVES_FROM"
          },
          {
            "src": "<doubleIt(5)>",
            "dst": "<doubleIt>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-computed-method",
      "category": "aliasing",
      "code": "const mathObj = { add(a, b) { return a + b; } };\nconst methodName = 'add';\nconst fn = mathObj[methodName];\nfn(1, 2);\n\n// --- Function reassignment ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<mathObj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<mathObj-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<add>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<methodName>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'add'>",
          "metadata": {
            "value": "add",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<mathObj[methodName]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<fn(1, 2)>",
          "metadata": {
            "callee": "fn"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<mathObj-object>",
            "dst": "<add>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<add>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<add>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<add>",
            "dst": "<a + b>",
            "type": "RETURNS"
          },
          {
            "src": "<fn(1, 2)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fn(1, 2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<mathObj>",
            "dst": "<mathObj-object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<methodName>",
            "dst": "<'add'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fn>",
            "dst": "<mathObj[methodName]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a + b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<mathObj[methodName]>",
            "dst": "<mathObj>",
            "type": "READS_FROM"
          },
          {
            "src": "<mathObj[methodName]>",
            "dst": "<methodName>",
            "type": "READS_FROM"
          },
          {
            "src": "<mathObj[methodName]>",
            "dst": "<add>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<fn(1, 2)>",
            "dst": "<fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-reassign-conditional",
      "category": "aliasing",
      "code": "let strategy;\nif (Math.random() > 0.5) {\n  strategy = function fast() { return 'fast'; };\n} else {\n  strategy = function slow() { return 'slow'; };\n}\nstrategy();\n\n// --- Callback identity through higher-order functions ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<strategy>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-random>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Math.random() > 0.5>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.random()>",
          "metadata": {
            "callee": "Math.random"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0.5>",
          "metadata": {
            "value": 0.5,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<fast>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fast'>",
          "metadata": {
            "value": "fast",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<slow>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'slow'>",
          "metadata": {
            "value": "slow",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<strategy()>",
          "metadata": {
            "callee": "strategy"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<if-random>",
            "dst": "<Math.random() > 0.5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<Math.random()>",
            "type": "CONTAINS"
          },
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<0.5>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-random>",
            "dst": "<strategy>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<fast>",
            "dst": "<'fast'>",
            "type": "RETURNS"
          },
          {
            "src": "<slow>",
            "dst": "<'slow'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<strategy>",
            "dst": "<fast>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<if-random>",
            "dst": "<strategy>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<strategy>",
            "dst": "<slow>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<strategy()>",
            "dst": "<strategy>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-callback-passed",
      "category": "aliasing",
      "code": "function applyToArray(arr, callback) {\n  return arr.map(callback);\n}\nfunction double(x) { return x * 2; }\napplyToArray([1, 2, 3], double);",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<applyToArray>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<arr>"
        },
        {
          "type": "PARAMETER",
          "id": "<callback>"
        },
        {
          "type": "CALL",
          "id": "<arr.map(callback)>",
          "metadata": {
            "method": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<double>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<applyToArray([1, 2, 3], double)>",
          "metadata": {
            "callee": "applyToArray"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "value": [
              1,
              2,
              3
            ],
            "literalType": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<applyToArray>",
            "dst": "<arr>",
            "type": "HAS_BODY"
          },
          {
            "src": "<applyToArray>",
            "dst": "<callback>",
            "type": "HAS_BODY"
          },
          {
            "src": "<applyToArray>",
            "dst": "<arr.map(callback)>",
            "type": "RETURNS"
          },
          {
            "src": "<arr.map(callback)>",
            "dst": "<callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<double>",
            "dst": "<x>",
            "type": "HAS_BODY"
          },
          {
            "src": "<double>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          },
          {
            "src": "<applyToArray([1, 2, 3], double)>",
            "dst": "<[1, 2, 3]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<applyToArray([1, 2, 3], double)>",
            "dst": "<double>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<arr.map(callback)>",
            "dst": "<arr>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<applyToArray([1, 2, 3], double)>",
            "dst": "<applyToArray>",
            "type": "CALLS"
          },
          {
            "src": "<callback>",
            "dst": "<double>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-callback-returned",
      "category": "aliasing",
      "code": "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getComparator>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<ascending>"
        },
        {
          "type": "BRANCH",
          "id": "<if-ascending>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<ascending-comparator>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a1>"
        },
        {
          "type": "PARAMETER",
          "id": "<b1>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a - b>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<descending-comparator>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a2>"
        },
        {
          "type": "PARAMETER",
          "id": "<b2>"
        },
        {
          "type": "EXPRESSION",
          "id": "<b - a>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cmp>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<getComparator(true)>",
          "metadata": {
            "callee": "getComparator"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[3, 1, 2]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "CALL",
          "id": "<[3, 1, 2].sort(cmp)>",
          "metadata": {
            "callee": "sort"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getComparator>",
            "dst": "<ascending>",
            "type": "CONTAINS"
          },
          {
            "src": "<getComparator>",
            "dst": "<if-ascending>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-ascending>",
            "dst": "<ascending>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-ascending>",
            "dst": "<ascending-comparator>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ascending-comparator>",
            "dst": "<a1>",
            "type": "CONTAINS"
          },
          {
            "src": "<ascending-comparator>",
            "dst": "<b1>",
            "type": "CONTAINS"
          },
          {
            "src": "<ascending-comparator>",
            "dst": "<a - b>",
            "type": "RETURNS"
          },
          {
            "src": "<descending-comparator>",
            "dst": "<a2>",
            "type": "CONTAINS"
          },
          {
            "src": "<descending-comparator>",
            "dst": "<b2>",
            "type": "CONTAINS"
          },
          {
            "src": "<descending-comparator>",
            "dst": "<b - a>",
            "type": "RETURNS"
          },
          {
            "src": "<getComparator(true)>",
            "dst": "<true>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<[3, 1, 2].sort(cmp)>",
            "dst": "<cmp>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-ascending>",
            "dst": "<descending-comparator>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<cmp>",
            "dst": "<getComparator(true)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a - b>",
            "dst": "<a1>",
            "type": "READS_FROM"
          },
          {
            "src": "<a - b>",
            "dst": "<b1>",
            "type": "READS_FROM"
          },
          {
            "src": "<b - a>",
            "dst": "<b2>",
            "type": "READS_FROM"
          },
          {
            "src": "<b - a>",
            "dst": "<a2>",
            "type": "READS_FROM"
          },
          {
            "src": "<getComparator(true)>",
            "dst": "<getComparator>",
            "type": "CALLS"
          },
          {
            "src": "<[3, 1, 2].sort(cmp)>",
            "dst": "<[3, 1, 2]>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-callback-returned",
      "category": "aliasing",
      "code": "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getComparator>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<ascending>"
        },
        {
          "type": "BRANCH",
          "id": "<if-ascending>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<ascending-comparator>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a1>"
        },
        {
          "type": "PARAMETER",
          "id": "<b1>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a1 - b1>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<descending-comparator>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a2>"
        },
        {
          "type": "PARAMETER",
          "id": "<b2>"
        },
        {
          "type": "EXPRESSION",
          "id": "<b2 - a2>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cmp>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<getComparator(true)>",
          "metadata": {
            "callee": "getComparator"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[3, 1, 2]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "CALL",
          "id": "<[3, 1, 2].sort(cmp)>",
          "metadata": {
            "callee": "sort"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getComparator>",
            "dst": "<ascending>",
            "type": "CONTAINS"
          },
          {
            "src": "<getComparator>",
            "dst": "<if-ascending>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-ascending>",
            "dst": "<ascending>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-ascending>",
            "dst": "<ascending-comparator>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ascending-comparator>",
            "dst": "<a1>",
            "type": "CONTAINS"
          },
          {
            "src": "<ascending-comparator>",
            "dst": "<b1>",
            "type": "CONTAINS"
          },
          {
            "src": "<ascending-comparator>",
            "dst": "<a1 - b1>",
            "type": "RETURNS"
          },
          {
            "src": "<descending-comparator>",
            "dst": "<a2>",
            "type": "CONTAINS"
          },
          {
            "src": "<descending-comparator>",
            "dst": "<b2>",
            "type": "CONTAINS"
          },
          {
            "src": "<descending-comparator>",
            "dst": "<b2 - a2>",
            "type": "RETURNS"
          },
          {
            "src": "<getComparator(true)>",
            "dst": "<true>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<[3, 1, 2].sort(cmp)>",
            "dst": "<cmp>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-ascending>",
            "dst": "<descending-comparator>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<cmp>",
            "dst": "<getComparator(true)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a1 - b1>",
            "dst": "<a1>",
            "type": "READS_FROM"
          },
          {
            "src": "<a1 - b1>",
            "dst": "<b1>",
            "type": "READS_FROM"
          },
          {
            "src": "<b2 - a2>",
            "dst": "<b2>",
            "type": "READS_FROM"
          },
          {
            "src": "<b2 - a2>",
            "dst": "<a2>",
            "type": "READS_FROM"
          },
          {
            "src": "<getComparator(true)>",
            "dst": "<getComparator>",
            "type": "CALLS"
          },
          {
            "src": "<[3, 1, 2].sort(cmp)>",
            "dst": "<[3, 1, 2]>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-basic",
      "category": "aliasing",
      "code": "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sum>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<total>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < arguments.length>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments.length>",
          "metadata": {
            "objectName": "arguments",
            "property": "length"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<total += arguments[i]>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[i]>",
          "metadata": {
            "objectName": "arguments",
            "accessType": "computed"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<arguments>",
          "metadata": {
            "kind": "implicit-parameter"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<sum>",
            "dst": "<total>",
            "type": "CONTAINS"
          },
          {
            "src": "<sum>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < arguments.length>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<total += arguments[i]>",
            "type": "HAS_BODY"
          },
          {
            "src": "<sum>",
            "dst": "<total>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<total>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<total += arguments[i]>",
            "dst": "<total>",
            "type": "MODIFIES"
          },
          {
            "src": "<sum>",
            "dst": "<arguments>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<i < arguments.length>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < arguments.length>",
            "dst": "<arguments.length>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments.length>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<total += arguments[i]>",
            "dst": "<arguments[i]>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[i]>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[i]>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-bind-partial",
      "category": "aliasing",
      "code": "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<multiply>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a * b>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<doubleIt>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<multiply.bind(null, 2)>",
          "metadata": {
            "callee": "multiply.bind"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<doubleIt:bound>",
          "metadata": {
            "boundFunction": true,
            "partiallyApplied": true
          }
        },
        {
          "type": "CALL",
          "id": "<doubleIt(5)>",
          "metadata": {
            "callee": "doubleIt"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<multiply>",
            "dst": "<a>",
            "type": "HAS_BODY"
          },
          {
            "src": "<multiply>",
            "dst": "<b>",
            "type": "HAS_BODY"
          },
          {
            "src": "<multiply>",
            "dst": "<a * b>",
            "type": "RETURNS"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<null>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<doubleIt:bound>",
            "type": "RETURNS"
          },
          {
            "src": "<doubleIt(5)>",
            "dst": "<5>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<doubleIt>",
            "dst": "<multiply.bind(null, 2)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<doubleIt:bound>",
            "dst": "<2>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<a * b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a * b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<multiply.bind(null, 2)>",
            "dst": "<multiply>",
            "type": "CALLS"
          },
          {
            "src": "<doubleIt:bound>",
            "dst": "<multiply>",
            "type": "DERIVES_FROM"
          },
          {
            "src": "<doubleIt(5)>",
            "dst": "<doubleIt>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-import-dynamic-variable",
      "category": "aliasing",
      "code": "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<modulePath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./declarations.js'>",
          "metadata": {
            "value": "./declarations.js",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<dynamicMod>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import(modulePath)>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./declarations.js>",
          "metadata": {
            "path": "./declarations.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<import(modulePath)>",
            "dst": "<modulePath>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<modulePath>",
            "dst": "<'./declarations.js'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dynamicMod>",
            "dst": "<import(modulePath)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import(modulePath)>",
            "dst": "<./declarations.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<dynamicMod>",
            "dst": "<./declarations.js>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-callee",
      "category": "aliasing",
      "code": "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<factorial>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<factorial:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<n>"
        },
        {
          "type": "EXPRESSION",
          "id": "<n <= 1>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1-return>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n * arguments.callee(n - 1)>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments.callee>",
          "metadata": {
            "objectName": "arguments",
            "propertyName": "callee"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n - 1>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "CALL",
          "id": "<arguments.callee(n - 1)>",
          "metadata": {
            "recursive": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary>",
          "metadata": {
            "operator": "?:"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<factorial:fn>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<factorial:fn>",
            "dst": "<ternary>",
            "type": "RETURNS"
          },
          {
            "src": "<ternary>",
            "dst": "<n <= 1>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary>",
            "dst": "<1-return>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<arguments.callee(n - 1)>",
            "dst": "<n - 1>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<factorial>",
            "dst": "<factorial:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ternary>",
            "dst": "<n * arguments.callee(n - 1)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<n <= 1>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n <= 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<n * arguments.callee(n - 1)>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n * arguments.callee(n - 1)>",
            "dst": "<arguments.callee(n - 1)>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments.callee(n - 1)>",
            "dst": "<arguments.callee>",
            "type": "CALLS"
          },
          {
            "src": "<n - 1>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n - 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments.callee>",
            "dst": "<factorial:fn>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-basic",
      "category": "aliasing",
      "code": "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sum>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<total>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < arguments.length>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments.length>",
          "metadata": {
            "objectName": "arguments",
            "property": "length"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<total += arguments[i]>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[i]>",
          "metadata": {
            "objectName": "arguments",
            "accessType": "computed"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<arguments>",
          "metadata": {
            "kind": "implicit-parameter"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<sum>",
            "dst": "<total>",
            "type": "CONTAINS"
          },
          {
            "src": "<sum>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < arguments.length>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<total += arguments[i]>",
            "type": "HAS_BODY"
          },
          {
            "src": "<sum>",
            "dst": "<total>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<total>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<total += arguments[i]>",
            "dst": "<total>",
            "type": "MODIFIES"
          },
          {
            "src": "<sum>",
            "dst": "<arguments>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<i < arguments.length>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < arguments.length>",
            "dst": "<arguments.length>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments.length>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<total += arguments[i]>",
            "dst": "<arguments[i]>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[i]>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[i]>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-array-conversion",
      "category": "aliasing",
      "code": "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<toArray>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fromArrayFn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Array.from(arguments)>",
          "metadata": {
            "callee": "Array.from"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Array.from>",
          "metadata": {
            "objectName": "Array",
            "propertyName": "from"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arguments>",
          "metadata": {
            "implicitParameter": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fromSpread>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[...arguments]>",
          "metadata": {
            "type": "array",
            "hasSpread": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fromSlice>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<[].slice.call(arguments)>",
          "metadata": {
            "callee": "slice"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<[].slice>",
          "metadata": {
            "objectName": "[]",
            "propertyName": "slice"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<[].slice.call>",
          "metadata": {
            "objectName": "[].slice",
            "propertyName": "call"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ fromArrayFn, fromSpread, fromSlice }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<toArray>",
            "dst": "<fromArrayFn>",
            "type": "CONTAINS"
          },
          {
            "src": "<Array.from(arguments)>",
            "dst": "<arguments>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<toArray>",
            "dst": "<fromSpread>",
            "type": "CONTAINS"
          },
          {
            "src": "<[...arguments]>",
            "dst": "<arguments>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<toArray>",
            "dst": "<fromSlice>",
            "type": "CONTAINS"
          },
          {
            "src": "<[].slice.call(arguments)>",
            "dst": "<arguments>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<toArray>",
            "dst": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<fromArrayFn>",
            "dst": "<Array.from(arguments)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fromSpread>",
            "dst": "<[...arguments]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fromSlice>",
            "dst": "<[].slice.call(arguments)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Array.from(arguments)>",
            "dst": "<Array.from>",
            "type": "CALLS"
          },
          {
            "src": "<[].slice.call(arguments)>",
            "dst": "<[].slice.call>",
            "type": "CALLS"
          },
          {
            "src": "<[].slice>",
            "dst": "<[]>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "dst": "<fromArrayFn>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "dst": "<fromSpread>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "dst": "<fromSlice>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-array-conversion",
      "category": "aliasing",
      "code": "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<toArray>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fromArrayFn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Array.from(arguments)>",
          "metadata": {
            "callee": "Array.from"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Array.from>",
          "metadata": {
            "objectName": "Array",
            "propertyName": "from"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arguments>",
          "metadata": {
            "implicitParameter": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fromSpread>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[...arguments]>",
          "metadata": {
            "type": "array",
            "hasSpread": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fromSlice>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<[].slice.call(arguments)>",
          "metadata": {
            "callee": "slice"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<[].slice>",
          "metadata": {
            "objectName": "[]",
            "propertyName": "slice"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<[].slice.call>",
          "metadata": {
            "objectName": "[].slice",
            "propertyName": "call"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ fromArrayFn, fromSpread, fromSlice }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<toArray>",
            "dst": "<fromArrayFn>",
            "type": "CONTAINS"
          },
          {
            "src": "<Array.from(arguments)>",
            "dst": "<arguments>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<toArray>",
            "dst": "<fromSpread>",
            "type": "CONTAINS"
          },
          {
            "src": "<[...arguments]>",
            "dst": "<arguments>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<toArray>",
            "dst": "<fromSlice>",
            "type": "CONTAINS"
          },
          {
            "src": "<[].slice.call(arguments)>",
            "dst": "<arguments>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<toArray>",
            "dst": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<fromArrayFn>",
            "dst": "<Array.from(arguments)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fromSpread>",
            "dst": "<[...arguments]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fromSlice>",
            "dst": "<[].slice.call(arguments)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Array.from(arguments)>",
            "dst": "<Array.from>",
            "type": "CALLS"
          },
          {
            "src": "<[].slice.call(arguments)>",
            "dst": "<[].slice.call>",
            "type": "CALLS"
          },
          {
            "src": "<[].slice>",
            "dst": "<[]>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "dst": "<fromArrayFn>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "dst": "<fromSpread>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ fromArrayFn, fromSpread, fromSlice }>",
            "dst": "<fromSlice>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-import-dynamic-conditional",
      "category": "aliasing",
      "code": "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<impl>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import()>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Math.random() > 0.5>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.random()>",
          "metadata": {
            "callee": "Math.random"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0.5>",
          "metadata": {
            "value": 0.5,
            "literalType": "number"
          }
        },
        {
          "type": "BRANCH",
          "id": "<conditional>",
          "metadata": {
            "type": "ternary"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./declarations.js'>",
          "metadata": {
            "value": "./declarations.js",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./expressions.js'>",
          "metadata": {
            "value": "./expressions.js",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<import()>",
            "dst": "<conditional>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<conditional>",
            "dst": "<Math.random() > 0.5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<conditional>",
            "dst": "<'./declarations.js'>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<impl>",
            "dst": "<import()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<conditional>",
            "dst": "<'./expressions.js'>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<Math.random()>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<0.5>",
            "type": "READS_FROM"
          },
          {
            "src": "<import()>",
            "dst": "<'./declarations.js'>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<import()>",
            "dst": "<'./expressions.js'>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-callee",
      "category": "aliasing",
      "code": "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<factorial>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<factorial:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<n>"
        },
        {
          "type": "EXPRESSION",
          "id": "<n <= 1>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1-return>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n * arguments.callee(n - 1)>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments.callee>",
          "metadata": {
            "objectName": "arguments",
            "propertyName": "callee"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n - 1>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "CALL",
          "id": "<arguments.callee(n - 1)>",
          "metadata": {
            "recursive": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary>",
          "metadata": {
            "operator": "?:"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<factorial:fn>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<factorial:fn>",
            "dst": "<ternary>",
            "type": "RETURNS"
          },
          {
            "src": "<ternary>",
            "dst": "<n <= 1>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary>",
            "dst": "<1-return>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<arguments.callee(n - 1)>",
            "dst": "<n - 1>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<factorial>",
            "dst": "<factorial:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ternary>",
            "dst": "<n * arguments.callee(n - 1)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<n <= 1>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n <= 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<n * arguments.callee(n - 1)>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n * arguments.callee(n - 1)>",
            "dst": "<arguments.callee(n - 1)>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments.callee(n - 1)>",
            "dst": "<arguments.callee>",
            "type": "CALLS"
          },
          {
            "src": "<n - 1>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n - 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments.callee>",
            "dst": "<factorial:fn>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-import-dynamic-variable",
      "category": "aliasing",
      "code": "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<modulePath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./declarations.js'>",
          "metadata": {
            "value": "./declarations.js",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<dynamicMod>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import(modulePath)>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./declarations.js>",
          "metadata": {
            "path": "./declarations.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<import(modulePath)>",
            "dst": "<modulePath>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<modulePath>",
            "dst": "<'./declarations.js'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dynamicMod>",
            "dst": "<import(modulePath)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import(modulePath)>",
            "dst": "<./declarations.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<dynamicMod>",
            "dst": "<./declarations.js>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-import-dynamic-template",
      "category": "aliasing",
      "code": "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<loadPlugin>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "VARIABLE",
          "id": "<plugin>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "IMPORT",
          "id": "<dynamic-import>",
          "metadata": {
            "dynamic": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<plugin.default>",
          "metadata": {
            "objectName": "plugin",
            "property": "default"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<loadPlugin>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<loadPlugin>",
            "dst": "<plugin>",
            "type": "CONTAINS"
          },
          {
            "src": "<loadPlugin>",
            "dst": "<plugin.default>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<plugin>",
            "dst": "<dynamic-import>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<dynamic-import>",
            "dst": "<template-literal>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<name>",
            "type": "READS_FROM"
          },
          {
            "src": "<plugin.default>",
            "dst": "<plugin>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-import-dynamic-template",
      "category": "aliasing",
      "code": "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<loadPlugin>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "VARIABLE",
          "id": "<plugin>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "IMPORT",
          "id": "<dynamic-import>",
          "metadata": {
            "dynamic": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<plugin.default>",
          "metadata": {
            "objectName": "plugin",
            "property": "default"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<loadPlugin>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<loadPlugin>",
            "dst": "<plugin>",
            "type": "CONTAINS"
          },
          {
            "src": "<loadPlugin>",
            "dst": "<plugin.default>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<plugin>",
            "dst": "<dynamic-import>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<dynamic-import>",
            "dst": "<template-literal>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<name>",
            "type": "READS_FROM"
          },
          {
            "src": "<plugin.default>",
            "dst": "<plugin>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::alias-import-dynamic-conditional",
      "category": "aliasing",
      "code": "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<impl>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import()>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Math.random() > 0.5>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.random()>",
          "metadata": {
            "callee": "Math.random"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0.5>",
          "metadata": {
            "value": 0.5,
            "literalType": "number"
          }
        },
        {
          "type": "BRANCH",
          "id": "<conditional>",
          "metadata": {
            "type": "ternary"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./declarations.js'>",
          "metadata": {
            "value": "./declarations.js",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./expressions.js'>",
          "metadata": {
            "value": "./expressions.js",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<import()>",
            "dst": "<conditional>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<conditional>",
            "dst": "<Math.random() > 0.5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<conditional>",
            "dst": "<'./declarations.js'>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<impl>",
            "dst": "<import()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<conditional>",
            "dst": "<'./expressions.js'>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<Math.random()>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<0.5>",
            "type": "READS_FROM"
          },
          {
            "src": "<import()>",
            "dst": "<'./declarations.js'>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<import()>",
            "dst": "<'./expressions.js'>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arrow-no-arguments",
      "category": "aliasing",
      "code": "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<outerWithArguments>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[0]>",
          "metadata": {
            "objectName": "arguments",
            "property": "0"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arrowFromOuter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<outerWithArguments(42)>",
          "metadata": {
            "callee": "outerWithArguments"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<outerWithArguments>",
            "dst": "<arrow>",
            "type": "CONTAINS"
          },
          {
            "src": "<outerWithArguments>",
            "dst": "<arrow:fn>",
            "type": "RETURNS"
          },
          {
            "src": "<arrow:fn>",
            "dst": "<arguments[0]>",
            "type": "RETURNS"
          },
          {
            "src": "<outerWithArguments(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<arrow>",
            "dst": "<arrow:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<arguments[0]>",
            "dst": "<outerWithArguments>",
            "type": "CAPTURES"
          },
          {
            "src": "<arrowFromOuter>",
            "dst": "<outerWithArguments(42)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<outerWithArguments(42)>",
            "dst": "<outerWithArguments>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arrow-no-arguments",
      "category": "aliasing",
      "code": "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<outerWithArguments>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[0]>",
          "metadata": {
            "objectName": "arguments",
            "property": "0"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arrowFromOuter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<outerWithArguments(42)>",
          "metadata": {
            "callee": "outerWithArguments"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<outerWithArguments>",
            "dst": "<arrow>",
            "type": "CONTAINS"
          },
          {
            "src": "<outerWithArguments>",
            "dst": "<arrow:fn>",
            "type": "RETURNS"
          },
          {
            "src": "<arrow:fn>",
            "dst": "<arguments[0]>",
            "type": "RETURNS"
          },
          {
            "src": "<outerWithArguments(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<arrow>",
            "dst": "<arrow:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<arguments[0]>",
            "dst": "<outerWithArguments>",
            "type": "CAPTURES"
          },
          {
            "src": "<arrowFromOuter>",
            "dst": "<outerWithArguments(42)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<outerWithArguments(42)>",
            "dst": "<outerWithArguments>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-param-aliasing",
      "category": "aliasing",
      "code": "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode  bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<argumentsAliasing>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "VARIABLE",
          "id": "<arguments>",
          "metadata": {
            "kind": "implicit",
            "arrayLike": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[0]>",
          "metadata": {
            "objectName": "arguments",
            "property": "0"
          }
        },
        {
          "type": "LITERAL",
          "id": "<99>",
          "metadata": {
            "value": 99,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<aAfterMutation>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'changed'>",
          "metadata": {
            "value": "changed",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arg0AfterReassign>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ aAfterMutation, arg0AfterReassign }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<argumentsAliasing>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<arguments>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<aAfterMutation>",
            "type": "DECLARES"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<arg0AfterReassign>",
            "type": "DECLARES"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<{ aAfterMutation, arg0AfterReassign }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arguments[0]>",
            "dst": "<99>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<aAfterMutation>",
            "dst": "<a>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a>",
            "dst": "<'changed'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<arg0AfterReassign>",
            "dst": "<arguments[0]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arguments>",
            "dst": "<a>",
            "type": "ALIASES"
          },
          {
            "src": "<arguments>",
            "dst": "<b>",
            "type": "ALIASES"
          },
          {
            "src": "<a>",
            "dst": "<arguments[0]>",
            "type": "ALIASES"
          },
          {
            "src": "<{ aAfterMutation, arg0AfterReassign }>",
            "dst": "<aAfterMutation>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ aAfterMutation, arg0AfterReassign }>",
            "dst": "<arg0AfterReassign>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-param-aliasing",
      "category": "aliasing",
      "code": "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode  bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<argumentsAliasing>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "VARIABLE",
          "id": "<arguments>",
          "metadata": {
            "kind": "implicit",
            "arrayLike": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[0]>",
          "metadata": {
            "objectName": "arguments",
            "property": "0"
          }
        },
        {
          "type": "LITERAL",
          "id": "<99>",
          "metadata": {
            "value": 99,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<aAfterMutation>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'changed'>",
          "metadata": {
            "value": "changed",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arg0AfterReassign>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ aAfterMutation, arg0AfterReassign }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<argumentsAliasing>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<arguments>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<aAfterMutation>",
            "type": "DECLARES"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<arg0AfterReassign>",
            "type": "DECLARES"
          },
          {
            "src": "<argumentsAliasing>",
            "dst": "<{ aAfterMutation, arg0AfterReassign }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arguments[0]>",
            "dst": "<99>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<aAfterMutation>",
            "dst": "<a>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a>",
            "dst": "<'changed'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<arg0AfterReassign>",
            "dst": "<arguments[0]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arguments>",
            "dst": "<a>",
            "type": "ALIASES"
          },
          {
            "src": "<arguments>",
            "dst": "<b>",
            "type": "ALIASES"
          },
          {
            "src": "<a>",
            "dst": "<arguments[0]>",
            "type": "ALIASES"
          },
          {
            "src": "<{ aAfterMutation, arg0AfterReassign }>",
            "dst": "<aAfterMutation>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ aAfterMutation, arg0AfterReassign }>",
            "dst": "<arg0AfterReassign>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-rest-coexistence",
      "category": "aliasing",
      "code": "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<argumentsWithRest>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<first>"
        },
        {
          "type": "PARAMETER",
          "id": "<rest>",
          "metadata": {
            "restParameter": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<allCount>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments.length>",
          "metadata": {
            "objectName": "arguments",
            "property": "length"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<firstFromArgs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[0]>",
          "metadata": {
            "objectName": "arguments",
            "property": "0"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<restFromArgs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[1]>",
          "metadata": {
            "objectName": "arguments",
            "property": "1"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<arguments>",
          "metadata": {
            "implicitObject": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<argumentsWithRest>",
            "dst": "<first>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<rest>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<allCount>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<firstFromArgs>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<restFromArgs>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<return-object>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<allCount>",
            "dst": "<arguments.length>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<firstFromArgs>",
            "dst": "<arguments[0]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<restFromArgs>",
            "dst": "<arguments[1]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arguments.length>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[0]>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[1]>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<allCount>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<firstFromArgs>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<restFromArgs>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<rest>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-await-basic",
      "category": "async-generators",
      "code": "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fetchData>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch",
            "awaited": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<fetch>",
          "metadata": {
            "name": "fetch"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "awaited": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response.json>",
          "metadata": {
            "objectName": "response",
            "propertyName": "json"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetchData>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchData>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetchData>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchData>",
            "dst": "<data>",
            "type": "RETURNS"
          },
          {
            "src": "<fetchData>",
            "dst": "<fetch(url)>",
            "type": "AWAITS"
          },
          {
            "src": "<fetchData>",
            "dst": "<response.json()>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<response>",
            "dst": "<fetch(url)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<data>",
            "dst": "<response.json()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<fetch(url)>",
            "dst": "<fetch>",
            "type": "CALLS"
          },
          {
            "src": "<response.json()>",
            "dst": "<response.json>",
            "type": "CALLS"
          },
          {
            "src": "<response.json>",
            "dst": "<response>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "aliasing::arguments-rest-coexistence",
      "category": "aliasing",
      "code": "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<argumentsWithRest>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<first>"
        },
        {
          "type": "PARAMETER",
          "id": "<rest>",
          "metadata": {
            "restParameter": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<allCount>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments.length>",
          "metadata": {
            "objectName": "arguments",
            "property": "length"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<firstFromArgs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[0]>",
          "metadata": {
            "objectName": "arguments",
            "property": "0"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<restFromArgs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arguments[1]>",
          "metadata": {
            "objectName": "arguments",
            "property": "1"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<arguments>",
          "metadata": {
            "implicitObject": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<argumentsWithRest>",
            "dst": "<first>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<rest>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<allCount>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<firstFromArgs>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<restFromArgs>",
            "type": "CONTAINS"
          },
          {
            "src": "<argumentsWithRest>",
            "dst": "<return-object>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<allCount>",
            "dst": "<arguments.length>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<firstFromArgs>",
            "dst": "<arguments[0]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<restFromArgs>",
            "dst": "<arguments[1]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arguments.length>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[0]>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<arguments[1]>",
            "dst": "<arguments>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<allCount>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<firstFromArgs>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<restFromArgs>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<rest>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-await-basic",
      "category": "async-generators",
      "code": "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fetchData>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch",
            "awaited": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<fetch>",
          "metadata": {
            "name": "fetch"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "awaited": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response.json>",
          "metadata": {
            "objectName": "response",
            "propertyName": "json"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetchData>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchData>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetchData>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchData>",
            "dst": "<data>",
            "type": "RETURNS"
          },
          {
            "src": "<fetchData>",
            "dst": "<fetch(url)>",
            "type": "AWAITS"
          },
          {
            "src": "<fetchData>",
            "dst": "<response.json()>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<response>",
            "dst": "<fetch(url)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<data>",
            "dst": "<response.json()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<fetch(url)>",
            "dst": "<fetch>",
            "type": "CALLS"
          },
          {
            "src": "<response.json()>",
            "dst": "<response.json>",
            "type": "CALLS"
          },
          {
            "src": "<response.json>",
            "dst": "<response>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-arrow",
      "category": "async-generators",
      "code": "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncArrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncArrow:fn>",
          "metadata": {
            "arrowFunction": true,
            "async": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(42)>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(42)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<asyncArrow>",
            "type": "DECLARES"
          },
          {
            "src": "<asyncArrow:fn>",
            "dst": "<await Promise.resolve(42)>",
            "type": "RETURNS"
          },
          {
            "src": "<await Promise.resolve(42)>",
            "dst": "<Promise.resolve(42)>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<asyncArrow>",
            "dst": "<asyncArrow:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Promise.resolve(42)>",
            "dst": "<Promise>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::promise-construction",
      "category": "async-generators",
      "code": "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createPromise>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<shouldResolve>"
        },
        {
          "type": "CALL",
          "id": "<new Promise(...)>",
          "metadata": {
            "constructor": true,
            "callee": "Promise"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<executor>",
          "metadata": {
            "arrowFunction": true,
            "executorFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "PARAMETER",
          "id": "<reject>"
        },
        {
          "type": "BRANCH",
          "id": "<if-shouldResolve>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "CALL",
          "id": "<resolve('success')>",
          "metadata": {
            "callee": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'success'>",
          "metadata": {
            "value": "success",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<reject(new Error('failure'))>",
          "metadata": {
            "callee": "reject"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('failure')>",
          "metadata": {
            "constructor": true,
            "callee": "Error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'failure'>",
          "metadata": {
            "value": "failure",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createPromise>",
            "dst": "<shouldResolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<createPromise>",
            "dst": "<new Promise(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<new Promise(...)>",
            "dst": "<executor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<executor>",
            "dst": "<resolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<executor>",
            "dst": "<reject>",
            "type": "HAS_BODY"
          },
          {
            "src": "<executor>",
            "dst": "<if-shouldResolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-shouldResolve>",
            "dst": "<shouldResolve>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-shouldResolve>",
            "dst": "<resolve('success')>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<resolve('success')>",
            "dst": "<'success'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reject(new Error('failure'))>",
            "dst": "<new Error('failure')>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('failure')>",
            "dst": "<'failure'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-shouldResolve>",
            "dst": "<reject(new Error('failure'))>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<resolve('success')>",
            "dst": "<resolve>",
            "type": "CALLS"
          },
          {
            "src": "<reject(new Error('failure'))>",
            "dst": "<reject>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-await-try-catch",
      "category": "async-generators",
      "code": "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fetchWithErrorHandling>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch",
            "awaited": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!response.ok>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response.ok>"
        },
        {
          "type": "BRANCH",
          "id": "<if-not-ok>"
        },
        {
          "type": "CALL",
          "id": "<new Error>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<`HTTP ${response.status}`>",
          "metadata": {
            "value": "template",
            "literalType": "template"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response.status>"
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "awaited": true
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<error>"
        },
        {
          "type": "CALL",
          "id": "<console.error>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Fetch failed:'>",
          "metadata": {
            "value": "Fetch failed:",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetchWithErrorHandling>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithErrorHandling>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fetchWithErrorHandling>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<try-block>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<if-not-ok>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-not-ok>",
            "dst": "<!response.ok>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<new Error>",
            "dst": "<`HTTP ${response.status}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<catch-block>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<console.error>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.error>",
            "dst": "<'Fetch failed:'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.error>",
            "dst": "<error>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<null>",
            "type": "RETURNS"
          },
          {
            "src": "<catch-block>",
            "dst": "<try-block>",
            "type": "CATCHES_FROM"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<fetchWithErrorHandling>",
            "type": "AWAITS"
          },
          {
            "src": "<response.json()>",
            "dst": "<fetchWithErrorHandling>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<response>",
            "dst": "<fetch(url)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<if-not-ok>",
            "dst": "<new Error>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<!response.ok>",
            "dst": "<response.ok>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.ok>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<`HTTP ${response.status}`>",
            "dst": "<response.status>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.status>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::promise-construction",
      "category": "async-generators",
      "code": "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createPromise>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<shouldResolve>"
        },
        {
          "type": "CALL",
          "id": "<new Promise(...)>",
          "metadata": {
            "constructor": true,
            "callee": "Promise"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<executor>",
          "metadata": {
            "arrowFunction": true,
            "executorFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "PARAMETER",
          "id": "<reject>"
        },
        {
          "type": "BRANCH",
          "id": "<if-shouldResolve>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "CALL",
          "id": "<resolve('success')>",
          "metadata": {
            "callee": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'success'>",
          "metadata": {
            "value": "success",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<reject(new Error('failure'))>",
          "metadata": {
            "callee": "reject"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('failure')>",
          "metadata": {
            "constructor": true,
            "callee": "Error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'failure'>",
          "metadata": {
            "value": "failure",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createPromise>",
            "dst": "<shouldResolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<createPromise>",
            "dst": "<new Promise(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<new Promise(...)>",
            "dst": "<executor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<executor>",
            "dst": "<resolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<executor>",
            "dst": "<reject>",
            "type": "HAS_BODY"
          },
          {
            "src": "<executor>",
            "dst": "<if-shouldResolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-shouldResolve>",
            "dst": "<shouldResolve>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-shouldResolve>",
            "dst": "<resolve('success')>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<resolve('success')>",
            "dst": "<'success'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reject(new Error('failure'))>",
            "dst": "<new Error('failure')>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('failure')>",
            "dst": "<'failure'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-shouldResolve>",
            "dst": "<reject(new Error('failure'))>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<resolve('success')>",
            "dst": "<resolve>",
            "type": "CALLS"
          },
          {
            "src": "<reject(new Error('failure'))>",
            "dst": "<reject>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-arrow",
      "category": "async-generators",
      "code": "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncArrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncArrow:fn>",
          "metadata": {
            "arrowFunction": true,
            "async": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(42)>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(42)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<asyncArrow>",
            "type": "DECLARES"
          },
          {
            "src": "<asyncArrow:fn>",
            "dst": "<await Promise.resolve(42)>",
            "type": "RETURNS"
          },
          {
            "src": "<await Promise.resolve(42)>",
            "dst": "<Promise.resolve(42)>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<asyncArrow>",
            "dst": "<asyncArrow:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Promise.resolve(42)>",
            "dst": "<Promise>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-await-try-catch",
      "category": "async-generators",
      "code": "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fetchWithErrorHandling>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch",
            "awaited": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!response.ok>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response.ok>"
        },
        {
          "type": "BRANCH",
          "id": "<if-not-ok>"
        },
        {
          "type": "CALL",
          "id": "<new Error>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<`HTTP ${response.status}`>",
          "metadata": {
            "value": "template",
            "literalType": "template"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response.status>"
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "awaited": true
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<error>"
        },
        {
          "type": "CALL",
          "id": "<console.error>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Fetch failed:'>",
          "metadata": {
            "value": "Fetch failed:",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetchWithErrorHandling>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithErrorHandling>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fetchWithErrorHandling>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<try-block>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<if-not-ok>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-not-ok>",
            "dst": "<!response.ok>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<new Error>",
            "dst": "<`HTTP ${response.status}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<catch-block>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<console.error>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.error>",
            "dst": "<'Fetch failed:'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.error>",
            "dst": "<error>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<null>",
            "type": "RETURNS"
          },
          {
            "src": "<catch-block>",
            "dst": "<try-block>",
            "type": "CATCHES_FROM"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<fetchWithErrorHandling>",
            "type": "AWAITS"
          },
          {
            "src": "<response.json()>",
            "dst": "<fetchWithErrorHandling>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<response>",
            "dst": "<fetch(url)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<if-not-ok>",
            "dst": "<new Error>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<!response.ok>",
            "dst": "<response.ok>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.ok>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<`HTTP ${response.status}`>",
            "dst": "<response.status>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.status>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-arrow-with-params",
      "category": "async-generators",
      "code": "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncArrowWithParams>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncArrowWithParams:fn>",
          "metadata": {
            "arrowFunction": true,
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "PARAMETER",
          "id": "<options>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url, options)>",
          "metadata": {
            "callee": "fetch",
            "awaited": true
          }
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "method": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<options>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url, options)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetch(url, options)>",
            "dst": "<options>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<fetch(url, options)>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<asyncArrowWithParams>",
            "dst": "<asyncArrowWithParams:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<response>",
            "dst": "<fetch(url, options)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-basic",
      "category": "async-generators",
      "code": "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<counter>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i <= end>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield i>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<counter>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<counter>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<counter>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<i <= end>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield i>",
            "type": "HAS_BODY"
          },
          {
            "src": "<counter>",
            "dst": "<yield i>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i <= end>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i <= end>",
            "dst": "<end>",
            "type": "READS_FROM"
          },
          {
            "src": "<yield i>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::promise-chaining",
      "category": "async-generators",
      "code": "function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<promiseChaining>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch"
          }
        },
        {
          "type": "CALL",
          "id": "<.then(response => response.json())>",
          "metadata": {
            "method": "then"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<response => response.json()>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<response>"
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "method": "json"
          }
        },
        {
          "type": "CALL",
          "id": "<.then(data => data.result)>",
          "metadata": {
            "method": "then"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<data => data.result>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<data.result>",
          "metadata": {
            "property": "result"
          }
        },
        {
          "type": "CALL",
          "id": "<.catch(error => console.error(error))>",
          "metadata": {
            "method": "catch"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<error => console.error(error)>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<error>"
        },
        {
          "type": "CALL",
          "id": "<console.error(error)>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "CALL",
          "id": "<.finally(() => console.log('done'))>",
          "metadata": {
            "method": "finally"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<() => console.log('done')>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "CALL",
          "id": "<console.log('done')>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'done'>",
          "metadata": {
            "value": "done",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<promiseChaining>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<promiseChaining>",
            "dst": "<fetch(url)>",
            "type": "RETURNS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<.then(response => response.json())>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.then(response => response.json())>",
            "dst": "<response => response.json()>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<response => response.json()>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<response => response.json()>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<.then(response => response.json())>",
            "dst": "<.then(data => data.result)>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.then(data => data.result)>",
            "dst": "<data => data.result>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<data => data.result>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<data => data.result>",
            "dst": "<data.result>",
            "type": "RETURNS"
          },
          {
            "src": "<.then(data => data.result)>",
            "dst": "<.catch(error => console.error(error))>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.catch(error => console.error(error))>",
            "dst": "<error => console.error(error)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<error => console.error(error)>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<error => console.error(error)>",
            "dst": "<console.error(error)>",
            "type": "RETURNS"
          },
          {
            "src": "<console.error(error)>",
            "dst": "<error>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<.catch(error => console.error(error))>",
            "dst": "<.finally(() => console.log('done'))>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.finally(() => console.log('done'))>",
            "dst": "<() => console.log('done')>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<() => console.log('done')>",
            "dst": "<console.log('done')>",
            "type": "RETURNS"
          },
          {
            "src": "<console.log('done')>",
            "dst": "<'done'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<data.result>",
            "dst": "<data>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-arrow-with-params",
      "category": "async-generators",
      "code": "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncArrowWithParams>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncArrowWithParams:fn>",
          "metadata": {
            "arrowFunction": true,
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "PARAMETER",
          "id": "<options>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url, options)>",
          "metadata": {
            "callee": "fetch",
            "awaited": true
          }
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "method": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<options>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url, options)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetch(url, options)>",
            "dst": "<options>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<asyncArrowWithParams:fn>",
            "dst": "<fetch(url, options)>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<asyncArrowWithParams>",
            "dst": "<asyncArrowWithParams:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<response>",
            "dst": "<fetch(url, options)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-basic",
      "category": "async-generators",
      "code": "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<counter>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i <= end>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield i>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<counter>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<counter>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<counter>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<i <= end>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield i>",
            "type": "HAS_BODY"
          },
          {
            "src": "<counter>",
            "dst": "<yield i>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i <= end>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i <= end>",
            "dst": "<end>",
            "type": "READS_FROM"
          },
          {
            "src": "<yield i>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::promise-chaining",
      "category": "async-generators",
      "code": "function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<promiseChaining>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch"
          }
        },
        {
          "type": "CALL",
          "id": "<.then(response => response.json())>",
          "metadata": {
            "method": "then"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<response => response.json()>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<response>"
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "method": "json"
          }
        },
        {
          "type": "CALL",
          "id": "<.then(data => data.result)>",
          "metadata": {
            "method": "then"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<data => data.result>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<data.result>",
          "metadata": {
            "property": "result"
          }
        },
        {
          "type": "CALL",
          "id": "<.catch(error => console.error(error))>",
          "metadata": {
            "method": "catch"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<error => console.error(error)>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<error>"
        },
        {
          "type": "CALL",
          "id": "<console.error(error)>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "CALL",
          "id": "<.finally(() => console.log('done'))>",
          "metadata": {
            "method": "finally"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<() => console.log('done')>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "CALL",
          "id": "<console.log('done')>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'done'>",
          "metadata": {
            "value": "done",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<promiseChaining>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<promiseChaining>",
            "dst": "<fetch(url)>",
            "type": "RETURNS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<.then(response => response.json())>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.then(response => response.json())>",
            "dst": "<response => response.json()>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<response => response.json()>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<response => response.json()>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<.then(response => response.json())>",
            "dst": "<.then(data => data.result)>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.then(data => data.result)>",
            "dst": "<data => data.result>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<data => data.result>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<data => data.result>",
            "dst": "<data.result>",
            "type": "RETURNS"
          },
          {
            "src": "<.then(data => data.result)>",
            "dst": "<.catch(error => console.error(error))>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.catch(error => console.error(error))>",
            "dst": "<error => console.error(error)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<error => console.error(error)>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<error => console.error(error)>",
            "dst": "<console.error(error)>",
            "type": "RETURNS"
          },
          {
            "src": "<console.error(error)>",
            "dst": "<error>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<.catch(error => console.error(error))>",
            "dst": "<.finally(() => console.log('done'))>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.finally(() => console.log('done'))>",
            "dst": "<() => console.log('done')>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<() => console.log('done')>",
            "dst": "<console.log('done')>",
            "type": "RETURNS"
          },
          {
            "src": "<console.log('done')>",
            "dst": "<'done'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<data.result>",
            "dst": "<data>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-delegation",
      "category": "async-generators",
      "code": "function* innerGenerator() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* outerGenerator() {\n  yield 1;\n  yield* innerGenerator();\n  yield 2;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<innerGenerator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'a'>",
          "metadata": {
            "value": "a",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'b'>",
          "metadata": {
            "value": "b",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<outerGenerator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<innerGenerator()>",
          "metadata": {
            "callee": "innerGenerator"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<innerGenerator>",
            "dst": "<'a'>",
            "type": "YIELDS"
          },
          {
            "src": "<innerGenerator>",
            "dst": "<'b'>",
            "type": "YIELDS"
          },
          {
            "src": "<outerGenerator>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<outerGenerator>",
            "dst": "<innerGenerator()>",
            "type": "DELEGATES_TO"
          },
          {
            "src": "<outerGenerator>",
            "dst": "<2>",
            "type": "YIELDS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<innerGenerator()>",
            "dst": "<innerGenerator>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::top-level-await",
      "category": "async-generators",
      "code": "const config = await import('./declarations.js');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<config>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await import('./declarations.js')>",
          "metadata": {
            "async": true,
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<import('./declarations.js')>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./declarations.js'>",
          "metadata": {
            "value": "./declarations.js",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./declarations.js>",
          "metadata": {
            "path": "./declarations.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<await import('./declarations.js')>",
            "dst": "<import('./declarations.js')>",
            "type": "AWAITS"
          },
          {
            "src": "<import('./declarations.js')>",
            "dst": "<'./declarations.js'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<config>",
            "dst": "<await import('./declarations.js')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import('./declarations.js')>",
            "dst": "<./declarations.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-infinite",
      "category": "async-generators",
      "code": "function* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fibonacci>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LOOP",
          "id": "<while-true>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield-a>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a-plus-b>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure-array>",
          "metadata": {
            "type": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fibonacci>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<fibonacci>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<fibonacci>",
            "dst": "<while-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while-true>",
            "dst": "<yield-a>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<destructure-array>",
            "type": "CONTAINS"
          },
          {
            "src": "<fibonacci>",
            "dst": "<yield-a>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<a>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a>",
            "dst": "<destructure-array>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<destructure-array>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<yield-a>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a-plus-b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a-plus-b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure-array>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure-array>",
            "dst": "<a-plus-b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-return-thenable",
      "category": "async-generators",
      "code": "async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<returnsThenable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<thenable-object>",
          "metadata": {
            "thenable": true,
            "expressionType": "object_literal"
          }
        },
        {
          "type": "METHOD",
          "id": "<then>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "CALL",
          "id": "<resolve(42)>",
          "metadata": {
            "callee": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<returnsThenable>",
            "dst": "<thenable-object>",
            "type": "RETURNS"
          },
          {
            "src": "<thenable-object>",
            "dst": "<then>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<then>",
            "dst": "<resolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<then>",
            "dst": "<resolve(42)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<resolve(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<resolve(42)>",
            "dst": "<resolve>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-return-throw",
      "category": "async-generators",
      "code": "function* generatorReturnThrow() {\n  try {\n    yield 1;\n    yield 2;\n  } finally {\n    yield 'cleanup';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<generatorReturnThrow>",
          "metadata": {
            "async": false,
            "generator": true
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 1>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 2>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 'cleanup'>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'cleanup'>",
          "metadata": {
            "value": "cleanup",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<generatorReturnThrow>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<generatorReturnThrow>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<yield 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<yield 2>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield 1>",
            "dst": "<1>",
            "type": "RETURNS"
          },
          {
            "src": "<yield 2>",
            "dst": "<2>",
            "type": "RETURNS"
          },
          {
            "src": "<finally-block>",
            "dst": "<yield 'cleanup'>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield 'cleanup'>",
            "dst": "<'cleanup'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "async-generators::async-generator",
      "category": "async-generators",
      "code": "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<asyncCounter>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i <= end>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await new Promise(resolve => setTimeout(resolve, 100))>"
        },
        {
          "type": "CALL",
          "id": "<new Promise(resolve => setTimeout(resolve, 100))>",
          "metadata": {
            "callee": "Promise",
            "constructor": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<resolve => setTimeout(resolve, 100)>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "CALL",
          "id": "<setTimeout(resolve, 100)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "LITERAL",
          "id": "<100>",
          "metadata": {
            "value": 100,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield i>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncCounter>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncCounter>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncCounter>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<i <= end>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<await new Promise(resolve => setTimeout(resolve, 100))>",
            "type": "HAS_BODY"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield i>",
            "type": "HAS_BODY"
          },
          {
            "src": "<await new Promise(resolve => setTimeout(resolve, 100))>",
            "dst": "<new Promise(resolve => setTimeout(resolve, 100))>",
            "type": "AWAITS"
          },
          {
            "src": "<new Promise(resolve => setTimeout(resolve, 100))>",
            "dst": "<resolve => setTimeout(resolve, 100)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<resolve => setTimeout(resolve, 100)>",
            "dst": "<resolve>",
            "type": "CONTAINS"
          },
          {
            "src": "<resolve => setTimeout(resolve, 100)>",
            "dst": "<setTimeout(resolve, 100)>",
            "type": "RETURNS"
          },
          {
            "src": "<setTimeout(resolve, 100)>",
            "dst": "<resolve>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(resolve, 100)>",
            "dst": "<100>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<yield i>",
            "dst": "<i>",
            "type": "YIELDS"
          },
          {
            "src": "<asyncCounter>",
            "dst": "<yield i>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i <= end>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i <= end>",
            "dst": "<end>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::for-await-of",
      "category": "async-generators",
      "code": "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<consumeAsyncIterable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncIterable>"
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-await-of>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(item)>",
          "metadata": {
            "callee": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<asyncIterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<for-await-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<asyncIterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<results.push(item)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<results.push(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(item)>",
            "dst": "<results>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::for-await-of",
      "category": "async-generators",
      "code": "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<consumeAsyncIterable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncIterable>"
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-await-of>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(item)>",
          "metadata": {
            "callee": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<asyncIterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<for-await-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<asyncIterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<results.push(item)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<results.push(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<consumeAsyncIterable>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(item)>",
            "dst": "<results>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-finally-cleanup",
      "category": "async-generators",
      "code": "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<resourceGenerator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resource>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ acquired: true }>",
          "metadata": {
            "value": "{ acquired: true }",
            "literalType": "object"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<yield resource>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ transformed: true }>",
          "metadata": {
            "value": "{ transformed: true }",
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield { transformed: true }>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<resource.acquired>",
          "metadata": {
            "objectName": "resource",
            "propertyName": "acquired"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<resourceGenerator>",
            "dst": "<resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<resourceGenerator>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<resourceGenerator>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<yield resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<yield { transformed: true }>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<resource>",
            "dst": "<{ acquired: true }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<finally-block>",
            "dst": "<resource.acquired>",
            "type": "WRITES_TO"
          },
          {
            "src": "<resource.acquired>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<yield resource>",
            "dst": "<resource>",
            "type": "READS_FROM"
          },
          {
            "src": "<yield { transformed: true }>",
            "dst": "<{ transformed: true }>",
            "type": "READS_FROM"
          },
          {
            "src": "<resource.acquired>",
            "dst": "<resource>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-observer-pattern",
      "category": "async-generators",
      "code": "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<observer>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "LOOP",
          "id": "<while-true>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(value)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<results.push>",
          "metadata": {
            "objectName": "results",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<observer>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<observer>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<observer>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<while-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while-true>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<results.push(value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finally-block>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<value>",
            "dst": "<yield>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(value)>",
            "dst": "<results.push>",
            "type": "CALLS"
          },
          {
            "src": "<results.push>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::top-level-await",
      "category": "async-generators",
      "code": "const config = await import('./declarations.js');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<config>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await import('./declarations.js')>",
          "metadata": {
            "async": true,
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<import('./declarations.js')>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./declarations.js'>",
          "metadata": {
            "value": "./declarations.js",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./declarations.js>",
          "metadata": {
            "path": "./declarations.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<await import('./declarations.js')>",
            "dst": "<import('./declarations.js')>",
            "type": "AWAITS"
          },
          {
            "src": "<import('./declarations.js')>",
            "dst": "<'./declarations.js'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<config>",
            "dst": "<await import('./declarations.js')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import('./declarations.js')>",
            "dst": "<./declarations.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-two-way",
      "category": "async-generators",
      "code": "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<accumulator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<total>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<while-true>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield-total>",
          "metadata": {
            "expressionType": "yield",
            "yieldsValue": true,
            "receivesValue": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<total += value>",
          "metadata": {
            "operator": "+="
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<accumulator>",
            "dst": "<total>",
            "type": "CONTAINS"
          },
          {
            "src": "<accumulator>",
            "dst": "<while-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while-true>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<yield-total>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<total += value>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<total>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<value>",
            "dst": "<yield-total>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<total += value>",
            "dst": "<total>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<yield-total>",
            "dst": "<total>",
            "type": "READS_FROM"
          },
          {
            "src": "<total += value>",
            "dst": "<value>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-finally-yield-trap",
      "category": "async-generators",
      "code": "function* trickyFinally() {\n  try {\n    yield 1;\n  } finally {\n    yield 2; // return() pauses HERE, not at the return point\n  }\n}\n// const g = trickyFinally(); g.next(); g.return('end');\n//  { value: 2, done: false }  NOT 'end'!\n// g.next()  { value: 'end', done: true }\n\n// --- Async iterator cancellation ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<trickyFinally>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 1>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 2>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<trickyFinally>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<trickyFinally>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<yield 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<finally-block>",
            "dst": "<yield 2>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield 1>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<yield 2>",
            "dst": "<2>",
            "type": "YIELDS"
          },
          {
            "src": "<try-block>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "async-generators::generator-break-triggers-finally",
      "category": "async-generators",
      "code": "function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return()  finally runs\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<consumeWithBreak>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<gen>"
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-transformed>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<item.transformed>",
          "metadata": {
            "property": "transformed"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<break>",
          "metadata": {
            "type": "break"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<consumeWithBreak>",
            "dst": "<gen>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeWithBreak>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<gen>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<if-transformed>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-transformed>",
            "dst": "<item.transformed>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-transformed>",
            "dst": "<break>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<item.transformed>",
            "dst": "<item>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::promise-resolve-thenable",
      "category": "async-generators",
      "code": "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<nestedThenable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<thenable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<thenable-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<thenable.then>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "CALL",
          "id": "<resolve(nested-thenable)>",
          "metadata": {
            "callee": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<nested-thenable-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<nested-thenable.then>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve2>"
        },
        {
          "type": "CALL",
          "id": "<resolve2(42)>",
          "metadata": {
            "callee": "resolve2"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(thenable)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(thenable)>",
          "metadata": {
            "operator": "await"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<nestedThenable>",
            "dst": "<thenable>",
            "type": "CONTAINS"
          },
          {
            "src": "<thenable-object>",
            "dst": "<thenable.then>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<thenable.then>",
            "dst": "<resolve>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<thenable.then>",
            "dst": "<resolve(nested-thenable)>",
            "type": "CONTAINS"
          },
          {
            "src": "<resolve(nested-thenable)>",
            "dst": "<nested-thenable-object>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<nested-thenable-object>",
            "dst": "<nested-thenable.then>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<nested-thenable.then>",
            "dst": "<resolve2>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<nested-thenable.then>",
            "dst": "<resolve2(42)>",
            "type": "CONTAINS"
          },
          {
            "src": "<resolve2(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Promise.resolve(thenable)>",
            "dst": "<thenable>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<await Promise.resolve(thenable)>",
            "dst": "<Promise.resolve(thenable)>",
            "type": "AWAITS"
          },
          {
            "src": "<nestedThenable>",
            "dst": "<await Promise.resolve(thenable)>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<thenable>",
            "dst": "<thenable-object>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<resolve(nested-thenable)>",
            "dst": "<resolve>",
            "type": "CALLS"
          },
          {
            "src": "<resolve2(42)>",
            "dst": "<resolve2>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-generator",
      "category": "async-generators",
      "code": "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<asyncCounter>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i <= end>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await new Promise(resolve => setTimeout(resolve, 100))>"
        },
        {
          "type": "CALL",
          "id": "<new Promise(resolve => setTimeout(resolve, 100))>",
          "metadata": {
            "callee": "Promise",
            "constructor": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<resolve => setTimeout(resolve, 100)>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "CALL",
          "id": "<setTimeout(resolve, 100)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "LITERAL",
          "id": "<100>",
          "metadata": {
            "value": 100,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield i>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncCounter>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncCounter>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncCounter>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<i <= end>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<await new Promise(resolve => setTimeout(resolve, 100))>",
            "type": "HAS_BODY"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield i>",
            "type": "HAS_BODY"
          },
          {
            "src": "<await new Promise(resolve => setTimeout(resolve, 100))>",
            "dst": "<new Promise(resolve => setTimeout(resolve, 100))>",
            "type": "AWAITS"
          },
          {
            "src": "<new Promise(resolve => setTimeout(resolve, 100))>",
            "dst": "<resolve => setTimeout(resolve, 100)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<resolve => setTimeout(resolve, 100)>",
            "dst": "<resolve>",
            "type": "CONTAINS"
          },
          {
            "src": "<resolve => setTimeout(resolve, 100)>",
            "dst": "<setTimeout(resolve, 100)>",
            "type": "RETURNS"
          },
          {
            "src": "<setTimeout(resolve, 100)>",
            "dst": "<resolve>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(resolve, 100)>",
            "dst": "<100>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<yield i>",
            "dst": "<i>",
            "type": "YIELDS"
          },
          {
            "src": "<asyncCounter>",
            "dst": "<yield i>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i <= end>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i <= end>",
            "dst": "<end>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::yield-star-return-value",
      "category": "async-generators",
      "code": "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<innerWithReturn>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'done'>",
          "metadata": {
            "value": "done",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<outerCapturesReturn>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield* innerWithReturn()>",
          "metadata": {
            "operator": "yield*"
          }
        },
        {
          "type": "CALL",
          "id": "<innerWithReturn()>",
          "metadata": {
            "callee": "innerWithReturn"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<innerWithReturn>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<innerWithReturn>",
            "dst": "<2>",
            "type": "YIELDS"
          },
          {
            "src": "<innerWithReturn>",
            "dst": "<'done'>",
            "type": "RETURNS"
          },
          {
            "src": "<yield* innerWithReturn()>",
            "dst": "<innerWithReturn()>",
            "type": "DELEGATES_TO"
          },
          {
            "src": "<outerCapturesReturn>",
            "dst": "<result>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<yield* innerWithReturn()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<innerWithReturn()>",
            "dst": "<innerWithReturn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::yield-yield-chained",
      "category": "async-generators",
      "code": "function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<chainedYield>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield yield 1>",
          "metadata": {
            "type": "nested-yield"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<inner-yield>",
          "metadata": {
            "position": "inner",
            "operation": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<outer-yield>",
          "metadata": {
            "position": "outer",
            "operation": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<chainedYield>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<chainedYield>",
            "dst": "<yield yield 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield yield 1>",
            "dst": "<outer-yield>",
            "type": "CONTAINS"
          },
          {
            "src": "<outer-yield>",
            "dst": "<inner-yield>",
            "type": "YIELDS"
          },
          {
            "src": "<inner-yield>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<chainedYield>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<yield yield 1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "async-generators::for-await-sync-iterable",
      "category": "async-generators",
      "code": "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array  each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forAwaitSyncIterable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-await>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "value": [
              1,
              2,
              3
            ],
            "literalType": "array"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(item)>",
          "metadata": {
            "callee": "push",
            "method": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return results>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<for-await>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await>",
            "dst": "<[1, 2, 3]>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await>",
            "dst": "<results.push(item)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<return results>",
            "type": "CONTAINS"
          },
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<return results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(item)>",
            "dst": "<results>",
            "type": "CALLS_ON"
          },
          {
            "src": "<return results>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-iterator-cancel-manual",
      "category": "async-generators",
      "code": "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<manualAsyncCancel>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncGen>"
        },
        {
          "type": "VARIABLE",
          "id": "<iter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<asyncGen[Symbol.asyncIterator]>",
          "metadata": {
            "objectName": "asyncGen",
            "property": "Symbol.asyncIterator"
          }
        },
        {
          "type": "CALL",
          "id": "<asyncGen[Symbol.asyncIterator]()>",
          "metadata": {
            "callee": "asyncGen[Symbol.asyncIterator]"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<iter.next>",
          "metadata": {
            "objectName": "iter",
            "property": "next"
          }
        },
        {
          "type": "CALL",
          "id": "<iter.next()>",
          "metadata": {
            "callee": "iter.next",
            "awaited": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<iter.return>",
          "metadata": {
            "objectName": "iter",
            "property": "return"
          }
        },
        {
          "type": "CALL",
          "id": "<iter.return()>",
          "metadata": {
            "callee": "iter.return",
            "awaited": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return first>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<manualAsyncCancel>",
            "dst": "<asyncGen>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncCancel>",
            "dst": "<iter>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncCancel>",
            "dst": "<first>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncCancel>",
            "dst": "<return first>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<iter>",
            "dst": "<asyncGen[Symbol.asyncIterator]()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<first>",
            "dst": "<iter.next()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<asyncGen[Symbol.asyncIterator]()>",
            "dst": "<asyncGen[Symbol.asyncIterator]>",
            "type": "CALLS"
          },
          {
            "src": "<asyncGen[Symbol.asyncIterator]>",
            "dst": "<asyncGen>",
            "type": "READS_FROM"
          },
          {
            "src": "<iter.next()>",
            "dst": "<iter.next>",
            "type": "CALLS"
          },
          {
            "src": "<iter.next>",
            "dst": "<iter>",
            "type": "READS_FROM"
          },
          {
            "src": "<iter.return()>",
            "dst": "<iter.return>",
            "type": "CALLS"
          },
          {
            "src": "<iter.return>",
            "dst": "<iter>",
            "type": "READS_FROM"
          },
          {
            "src": "<return first>",
            "dst": "<first>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-stringify",
      "category": "builtins",
      "code": "function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonStringify>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<JSON.stringify(obj)>",
          "metadata": {
            "callee": "JSON.stringify"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.stringify>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "stringify"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<JSON>",
          "metadata": {
            "builtin": true,
            "global": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<jsonStringify>",
            "type": "DECLARES"
          },
          {
            "src": "<jsonStringify>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<jsonStringify>",
            "dst": "<JSON.stringify(obj)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.stringify(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<JSON.stringify(obj)>",
            "dst": "<JSON.stringify>",
            "type": "CALLS"
          },
          {
            "src": "<JSON.stringify>",
            "dst": "<JSON>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-generator-destructure-default",
      "category": "async-generators",
      "code": "async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<processStream>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<source>"
        },
        {
          "type": "LOOP",
          "id": "<for-await-of>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<priority>",
          "metadata": {
            "kind": "const",
            "destructured": true,
            "nested": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'normal'>",
          "metadata": {
            "value": "normal",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...data, priority }>",
          "metadata": {
            "type": "object-spread"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield { ...data, priority }>",
          "metadata": {
            "type": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<processStream>",
            "dst": "<source>",
            "type": "HAS_BODY"
          },
          {
            "src": "<processStream>",
            "dst": "<for-await-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<source>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await-of>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<priority>",
            "type": "CONTAINS"
          },
          {
            "src": "<priority>",
            "dst": "<'normal'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<{ ...data, priority }>",
            "dst": "<data>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<yield { ...data, priority }>",
            "dst": "<{ ...data, priority }>",
            "type": "YIELDS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<yield { ...data, priority }>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<{ ...data, priority }>",
            "dst": "<priority>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-parse",
      "category": "builtins",
      "code": "function jsonParse(str) {\n  return JSON.parse(str);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonParse>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "CALL",
          "id": "<JSON.parse(str)>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.parse>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "parse"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<JSON>",
          "metadata": {
            "builtin": true,
            "global": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<jsonParse>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<jsonParse>",
            "dst": "<JSON.parse(str)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.parse(str)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<JSON.parse(str)>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<JSON.parse>",
            "dst": "<JSON>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-two-way",
      "category": "async-generators",
      "code": "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<accumulator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<total>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<while-true>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield-total>",
          "metadata": {
            "expressionType": "yield",
            "yieldsValue": true,
            "receivesValue": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<total += value>",
          "metadata": {
            "operator": "+="
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<accumulator>",
            "dst": "<total>",
            "type": "CONTAINS"
          },
          {
            "src": "<accumulator>",
            "dst": "<while-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while-true>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<yield-total>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<total += value>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<total>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<value>",
            "dst": "<yield-total>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<total += value>",
            "dst": "<total>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<yield-total>",
            "dst": "<total>",
            "type": "READS_FROM"
          },
          {
            "src": "<total += value>",
            "dst": "<value>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-iter-manual",
      "category": "async-generators",
      "code": "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<manualAsyncIteration>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncIterable>"
        },
        {
          "type": "VARIABLE",
          "id": "<asyncIter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<asyncIterable[Symbol.asyncIterator]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIterable[Symbol.asyncIterator]()>",
          "metadata": {
            "callee": "asyncIterable[Symbol.asyncIterator]"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<step>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIter.next()>",
          "metadata": {
            "callee": "asyncIter.next",
            "awaited": true
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!step.done>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<step.done>"
        },
        {
          "type": "CALL",
          "id": "<results.push(step.value)>",
          "metadata": {
            "callee": "results.push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<step.value>"
        },
        {
          "type": "EXPRESSION",
          "id": "<step = await asyncIter.next()>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIter.next()#2>",
          "metadata": {
            "callee": "asyncIter.next",
            "awaited": true
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIter.return?.()>",
          "metadata": {
            "callee": "asyncIter.return",
            "optional": true,
            "awaited": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<asyncIter.return>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<manualAsyncIteration>",
            "dst": "<asyncIterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<asyncIter>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<step>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<while>",
            "dst": "<!step.done>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while>",
            "dst": "<results.push(step.value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(step.value)>",
            "dst": "<step.value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<while>",
            "dst": "<step = await asyncIter.next()>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<asyncIter.return?.()>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<asyncIter>",
            "dst": "<asyncIterable[Symbol.asyncIterator]()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<step>",
            "dst": "<asyncIter.next()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<step = await asyncIter.next()>",
            "dst": "<step>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<asyncIterable[Symbol.asyncIterator]()>",
            "dst": "<asyncIterable[Symbol.asyncIterator]>",
            "type": "CALLS"
          },
          {
            "src": "<asyncIterable[Symbol.asyncIterator]>",
            "dst": "<asyncIterable>",
            "type": "READS_FROM"
          },
          {
            "src": "<asyncIter.next()>",
            "dst": "<asyncIter>",
            "type": "READS_FROM"
          },
          {
            "src": "<!step.done>",
            "dst": "<step.done>",
            "type": "READS_FROM"
          },
          {
            "src": "<step.done>",
            "dst": "<step>",
            "type": "READS_FROM"
          },
          {
            "src": "<results.push(step.value)>",
            "dst": "<results>",
            "type": "READS_FROM"
          },
          {
            "src": "<step.value>",
            "dst": "<step>",
            "type": "READS_FROM"
          },
          {
            "src": "<step = await asyncIter.next()>",
            "dst": "<asyncIter.next()#2>",
            "type": "READS_FROM"
          },
          {
            "src": "<asyncIter.next()#2>",
            "dst": "<asyncIter>",
            "type": "READS_FROM"
          },
          {
            "src": "<asyncIter.return?.()>",
            "dst": "<asyncIter.return>",
            "type": "CALLS"
          },
          {
            "src": "<asyncIter.return>",
            "dst": "<asyncIter>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-return-throw",
      "category": "async-generators",
      "code": "function* generatorReturnThrow() {\n  try {\n    yield 1;\n    yield 2;\n  } finally {\n    yield 'cleanup';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<generatorReturnThrow>",
          "metadata": {
            "async": false,
            "generator": true
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 1>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 2>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 'cleanup'>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'cleanup'>",
          "metadata": {
            "value": "cleanup",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<generatorReturnThrow>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<generatorReturnThrow>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<yield 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<yield 2>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield 1>",
            "dst": "<1>",
            "type": "RETURNS"
          },
          {
            "src": "<yield 2>",
            "dst": "<2>",
            "type": "RETURNS"
          },
          {
            "src": "<finally-block>",
            "dst": "<yield 'cleanup'>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield 'cleanup'>",
            "dst": "<'cleanup'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "async-generators::async-iterator-cancel-break",
      "category": "async-generators",
      "code": "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<streamChunks>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "VARIABLE",
          "id": "<reader>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ locked: true }>",
          "metadata": {
            "value": "{ locked: true }",
            "literalType": "object"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": "0",
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": "10",
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 10>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield { chunk: i, size: i * 100 }>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ chunk: i, size: i * 100 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i * 100>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<100>",
          "metadata": {
            "value": "100",
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<reader.locked>",
          "metadata": {
            "objectName": "reader",
            "propertyName": "locked"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": "false",
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<streamChunks>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<streamChunks>",
            "dst": "<reader>",
            "type": "CONTAINS"
          },
          {
            "src": "<streamChunks>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<streamChunks>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 10>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield { chunk: i, size: i * 100 }>",
            "type": "HAS_BODY"
          },
          {
            "src": "<yield { chunk: i, size: i * 100 }>",
            "dst": "<{ chunk: i, size: i * 100 }>",
            "type": "YIELDS"
          },
          {
            "src": "<finally-block>",
            "dst": "<reader.locked>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<reader>",
            "dst": "<{ locked: true }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<reader.locked>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<i < 10>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 10>",
            "dst": "<10>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ chunk: i, size: i * 100 }>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ chunk: i, size: i * 100 }>",
            "dst": "<i * 100>",
            "type": "READS_FROM"
          },
          {
            "src": "<i * 100>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i * 100>",
            "dst": "<100>",
            "type": "READS_FROM"
          },
          {
            "src": "<reader.locked>",
            "dst": "<reader>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-weakref",
      "category": "builtins",
      "code": "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<weakRefUsage>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<target>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ data: 'important' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<ref>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new WeakRef(target)>",
          "metadata": {
            "callee": "WeakRef",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<deref>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ref.deref()>",
          "metadata": {
            "callee": "deref",
            "isMethodCall": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<deref?.data>",
          "metadata": {
            "objectName": "deref",
            "propertyName": "data",
            "optional": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<weakRefUsage>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakRefUsage>",
            "dst": "<ref>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakRefUsage>",
            "dst": "<deref>",
            "type": "CONTAINS"
          },
          {
            "src": "<new WeakRef(target)>",
            "dst": "<target>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<weakRefUsage>",
            "dst": "<deref?.data>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<target>",
            "dst": "<{ data: 'important' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ref>",
            "dst": "<new WeakRef(target)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<deref>",
            "dst": "<ref.deref()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<ref.deref()>",
            "dst": "<ref>",
            "type": "READS_FROM"
          },
          {
            "src": "<deref?.data>",
            "dst": "<deref>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-map-constructor",
      "category": "builtins",
      "code": "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<mapFromEntries>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<map>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map([...])>",
          "metadata": {
            "callee": "Map",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<[['x', 10], ['y', 20]]>",
          "metadata": {
            "value": "[['x', 10], ['y', 20]]",
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<['x', 10]>",
          "metadata": {
            "value": "['x', 10]",
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'x'>",
          "metadata": {
            "value": "x",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<['y', 20]>",
          "metadata": {
            "value": "['y', 20]",
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'y'>",
          "metadata": {
            "value": "y",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<20>",
          "metadata": {
            "value": 20,
            "literalType": "number"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Map>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<mapFromEntries>",
            "dst": "<map>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Map([...])>",
            "dst": "<[['x', 10], ['y', 20]]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<[['x', 10], ['y', 20]]>",
            "dst": "<['x', 10]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[['x', 10], ['y', 20]]>",
            "dst": "<['y', 20]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['x', 10]>",
            "dst": "<'x'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['x', 10]>",
            "dst": "<10>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['y', 20]>",
            "dst": "<'y'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['y', 20]>",
            "dst": "<20>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<mapFromEntries>",
            "dst": "<map>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<map>",
            "dst": "<new Map([...])>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new Map([...])>",
            "dst": "<Map>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-parse-reviver",
      "category": "builtins",
      "code": "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonParseReviver>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "CALL",
          "id": "<JSON.parse(str, reviver)>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.parse>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "parse"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<reviver>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "BRANCH",
          "id": "<if-date-check>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<key === 'date'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'date'>",
          "metadata": {
            "value": "date",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new Date(value)>",
          "metadata": {
            "callee": "Date",
            "isConstructor": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Date>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<jsonParseReviver>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<jsonParseReviver>",
            "dst": "<JSON.parse(str, reviver)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.parse(str, reviver)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.parse(str, reviver)>",
            "dst": "<reviver>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reviver>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<reviver>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<reviver>",
            "dst": "<if-date-check>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-date-check>",
            "dst": "<key === 'date'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-date-check>",
            "dst": "<new Date(value)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<new Date(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-date-check>",
            "dst": "<value>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<JSON.parse(str, reviver)>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<key === 'date'>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<key === 'date'>",
            "dst": "<'date'>",
            "type": "READS_FROM"
          },
          {
            "src": "<new Date(value)>",
            "dst": "<Date>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-destructure-await-default",
      "category": "async-generators",
      "code": "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getConfigValue>",
          "metadata": {
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "VARIABLE",
          "id": "<asyncDestructureHandler>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncDestructureHandler:fn>",
          "metadata": {
            "async": true,
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<destructured-param>",
          "metadata": {
            "destructured": true,
            "defaultValue": "{}"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<timeout>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<retries>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "CALL",
          "id": "<getConfigValue('timeout')>",
          "metadata": {
            "callee": "getConfigValue",
            "awaited": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'timeout'>",
          "metadata": {
            "value": "timeout",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<getConfigValue('retries')>",
          "metadata": {
            "callee": "getConfigValue",
            "awaited": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'retries'>",
          "metadata": {
            "value": "retries",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ timeout, retries }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getConfigValue>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<getConfigValue>",
            "dst": "<key>",
            "type": "RETURNS"
          },
          {
            "src": "<asyncDestructureHandler:fn>",
            "dst": "<destructured-param>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructured-param>",
            "dst": "<timeout>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<destructured-param>",
            "dst": "<retries>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<timeout>",
            "dst": "<getConfigValue('timeout')>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<retries>",
            "dst": "<getConfigValue('retries')>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<getConfigValue('timeout')>",
            "dst": "<'timeout'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getConfigValue('retries')>",
            "dst": "<'retries'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<asyncDestructureHandler:fn>",
            "dst": "<{ timeout, retries }>",
            "type": "RETURNS"
          },
          {
            "src": "<getConfigValue('timeout')>",
            "dst": "<timeout>",
            "type": "AWAITS"
          },
          {
            "src": "<getConfigValue('retries')>",
            "dst": "<retries>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<asyncDestructureHandler>",
            "dst": "<asyncDestructureHandler:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<getConfigValue('timeout')>",
            "dst": "<getConfigValue>",
            "type": "CALLS"
          },
          {
            "src": "<getConfigValue('retries')>",
            "dst": "<getConfigValue>",
            "type": "CALLS"
          },
          {
            "src": "<{ timeout, retries }>",
            "dst": "<timeout>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ timeout, retries }>",
            "dst": "<retries>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-stringify-replacer",
      "category": "builtins",
      "code": "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonStringifyReplacer>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<JSON.stringify(obj, replacer, 2)>",
          "metadata": {
            "callee": "JSON.stringify"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.stringify>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "stringify"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<replacer>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value === 'function'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'function'>",
          "metadata": {
            "value": "function",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<undefined>",
          "metadata": {
            "value": "undefined",
            "literalType": "undefined"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-typeof-function>",
          "metadata": {
            "branchType": "if"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<jsonStringifyReplacer>",
            "dst": "<obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<jsonStringifyReplacer>",
            "dst": "<JSON.stringify(obj, replacer, 2)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<replacer>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<replacer>",
            "dst": "<key>",
            "type": "HAS_BODY"
          },
          {
            "src": "<replacer>",
            "dst": "<value>",
            "type": "HAS_BODY"
          },
          {
            "src": "<replacer>",
            "dst": "<if-typeof-function>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-typeof-function>",
            "dst": "<typeof value === 'function'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-typeof-function>",
            "dst": "<undefined>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-typeof-function>",
            "dst": "<value>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<JSON.stringify>",
            "type": "CALLS"
          },
          {
            "src": "<typeof value === 'function'>",
            "dst": "<typeof value>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value === 'function'>",
            "dst": "<'function'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value>",
            "dst": "<value>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-weakset",
      "category": "builtins",
      "code": "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<weakSetUsage>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<ws>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new WeakSet()>",
          "metadata": {
            "callee": "WeakSet",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj1>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj2>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}2>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "CALL",
          "id": "<ws.add(obj1)>",
          "metadata": {
            "callee": "add",
            "method": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<has>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ws.has(obj1)>",
          "metadata": {
            "callee": "has",
            "method": true
          }
        },
        {
          "type": "CALL",
          "id": "<ws.delete(obj1)>",
          "metadata": {
            "callee": "delete",
            "method": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasAfter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ws.has(obj1)2>",
          "metadata": {
            "callee": "has",
            "method": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ has, hasAfter }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<weakSetUsage>",
            "dst": "<ws>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<obj1>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<obj2>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<has>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<hasAfter>",
            "type": "CONTAINS"
          },
          {
            "src": "<ws.add(obj1)>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ws.has(obj1)>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ws.delete(obj1)>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ws.has(obj1)2>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<{ has, hasAfter }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<ws>",
            "dst": "<new WeakSet()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj1>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj2>",
            "dst": "<{}2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<has>",
            "dst": "<ws.has(obj1)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasAfter>",
            "dst": "<ws.has(obj1)2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new WeakSet()>",
            "dst": "<WeakSet>",
            "type": "CALLS"
          },
          {
            "src": "<ws.add(obj1)>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<ws.has(obj1)>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<ws.delete(obj1)>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<ws.has(obj1)2>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<{ has, hasAfter }>",
            "dst": "<has>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ has, hasAfter }>",
            "dst": "<hasAfter>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-globalthis",
      "category": "builtins",
      "code": "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<globalThisAccess>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<g>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<globalThis>",
          "metadata": {
            "builtinType": "global"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasConsole>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'console' in globalThis>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'console'>",
          "metadata": {
            "value": "console",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ g, hasConsole }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<globalThisAccess>",
            "dst": "<g>",
            "type": "CONTAINS"
          },
          {
            "src": "<globalThisAccess>",
            "dst": "<hasConsole>",
            "type": "CONTAINS"
          },
          {
            "src": "<globalThisAccess>",
            "dst": "<{ g, hasConsole }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<g>",
            "dst": "<globalThis>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasConsole>",
            "dst": "<'console' in globalThis>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<'console' in globalThis>",
            "dst": "<'console'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'console' in globalThis>",
            "dst": "<globalThis>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ g, hasConsole }>",
            "dst": "<g>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ g, hasConsole }>",
            "dst": "<hasConsole>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-return-thenable",
      "category": "async-generators",
      "code": "async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<returnsThenable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<thenable-object>",
          "metadata": {
            "thenable": true,
            "expressionType": "object_literal"
          }
        },
        {
          "type": "METHOD",
          "id": "<then>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "CALL",
          "id": "<resolve(42)>",
          "metadata": {
            "callee": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<returnsThenable>",
            "dst": "<thenable-object>",
            "type": "RETURNS"
          },
          {
            "src": "<thenable-object>",
            "dst": "<then>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<then>",
            "dst": "<resolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<then>",
            "dst": "<resolve(42)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<resolve(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<resolve(42)>",
            "dst": "<resolve>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-finalization-registry",
      "category": "builtins",
      "code": "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<finalizationUsage>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<registry>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new FinalizationRegistry(...)>",
          "metadata": {
            "callee": "FinalizationRegistry",
            "constructor": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<cleanup-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<heldValue>"
        },
        {
          "type": "CALL",
          "id": "<console.log(...)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Cleaned up: ${heldValue}`>",
          "metadata": {
            "templateLiteral": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ id: 1 }>",
          "metadata": {
            "value": "{ id: 1 }",
            "literalType": "object"
          }
        },
        {
          "type": "CALL",
          "id": "<registry.register(obj, 'resource-1')>",
          "metadata": {
            "callee": "register"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'resource-1'>",
          "metadata": {
            "value": "resource-1",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<finalizationUsage>",
            "dst": "<registry>",
            "type": "CONTAINS"
          },
          {
            "src": "<finalizationUsage>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<new FinalizationRegistry(...)>",
            "dst": "<cleanup-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cleanup-callback>",
            "dst": "<heldValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<cleanup-callback>",
            "dst": "<console.log(...)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(...)>",
            "dst": "<`Cleaned up: ${heldValue}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finalizationUsage>",
            "dst": "<registry.register(obj, 'resource-1')>",
            "type": "CONTAINS"
          },
          {
            "src": "<registry.register(obj, 'resource-1')>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<registry.register(obj, 'resource-1')>",
            "dst": "<'resource-1'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finalizationUsage>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<registry>",
            "dst": "<new FinalizationRegistry(...)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<{ id: 1 }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`Cleaned up: ${heldValue}`>",
            "dst": "<heldValue>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::regex-lookahead",
      "category": "builtins",
      "code": "const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<posLookahead>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\d+(?=px)/>",
          "metadata": {
            "value": "/\\d+(?=px)/",
            "literalType": "regex",
            "pattern": "\\d+(?=px)",
            "flags": ""
          }
        },
        {
          "type": "VARIABLE",
          "id": "<negLookahead>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\d+(?!px)/>",
          "metadata": {
            "value": "/\\d+(?!px)/",
            "literalType": "regex",
            "pattern": "\\d+(?!px)",
            "flags": ""
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<posLookahead>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<negLookahead>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<posLookahead>",
            "dst": "</\\d+(?=px)/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<negLookahead>",
            "dst": "</\\d+(?!px)/>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "builtins::builtin-regex-named-groups",
      "category": "builtins",
      "code": "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<regexNamedGroups>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<dateStr>"
        },
        {
          "type": "VARIABLE",
          "id": "<pattern>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>",
          "metadata": {
            "value": "/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/",
            "literalType": "regex",
            "namedGroups": [
              "year",
              "month",
              "day"
            ]
          }
        },
        {
          "type": "VARIABLE",
          "id": "<match>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<dateStr.match(pattern)>",
          "metadata": {
            "callee": "match",
            "method": true
          }
        },
        {
          "type": "BRANCH",
          "id": "<if (!match)>",
          "metadata": {
            "condition": "!match"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<year>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<month>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<day>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<match.groups>",
          "metadata": {
            "objectName": "match",
            "propertyName": "groups"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ year, month, day }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<regexNamedGroups>",
            "dst": "<dateStr>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<pattern>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<match>",
            "type": "CONTAINS"
          },
          {
            "src": "<dateStr.match(pattern)>",
            "dst": "<pattern>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<if (!match)>",
            "type": "CONTAINS"
          },
          {
            "src": "<if (!match)>",
            "dst": "<match>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if (!match)>",
            "dst": "<null>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<year>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<month>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<day>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<{ year, month, day }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<pattern>",
            "dst": "</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<match>",
            "dst": "<dateStr.match(pattern)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<year>",
            "dst": "<match.groups>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<month>",
            "dst": "<match.groups>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<day>",
            "dst": "<match.groups>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<dateStr.match(pattern)>",
            "dst": "<dateStr>",
            "type": "READS_FROM"
          },
          {
            "src": "<match.groups>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ year, month, day }>",
            "dst": "<year>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ year, month, day }>",
            "dst": "<month>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ year, month, day }>",
            "dst": "<day>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::regex-lookbehind",
      "category": "builtins",
      "code": "const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<posLookbehind>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<=\\$)\\d+/>",
          "metadata": {
            "value": "/(?<=\\$)\\d+/",
            "literalType": "regex",
            "flags": "",
            "hasLookbehind": true,
            "lookbehindType": "positive"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<negLookbehind>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<!\\$)\\d+/>",
          "metadata": {
            "value": "/(?<!\\$)\\d+/",
            "literalType": "regex",
            "flags": "",
            "hasLookbehind": true,
            "lookbehindType": "negative"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<posLookbehind>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<negLookbehind>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<posLookbehind>",
            "dst": "</(?<=\\$)\\d+/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<negLookbehind>",
            "dst": "</(?<!\\$)\\d+/>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "builtins::builtin-regex-exec",
      "category": "builtins",
      "code": "function regexExec(pattern, str) {\n  const regex = new RegExp(pattern, 'g');\n  const matches = [];\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    matches.push({ match: match[0], index: match.index });\n  }\n  return matches;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<regexExec>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<pattern>"
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "VARIABLE",
          "id": "<regex>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new RegExp(pattern, 'g')>",
          "metadata": {
            "callee": "RegExp",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'g'>",
          "metadata": {
            "value": "g",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<matches>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "literalType": "array",
            "empty": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<match>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<(match = regex.exec(str)) !== null>",
          "metadata": {
            "operator": "!=="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<match = regex.exec(str)>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "CALL",
          "id": "<regex.exec(str)>",
          "metadata": {
            "callee": "exec",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "literalType": "null"
          }
        },
        {
          "type": "CALL",
          "id": "<matches.push({ match: match[0], index: match.index })>",
          "metadata": {
            "callee": "push",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ match: match[0], index: match.index }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<match[0]>",
          "metadata": {
            "property": "0",
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<match.index>",
          "metadata": {
            "property": "index"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<regexExec>",
            "dst": "<pattern>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexExec>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexExec>",
            "dst": "<regex>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexExec>",
            "dst": "<matches>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexExec>",
            "dst": "<match>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexExec>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<new RegExp(pattern, 'g')>",
            "dst": "<pattern>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new RegExp(pattern, 'g')>",
            "dst": "<'g'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<while>",
            "dst": "<(match = regex.exec(str)) !== null>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<regex.exec(str)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<while>",
            "dst": "<matches.push({ match: match[0], index: match.index })>",
            "type": "HAS_BODY"
          },
          {
            "src": "<matches.push({ match: match[0], index: match.index })>",
            "dst": "<{ match: match[0], index: match.index }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<regexExec>",
            "dst": "<matches>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<regex>",
            "dst": "<new RegExp(pattern, 'g')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<matches>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<match = regex.exec(str)>",
            "dst": "<match>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<(match = regex.exec(str)) !== null>",
            "dst": "<match = regex.exec(str)>",
            "type": "READS_FROM"
          },
          {
            "src": "<(match = regex.exec(str)) !== null>",
            "dst": "<null>",
            "type": "READS_FROM"
          },
          {
            "src": "<match = regex.exec(str)>",
            "dst": "<regex.exec(str)>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ match: match[0], index: match.index }>",
            "dst": "<match[0]>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ match: match[0], index: match.index }>",
            "dst": "<match.index>",
            "type": "READS_FROM"
          },
          {
            "src": "<match[0]>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<match.index>",
            "dst": "<match>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-iter-manual",
      "category": "async-generators",
      "code": "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<manualAsyncIteration>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncIterable>"
        },
        {
          "type": "VARIABLE",
          "id": "<asyncIter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<asyncIterable[Symbol.asyncIterator]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIterable[Symbol.asyncIterator]()>",
          "metadata": {
            "callee": "asyncIterable[Symbol.asyncIterator]"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<step>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIter.next()>",
          "metadata": {
            "callee": "asyncIter.next",
            "awaited": true
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!step.done>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<step.done>"
        },
        {
          "type": "CALL",
          "id": "<results.push(step.value)>",
          "metadata": {
            "callee": "results.push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<step.value>"
        },
        {
          "type": "EXPRESSION",
          "id": "<step = await asyncIter.next()>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIter.next()#2>",
          "metadata": {
            "callee": "asyncIter.next",
            "awaited": true
          }
        },
        {
          "type": "CALL",
          "id": "<asyncIter.return?.()>",
          "metadata": {
            "callee": "asyncIter.return",
            "optional": true,
            "awaited": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<asyncIter.return>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<manualAsyncIteration>",
            "dst": "<asyncIterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<asyncIter>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<step>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<while>",
            "dst": "<!step.done>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while>",
            "dst": "<results.push(step.value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(step.value)>",
            "dst": "<step.value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<while>",
            "dst": "<step = await asyncIter.next()>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<asyncIter.return?.()>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncIteration>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<asyncIter>",
            "dst": "<asyncIterable[Symbol.asyncIterator]()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<step>",
            "dst": "<asyncIter.next()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<step = await asyncIter.next()>",
            "dst": "<step>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<asyncIterable[Symbol.asyncIterator]()>",
            "dst": "<asyncIterable[Symbol.asyncIterator]>",
            "type": "CALLS"
          },
          {
            "src": "<asyncIterable[Symbol.asyncIterator]>",
            "dst": "<asyncIterable>",
            "type": "READS_FROM"
          },
          {
            "src": "<asyncIter.next()>",
            "dst": "<asyncIter>",
            "type": "READS_FROM"
          },
          {
            "src": "<!step.done>",
            "dst": "<step.done>",
            "type": "READS_FROM"
          },
          {
            "src": "<step.done>",
            "dst": "<step>",
            "type": "READS_FROM"
          },
          {
            "src": "<results.push(step.value)>",
            "dst": "<results>",
            "type": "READS_FROM"
          },
          {
            "src": "<step.value>",
            "dst": "<step>",
            "type": "READS_FROM"
          },
          {
            "src": "<step = await asyncIter.next()>",
            "dst": "<asyncIter.next()#2>",
            "type": "READS_FROM"
          },
          {
            "src": "<asyncIter.next()#2>",
            "dst": "<asyncIter>",
            "type": "READS_FROM"
          },
          {
            "src": "<asyncIter.return?.()>",
            "dst": "<asyncIter.return>",
            "type": "CALLS"
          },
          {
            "src": "<asyncIter.return>",
            "dst": "<asyncIter>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::string-raw-template",
      "category": "builtins",
      "code": "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file'  no escape processing",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<windowsPath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<String.raw`C:\\Users\\name\\file`>",
          "metadata": {
            "callee": "String.raw",
            "callType": "tagged-template"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<String.raw>",
          "metadata": {
            "objectName": "String",
            "propertyName": "raw"
          }
        },
        {
          "type": "LITERAL",
          "id": "<String>",
          "metadata": {
            "value": "String",
            "literalType": "identifier",
            "builtinType": "constructor"
          }
        },
        {
          "type": "LITERAL",
          "id": "<template-literal>",
          "metadata": {
            "value": "C:\\Users\\name\\file",
            "literalType": "template",
            "raw": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<windowsPath>",
            "type": "DECLARES"
          },
          {
            "src": "<String.raw`C:\\Users\\name\\file`>",
            "dst": "<template-literal>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<windowsPath>",
            "dst": "<String.raw`C:\\Users\\name\\file`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<String.raw`C:\\Users\\name\\file`>",
            "dst": "<String.raw>",
            "type": "CALLS"
          },
          {
            "src": "<String.raw>",
            "dst": "<String>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::regex-unicode-props",
      "category": "builtins",
      "code": "const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<emoji>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\p{Emoji}/u>",
          "metadata": {
            "value": "/\\p{Emoji}/u",
            "literalType": "regex",
            "flags": [
              "u"
            ],
            "unicodeProperty": "Emoji"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<greek>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\p{Script=Greek}/u>",
          "metadata": {
            "value": "/\\p{Script=Greek}/u",
            "literalType": "regex",
            "flags": [
              "u"
            ],
            "unicodeProperty": "Script=Greek"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<letter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\p{Letter}/u>",
          "metadata": {
            "value": "/\\p{Letter}/u",
            "literalType": "regex",
            "flags": [
              "u"
            ],
            "unicodeProperty": "Letter"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<emoji>",
            "type": "DECLARES"
          },
          {
            "src": "<MODULE>",
            "dst": "<greek>",
            "type": "DECLARES"
          },
          {
            "src": "<MODULE>",
            "dst": "<letter>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<emoji>",
            "dst": "</\\p{Emoji}/u>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<greek>",
            "dst": "</\\p{Script=Greek}/u>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<letter>",
            "dst": "</\\p{Letter}/u>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "builtins::array-from-mapfn",
      "category": "builtins",
      "code": "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<arrayFromMapFn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<indices>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Array.from({ length: 5 }, (_, i) => i)>",
          "metadata": {
            "callee": "Array.from"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ length: 5 }>",
          "metadata": {
            "value": "{ length: 5 }",
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<(_, i) => i>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<_>"
        },
        {
          "type": "PARAMETER",
          "id": "<i>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<arrayFromMapFn>",
            "dst": "<indices>",
            "type": "CONTAINS"
          },
          {
            "src": "<Array.from({ length: 5 }, (_, i) => i)>",
            "dst": "<{ length: 5 }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Array.from({ length: 5 }, (_, i) => i)>",
            "dst": "<(_, i) => i>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<(_, i) => i>",
            "dst": "<_>",
            "type": "CONTAINS"
          },
          {
            "src": "<(_, i) => i>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<(_, i) => i>",
            "dst": "<i>",
            "type": "RETURNS"
          },
          {
            "src": "<arrayFromMapFn>",
            "dst": "<indices>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<indices>",
            "dst": "<Array.from({ length: 5 }, (_, i) => i)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Array.from({ length: 5 }, (_, i) => i)>",
            "dst": "<Array.from>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::callback-error-first",
      "category": "callbacks",
      "code": "function readFileCallback(path, callback) {\n  try {\n    const data = `contents of ${path}`;\n    callback(null, data);\n  } catch (err) {\n    callback(err, null);\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<readFileCallback>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<path>"
        },
        {
          "type": "PARAMETER",
          "id": "<callback>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`contents of ${path}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<callback(null, data)>",
          "metadata": {
            "callee": "callback"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "CALL",
          "id": "<callback(err, null)>",
          "metadata": {
            "callee": "callback"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<readFileCallback>",
            "dst": "<path>",
            "type": "CONTAINS"
          },
          {
            "src": "<readFileCallback>",
            "dst": "<callback>",
            "type": "CONTAINS"
          },
          {
            "src": "<readFileCallback>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<try-block>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<callback(null, data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<callback(null, data)>",
            "dst": "<null>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<callback(null, data)>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<callback(err, null)>",
            "type": "CONTAINS"
          },
          {
            "src": "<callback(err, null)>",
            "dst": "<err>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<callback(err, null)>",
            "dst": "<null>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<data>",
            "dst": "<`contents of ${path}`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`contents of ${path}`>",
            "dst": "<path>",
            "type": "READS_FROM"
          },
          {
            "src": "<callback(null, data)>",
            "dst": "<callback>",
            "type": "CALLS"
          },
          {
            "src": "<callback(err, null)>",
            "dst": "<callback>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::promise-resolve-thenable",
      "category": "async-generators",
      "code": "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<nestedThenable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<thenable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<thenable-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<thenable.then>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "CALL",
          "id": "<resolve(nested-thenable)>",
          "metadata": {
            "callee": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<nested-thenable-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<nested-thenable.then>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve2>"
        },
        {
          "type": "CALL",
          "id": "<resolve2(42)>",
          "metadata": {
            "callee": "resolve2"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(thenable)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(thenable)>",
          "metadata": {
            "operator": "await"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<nestedThenable>",
            "dst": "<thenable>",
            "type": "CONTAINS"
          },
          {
            "src": "<thenable-object>",
            "dst": "<thenable.then>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<thenable.then>",
            "dst": "<resolve>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<thenable.then>",
            "dst": "<resolve(nested-thenable)>",
            "type": "CONTAINS"
          },
          {
            "src": "<resolve(nested-thenable)>",
            "dst": "<nested-thenable-object>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<nested-thenable-object>",
            "dst": "<nested-thenable.then>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<nested-thenable.then>",
            "dst": "<resolve2>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<nested-thenable.then>",
            "dst": "<resolve2(42)>",
            "type": "CONTAINS"
          },
          {
            "src": "<resolve2(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Promise.resolve(thenable)>",
            "dst": "<thenable>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<await Promise.resolve(thenable)>",
            "dst": "<Promise.resolve(thenable)>",
            "type": "AWAITS"
          },
          {
            "src": "<nestedThenable>",
            "dst": "<await Promise.resolve(thenable)>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<thenable>",
            "dst": "<thenable-object>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<resolve(nested-thenable)>",
            "dst": "<resolve>",
            "type": "CALLS"
          },
          {
            "src": "<resolve2(42)>",
            "dst": "<resolve2>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::callback-error-first-usage",
      "category": "callbacks",
      "code": "function processFile(path) {\n  readFileCallback(path, function (err, data) {\n    if (err) {\n      console.error('Failed:', err);\n      return;\n    }\n    console.log('Data:', data);\n  });\n}\n\n// --- Callback hell (3+ levels) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<processFile>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<path>"
        },
        {
          "type": "CALL",
          "id": "<readFileCallback(path, callback)>",
          "metadata": {
            "callee": "readFileCallback"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<callback>",
          "metadata": {
            "async": false,
            "generator": false,
            "callbackStyle": "error-first"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "BRANCH",
          "id": "<if-err>",
          "metadata": {
            "condition": "err"
          }
        },
        {
          "type": "CALL",
          "id": "<console.error('Failed:', err)>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Failed:'>",
          "metadata": {
            "value": "Failed:",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log('Data:', data)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Data:'>",
          "metadata": {
            "value": "Data:",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<processFile>",
            "dst": "<path>",
            "type": "HAS_BODY"
          },
          {
            "src": "<processFile>",
            "dst": "<readFileCallback(path, callback)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<readFileCallback(path, callback)>",
            "dst": "<path>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<readFileCallback(path, callback)>",
            "dst": "<callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<callback>",
            "dst": "<err>",
            "type": "HAS_BODY"
          },
          {
            "src": "<callback>",
            "dst": "<data>",
            "type": "HAS_BODY"
          },
          {
            "src": "<callback>",
            "dst": "<if-err>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-err>",
            "dst": "<err>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-err>",
            "dst": "<console.error('Failed:', err)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<console.error('Failed:', err)>",
            "dst": "<'Failed:'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.error('Failed:', err)>",
            "dst": "<err>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.log('Data:', data)>",
            "dst": "<'Data:'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.log('Data:', data)>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-err>",
            "dst": "<console.log('Data:', data)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "callbacks::callback-settimeout",
      "category": "callbacks",
      "code": "function delayedExecution(fn, ms) {\n  const id = setTimeout(fn, ms);\n  return function cancel() {\n    clearTimeout(id);\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<delayedExecution>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "PARAMETER",
          "id": "<ms>"
        },
        {
          "type": "VARIABLE",
          "id": "<id>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout(fn, ms)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<setTimeout>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<cancel>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<clearTimeout(id)>",
          "metadata": {
            "callee": "clearTimeout"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<clearTimeout>",
          "metadata": {
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<delayedExecution>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<delayedExecution>",
            "dst": "<ms>",
            "type": "HAS_BODY"
          },
          {
            "src": "<delayedExecution>",
            "dst": "<id>",
            "type": "HAS_BODY"
          },
          {
            "src": "<setTimeout(fn, ms)>",
            "dst": "<fn>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(fn, ms)>",
            "dst": "<ms>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<delayedExecution>",
            "dst": "<cancel>",
            "type": "RETURNS"
          },
          {
            "src": "<cancel>",
            "dst": "<clearTimeout(id)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<clearTimeout(id)>",
            "dst": "<id>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<id>",
            "dst": "<setTimeout(fn, ms)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<cancel>",
            "dst": "<id>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<setTimeout(fn, ms)>",
            "dst": "<setTimeout>",
            "type": "CALLS"
          },
          {
            "src": "<clearTimeout(id)>",
            "dst": "<clearTimeout>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::symbol-private-property",
      "category": "builtins",
      "code": "const _private = Symbol('private');\nclass SymbolStore {\n  [_private] = new Map();\n  set(key, value) { this[_private].set(key, value); }\n  get(key) { return this[_private].get(key); }\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<_private>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Symbol('private')>",
          "metadata": {
            "callee": "Symbol"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'private'>",
          "metadata": {
            "value": "private",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<SymbolStore>"
        },
        {
          "type": "PROPERTY",
          "id": "<SymbolStore[_private]>",
          "metadata": {
            "computed": true,
            "private": true
          }
        },
        {
          "type": "CALL",
          "id": "<new Map()>",
          "metadata": {
            "callee": "Map",
            "constructor": true
          }
        },
        {
          "type": "METHOD",
          "id": "<SymbolStore.set>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this[_private]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<this[_private].set(key, value)>",
          "metadata": {
            "callee": "set"
          }
        },
        {
          "type": "METHOD",
          "id": "<SymbolStore.get>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key2>",
          "metadata": {
            "parameterName": "key"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this[_private]2>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<this[_private].get(key)>",
          "metadata": {
            "callee": "get"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Symbol('private')>",
            "dst": "<'private'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<SymbolStore>",
            "dst": "<SymbolStore[_private]>",
            "type": "CONTAINS"
          },
          {
            "src": "<SymbolStore[_private]>",
            "dst": "<_private>",
            "type": "USES"
          },
          {
            "src": "<SymbolStore>",
            "dst": "<SymbolStore.set>",
            "type": "CONTAINS"
          },
          {
            "src": "<SymbolStore.set>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<SymbolStore.set>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<SymbolStore.set>",
            "dst": "<this[_private].set(key, value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<this[_private].set(key, value)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<this[_private].set(key, value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<SymbolStore>",
            "dst": "<SymbolStore.get>",
            "type": "CONTAINS"
          },
          {
            "src": "<SymbolStore.get>",
            "dst": "<key2>",
            "type": "CONTAINS"
          },
          {
            "src": "<SymbolStore.get>",
            "dst": "<this[_private].get(key)>",
            "type": "RETURNS"
          },
          {
            "src": "<this[_private].get(key)>",
            "dst": "<key2>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<_private>",
            "dst": "<Symbol('private')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<SymbolStore[_private]>",
            "dst": "<new Map()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this[_private]>",
            "dst": "<_private>",
            "type": "READS_FROM"
          },
          {
            "src": "<this[_private].set(key, value)>",
            "dst": "<this[_private]>",
            "type": "CALLS_ON"
          },
          {
            "src": "<this[_private]2>",
            "dst": "<_private>",
            "type": "READS_FROM"
          },
          {
            "src": "<this[_private].get(key)>",
            "dst": "<this[_private]2>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-observer-pattern",
      "category": "async-generators",
      "code": "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<observer>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "LOOP",
          "id": "<while-true>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(value)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<results.push>",
          "metadata": {
            "property": "push"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return results>",
          "metadata": {
            "operator": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<observer>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<observer>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<observer>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<while-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while-true>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<while-true>",
            "dst": "<results.push(value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finally-block>",
            "dst": "<return results>",
            "type": "CONTAINS"
          },
          {
            "src": "<observer>",
            "dst": "<return results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<value>",
            "dst": "<yield>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(value)>",
            "dst": "<results.push>",
            "type": "CALLS"
          },
          {
            "src": "<results.push>",
            "dst": "<results>",
            "type": "READS_FROM"
          },
          {
            "src": "<return results>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::callback-promisify-usage",
      "category": "callbacks",
      "code": "const readFileAsync = promisify(readFileCallback);\n\n// --- Array callback patterns ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<readFileAsync>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<promisify(readFileCallback)>",
          "metadata": {
            "callee": "promisify"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<readFileAsync>",
            "type": "DECLARES"
          },
          {
            "src": "<promisify(readFileCallback)>",
            "dst": "<readFileCallback>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<readFileAsync>",
            "dst": "<promisify(readFileCallback)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<promisify(readFileCallback)>",
            "dst": "<promisify>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::callback-higher-order",
      "category": "callbacks",
      "code": "function retry(fn, attempts, callback) {\n  fn(function (err, result) {\n    if (err && attempts > 1) {\n      retry(fn, attempts - 1, callback);\n    } else {\n      callback(err, result);\n    }\n  });\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<retry>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "PARAMETER",
          "id": "<attempts>"
        },
        {
          "type": "PARAMETER",
          "id": "<callback>"
        },
        {
          "type": "FUNCTION",
          "id": "<anonymous-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "PARAMETER",
          "id": "<result>"
        },
        {
          "type": "BRANCH",
          "id": "<if-err-attempts>"
        },
        {
          "type": "EXPRESSION",
          "id": "<err && attempts > 1>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<attempts > 1>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<retry-recursive>",
          "metadata": {
            "callee": "retry",
            "recursive": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<attempts - 1>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "CALL",
          "id": "<callback-call>",
          "metadata": {
            "callee": "callback"
          }
        },
        {
          "type": "CALL",
          "id": "<fn-call>",
          "metadata": {
            "callee": "fn"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<retry>",
            "dst": "<fn>",
            "type": "CONTAINS"
          },
          {
            "src": "<retry>",
            "dst": "<attempts>",
            "type": "CONTAINS"
          },
          {
            "src": "<retry>",
            "dst": "<callback>",
            "type": "CONTAINS"
          },
          {
            "src": "<retry>",
            "dst": "<fn-call>",
            "type": "CONTAINS"
          },
          {
            "src": "<fn-call>",
            "dst": "<anonymous-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<anonymous-callback>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-callback>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-callback>",
            "dst": "<if-err-attempts>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-err-attempts>",
            "dst": "<err && attempts > 1>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-err-attempts>",
            "dst": "<retry-recursive>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<retry-recursive>",
            "dst": "<fn>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<retry-recursive>",
            "dst": "<attempts - 1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<retry-recursive>",
            "dst": "<callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<callback-call>",
            "dst": "<err>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<callback-call>",
            "dst": "<result>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-err-attempts>",
            "dst": "<callback-call>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<fn-call>",
            "dst": "<fn>",
            "type": "CALLS"
          },
          {
            "src": "<err && attempts > 1>",
            "dst": "<err>",
            "type": "READS_FROM"
          },
          {
            "src": "<err && attempts > 1>",
            "dst": "<attempts > 1>",
            "type": "READS_FROM"
          },
          {
            "src": "<attempts > 1>",
            "dst": "<attempts>",
            "type": "READS_FROM"
          },
          {
            "src": "<attempts > 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<retry-recursive>",
            "dst": "<retry>",
            "type": "CALLS"
          },
          {
            "src": "<attempts - 1>",
            "dst": "<attempts>",
            "type": "READS_FROM"
          },
          {
            "src": "<attempts - 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<callback-call>",
            "dst": "<callback>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::sparse-array",
      "category": "builtins",
      "code": "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false  hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sparseArrayOps>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<sparse>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<sparse-array>",
          "metadata": {
            "value": "[1, , 3, , 5]",
            "literalType": "array",
            "sparse": true,
            "holes": [
              1,
              3
            ]
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<length>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<sparse.length>",
          "metadata": {
            "property": "length"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasIndex1>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<1 in sparse>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1-key>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<mapped>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<sparse.map(x => x * 2)>",
          "metadata": {
            "method": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<map-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<sparseArrayOps>",
            "dst": "<sparse>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<length>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<hasIndex1>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<mapped>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparse-array>",
            "dst": "<1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<sparse-array>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<sparse-array>",
            "dst": "<5>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<sparse.map(x => x * 2)>",
            "dst": "<map-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<map-callback>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<map-callback>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<length>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<hasIndex1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<mapped>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<sparse>",
            "dst": "<sparse-array>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<length>",
            "dst": "<sparse.length>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasIndex1>",
            "dst": "<1 in sparse>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<mapped>",
            "dst": "<sparse.map(x => x * 2)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<sparse.length>",
            "dst": "<sparse>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 in sparse>",
            "dst": "<1-key>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 in sparse>",
            "dst": "<sparse>",
            "type": "READS_FROM"
          },
          {
            "src": "<sparse.map(x => x * 2)>",
            "dst": "<sparse>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::callback-microtask",
      "category": "callbacks",
      "code": "function withMicrotask(fn) {\n  queueMicrotask(() => {\n    fn();\n  });\n}\n\n// --- Promisify ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withMicrotask>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "CALL",
          "id": "<queueMicrotask(...)>",
          "metadata": {
            "callee": "queueMicrotask"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<microtask-callback>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "CALL",
          "id": "<fn()>",
          "metadata": {
            "callee": "fn"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withMicrotask>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<withMicrotask>",
            "dst": "<queueMicrotask(...)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<queueMicrotask(...)>",
            "dst": "<microtask-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<microtask-callback>",
            "dst": "<fn()>",
            "type": "HAS_BODY"
          }
        ],
        "postFile": [
          {
            "src": "<microtask-callback>",
            "dst": "<fn>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<queueMicrotask(...)>",
            "dst": "<queueMicrotask>",
            "type": "CALLS"
          },
          {
            "src": "<fn()>",
            "dst": "<fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::require-simple",
      "category": "cjs-patterns",
      "code": "const fs = require('fs');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<fs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<require('fs')>",
          "metadata": {
            "callee": "require"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fs'>",
          "metadata": {
            "value": "fs",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<fs-module>",
          "metadata": {
            "name": "fs",
            "type": "builtin"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<require('fs')>",
            "dst": "<'fs'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<fs>",
            "dst": "<require('fs')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<require('fs')>",
            "dst": "<fs-module>",
            "type": "IMPORTS"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::require-destructured",
      "category": "cjs-patterns",
      "code": "const { readFile, writeFile } = require('fs/promises');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<readFile>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<writeFile>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "CALL",
          "id": "<require('fs/promises')>",
          "metadata": {
            "callee": "require"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fs/promises'>",
          "metadata": {
            "value": "fs/promises",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<fs/promises>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<readFile>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<writeFile>",
            "type": "DECLARES"
          },
          {
            "src": "<require('fs/promises')>",
            "dst": "<'fs/promises'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<readFile>",
            "dst": "<require('fs/promises')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<writeFile>",
            "dst": "<require('fs/promises')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<require('fs/promises')>",
            "dst": "<require>",
            "type": "CALLS"
          },
          {
            "src": "<require('fs/promises')>",
            "dst": "<fs/promises>",
            "type": "IMPORTS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "callbacks::callback-thisarg-filter",
      "category": "callbacks",
      "code": "class Validator {\n  threshold = 10;\n  filter(items) {\n    return items.filter(function(item) {\n      return item > this.threshold;\n    }, this);\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Validator>"
        },
        {
          "type": "PROPERTY",
          "id": "<Validator.threshold>",
          "metadata": {
            "value": 10
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Validator.filter>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "CALL",
          "id": "<items.filter(...)>",
          "metadata": {
            "callee": "filter"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<filter-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "EXPRESSION",
          "id": "<item > this.threshold>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.threshold>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Validator>",
            "dst": "<Validator.threshold>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validator>",
            "dst": "<Validator.filter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validator.filter>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validator.filter>",
            "dst": "<items.filter(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<items.filter(...)>",
            "dst": "<filter-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<items.filter(...)>",
            "dst": "<Validator>",
            "type": "BINDS_THIS_TO"
          },
          {
            "src": "<filter-callback>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<filter-callback>",
            "dst": "<item > this.threshold>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Validator.threshold>",
            "dst": "<10>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<items.filter(...)>",
            "dst": "<items>",
            "type": "CALLS_ON"
          },
          {
            "src": "<item > this.threshold>",
            "dst": "<item>",
            "type": "READS_FROM"
          },
          {
            "src": "<item > this.threshold>",
            "dst": "<this.threshold>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.threshold>",
            "dst": "<Validator.threshold>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::cjs-class-decl",
      "category": "cjs-patterns",
      "code": "class CjsClass {\n  method() {\n    return true;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<CjsClass>"
        },
        {
          "type": "METHOD",
          "id": "<CjsClass.method>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<CjsClass>",
            "type": "DECLARES"
          },
          {
            "src": "<CjsClass>",
            "dst": "<CjsClass.method>",
            "type": "CONTAINS"
          },
          {
            "src": "<CjsClass.method>",
            "dst": "<true>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "callbacks::callback-thisarg-map",
      "category": "callbacks",
      "code": "class Processor {\n  multiplier = 3;\n  process(items) {\n    return items.map(function(item) {\n      return item * this.multiplier; // `this` = Processor instance via thisArg\n    }, this);\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Processor>"
        },
        {
          "type": "PROPERTY",
          "id": "<Processor.multiplier>",
          "metadata": {
            "value": 3
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Processor.process>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "CALL",
          "id": "<items.map(...)>",
          "metadata": {
            "callee": "map",
            "hasThisArg": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<map-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "EXPRESSION",
          "id": "<item * this.multiplier>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.multiplier>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Processor>",
            "dst": "<Processor.multiplier>",
            "type": "CONTAINS"
          },
          {
            "src": "<Processor>",
            "dst": "<Processor.process>",
            "type": "CONTAINS"
          },
          {
            "src": "<Processor.process>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<Processor.process>",
            "dst": "<items.map(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<map-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<Processor>",
            "type": "BINDS_THIS_TO"
          },
          {
            "src": "<map-callback>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<map-callback>",
            "dst": "<item * this.multiplier>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Processor.multiplier>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<items.map(...)>",
            "dst": "<items>",
            "type": "CALLS_ON"
          },
          {
            "src": "<item * this.multiplier>",
            "dst": "<item>",
            "type": "READS_FROM"
          },
          {
            "src": "<item * this.multiplier>",
            "dst": "<this.multiplier>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.multiplier>",
            "dst": "<Processor.multiplier>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::cjs-function-decl",
      "category": "cjs-patterns",
      "code": "function cjsFunction() {\n  return 'cjs';\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<cjsFunction>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'cjs'>",
          "metadata": {
            "value": "cjs",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<cjsFunction>",
            "type": "DECLARES"
          },
          {
            "src": "<cjsFunction>",
            "dst": "<'cjs'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::cjs-const-decl",
      "category": "cjs-patterns",
      "code": "const CJS_CONSTANT = 42;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<CJS_CONSTANT>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<CJS_CONSTANT>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<CJS_CONSTANT>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "callbacks::callback-continuation-passing",
      "category": "callbacks",
      "code": "function waterfall(tasks, callback) {\n  let index = 0;\n  function next(err, result) {\n    if (err || index >= tasks.length) return callback(err, result);\n    tasks[index++](result, next);\n  }\n  next(null, null);\n}\n\n// --- Event emitter pattern ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<waterfall>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<tasks>"
        },
        {
          "type": "PARAMETER",
          "id": "<callback>"
        },
        {
          "type": "VARIABLE",
          "id": "<index>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<next>",
          "metadata": {
            "async": false,
            "generator": false,
            "nested": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "PARAMETER",
          "id": "<result>"
        },
        {
          "type": "EXPRESSION",
          "id": "<err || index >= tasks.length>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<index >= tasks.length>",
          "metadata": {
            "operator": ">="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<tasks.length>",
          "metadata": {
            "objectName": "tasks"
          }
        },
        {
          "type": "CALL",
          "id": "<callback(err, result)>",
          "metadata": {
            "callee": "callback"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<tasks[index++]>",
          "metadata": {
            "operator": "[]"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<index++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "CALL",
          "id": "<tasks[index++](result, next)>",
          "metadata": {
            "callee": "tasks[index++]"
          }
        },
        {
          "type": "CALL",
          "id": "<next(null, null)>",
          "metadata": {
            "callee": "next"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null1>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null2>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<waterfall>",
            "dst": "<tasks>",
            "type": "CONTAINS"
          },
          {
            "src": "<waterfall>",
            "dst": "<callback>",
            "type": "CONTAINS"
          },
          {
            "src": "<waterfall>",
            "dst": "<index>",
            "type": "DECLARES"
          },
          {
            "src": "<waterfall>",
            "dst": "<next>",
            "type": "DECLARES"
          },
          {
            "src": "<next>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<next>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<callback(err, result)>",
            "dst": "<err>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<callback(err, result)>",
            "dst": "<result>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tasks[index++](result, next)>",
            "dst": "<result>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tasks[index++](result, next)>",
            "dst": "<next>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<next(null, null)>",
            "dst": "<null1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<next(null, null)>",
            "dst": "<null2>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<index>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<index++>",
            "dst": "<index>",
            "type": "MODIFIES"
          },
          {
            "src": "<next>",
            "dst": "<callback>",
            "type": "CAPTURES"
          },
          {
            "src": "<next>",
            "dst": "<tasks>",
            "type": "CAPTURES"
          },
          {
            "src": "<next>",
            "dst": "<index>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<err || index >= tasks.length>",
            "dst": "<err>",
            "type": "READS_FROM"
          },
          {
            "src": "<err || index >= tasks.length>",
            "dst": "<index >= tasks.length>",
            "type": "READS_FROM"
          },
          {
            "src": "<index >= tasks.length>",
            "dst": "<index>",
            "type": "READS_FROM"
          },
          {
            "src": "<index >= tasks.length>",
            "dst": "<tasks.length>",
            "type": "READS_FROM"
          },
          {
            "src": "<tasks.length>",
            "dst": "<tasks>",
            "type": "READS_FROM"
          },
          {
            "src": "<callback(err, result)>",
            "dst": "<callback>",
            "type": "CALLS"
          },
          {
            "src": "<tasks[index++]>",
            "dst": "<tasks>",
            "type": "READS_FROM"
          },
          {
            "src": "<tasks[index++]>",
            "dst": "<index++>",
            "type": "READS_FROM"
          },
          {
            "src": "<tasks[index++](result, next)>",
            "dst": "<tasks[index++]>",
            "type": "CALLS"
          },
          {
            "src": "<next(null, null)>",
            "dst": "<next>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::generator-finally-cleanup",
      "category": "async-generators",
      "code": "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<resourceGenerator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resource>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ acquired: true }>",
          "metadata": {
            "value": "{ acquired: true }",
            "literalType": "object"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<yield resource>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ transformed: true }>",
          "metadata": {
            "value": "{ transformed: true }",
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield { transformed: true }>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<resource.acquired>",
          "metadata": {
            "objectName": "resource",
            "propertyName": "acquired"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<resourceGenerator>",
            "dst": "<resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<resourceGenerator>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<resourceGenerator>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<yield resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<yield { transformed: true }>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<resource>",
            "dst": "<{ acquired: true }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<finally-block>",
            "dst": "<resource.acquired>",
            "type": "WRITES_TO"
          },
          {
            "src": "<resource.acquired>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<yield resource>",
            "dst": "<resource>",
            "type": "READS_FROM"
          },
          {
            "src": "<yield { transformed: true }>",
            "dst": "<{ transformed: true }>",
            "type": "READS_FROM"
          },
          {
            "src": "<resource.acquired>",
            "dst": "<resource>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::callback-thisarg-foreach",
      "category": "callbacks",
      "code": "function forEachWithContext(items, logger) {\n  items.forEach(function(item) {\n    this.log(item); // `this` = logger\n  }, logger);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forEachWithContext>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "PARAMETER",
          "id": "<logger>"
        },
        {
          "type": "CALL",
          "id": "<items.forEach>",
          "metadata": {
            "callee": "forEach",
            "method": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<forEach-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "CALL",
          "id": "<this.log(item)>",
          "metadata": {
            "callee": "log",
            "method": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.log>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forEachWithContext>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<forEachWithContext>",
            "dst": "<logger>",
            "type": "CONTAINS"
          },
          {
            "src": "<forEachWithContext>",
            "dst": "<items.forEach>",
            "type": "CONTAINS"
          },
          {
            "src": "<items.forEach>",
            "dst": "<forEach-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<items.forEach>",
            "dst": "<logger>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forEach-callback>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<forEach-callback>",
            "dst": "<this.log(item)>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.log(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<this.log>",
            "dst": "<logger>",
            "type": "BINDS_THIS_TO"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<items.forEach>",
            "dst": "<items>",
            "type": "CALLS_ON"
          },
          {
            "src": "<this.log(item)>",
            "dst": "<this.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::require-path",
      "category": "cjs-patterns",
      "code": "const path = require('path');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<path>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<require('path')>",
          "metadata": {
            "callee": "require"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'path'>",
          "metadata": {
            "value": "path",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<path-module>",
          "metadata": {
            "name": "path",
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<path>",
            "type": "DECLARES"
          },
          {
            "src": "<require('path')>",
            "dst": "<'path'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<path>",
            "dst": "<require('path')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<require('path')>",
            "dst": "<require>",
            "type": "CALLS"
          },
          {
            "src": "<require('path')>",
            "dst": "<path-module>",
            "type": "IMPORTS"
          },
          {
            "src": "<module>",
            "dst": "<path-module>",
            "type": "IMPORTS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::cjs-exports-named-1",
      "category": "cjs-patterns",
      "code": "exports.CjsClass = CjsClass;",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<exports.CjsClass>",
          "metadata": {
            "exportType": "named",
            "exportName": "CjsClass"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<exports.CjsClass:access>",
          "metadata": {
            "objectName": "exports",
            "propertyName": "CjsClass"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<exports.CjsClass>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<exports.CjsClass>",
            "dst": "<exports.CjsClass:access>",
            "type": "WRITES_TO"
          },
          {
            "src": "<exports.CjsClass:access>",
            "dst": "<CjsClass>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<exports.CjsClass>",
            "dst": "<CjsClass>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::cjs-exports-named-2",
      "category": "cjs-patterns",
      "code": "exports.CJS_CONSTANT = CJS_CONSTANT;",
      "expectedNodes": [
        {
          "type": "PROPERTY_ACCESS",
          "id": "<exports.CJS_CONSTANT>",
          "metadata": {
            "objectName": "exports",
            "propertyName": "CJS_CONSTANT"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<CJS_CONSTANT>",
          "metadata": {
            "referenced": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<exports.CJS_CONSTANT>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<exports.CJS_CONSTANT>",
            "dst": "<CJS_CONSTANT>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<module>",
            "dst": "<CJS_CONSTANT>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::cjs-exports-named",
      "category": "cjs-patterns",
      "code": "exports.cjsFunction = cjsFunction;",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<exports.cjsFunction>",
          "metadata": {
            "exportType": "named",
            "exportName": "cjsFunction"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<exports.cjsFunction:access>",
          "metadata": {
            "objectName": "exports",
            "propertyName": "cjsFunction"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<exports.cjsFunction>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<exports.cjsFunction>",
            "dst": "<exports.cjsFunction:access>",
            "type": "WRITES_TO"
          },
          {
            "src": "<exports.cjsFunction:access>",
            "dst": "<cjsFunction>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<exports.cjsFunction>",
            "dst": "<cjsFunction>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "callbacks::callback-promisify",
      "category": "callbacks",
      "code": "function promisify(fn) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args, function (err, result) {\n        if (err) reject(err);\n        else resolve(result);\n      });\n    });\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<promisify>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "FUNCTION",
          "id": "<promisify:wrapper>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<...args>",
          "metadata": {
            "rest": true
          }
        },
        {
          "type": "CALL",
          "id": "<new Promise>",
          "metadata": {
            "constructor": true,
            "callee": "Promise"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<promisify:executor>",
          "metadata": {
            "anonymous": true,
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resolve>"
        },
        {
          "type": "PARAMETER",
          "id": "<reject>"
        },
        {
          "type": "CALL",
          "id": "<fn(...args, callback)>",
          "metadata": {
            "callee": "fn"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<promisify:callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "PARAMETER",
          "id": "<result>"
        },
        {
          "type": "BRANCH",
          "id": "<if-err>",
          "metadata": {
            "condition": "err"
          }
        },
        {
          "type": "CALL",
          "id": "<reject(err)>",
          "metadata": {
            "callee": "reject"
          }
        },
        {
          "type": "CALL",
          "id": "<resolve(result)>",
          "metadata": {
            "callee": "resolve"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<promisify>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<promisify>",
            "dst": "<promisify:wrapper>",
            "type": "RETURNS"
          },
          {
            "src": "<promisify:wrapper>",
            "dst": "<...args>",
            "type": "HAS_BODY"
          },
          {
            "src": "<promisify:wrapper>",
            "dst": "<new Promise>",
            "type": "RETURNS"
          },
          {
            "src": "<new Promise>",
            "dst": "<promisify:executor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<promisify:executor>",
            "dst": "<resolve>",
            "type": "HAS_BODY"
          },
          {
            "src": "<promisify:executor>",
            "dst": "<reject>",
            "type": "HAS_BODY"
          },
          {
            "src": "<promisify:executor>",
            "dst": "<fn(...args, callback)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fn(...args, callback)>",
            "dst": "<...args>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fn(...args, callback)>",
            "dst": "<promisify:callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<promisify:callback>",
            "dst": "<err>",
            "type": "HAS_BODY"
          },
          {
            "src": "<promisify:callback>",
            "dst": "<result>",
            "type": "HAS_BODY"
          },
          {
            "src": "<promisify:callback>",
            "dst": "<if-err>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-err>",
            "dst": "<reject(err)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<reject(err)>",
            "dst": "<err>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<resolve(result)>",
            "dst": "<result>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-err>",
            "dst": "<resolve(result)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<fn(...args, callback)>",
            "dst": "<fn>",
            "type": "CALLS"
          },
          {
            "src": "<reject(err)>",
            "dst": "<reject>",
            "type": "CALLS"
          },
          {
            "src": "<resolve(result)>",
            "dst": "<resolve>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::require-conditional",
      "category": "cjs-patterns",
      "code": "let optionalDep;\ntry {\n  optionalDep = require('optional-package');\n} catch (e) {\n  optionalDep = null;\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<optionalDep>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<require('optional-package')>",
          "metadata": {
            "callee": "require"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'optional-package'>",
          "metadata": {
            "value": "optional-package",
            "literalType": "string"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<optionalDep>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<require('optional-package')>",
            "type": "CONTAINS"
          },
          {
            "src": "<require('optional-package')>",
            "dst": "<'optional-package'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<null>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<optionalDep>",
            "dst": "<require('optional-package')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<optionalDep>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "async-generators::generator-break-triggers-finally",
      "category": "async-generators",
      "code": "function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return()  finally runs\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<consumeWithBreak>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<gen>"
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-transformed>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<item.transformed>",
          "metadata": {
            "property": "transformed"
          }
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<break>",
          "metadata": {
            "type": "break",
            "description": "break statement that exits loop"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<consumeWithBreak>",
            "dst": "<gen>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeWithBreak>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<gen>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<if-transformed>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-transformed>",
            "dst": "<item.transformed>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-transformed>",
            "dst": "<break>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<item.transformed>",
            "dst": "<item>",
            "type": "READS_FROM"
          },
          {
            "src": "<break>",
            "dst": "<for-of>",
            "type": "FLOWS_INTO"
          }
        ]
      }
    },
    {
      "constructId": "callbacks::export-named-list",
      "category": "callbacks",
      "code": "export {\n  readFileCallback,\n  processFile,\n  callbackHell,\n  getUser,\n  getOrders,\n  getOrderDetails,\n  retry,\n  waterfall,\n  EventEmitter,\n  delayedExecution,\n  pollUntil,\n  withMicrotask,\n  promisify,\n  readFileAsync,\n  arrayCallbackPatterns,\n  Processor,\n  Validator,\n  forEachWithContext,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<readFileCallback>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<processFile>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<callbackHell>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getUser>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getOrders>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getOrderDetails>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<retry>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<waterfall>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<EventEmitter>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<delayedExecution>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<pollUntil>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<withMicrotask>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<promisify>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<readFileAsync>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arrayCallbackPatterns>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Processor>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Validator>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<forEachWithContext>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<readFileCallback>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<processFile>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<callbackHell>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<getUser>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<getOrders>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<getOrderDetails>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<retry>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<waterfall>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<EventEmitter>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<delayedExecution>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<pollUntil>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<withMicrotask>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<promisify>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<readFileAsync>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrayCallbackPatterns>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Processor>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Validator>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<forEachWithContext>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "cjs-patterns::cjs-dynamic-require",
      "category": "cjs-patterns",
      "code": "function loadImplementation(useNative) {\n  const impl = useNative ? require('path') : require('fs');\n  return impl;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<loadImplementation>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<useNative>"
        },
        {
          "type": "VARIABLE",
          "id": "<impl>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "CALL",
          "id": "<require('path')>",
          "metadata": {
            "callee": "require"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'path'>",
          "metadata": {
            "value": "path",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<require('fs')>",
          "metadata": {
            "callee": "require"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fs'>",
          "metadata": {
            "value": "fs",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<require>",
          "metadata": {
            "source": "commonjs"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<loadImplementation>",
            "dst": "<useNative>",
            "type": "CONTAINS"
          },
          {
            "src": "<loadImplementation>",
            "dst": "<impl>",
            "type": "CONTAINS"
          },
          {
            "src": "<ternary>",
            "dst": "<useNative>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary>",
            "dst": "<require('path')>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<require('path')>",
            "dst": "<'path'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<require('fs')>",
            "dst": "<'fs'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<loadImplementation>",
            "dst": "<impl>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<impl>",
            "dst": "<ternary>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ternary>",
            "dst": "<require('fs')>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<require('path')>",
            "dst": "<require>",
            "type": "CALLS"
          },
          {
            "src": "<require('fs')>",
            "dst": "<require>",
            "type": "CALLS"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::with-statement",
      "category": "cjs-patterns",
      "code": "function withStatement(obj) {\n  with (obj) {\n    return toString();\n  }\n}\n\nexports.withStatement = withStatement;",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withStatement>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "SCOPE",
          "id": "<with-scope>",
          "metadata": {
            "type": "with",
            "object": "obj"
          }
        },
        {
          "type": "CALL",
          "id": "<toString()>",
          "metadata": {
            "callee": "toString",
            "arguments": []
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<exports.withStatement>",
          "metadata": {
            "objectName": "exports",
            "propertyName": "withStatement"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<withStatement>",
            "type": "DECLARES"
          },
          {
            "src": "<withStatement>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<withStatement>",
            "dst": "<with-scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<with-scope>",
            "dst": "<obj>",
            "type": "EXTENDS_SCOPE_WITH"
          },
          {
            "src": "<with-scope>",
            "dst": "<toString()>",
            "type": "CONTAINS"
          },
          {
            "src": "<withStatement>",
            "dst": "<toString()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<exports.withStatement>",
            "dst": "<withStatement>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<MODULE>",
            "dst": "<exports.withStatement>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<toString()>",
            "dst": "<obj>",
            "type": "RESOLVES_TO"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "cjs-patterns::block-function-decl-annex-b",
      "category": "cjs-patterns",
      "code": "// Sloppy mode (CJS)  Annex B behavior: function leaks out of block\nfunction annexBDemo() {\n  console.log(typeof leaked); // \"undefined\"  var-hoisted but not initialized\n\n  if (true) {\n    function leaked() { return 'I escaped!'; }\n  }\n\n  return leaked(); // works in sloppy mode  Annex B hoisting\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<annexBDemo>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(typeof leaked)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof leaked>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-true>",
          "metadata": {
            "condition": "true"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<leaked>",
          "metadata": {
            "async": false,
            "generator": false,
            "blockScoped": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'I escaped!'>",
          "metadata": {
            "value": "I escaped!",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<leaked()>",
          "metadata": {
            "callee": "leaked"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<annexBDemo>",
            "dst": "<console.log(typeof leaked)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(typeof leaked)>",
            "dst": "<typeof leaked>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<annexBDemo>",
            "dst": "<if-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-true>",
            "dst": "<leaked>",
            "type": "CONTAINS"
          },
          {
            "src": "<leaked>",
            "dst": "<'I escaped!'>",
            "type": "RETURNS"
          },
          {
            "src": "<annexBDemo>",
            "dst": "<leaked()>",
            "type": "CONTAINS"
          },
          {
            "src": "<annexBDemo>",
            "dst": "<leaked()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<typeof leaked>",
            "dst": "<leaked>",
            "type": "READS_FROM"
          },
          {
            "src": "<leaked()>",
            "dst": "<leaked>",
            "type": "CALLS"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "async-generators::generator-finally-yield-trap",
      "category": "async-generators",
      "code": "function* trickyFinally() {\n  try {\n    yield 1;\n  } finally {\n    yield 2; // return() pauses HERE, not at the return point\n  }\n}\n// const g = trickyFinally(); g.next(); g.return('end');\n//  { value: 2, done: false }  NOT 'end'!\n// g.next()  { value: 'end', done: true }\n\n// --- Async iterator cancellation ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<trickyFinally>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 1>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 2>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<trickyFinally>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<trickyFinally>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<yield 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<finally-block>",
            "dst": "<yield 2>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield 1>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<yield 2>",
            "dst": "<2>",
            "type": "YIELDS"
          },
          {
            "src": "<try-block>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "cjs-patterns::with-nested",
      "category": "cjs-patterns",
      "code": "function withNested(defaults, overrides) {\n  with (defaults) {\n    with (overrides) {\n      return color; // overrides.color ?? defaults.color ?? outer scope\n    }\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withNested>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<defaults>"
        },
        {
          "type": "PARAMETER",
          "id": "<overrides>"
        },
        {
          "type": "SCOPE",
          "id": "<with-defaults-scope>",
          "metadata": {
            "scopeType": "with"
          }
        },
        {
          "type": "SCOPE",
          "id": "<with-overrides-scope>",
          "metadata": {
            "scopeType": "with"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<color>",
          "metadata": {
            "unresolved": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withNested>",
            "dst": "<defaults>",
            "type": "CONTAINS"
          },
          {
            "src": "<withNested>",
            "dst": "<overrides>",
            "type": "CONTAINS"
          },
          {
            "src": "<with-defaults-scope>",
            "dst": "<defaults>",
            "type": "EXTENDS_SCOPE_WITH"
          },
          {
            "src": "<with-overrides-scope>",
            "dst": "<overrides>",
            "type": "EXTENDS_SCOPE_WITH"
          },
          {
            "src": "<with-overrides-scope>",
            "dst": "<with-defaults-scope>",
            "type": "CONTAINS"
          },
          {
            "src": "<withNested>",
            "dst": "<color>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<color>",
            "dst": "<with-overrides-scope>",
            "type": "RESOLVES_TO"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "classes::class-basic",
      "category": "classes",
      "code": "class Animal {\n  constructor(name, sound) {\n    this.name = name;\n    this.sound = sound;\n  }\n\n  speak() {\n    return `${this.name} says ${this.sound}`;\n  }\n\n  toString() {\n    return `Animal(${this.name})`;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Animal>"
        },
        {
          "type": "METHOD",
          "id": "<Animal.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PARAMETER",
          "id": "<sound>"
        },
        {
          "type": "PROPERTY",
          "id": "<Animal.name>",
          "metadata": {
            "instanceProperty": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Animal.sound>",
          "metadata": {
            "instanceProperty": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Animal.speak>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal-speak>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "METHOD",
          "id": "<Animal.toString>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal-toString>",
          "metadata": {
            "type": "template-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Animal>",
            "dst": "<Animal.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Animal>",
            "dst": "<Animal.speak>",
            "type": "CONTAINS"
          },
          {
            "src": "<Animal>",
            "dst": "<Animal.toString>",
            "type": "CONTAINS"
          },
          {
            "src": "<Animal>",
            "dst": "<Animal.name>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Animal>",
            "dst": "<Animal.sound>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Animal.constructor>",
            "dst": "<name>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Animal.constructor>",
            "dst": "<sound>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Animal.speak>",
            "dst": "<template-literal-speak>",
            "type": "RETURNS"
          },
          {
            "src": "<Animal.toString>",
            "dst": "<template-literal-toString>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Animal.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Animal.sound>",
            "dst": "<sound>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<template-literal-speak>",
            "dst": "<Animal.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal-speak>",
            "dst": "<Animal.sound>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal-toString>",
            "dst": "<Animal.name>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::cjs-conditional-exports",
      "category": "cjs-patterns",
      "code": "if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n  exports._testHelper = function () { return 'test-only'; };\n  exports._internal = cjsFunction;\n}",
      "expectedNodes": [
        {
          "type": "BRANCH",
          "id": "<conditional-exports>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof-check>",
          "metadata": {
            "operator": "!=="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<env-check>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<condition>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<exports._testHelper>",
          "metadata": {
            "objectName": "exports",
            "propertyName": "_testHelper"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<testHelper:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'test-only'>",
          "metadata": {
            "value": "test-only",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<exports._internal>",
          "metadata": {
            "objectName": "exports",
            "propertyName": "_internal"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cjsFunction>"
        },
        {
          "type": "EXTERNAL",
          "id": "<process>",
          "metadata": {
            "source": "Node.js runtime"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<process.env.NODE_ENV>",
          "metadata": {
            "objectName": "process.env",
            "propertyName": "NODE_ENV"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<conditional-exports>",
            "dst": "<condition>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<conditional-exports>",
            "dst": "<exports._testHelper>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<conditional-exports>",
            "dst": "<exports._internal>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<testHelper:fn>",
            "dst": "<'test-only'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<exports._testHelper>",
            "dst": "<testHelper:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<exports._internal>",
            "dst": "<cjsFunction>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<condition>",
            "dst": "<typeof-check>",
            "type": "READS_FROM"
          },
          {
            "src": "<condition>",
            "dst": "<env-check>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof-check>",
            "dst": "<process>",
            "type": "READS_FROM"
          },
          {
            "src": "<env-check>",
            "dst": "<process.env.NODE_ENV>",
            "type": "READS_FROM"
          },
          {
            "src": "<process.env.NODE_ENV>",
            "dst": "<process>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "classes::class-expr-anonymous",
      "category": "classes",
      "code": "const AnonymousClassExpr = class {\n  run() {\n    return 'running';\n  }\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<AnonymousClassExpr>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CLASS",
          "id": "<AnonymousClassExpr:class>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "METHOD",
          "id": "<AnonymousClassExpr:class.run>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'running'>",
          "metadata": {
            "value": "running",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<AnonymousClassExpr>",
            "type": "DECLARES"
          },
          {
            "src": "<AnonymousClassExpr:class>",
            "dst": "<AnonymousClassExpr:class.run>",
            "type": "CONTAINS"
          },
          {
            "src": "<AnonymousClassExpr:class.run>",
            "dst": "<'running'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<AnonymousClassExpr>",
            "dst": "<AnonymousClassExpr:class>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "classes::class-static-members",
      "category": "classes",
      "code": "class MathUtils {\n  static PI = 3.14159;\n\n  static add(a, b) {\n    return a + b;\n  }\n\n  static #internalHelper() {\n    return 42;\n  }\n\n  static create() {\n    return new MathUtils();\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<MathUtils>"
        },
        {
          "type": "PROPERTY",
          "id": "<MathUtils.PI>",
          "metadata": {
            "static": true,
            "value": 3.14159
          }
        },
        {
          "type": "LITERAL",
          "id": "<3.14159>",
          "metadata": {
            "value": 3.14159,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<MathUtils.add>",
          "metadata": {
            "static": true,
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "METHOD",
          "id": "<MathUtils.#internalHelper>",
          "metadata": {
            "static": true,
            "private": true,
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<MathUtils.create>",
          "metadata": {
            "static": true,
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<new MathUtils()>",
          "metadata": {
            "operator": "new"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MathUtils>",
            "dst": "<MathUtils.PI>",
            "type": "CONTAINS"
          },
          {
            "src": "<MathUtils>",
            "dst": "<MathUtils.add>",
            "type": "CONTAINS"
          },
          {
            "src": "<MathUtils.add>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<MathUtils.add>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<MathUtils.add>",
            "dst": "<a + b>",
            "type": "RETURNS"
          },
          {
            "src": "<MathUtils>",
            "dst": "<MathUtils.#internalHelper>",
            "type": "CONTAINS"
          },
          {
            "src": "<MathUtils.#internalHelper>",
            "dst": "<42>",
            "type": "RETURNS"
          },
          {
            "src": "<MathUtils>",
            "dst": "<MathUtils.create>",
            "type": "CONTAINS"
          },
          {
            "src": "<MathUtils.create>",
            "dst": "<new MathUtils()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<MathUtils.PI>",
            "dst": "<3.14159>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a + b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<new MathUtils()>",
            "dst": "<MathUtils>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-expr-named",
      "category": "classes",
      "code": "const NamedClassExpr = class InternalName {\n  constructor(value) {\n    this.value = value;\n  }\n\n  getValue() {\n    return this.value;\n  }\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<NamedClassExpr>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CLASS",
          "id": "<InternalName>",
          "metadata": {
            "isExpression": true,
            "externalName": "NamedClassExpr"
          }
        },
        {
          "type": "METHOD",
          "id": "<InternalName.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.value>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<InternalName.getValue>",
          "metadata": {
            "kind": "method"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<InternalName>",
            "dst": "<InternalName.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<InternalName>",
            "dst": "<InternalName.getValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<InternalName.constructor>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<InternalName.getValue>",
            "dst": "<this.value>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<NamedClassExpr>",
            "dst": "<InternalName>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.value>",
            "dst": "<value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<InternalName.constructor>",
            "dst": "<this.value>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<InternalName.getValue>",
            "dst": "<this.value>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "cjs-patterns::with-property-fallback",
      "category": "cjs-patterns",
      "code": "const fallbackColor = 'red';\nfunction withPropertyFallback(config) {\n  with (config) {\n    return fallbackColor; // config.fallbackColor ?? outer fallbackColor  ambiguous\n  }\n}\n\nexports.loadImplementation = loadImplementation;\nexports.annexBDemo = annexBDemo;\nexports.withNested = withNested;\nexports.withPropertyFallback = withPropertyFallback;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<fallbackColor>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'red'>",
          "metadata": {
            "value": "red",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<withPropertyFallback>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<config>"
        },
        {
          "type": "SCOPE",
          "id": "<with-scope>",
          "metadata": {
            "type": "with",
            "object": "config"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<fallbackColor-ref>",
          "metadata": {
            "ambiguous": true,
            "name": "fallbackColor"
          }
        },
        {
          "type": "EXPORT",
          "id": "<exports.loadImplementation>"
        },
        {
          "type": "EXPORT",
          "id": "<exports.annexBDemo>"
        },
        {
          "type": "EXPORT",
          "id": "<exports.withNested>"
        },
        {
          "type": "EXPORT",
          "id": "<exports.withPropertyFallback>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withPropertyFallback>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<withPropertyFallback>",
            "dst": "<with-scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<with-scope>",
            "dst": "<config>",
            "type": "EXTENDS_SCOPE_WITH"
          },
          {
            "src": "<with-scope>",
            "dst": "<fallbackColor-ref>",
            "type": "CONTAINS"
          },
          {
            "src": "<withPropertyFallback>",
            "dst": "<fallbackColor-ref>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<fallbackColor>",
            "dst": "<'red'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<exports.loadImplementation>",
            "dst": "<loadImplementation>",
            "type": "EXPORTS"
          },
          {
            "src": "<exports.annexBDemo>",
            "dst": "<annexBDemo>",
            "type": "EXPORTS"
          },
          {
            "src": "<exports.withNested>",
            "dst": "<withNested>",
            "type": "EXPORTS"
          },
          {
            "src": "<exports.withPropertyFallback>",
            "dst": "<withPropertyFallback>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<fallbackColor-ref>",
            "dst": "<fallbackColor>",
            "type": "READS_FROM"
          },
          {
            "src": "<fallbackColor-ref>",
            "dst": "<config>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "classes::class-inline-new",
      "category": "classes",
      "code": "const inlineInstance = new (class {\n  constructor() { this.x = 1; }\n  getX() { return this.x; }\n})();",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<inlineInstance>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CLASS",
          "id": "<anonymous-class>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "METHOD",
          "id": "<anonymous-class.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.x>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<anonymous-class.getX>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<new-anonymous-class>",
          "metadata": {
            "constructor": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<inlineInstance>",
            "type": "DECLARES"
          },
          {
            "src": "<anonymous-class>",
            "dst": "<anonymous-class.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-class>",
            "dst": "<anonymous-class.getX>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-class.getX>",
            "dst": "<this.x>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<inlineInstance>",
            "dst": "<new-anonymous-class>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<anonymous-class.constructor>",
            "dst": "<this.x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.x>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new-anonymous-class>",
            "dst": "<anonymous-class>",
            "type": "CALLS"
          },
          {
            "src": "<anonymous-class.getX>",
            "dst": "<this.x>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-extends-super",
      "category": "classes",
      "code": "class Dog extends Animal {\n  constructor(name) {\n    super(name, 'woof');\n    this.tricks = [];\n  }\n\n  learn(trick) {\n    this.tricks.push(trick);\n  }\n\n  speak() {\n    return `${super.speak()}!`;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Dog>"
        },
        {
          "type": "METHOD",
          "id": "<Dog.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "CALL",
          "id": "<super(name, 'woof')>",
          "metadata": {
            "callee": "super",
            "isSuper": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'woof'>",
          "metadata": {
            "value": "woof",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.tricks>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "METHOD",
          "id": "<Dog.learn>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<trick>"
        },
        {
          "type": "CALL",
          "id": "<this.tricks.push(trick)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "METHOD",
          "id": "<Dog.speak>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`${super.speak()}!`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<super.speak()>",
          "metadata": {
            "callee": "speak",
            "isSuper": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Dog>",
            "dst": "<Dog.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog>",
            "dst": "<Dog.learn>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog>",
            "dst": "<Dog.speak>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog.constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog.constructor>",
            "dst": "<super(name, 'woof')>",
            "type": "CONTAINS"
          },
          {
            "src": "<super(name, 'woof')>",
            "dst": "<name>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<super(name, 'woof')>",
            "dst": "<'woof'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Dog.learn>",
            "dst": "<trick>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog.learn>",
            "dst": "<this.tricks.push(trick)>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.tricks.push(trick)>",
            "dst": "<trick>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Dog.speak>",
            "dst": "<`${super.speak()}!`>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<this.tricks>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Dog>",
            "dst": "<Animal>",
            "type": "EXTENDS"
          },
          {
            "src": "<`${super.speak()}!`>",
            "dst": "<super.speak()>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-static-block",
      "category": "classes",
      "code": "class Config {\n  static defaults;\n\n  static {\n    Config.defaults = {\n      timeout: 5000,\n      retries: 3,\n    };\n  }\n\n  constructor(overrides = {}) {\n    this.settings = { ...Config.defaults, ...overrides };\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Config>"
        },
        {
          "type": "PROPERTY",
          "id": "<Config.defaults>",
          "metadata": {
            "static": true
          }
        },
        {
          "type": "STATIC_BLOCK",
          "id": "<Config:static-block>"
        },
        {
          "type": "LITERAL",
          "id": "<{timeout: 5000, retries: 3}>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5000>",
          "metadata": {
            "value": 5000,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Config.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<overrides>",
          "metadata": {
            "defaultValue": "{}"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.settings>"
        },
        {
          "type": "EXPRESSION",
          "id": "<{...Config.defaults, ...overrides}>",
          "metadata": {
            "operator": "spread"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Config>",
            "dst": "<Config.defaults>",
            "type": "CONTAINS"
          },
          {
            "src": "<Config>",
            "dst": "<Config:static-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<Config>",
            "dst": "<Config.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<{timeout: 5000, retries: 3}>",
            "dst": "<5000>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{timeout: 5000, retries: 3}>",
            "dst": "<3>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Config.constructor>",
            "dst": "<overrides>",
            "type": "CONTAINS"
          },
          {
            "src": "<overrides>",
            "dst": "<{}>",
            "type": "DEFAULTS_TO"
          }
        ],
        "postFile": [
          {
            "src": "<Config:static-block>",
            "dst": "<Config.defaults>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Config.defaults>",
            "dst": "<{timeout: 5000, retries: 3}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Config.constructor>",
            "dst": "<this.settings>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.settings>",
            "dst": "<{...Config.defaults, ...overrides}>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{...Config.defaults, ...overrides}>",
            "dst": "<Config.defaults>",
            "type": "READS_FROM"
          },
          {
            "src": "<{...Config.defaults, ...overrides}>",
            "dst": "<overrides>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-computed-methods",
      "category": "classes",
      "code": "const METHOD_KEY = 'dynamicMethod';\n\nclass WithComputedMethods {\n  [METHOD_KEY]() {\n    return 'dynamic';\n  }\n\n  [Symbol.toPrimitive](hint) {\n    return hint === 'number' ? 42 : 'string';\n  }\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<METHOD_KEY>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'dynamicMethod'>",
          "metadata": {
            "value": "dynamicMethod",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<WithComputedMethods>"
        },
        {
          "type": "METHOD",
          "id": "<WithComputedMethods.[METHOD_KEY]>",
          "metadata": {
            "kind": "method",
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'dynamic'>",
          "metadata": {
            "value": "dynamic",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<WithComputedMethods.[Symbol.toPrimitive]>",
          "metadata": {
            "kind": "method",
            "computed": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<hint>"
        },
        {
          "type": "EXPRESSION",
          "id": "<hint === 'number'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'number'>",
          "metadata": {
            "value": "number",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'string'>",
          "metadata": {
            "value": "string",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary>",
          "metadata": {
            "operator": "?:"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<WithComputedMethods>",
            "dst": "<WithComputedMethods.[METHOD_KEY]>",
            "type": "CONTAINS"
          },
          {
            "src": "<WithComputedMethods.[METHOD_KEY]>",
            "dst": "<'dynamic'>",
            "type": "RETURNS"
          },
          {
            "src": "<WithComputedMethods>",
            "dst": "<WithComputedMethods.[Symbol.toPrimitive]>",
            "type": "CONTAINS"
          },
          {
            "src": "<WithComputedMethods.[Symbol.toPrimitive]>",
            "dst": "<hint>",
            "type": "CONTAINS"
          },
          {
            "src": "<WithComputedMethods.[Symbol.toPrimitive]>",
            "dst": "<ternary>",
            "type": "RETURNS"
          },
          {
            "src": "<ternary>",
            "dst": "<hint === 'number'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary>",
            "dst": "<42>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<METHOD_KEY>",
            "dst": "<'dynamicMethod'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ternary>",
            "dst": "<'string'>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<WithComputedMethods.[METHOD_KEY]>",
            "dst": "<METHOD_KEY>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<hint === 'number'>",
            "dst": "<hint>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'number'>",
            "dst": "<'number'>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-new-target",
      "category": "classes",
      "code": "class AbstractBase {\n  constructor() {\n    if (new.target === AbstractBase) {\n      throw new Error('Cannot instantiate AbstractBase directly');\n    }\n  }\n}\n\nclass Concrete extends AbstractBase {\n  constructor() {\n    super();\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<AbstractBase>"
        },
        {
          "type": "METHOD",
          "id": "<AbstractBase.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-new.target>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<new.target === AbstractBase>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<new.target>",
          "metadata": {
            "property": "target"
          }
        },
        {
          "type": "CALL",
          "id": "<throw new Error>",
          "metadata": {
            "callee": "Error",
            "isThrow": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Cannot instantiate AbstractBase directly'>",
          "metadata": {
            "value": "Cannot instantiate AbstractBase directly",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<Concrete>"
        },
        {
          "type": "METHOD",
          "id": "<Concrete.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "CALL",
          "id": "<super()>",
          "metadata": {
            "callee": "super"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<AbstractBase>",
            "dst": "<AbstractBase.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<AbstractBase.constructor>",
            "dst": "<if-new.target>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-new.target>",
            "dst": "<new.target === AbstractBase>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-new.target>",
            "dst": "<throw new Error>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<throw new Error>",
            "dst": "<'Cannot instantiate AbstractBase directly'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Concrete>",
            "dst": "<Concrete.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Concrete.constructor>",
            "dst": "<super()>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<new.target === AbstractBase>",
            "dst": "<new.target>",
            "type": "READS_FROM"
          },
          {
            "src": "<new.target === AbstractBase>",
            "dst": "<AbstractBase>",
            "type": "READS_FROM"
          },
          {
            "src": "<Concrete>",
            "dst": "<AbstractBase>",
            "type": "EXTENDS"
          },
          {
            "src": "<super()>",
            "dst": "<AbstractBase.constructor>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-getters-setters",
      "category": "classes",
      "code": "class Temperature {\n  #celsius;\n\n  constructor(celsius) {\n    this.#celsius = celsius;\n  }\n\n  get fahrenheit() {\n    return this.#celsius * 9 / 5 + 32;\n  }\n\n  set fahrenheit(f) {\n    this.#celsius = (f - 32) * 5 / 9;\n  }\n\n  get celsius() {\n    return this.#celsius;\n  }\n\n  set celsius(c) {\n    this.#celsius = c;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Temperature>"
        },
        {
          "type": "PROPERTY",
          "id": "<#celsius>",
          "metadata": {
            "private": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Temperature.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<celsius>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.#celsius>",
          "metadata": {
            "objectName": "this",
            "private": true
          }
        },
        {
          "type": "GETTER",
          "id": "<Temperature.fahrenheit:getter>",
          "metadata": {
            "propertyName": "fahrenheit"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.#celsius * 9 / 5 + 32>",
          "metadata": {
            "operator": "arithmetic"
          }
        },
        {
          "type": "SETTER",
          "id": "<Temperature.fahrenheit:setter>",
          "metadata": {
            "propertyName": "fahrenheit"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<f>"
        },
        {
          "type": "EXPRESSION",
          "id": "<(f - 32) * 5 / 9>",
          "metadata": {
            "operator": "arithmetic"
          }
        },
        {
          "type": "GETTER",
          "id": "<Temperature.celsius:getter>",
          "metadata": {
            "propertyName": "celsius"
          }
        },
        {
          "type": "SETTER",
          "id": "<Temperature.celsius:setter>",
          "metadata": {
            "propertyName": "celsius"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<c>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Temperature>",
            "dst": "<#celsius>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature>",
            "dst": "<Temperature.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature>",
            "dst": "<Temperature.fahrenheit:getter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature>",
            "dst": "<Temperature.fahrenheit:setter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature>",
            "dst": "<Temperature.celsius:getter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature>",
            "dst": "<Temperature.celsius:setter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature.constructor>",
            "dst": "<celsius>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature.fahrenheit:getter>",
            "dst": "<this.#celsius * 9 / 5 + 32>",
            "type": "RETURNS"
          },
          {
            "src": "<Temperature.fahrenheit:setter>",
            "dst": "<f>",
            "type": "CONTAINS"
          },
          {
            "src": "<Temperature.celsius:getter>",
            "dst": "<this.#celsius>",
            "type": "RETURNS"
          },
          {
            "src": "<Temperature.celsius:setter>",
            "dst": "<c>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<this.#celsius>",
            "dst": "<celsius>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Temperature.constructor>",
            "dst": "<this.#celsius>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Temperature.fahrenheit:setter>",
            "dst": "<this.#celsius>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.#celsius>",
            "dst": "<(f - 32) * 5 / 9>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Temperature.celsius:setter>",
            "dst": "<this.#celsius>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.#celsius>",
            "dst": "<c>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this.#celsius * 9 / 5 + 32>",
            "dst": "<this.#celsius>",
            "type": "READS_FROM"
          },
          {
            "src": "<(f - 32) * 5 / 9>",
            "dst": "<f>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::in-brand-check",
      "category": "classes",
      "code": "class Branded {\n  #secret = true;\n  static isBranded(obj) {\n    return #secret in obj;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Branded>"
        },
        {
          "type": "PROPERTY",
          "id": "<#secret>",
          "metadata": {
            "private": true,
            "static": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "METHOD",
          "id": "<Branded.isBranded>",
          "metadata": {
            "static": true,
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "EXPRESSION",
          "id": "<#secret in obj>",
          "metadata": {
            "operator": "in",
            "privateFieldCheck": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Branded>",
            "dst": "<#secret>",
            "type": "CONTAINS"
          },
          {
            "src": "<Branded>",
            "dst": "<Branded.isBranded>",
            "type": "CONTAINS"
          },
          {
            "src": "<Branded.isBranded>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<Branded.isBranded>",
            "dst": "<#secret in obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<#secret>",
            "dst": "<true>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<#secret in obj>",
            "dst": "<#secret>",
            "type": "READS_FROM"
          },
          {
            "src": "<#secret in obj>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::new-arrow-throws",
      "category": "classes",
      "code": "const ArrowNotConstructable = () => {};\nconst methodShorthandObj = { method() {} };\n// new ArrowNotConstructable(); // TypeError: not a constructor\n// new methodShorthandObj.method(); // TypeError: not a constructor",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<ArrowNotConstructable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<ArrowNotConstructable:fn>",
          "metadata": {
            "arrowFunction": true,
            "constructable": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<methodShorthandObj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<methodShorthandObj:obj>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<method>",
          "metadata": {
            "kind": "method",
            "constructable": false
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ArrowNotConstructable>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<methodShorthandObj>",
            "type": "DECLARES"
          },
          {
            "src": "<methodShorthandObj:obj>",
            "dst": "<method>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<ArrowNotConstructable>",
            "dst": "<ArrowNotConstructable:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<methodShorthandObj>",
            "dst": "<methodShorthandObj:obj>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "classes::mixin-composition",
      "category": "classes",
      "code": "class User extends Serializable(Validatable(class {\n  constructor(name) { this.name = name; }\n})) {\n  greet() { return `Hi, ${this.name}`; }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<User>"
        },
        {
          "type": "CLASS",
          "id": "<anonymous-base>"
        },
        {
          "type": "METHOD",
          "id": "<anonymous-base.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "CALL",
          "id": "<Validatable(anonymous-base)>",
          "metadata": {
            "callee": "Validatable"
          }
        },
        {
          "type": "CALL",
          "id": "<Serializable(Validatable-result)>",
          "metadata": {
            "callee": "Serializable"
          }
        },
        {
          "type": "METHOD",
          "id": "<User.greet>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Hi, '>",
          "metadata": {
            "value": "Hi, ",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name-read>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<User>",
            "dst": "<User.greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-base>",
            "dst": "<anonymous-base.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-base.constructor>",
            "dst": "<name>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Validatable(anonymous-base)>",
            "dst": "<anonymous-base>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Serializable(Validatable-result)>",
            "dst": "<Validatable(anonymous-base)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<User.greet>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<template-literal>",
            "dst": "<'Hi, '>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<User>",
            "dst": "<Serializable(Validatable-result)>",
            "type": "EXTENDS"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.name-read>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-multi-level-inheritance",
      "category": "classes",
      "code": "class Base {\n  baseMethod() {\n    return 'base';\n  }\n}\n\nclass Middle extends Base {\n  middleMethod() {\n    return 'middle';\n  }\n}\n\nclass Derived extends Middle {\n  derivedMethod() {\n    return 'derived';\n  }\n\n  allMethods() {\n    return [this.baseMethod(), this.middleMethod(), this.derivedMethod()];\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Base>"
        },
        {
          "type": "METHOD",
          "id": "<Base.baseMethod>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'base'>",
          "metadata": {
            "value": "base",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<Middle>"
        },
        {
          "type": "METHOD",
          "id": "<Middle.middleMethod>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'middle'>",
          "metadata": {
            "value": "middle",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<Derived>"
        },
        {
          "type": "METHOD",
          "id": "<Derived.derivedMethod>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'derived'>",
          "metadata": {
            "value": "derived",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<Derived.allMethods>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<this.baseMethod()>",
          "metadata": {
            "callee": "baseMethod"
          }
        },
        {
          "type": "CALL",
          "id": "<this.middleMethod()>",
          "metadata": {
            "callee": "middleMethod"
          }
        },
        {
          "type": "CALL",
          "id": "<this.derivedMethod()>",
          "metadata": {
            "callee": "derivedMethod"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>",
          "metadata": {
            "type": "array"
          }
        },
        {
          "type": "MODULE",
          "id": "<module>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Base>",
            "type": "DECLARES"
          },
          {
            "src": "<Base>",
            "dst": "<Base.baseMethod>",
            "type": "CONTAINS"
          },
          {
            "src": "<Base.baseMethod>",
            "dst": "<'base'>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<Middle>",
            "type": "DECLARES"
          },
          {
            "src": "<Middle>",
            "dst": "<Middle.middleMethod>",
            "type": "CONTAINS"
          },
          {
            "src": "<Middle.middleMethod>",
            "dst": "<'middle'>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<Derived>",
            "type": "DECLARES"
          },
          {
            "src": "<Derived>",
            "dst": "<Derived.derivedMethod>",
            "type": "CONTAINS"
          },
          {
            "src": "<Derived.derivedMethod>",
            "dst": "<'derived'>",
            "type": "RETURNS"
          },
          {
            "src": "<Derived>",
            "dst": "<Derived.allMethods>",
            "type": "CONTAINS"
          },
          {
            "src": "<Derived.allMethods>",
            "dst": "<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>",
            "type": "RETURNS"
          },
          {
            "src": "<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>",
            "dst": "<this.baseMethod()>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>",
            "dst": "<this.middleMethod()>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>",
            "dst": "<this.derivedMethod()>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Middle>",
            "dst": "<Base>",
            "type": "EXTENDS"
          },
          {
            "src": "<Derived>",
            "dst": "<Middle>",
            "type": "EXTENDS"
          },
          {
            "src": "<this.baseMethod()>",
            "dst": "<Base.baseMethod>",
            "type": "CALLS"
          },
          {
            "src": "<this.middleMethod()>",
            "dst": "<Middle.middleMethod>",
            "type": "CALLS"
          },
          {
            "src": "<this.derivedMethod()>",
            "dst": "<Derived.derivedMethod>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::mixin-class-expression",
      "category": "classes",
      "code": "const Serializable = (SuperClass) => class extends SuperClass {\n  serialize() { return JSON.stringify(this); }\n};\n\nconst Validatable = (SuperClass) => class extends SuperClass {\n  validate() { return true; }\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<Serializable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Serializable:fn>",
          "metadata": {
            "arrowFunction": true,
            "mixin": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<SuperClass>"
        },
        {
          "type": "CLASS",
          "id": "<Serializable:class>",
          "metadata": {
            "anonymous": true,
            "mixin": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Serializable:class.serialize>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<JSON.stringify(this)>",
          "metadata": {
            "callee": "JSON.stringify"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.stringify>",
          "metadata": {
            "object": "JSON",
            "property": "stringify"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<this>",
          "metadata": {
            "kind": "this"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Validatable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Validatable:fn>",
          "metadata": {
            "arrowFunction": true,
            "mixin": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<SuperClass2>"
        },
        {
          "type": "CLASS",
          "id": "<Validatable:class>",
          "metadata": {
            "anonymous": true,
            "mixin": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Validatable:class.validate>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Serializable:fn>",
            "dst": "<SuperClass>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Serializable:fn>",
            "dst": "<Serializable:class>",
            "type": "RETURNS"
          },
          {
            "src": "<Serializable:class>",
            "dst": "<Serializable:class.serialize>",
            "type": "CONTAINS"
          },
          {
            "src": "<Serializable:class.serialize>",
            "dst": "<JSON.stringify(this)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.stringify(this)>",
            "dst": "<this>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Validatable:fn>",
            "dst": "<SuperClass2>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Validatable:fn>",
            "dst": "<Validatable:class>",
            "type": "RETURNS"
          },
          {
            "src": "<Validatable:class>",
            "dst": "<Validatable:class.validate>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validatable:class.validate>",
            "dst": "<true>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Serializable>",
            "dst": "<Serializable:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Validatable>",
            "dst": "<Validatable:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Serializable:class>",
            "dst": "<SuperClass>",
            "type": "EXTENDS"
          },
          {
            "src": "<JSON.stringify(this)>",
            "dst": "<JSON.stringify>",
            "type": "CALLS"
          },
          {
            "src": "<Validatable:class>",
            "dst": "<SuperClass2>",
            "type": "EXTENDS"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-async-method",
      "category": "classes",
      "code": "class ApiClient {\n  async fetch(url) { return url; }\n  static async create() { return new ApiClient(); }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ApiClient>"
        },
        {
          "type": "METHOD",
          "id": "<ApiClient.fetch>",
          "metadata": {
            "kind": "method",
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "METHOD",
          "id": "<ApiClient.create>",
          "metadata": {
            "kind": "static",
            "async": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<new ApiClient()>",
          "metadata": {
            "type": "constructor-call"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ApiClient>",
            "dst": "<ApiClient.fetch>",
            "type": "CONTAINS"
          },
          {
            "src": "<ApiClient>",
            "dst": "<ApiClient.create>",
            "type": "CONTAINS"
          },
          {
            "src": "<ApiClient.fetch>",
            "dst": "<url>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<ApiClient.fetch>",
            "dst": "<url>",
            "type": "RETURNS"
          },
          {
            "src": "<ApiClient.create>",
            "dst": "<new ApiClient()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<new ApiClient()>",
            "dst": "<ApiClient>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-inline-extends",
      "category": "classes",
      "code": "const inlineChild = new (class extends Error {\n  constructor(msg) { super(msg); this.custom = true; }\n})('inline error');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<inlineChild>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new (class extends Error {...})('inline error')>",
          "metadata": {
            "operator": "new"
          }
        },
        {
          "type": "CLASS",
          "id": "<anonymous-class>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "METHOD",
          "id": "<anonymous-class.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<msg>"
        },
        {
          "type": "CALL",
          "id": "<super(msg)>",
          "metadata": {
            "callee": "super"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.custom>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'inline error'>",
          "metadata": {
            "value": "inline error",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<new (class extends Error {...})('inline error')>",
            "dst": "<'inline error'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<anonymous-class>",
            "dst": "<anonymous-class.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-class.constructor>",
            "dst": "<msg>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-class.constructor>",
            "dst": "<super(msg)>",
            "type": "CONTAINS"
          },
          {
            "src": "<super(msg)>",
            "dst": "<msg>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<inlineChild>",
            "dst": "<new (class extends Error {...})('inline error')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<anonymous-class.constructor>",
            "dst": "<this.custom>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.custom>",
            "dst": "<true>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new (class extends Error {...})('inline error')>",
            "dst": "<anonymous-class>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-constructor-return-non-this",
      "category": "classes",
      "code": "class Singleton {\n  static instance;\n  constructor() {\n    if (Singleton.instance) return Singleton.instance;\n    Singleton.instance = this;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Singleton>"
        },
        {
          "type": "PROPERTY",
          "id": "<Singleton.instance>",
          "metadata": {
            "static": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Singleton.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-instance-exists>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Singleton.instance-read>",
          "metadata": {
            "objectName": "Singleton",
            "propertyName": "instance"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Singleton.instance-write>",
          "metadata": {
            "objectName": "Singleton",
            "propertyName": "instance"
          }
        },
        {
          "type": "LITERAL",
          "id": "<this>",
          "metadata": {
            "value": "this",
            "literalType": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Singleton>",
            "dst": "<Singleton.instance>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Singleton>",
            "dst": "<Singleton.constructor>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Singleton.constructor>",
            "dst": "<if-instance-exists>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-instance-exists>",
            "dst": "<Singleton.instance-read>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-instance-exists>",
            "dst": "<Singleton.instance-read>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Singleton.constructor>",
            "dst": "<Singleton.instance-read>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Singleton.instance-write>",
            "dst": "<this>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Singleton.constructor>",
            "dst": "<Singleton.instance-write>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Singleton.instance-write>",
            "dst": "<Singleton.instance>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<Singleton.instance-read>",
            "dst": "<Singleton.instance>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-field-no-initializer",
      "category": "classes",
      "code": "class Form {\n  errors;\n  static count;\n}\n\n// --- Dynamic super property access ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Form>"
        },
        {
          "type": "PROPERTY",
          "id": "<Form.errors>",
          "metadata": {
            "static": false,
            "hasInitializer": false
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Form.count>",
          "metadata": {
            "static": true,
            "hasInitializer": false
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Form>",
            "type": "DECLARES"
          },
          {
            "src": "<Form>",
            "dst": "<Form.errors>",
            "type": "CONTAINS"
          },
          {
            "src": "<Form>",
            "dst": "<Form.count>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "classes::class-generator-method",
      "category": "classes",
      "code": "class Stream {\n  data = [];\n  *items() { for (const item of this.data) yield item; }\n  async *pages() { yield* this.data; }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Stream>"
        },
        {
          "type": "PROPERTY",
          "id": "<Stream.data>",
          "metadata": {
            "kind": "field"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "METHOD",
          "id": "<Stream.items>",
          "metadata": {
            "kind": "generator",
            "async": false
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of-data>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.data>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield item>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "METHOD",
          "id": "<Stream.pages>",
          "metadata": {
            "kind": "generator",
            "async": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield* this.data>",
          "metadata": {
            "operator": "yield*"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Stream>",
            "dst": "<Stream.data>",
            "type": "CONTAINS"
          },
          {
            "src": "<Stream>",
            "dst": "<Stream.items>",
            "type": "CONTAINS"
          },
          {
            "src": "<Stream>",
            "dst": "<Stream.pages>",
            "type": "CONTAINS"
          },
          {
            "src": "<Stream.items>",
            "dst": "<for-of-data>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of-data>",
            "dst": "<this.data>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of-data>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<Stream.items>",
            "dst": "<yield item>",
            "type": "YIELDS"
          },
          {
            "src": "<Stream.pages>",
            "dst": "<yield* this.data>",
            "type": "DELEGATES_TO"
          }
        ],
        "postFile": [
          {
            "src": "<Stream.data>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<yield item>",
            "dst": "<item>",
            "type": "READS_FROM"
          },
          {
            "src": "<yield* this.data>",
            "dst": "<this.data>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-static-getter-setter",
      "category": "classes",
      "code": "class Registry {\n  static #store = new Map();\n  static get size() { return this.#store.size; }\n  static set defaultValue(value) { this.#store.set('default', value); }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Registry>"
        },
        {
          "type": "PROPERTY",
          "id": "<Registry.#store>",
          "metadata": {
            "static": true,
            "private": true
          }
        },
        {
          "type": "CALL",
          "id": "<new Map()>",
          "metadata": {
            "constructor": true,
            "callee": "Map"
          }
        },
        {
          "type": "GETTER",
          "id": "<Registry.size>",
          "metadata": {
            "static": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.#store.size>",
          "metadata": {
            "objectName": "this",
            "propertyChain": [
              "#store",
              "size"
            ]
          }
        },
        {
          "type": "SETTER",
          "id": "<Registry.defaultValue>",
          "metadata": {
            "static": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "CALL",
          "id": "<this.#store.set('default', value)>",
          "metadata": {
            "callee": "set"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'default'>",
          "metadata": {
            "value": "default",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Registry>",
            "dst": "<Registry.#store>",
            "type": "CONTAINS"
          },
          {
            "src": "<Registry>",
            "dst": "<Registry.size>",
            "type": "CONTAINS"
          },
          {
            "src": "<Registry>",
            "dst": "<Registry.defaultValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<Registry.size>",
            "dst": "<this.#store.size>",
            "type": "RETURNS"
          },
          {
            "src": "<Registry.defaultValue>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<Registry.defaultValue>",
            "dst": "<this.#store.set('default', value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.#store.set('default', value)>",
            "dst": "<'default'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<this.#store.set('default', value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<Registry.#store>",
            "dst": "<new Map()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new Map()>",
            "dst": "<Map>",
            "type": "CALLS"
          },
          {
            "src": "<this.#store.size>",
            "dst": "<Registry.#store>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.#store.set('default', value)>",
            "dst": "<Registry.#store>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-iterator-cancel-break",
      "category": "async-generators",
      "code": "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<streamChunks>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "VARIABLE",
          "id": "<reader>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ locked: true }>",
          "metadata": {
            "value": "{ locked: true }",
            "literalType": "object"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": "0",
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": "10",
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 10>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield { chunk: i, size: i * 100 }>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ chunk: i, size: i * 100 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i * 100>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<100>",
          "metadata": {
            "value": "100",
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<reader.locked>",
          "metadata": {
            "objectName": "reader",
            "propertyName": "locked"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": "false",
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<streamChunks>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<streamChunks>",
            "dst": "<reader>",
            "type": "CONTAINS"
          },
          {
            "src": "<streamChunks>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<streamChunks>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 10>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield { chunk: i, size: i * 100 }>",
            "type": "HAS_BODY"
          },
          {
            "src": "<yield { chunk: i, size: i * 100 }>",
            "dst": "<{ chunk: i, size: i * 100 }>",
            "type": "YIELDS"
          },
          {
            "src": "<finally-block>",
            "dst": "<reader.locked>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<reader>",
            "dst": "<{ locked: true }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<reader.locked>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<i < 10>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 10>",
            "dst": "<10>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ chunk: i, size: i * 100 }>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ chunk: i, size: i * 100 }>",
            "dst": "<i * 100>",
            "type": "READS_FROM"
          },
          {
            "src": "<i * 100>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i * 100>",
            "dst": "<100>",
            "type": "READS_FROM"
          },
          {
            "src": "<reader.locked>",
            "dst": "<reader>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::super-computed-access",
      "category": "classes",
      "code": "class DynamicChild extends Animal {\n  callDynamic(methodName) {\n    return super[methodName](); // dynamic dispatch through prototype chain\n  }\n  delegateAll(methods) {\n    return methods.map(m => super[m]());\n  }\n}\n\n// --- Method chaining / fluent API ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<DynamicChild>"
        },
        {
          "type": "METHOD",
          "id": "<DynamicChild.callDynamic>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<methodName>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<super[methodName]>",
          "metadata": {
            "objectName": "super",
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<super[methodName]()>",
          "metadata": {
            "dynamic": true
          }
        },
        {
          "type": "METHOD",
          "id": "<DynamicChild.delegateAll>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<methods>"
        },
        {
          "type": "CALL",
          "id": "<methods.map(m => super[m]())>",
          "metadata": {
            "callee": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<m => super[m]()>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<m>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<super[m]>",
          "metadata": {
            "objectName": "super",
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<super[m]()>",
          "metadata": {
            "dynamic": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<DynamicChild>",
            "dst": "<DynamicChild.callDynamic>",
            "type": "CONTAINS"
          },
          {
            "src": "<DynamicChild>",
            "dst": "<DynamicChild.delegateAll>",
            "type": "CONTAINS"
          },
          {
            "src": "<DynamicChild.callDynamic>",
            "dst": "<methodName>",
            "type": "CONTAINS"
          },
          {
            "src": "<DynamicChild.callDynamic>",
            "dst": "<super[methodName]()>",
            "type": "RETURNS"
          },
          {
            "src": "<DynamicChild.delegateAll>",
            "dst": "<methods>",
            "type": "CONTAINS"
          },
          {
            "src": "<methods.map(m => super[m]())>",
            "dst": "<m => super[m]()>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<DynamicChild.delegateAll>",
            "dst": "<methods.map(m => super[m]())>",
            "type": "RETURNS"
          },
          {
            "src": "<m => super[m]()>",
            "dst": "<m>",
            "type": "CONTAINS"
          },
          {
            "src": "<m => super[m]()>",
            "dst": "<super[m]()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<super[methodName]>",
            "dst": "<methodName>",
            "type": "READS_FROM"
          },
          {
            "src": "<super[methodName]()>",
            "dst": "<super[methodName]>",
            "type": "CALLS"
          },
          {
            "src": "<methods.map(m => super[m]())>",
            "dst": "<methods>",
            "type": "CALLS_ON"
          },
          {
            "src": "<super[m]>",
            "dst": "<m>",
            "type": "READS_FROM"
          },
          {
            "src": "<super[m]()>",
            "dst": "<super[m]>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::method-chaining-usage",
      "category": "classes",
      "code": "const chainedQuery = new QueryBuilder()\n  .from('users')\n  .where('age > 18')\n  .orderBy('name')\n  .limit(10)\n  .build();",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<chainedQuery>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new QueryBuilder()>",
          "metadata": {
            "callee": "QueryBuilder",
            "isConstructor": true
          }
        },
        {
          "type": "CALL",
          "id": "<.from('users')>",
          "metadata": {
            "callee": "from",
            "isChained": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'users'>",
          "metadata": {
            "value": "users",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<.where('age > 18')>",
          "metadata": {
            "callee": "where",
            "isChained": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'age > 18'>",
          "metadata": {
            "value": "age > 18",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<.orderBy('name')>",
          "metadata": {
            "callee": "orderBy",
            "isChained": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<.limit(10)>",
          "metadata": {
            "callee": "limit",
            "isChained": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<.build()>",
          "metadata": {
            "callee": "build",
            "isChained": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<.from('users')>",
            "dst": "<new QueryBuilder()>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.from('users')>",
            "dst": "<'users'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<.where('age > 18')>",
            "dst": "<.from('users')>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.where('age > 18')>",
            "dst": "<'age > 18'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<.orderBy('name')>",
            "dst": "<.where('age > 18')>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.orderBy('name')>",
            "dst": "<'name'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<.limit(10)>",
            "dst": "<.orderBy('name')>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.limit(10)>",
            "dst": "<10>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<.build()>",
            "dst": "<.limit(10)>",
            "type": "CHAINS_FROM"
          }
        ],
        "postFile": [
          {
            "src": "<chainedQuery>",
            "dst": "<.build()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new QueryBuilder()>",
            "dst": "QueryBuilder",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-iterator-cancel-manual",
      "category": "async-generators",
      "code": "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<manualAsyncCancel>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncGen>"
        },
        {
          "type": "VARIABLE",
          "id": "<iter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<asyncGen[Symbol.asyncIterator]>",
          "metadata": {
            "objectName": "asyncGen",
            "property": "Symbol.asyncIterator"
          }
        },
        {
          "type": "CALL",
          "id": "<asyncGen[Symbol.asyncIterator]()>",
          "metadata": {
            "callee": "asyncGen[Symbol.asyncIterator]"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<iter.next>",
          "metadata": {
            "objectName": "iter",
            "property": "next"
          }
        },
        {
          "type": "CALL",
          "id": "<iter.next()>",
          "metadata": {
            "callee": "iter.next",
            "awaited": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<iter.return>",
          "metadata": {
            "objectName": "iter",
            "property": "return"
          }
        },
        {
          "type": "CALL",
          "id": "<iter.return()>",
          "metadata": {
            "callee": "iter.return",
            "awaited": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return first>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<manualAsyncCancel>",
            "dst": "<asyncGen>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualAsyncCancel>",
            "dst": "<return first>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<iter>",
            "dst": "<asyncGen[Symbol.asyncIterator]()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<first>",
            "dst": "<iter.next()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<asyncGen[Symbol.asyncIterator]()>",
            "dst": "<asyncGen[Symbol.asyncIterator]>",
            "type": "CALLS"
          },
          {
            "src": "<asyncGen[Symbol.asyncIterator]>",
            "dst": "<asyncGen>",
            "type": "READS_FROM"
          },
          {
            "src": "<iter.next()>",
            "dst": "<iter.next>",
            "type": "CALLS"
          },
          {
            "src": "<iter.next>",
            "dst": "<iter>",
            "type": "READS_FROM"
          },
          {
            "src": "<iter.return()>",
            "dst": "<iter.return>",
            "type": "CALLS"
          },
          {
            "src": "<iter.return>",
            "dst": "<iter>",
            "type": "READS_FROM"
          },
          {
            "src": "<return first>",
            "dst": "<first>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::destructure-assign-to-this",
      "category": "classes",
      "code": "class ComponentState {\n  width = 0;\n  height = 0;\n\n  update(props) {\n    ({ width: this.width, height: this.height } = props);\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ComponentState>"
        },
        {
          "type": "PROPERTY",
          "id": "<ComponentState.width>",
          "metadata": {
            "initialValue": 0
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ComponentState.height>",
          "metadata": {
            "initialValue": 0
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<ComponentState.update>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<props>"
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure-props>",
          "metadata": {
            "pattern": "object",
            "kind": "destructuring_assignment"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.width>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.height>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<props.width>",
          "metadata": {
            "objectName": "props"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<props.height>",
          "metadata": {
            "objectName": "props"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ComponentState>",
            "dst": "<ComponentState.width>",
            "type": "CONTAINS"
          },
          {
            "src": "<ComponentState>",
            "dst": "<ComponentState.height>",
            "type": "CONTAINS"
          },
          {
            "src": "<ComponentState>",
            "dst": "<ComponentState.update>",
            "type": "CONTAINS"
          },
          {
            "src": "<ComponentState.update>",
            "dst": "<props>",
            "type": "CONTAINS"
          },
          {
            "src": "<ComponentState.update>",
            "dst": "<destructure-props>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<ComponentState.width>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ComponentState.height>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructure-props>",
            "dst": "<this.width>",
            "type": "WRITES_TO"
          },
          {
            "src": "<destructure-props>",
            "dst": "<this.height>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.width>",
            "dst": "<ComponentState.width>",
            "type": "MODIFIES"
          },
          {
            "src": "<this.height>",
            "dst": "<ComponentState.height>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<destructure-props>",
            "dst": "<props.width>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure-props>",
            "dst": "<props.height>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-private-cross-instance",
      "category": "classes",
      "code": "class Vec {\n  #x; #y;\n  constructor(x, y) { this.#x = x; this.#y = y; }\n  equals(other) {\n    return this.#x === other.#x && this.#y === other.#y;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Vec>"
        },
        {
          "type": "PROPERTY",
          "id": "<Vec.#x>",
          "metadata": {
            "visibility": "private"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Vec.#y>",
          "metadata": {
            "visibility": "private"
          }
        },
        {
          "type": "METHOD",
          "id": "<Vec.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "PARAMETER",
          "id": "<y>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.#x>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.#y>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<Vec.equals>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<other>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<other.#x>",
          "metadata": {
            "objectName": "other"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<other.#y>",
          "metadata": {
            "objectName": "other"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.#x === other.#x>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.#y === other.#y>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<equals-return>",
          "metadata": {
            "operator": "&&"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Vec>",
            "dst": "<Vec.#x>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Vec>",
            "dst": "<Vec.#y>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Vec>",
            "dst": "<Vec.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Vec>",
            "dst": "<Vec.equals>",
            "type": "CONTAINS"
          },
          {
            "src": "<Vec.constructor>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<Vec.constructor>",
            "dst": "<y>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.#x>",
            "dst": "<Vec.#x>",
            "type": "ACCESSES_PRIVATE"
          },
          {
            "src": "<this.#y>",
            "dst": "<Vec.#y>",
            "type": "ACCESSES_PRIVATE"
          },
          {
            "src": "<Vec.equals>",
            "dst": "<other>",
            "type": "CONTAINS"
          },
          {
            "src": "<Vec.equals>",
            "dst": "<equals-return>",
            "type": "RETURNS"
          },
          {
            "src": "<other.#x>",
            "dst": "<Vec.#x>",
            "type": "ACCESSES_PRIVATE"
          },
          {
            "src": "<other.#y>",
            "dst": "<Vec.#y>",
            "type": "ACCESSES_PRIVATE"
          }
        ],
        "postFile": [
          {
            "src": "<Vec.constructor>",
            "dst": "<this.#x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Vec.constructor>",
            "dst": "<this.#y>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.#x>",
            "dst": "<x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.#y>",
            "dst": "<y>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this.#x === other.#x>",
            "dst": "<this.#x>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.#x === other.#x>",
            "dst": "<other.#x>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.#y === other.#y>",
            "dst": "<this.#y>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.#y === other.#y>",
            "dst": "<other.#y>",
            "type": "READS_FROM"
          },
          {
            "src": "<equals-return>",
            "dst": "<this.#x === other.#x>",
            "type": "READS_FROM"
          },
          {
            "src": "<equals-return>",
            "dst": "<this.#y === other.#y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::yield-star-return-value",
      "category": "async-generators",
      "code": "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<innerWithReturn>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'done'>",
          "metadata": {
            "value": "done",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<outerCapturesReturn>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield* innerWithReturn()>",
          "metadata": {
            "operator": "yield*"
          }
        },
        {
          "type": "CALL",
          "id": "<innerWithReturn()>",
          "metadata": {
            "callee": "innerWithReturn"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<innerWithReturn>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<innerWithReturn>",
            "dst": "<2>",
            "type": "YIELDS"
          },
          {
            "src": "<innerWithReturn>",
            "dst": "<'done'>",
            "type": "RETURNS"
          },
          {
            "src": "<yield* innerWithReturn()>",
            "dst": "<innerWithReturn()>",
            "type": "DELEGATES_TO"
          },
          {
            "src": "<outerCapturesReturn>",
            "dst": "<result>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<yield* innerWithReturn()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<innerWithReturn()>",
            "dst": "<innerWithReturn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::super-in-nested-arrows",
      "category": "classes",
      "code": "class DeepSuper extends ParentProcessor {\n  deepProcess(items) {\n    return items.map(item => {\n      return this.validate(item).then(valid => {\n        return super.transform(valid);   // super through 2 levels of arrows\n      });\n    });\n  }\n  validate(item) { return Promise.resolve(item); }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<DeepSuper>"
        },
        {
          "type": "METHOD",
          "id": "<DeepSuper.deepProcess>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "CALL",
          "id": "<items.map(...)>",
          "metadata": {
            "callee": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<map-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "CALL",
          "id": "<this.validate(item)>",
          "metadata": {
            "callee": "validate"
          }
        },
        {
          "type": "CALL",
          "id": "<...then(...)>",
          "metadata": {
            "callee": "then"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<then-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<valid>"
        },
        {
          "type": "CALL",
          "id": "<super.transform(valid)>",
          "metadata": {
            "method": "transform",
            "isSuper": true
          }
        },
        {
          "type": "METHOD",
          "id": "<DeepSuper.validate>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item-validate>"
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(item)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<ParentProcessor>"
        },
        {
          "type": "EXTERNAL",
          "id": "<Promise>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<DeepSuper>",
            "dst": "<DeepSuper.deepProcess>",
            "type": "CONTAINS"
          },
          {
            "src": "<DeepSuper>",
            "dst": "<DeepSuper.validate>",
            "type": "CONTAINS"
          },
          {
            "src": "<DeepSuper.deepProcess>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<DeepSuper.deepProcess>",
            "dst": "<items.map(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<map-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<map-callback>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<map-callback>",
            "dst": "<this.validate(item)>",
            "type": "RETURNS"
          },
          {
            "src": "<this.validate(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<...then(...)>",
            "dst": "<then-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<then-callback>",
            "dst": "<valid>",
            "type": "CONTAINS"
          },
          {
            "src": "<then-callback>",
            "dst": "<super.transform(valid)>",
            "type": "RETURNS"
          },
          {
            "src": "<super.transform(valid)>",
            "dst": "<valid>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<DeepSuper.validate>",
            "dst": "<item-validate>",
            "type": "CONTAINS"
          },
          {
            "src": "<DeepSuper.validate>",
            "dst": "<Promise.resolve(item)>",
            "type": "RETURNS"
          },
          {
            "src": "<Promise.resolve(item)>",
            "dst": "<item-validate>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<DeepSuper>",
            "dst": "<ParentProcessor>",
            "type": "EXTENDS"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<items>",
            "type": "CALLS_ON"
          },
          {
            "src": "<this.validate(item)>",
            "dst": "<DeepSuper.validate>",
            "type": "CALLS"
          },
          {
            "src": "<...then(...)>",
            "dst": "<this.validate(item)>",
            "type": "CALLS_ON"
          },
          {
            "src": "<super.transform(valid)>",
            "dst": "<ParentProcessor>",
            "type": "CALLS_ON"
          },
          {
            "src": "<Promise.resolve(item)>",
            "dst": "<Promise>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "classes::object-assign-this",
      "category": "classes",
      "code": "class MergeConfig {\n  constructor(opts) {\n    Object.assign(this, opts);           // copies ALL properties from opts\n  }\n}\n\nclass MergeConfigDefaults {\n  constructor(defaults, overrides) {\n    Object.assign(this, defaults, overrides); // merge with precedence\n  }\n}\n\n// --- super in static context ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<MergeConfig>"
        },
        {
          "type": "METHOD",
          "id": "<MergeConfig.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<opts>"
        },
        {
          "type": "CALL",
          "id": "<Object.assign(this, opts)>",
          "metadata": {
            "callee": "Object.assign"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.assign>",
          "metadata": {
            "objectName": "Object"
          }
        },
        {
          "type": "CLASS",
          "id": "<MergeConfigDefaults>"
        },
        {
          "type": "METHOD",
          "id": "<MergeConfigDefaults.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<defaults>"
        },
        {
          "type": "PARAMETER",
          "id": "<overrides>"
        },
        {
          "type": "CALL",
          "id": "<Object.assign(this, defaults, overrides)>",
          "metadata": {
            "callee": "Object.assign"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MergeConfig>",
            "dst": "<MergeConfig.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<MergeConfig.constructor>",
            "dst": "<opts>",
            "type": "CONTAINS"
          },
          {
            "src": "<MergeConfig.constructor>",
            "dst": "<Object.assign(this, opts)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.assign(this, opts)>",
            "dst": "<opts>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<MergeConfigDefaults>",
            "dst": "<MergeConfigDefaults.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<MergeConfigDefaults.constructor>",
            "dst": "<defaults>",
            "type": "CONTAINS"
          },
          {
            "src": "<MergeConfigDefaults.constructor>",
            "dst": "<overrides>",
            "type": "CONTAINS"
          },
          {
            "src": "<MergeConfigDefaults.constructor>",
            "dst": "<Object.assign(this, defaults, overrides)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.assign(this, defaults, overrides)>",
            "dst": "<defaults>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.assign(this, defaults, overrides)>",
            "dst": "<overrides>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.assign(this, opts)>",
            "dst": "<Object.assign>",
            "type": "CALLS"
          },
          {
            "src": "<Object.assign(this, defaults, overrides)>",
            "dst": "<Object.assign>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::destructure-assign-to-this-defaults",
      "category": "classes",
      "code": "class ConfigFromOpts {\n  host = '';\n  port = 3000;\n\n  constructor(opts) {\n    ({ host: this.host, port: this.port = 3000 } = opts);\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ConfigFromOpts>"
        },
        {
          "type": "PROPERTY",
          "id": "<ConfigFromOpts.host>",
          "metadata": {
            "defaultValue": ""
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ConfigFromOpts.port>",
          "metadata": {
            "defaultValue": 3000
          }
        },
        {
          "type": "LITERAL",
          "id": "<3000>",
          "metadata": {
            "value": 3000,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<ConfigFromOpts.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<opts>"
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure-opts>",
          "metadata": {
            "pattern": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.host>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.port>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3000-default>",
          "metadata": {
            "value": 3000,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ConfigFromOpts>",
            "dst": "<ConfigFromOpts.host>",
            "type": "CONTAINS"
          },
          {
            "src": "<ConfigFromOpts>",
            "dst": "<ConfigFromOpts.port>",
            "type": "CONTAINS"
          },
          {
            "src": "<ConfigFromOpts>",
            "dst": "<ConfigFromOpts.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<ConfigFromOpts.constructor>",
            "dst": "<opts>",
            "type": "CONTAINS"
          },
          {
            "src": "<ConfigFromOpts.constructor>",
            "dst": "<destructure-opts>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.port>",
            "dst": "<3000-default>",
            "type": "DEFAULTS_TO"
          }
        ],
        "postFile": [
          {
            "src": "<ConfigFromOpts.host>",
            "dst": "<''>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ConfigFromOpts.port>",
            "dst": "<3000>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructure-opts>",
            "dst": "<this.host>",
            "type": "WRITES_TO"
          },
          {
            "src": "<destructure-opts>",
            "dst": "<this.port>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<destructure-opts>",
            "dst": "<opts>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::default-param-this-access",
      "category": "classes",
      "code": "class ServiceWithDefaults {\n  defaultTimeout = 5000;\n  baseUrl = '/api';\n\n  fetch(url, timeout = this.defaultTimeout) {\n    return { url: this.baseUrl + url, timeout };\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ServiceWithDefaults>"
        },
        {
          "type": "PROPERTY",
          "id": "<ServiceWithDefaults.defaultTimeout>",
          "metadata": {
            "kind": "field"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5000>",
          "metadata": {
            "value": 5000,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ServiceWithDefaults.baseUrl>",
          "metadata": {
            "kind": "field"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/api'>",
          "metadata": {
            "value": "/api",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<ServiceWithDefaults.fetch>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "PARAMETER",
          "id": "<timeout>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.defaultTimeout>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.baseUrl + url>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.baseUrl>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ url: this.baseUrl + url, timeout }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ServiceWithDefaults>",
            "dst": "<ServiceWithDefaults.defaultTimeout>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithDefaults>",
            "dst": "<ServiceWithDefaults.baseUrl>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithDefaults>",
            "dst": "<ServiceWithDefaults.fetch>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithDefaults.fetch>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithDefaults.fetch>",
            "dst": "<timeout>",
            "type": "CONTAINS"
          },
          {
            "src": "<timeout>",
            "dst": "<this.defaultTimeout>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<{ url: this.baseUrl + url, timeout }>",
            "dst": "<this.baseUrl + url>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ url: this.baseUrl + url, timeout }>",
            "dst": "<timeout>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<ServiceWithDefaults.fetch>",
            "dst": "<{ url: this.baseUrl + url, timeout }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<ServiceWithDefaults.defaultTimeout>",
            "dst": "<5000>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ServiceWithDefaults.baseUrl>",
            "dst": "<'/api'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this.defaultTimeout>",
            "dst": "<ServiceWithDefaults.defaultTimeout>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.baseUrl + url>",
            "dst": "<this.baseUrl>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.baseUrl + url>",
            "dst": "<url>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.baseUrl>",
            "dst": "<ServiceWithDefaults.baseUrl>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::super-in-arrow-callback",
      "category": "classes",
      "code": "class ParentProcessor {\n  transform(item) { return { ...item, processed: true }; }\n  cleanup() { return 'cleaned'; }\n}\n\nclass ChildProcessor extends ParentProcessor {\n  processAll(items) {\n    return items.map(item => {\n      return super.transform(item);     // super captured via arrow\n    });\n  }\n\n  delayed() {\n    setTimeout(() => {\n      super.cleanup();                   // super in async callback arrow\n    }, 100);\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ParentProcessor>"
        },
        {
          "type": "METHOD",
          "id": "<ParentProcessor.transform>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...item, processed: true }>",
          "metadata": {
            "type": "object-spread"
          }
        },
        {
          "type": "METHOD",
          "id": "<ParentProcessor.cleanup>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'cleaned'>",
          "metadata": {
            "value": "cleaned",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<ChildProcessor>"
        },
        {
          "type": "METHOD",
          "id": "<ChildProcessor.processAll>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "CALL",
          "id": "<items.map(...)>",
          "metadata": {
            "callee": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow-fn-1>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item-2>"
        },
        {
          "type": "CALL",
          "id": "<super.transform(item)>",
          "metadata": {
            "callee": "super.transform"
          }
        },
        {
          "type": "METHOD",
          "id": "<ChildProcessor.delayed>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout(...)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow-fn-2>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "CALL",
          "id": "<super.cleanup()>",
          "metadata": {
            "callee": "super.cleanup"
          }
        },
        {
          "type": "LITERAL",
          "id": "<100>",
          "metadata": {
            "value": 100,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ParentProcessor>",
            "dst": "<ParentProcessor.transform>",
            "type": "CONTAINS"
          },
          {
            "src": "<ParentProcessor.transform>",
            "dst": "<item>",
            "type": "HAS_BODY"
          },
          {
            "src": "<ParentProcessor.transform>",
            "dst": "<{ ...item, processed: true }>",
            "type": "RETURNS"
          },
          {
            "src": "<ParentProcessor>",
            "dst": "<ParentProcessor.cleanup>",
            "type": "CONTAINS"
          },
          {
            "src": "<ParentProcessor.cleanup>",
            "dst": "<'cleaned'>",
            "type": "RETURNS"
          },
          {
            "src": "<ChildProcessor>",
            "dst": "<ChildProcessor.processAll>",
            "type": "CONTAINS"
          },
          {
            "src": "<ChildProcessor.processAll>",
            "dst": "<items>",
            "type": "HAS_BODY"
          },
          {
            "src": "<ChildProcessor.processAll>",
            "dst": "<items.map(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<arrow-fn-1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrow-fn-1>",
            "dst": "<item-2>",
            "type": "HAS_BODY"
          },
          {
            "src": "<arrow-fn-1>",
            "dst": "<super.transform(item)>",
            "type": "RETURNS"
          },
          {
            "src": "<super.transform(item)>",
            "dst": "<item-2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ChildProcessor>",
            "dst": "<ChildProcessor.delayed>",
            "type": "CONTAINS"
          },
          {
            "src": "<ChildProcessor.delayed>",
            "dst": "<setTimeout(...)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "<arrow-fn-2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "<100>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrow-fn-2>",
            "dst": "<super.cleanup()>",
            "type": "HAS_BODY"
          }
        ],
        "postFile": [
          {
            "src": "<arrow-fn-1>",
            "dst": "<ChildProcessor>",
            "type": "CAPTURES"
          },
          {
            "src": "<arrow-fn-2>",
            "dst": "<ChildProcessor>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<{ ...item, processed: true }>",
            "dst": "<item>",
            "type": "READS_FROM"
          },
          {
            "src": "<ChildProcessor>",
            "dst": "<ParentProcessor>",
            "type": "EXTENDS"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<items>",
            "type": "CALLS_ON"
          },
          {
            "src": "<super.transform(item)>",
            "dst": "<ParentProcessor.transform>",
            "type": "CALLS"
          },
          {
            "src": "<super.cleanup()>",
            "dst": "<ParentProcessor.cleanup>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "classes::computed-class-member-side-effect",
      "category": "classes",
      "code": "let classFieldId = 0;\nclass AutoIdFields {\n  [`field_${classFieldId++}`] = 'first';\n  [`field_${classFieldId++}`] = 'second';\n  [`method_${classFieldId++}`]() { return 'dynamic'; }\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<classFieldId>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "CLASS",
          "id": "<AutoIdFields>"
        },
        {
          "type": "EXPRESSION",
          "id": "<`field_${classFieldId++}`_1>",
          "metadata": {
            "type": "template-literal",
            "hasSideEffect": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<AutoIdFields[computed1]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'first'>",
          "metadata": {
            "value": "first",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`field_${classFieldId++}`_2>",
          "metadata": {
            "type": "template-literal",
            "hasSideEffect": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<AutoIdFields[computed2]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'second'>",
          "metadata": {
            "value": "second",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`method_${classFieldId++}`>",
          "metadata": {
            "type": "template-literal",
            "hasSideEffect": true
          }
        },
        {
          "type": "METHOD",
          "id": "<AutoIdFields[computedMethod]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'dynamic'>",
          "metadata": {
            "value": "dynamic",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<AutoIdFields>",
            "dst": "<AutoIdFields[computed1]>",
            "type": "CONTAINS"
          },
          {
            "src": "<AutoIdFields>",
            "dst": "<AutoIdFields[computed2]>",
            "type": "CONTAINS"
          },
          {
            "src": "<AutoIdFields>",
            "dst": "<AutoIdFields[computedMethod]>",
            "type": "CONTAINS"
          },
          {
            "src": "<AutoIdFields[computedMethod]>",
            "dst": "<'dynamic'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<classFieldId>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<AutoIdFields[computed1]>",
            "dst": "<'first'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<`field_${classFieldId++}`_1>",
            "dst": "<classFieldId>",
            "type": "MODIFIES"
          },
          {
            "src": "<AutoIdFields[computed2]>",
            "dst": "<'second'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<`field_${classFieldId++}`_2>",
            "dst": "<classFieldId>",
            "type": "MODIFIES"
          },
          {
            "src": "<`method_${classFieldId++}`>",
            "dst": "<classFieldId>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<`field_${classFieldId++}`_1>",
            "dst": "<classFieldId>",
            "type": "READS_FROM"
          },
          {
            "src": "<`field_${classFieldId++}`_2>",
            "dst": "<classFieldId>",
            "type": "READS_FROM"
          },
          {
            "src": "<`method_${classFieldId++}`>",
            "dst": "<classFieldId>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-in-array",
      "category": "classes",
      "code": "const classHandlers = [\n  class GetHandler { handle() { return 'get'; } },\n  class PostHandler { handle() { return 'post'; } },\n];",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<classHandlers>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<classHandlers-array>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "CLASS",
          "id": "<GetHandler>"
        },
        {
          "type": "METHOD",
          "id": "<GetHandler.handle>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'get'>",
          "metadata": {
            "value": "get",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<PostHandler>"
        },
        {
          "type": "METHOD",
          "id": "<PostHandler.handle>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'post'>",
          "metadata": {
            "value": "post",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<classHandlers-array>",
            "dst": "<GetHandler>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<classHandlers-array>",
            "dst": "<PostHandler>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<GetHandler>",
            "dst": "<GetHandler.handle>",
            "type": "CONTAINS"
          },
          {
            "src": "<GetHandler.handle>",
            "dst": "<'get'>",
            "type": "RETURNS"
          },
          {
            "src": "<PostHandler>",
            "dst": "<PostHandler.handle>",
            "type": "CONTAINS"
          },
          {
            "src": "<PostHandler.handle>",
            "dst": "<'post'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<classHandlers>",
            "dst": "<classHandlers-array>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "classes::class-as-argument",
      "category": "classes",
      "code": "function registerClass(cls) { return new cls(); }\nregisterClass(class InlinePlugin { activate() { return true; } });",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<registerClass>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<cls>"
        },
        {
          "type": "EXPRESSION",
          "id": "<new cls()>",
          "metadata": {
            "operator": "new"
          }
        },
        {
          "type": "CALL",
          "id": "<registerClass(class InlinePlugin)>",
          "metadata": {
            "callee": "registerClass"
          }
        },
        {
          "type": "CLASS",
          "id": "<InlinePlugin>",
          "metadata": {
            "inline": true
          }
        },
        {
          "type": "METHOD",
          "id": "<InlinePlugin.activate>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<registerClass>",
            "dst": "<cls>",
            "type": "CONTAINS"
          },
          {
            "src": "<registerClass>",
            "dst": "<new cls()>",
            "type": "RETURNS"
          },
          {
            "src": "<registerClass(class InlinePlugin)>",
            "dst": "<InlinePlugin>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<InlinePlugin>",
            "dst": "<InlinePlugin.activate>",
            "type": "CONTAINS"
          },
          {
            "src": "<InlinePlugin.activate>",
            "dst": "<true>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<new cls()>",
            "dst": "<cls>",
            "type": "READS_FROM"
          },
          {
            "src": "<registerClass(class InlinePlugin)>",
            "dst": "<registerClass>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-module-var-read",
      "category": "closures",
      "code": "let requestCount = 0;\n\nfunction getRequestCount() {\n  return requestCount;\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<requestCount>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getRequestCount>",
          "metadata": {
            "async": false,
            "generator": false
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<requestCount>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<getRequestCount>",
            "type": "DECLARES"
          },
          {
            "src": "<getRequestCount>",
            "dst": "<requestCount>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<requestCount>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<getRequestCount>",
            "dst": "<requestCount>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<getRequestCount>",
            "dst": "<requestCount>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::super-in-field-initializer",
      "category": "classes",
      "code": "class FieldParent {\n  getDefaults() { return { timeout: 5000 }; }\n}\n\nclass FieldChild extends FieldParent {\n  defaults = super.getDefaults(); // super in instance field initializer\n}\n\n// --- Interleaved static blocks and static fields ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<FieldParent>"
        },
        {
          "type": "METHOD",
          "id": "<FieldParent.getDefaults>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ timeout: 5000 }>",
          "metadata": {
            "value": "{ timeout: 5000 }",
            "literalType": "object"
          }
        },
        {
          "type": "CLASS",
          "id": "<FieldChild>"
        },
        {
          "type": "PROPERTY",
          "id": "<FieldChild.defaults>",
          "metadata": {
            "kind": "instance"
          }
        },
        {
          "type": "CALL",
          "id": "<super.getDefaults()>",
          "metadata": {
            "callee": "super.getDefaults"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<super.getDefaults>",
          "metadata": {
            "property": "getDefaults",
            "object": "super"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<FieldParent>",
            "dst": "<FieldParent.getDefaults>",
            "type": "CONTAINS"
          },
          {
            "src": "<FieldParent.getDefaults>",
            "dst": "<{ timeout: 5000 }>",
            "type": "RETURNS"
          },
          {
            "src": "<FieldChild>",
            "dst": "<FieldChild.defaults>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<FieldChild.defaults>",
            "dst": "<super.getDefaults()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<FieldChild>",
            "dst": "<FieldParent>",
            "type": "EXTENDS"
          },
          {
            "src": "<super.getDefaults()>",
            "dst": "<super.getDefaults>",
            "type": "CALLS"
          },
          {
            "src": "<super.getDefaults>",
            "dst": "<FieldParent.getDefaults>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-module-var-write",
      "category": "closures",
      "code": "function incrementRequestCount() {\n  requestCount++;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<incrementRequestCount>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<requestCount++>",
          "metadata": {
            "operator": "++"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<incrementRequestCount>",
            "type": "DECLARES"
          },
          {
            "src": "<incrementRequestCount>",
            "dst": "<requestCount++>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<requestCount++>",
            "dst": "<requestCount>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<requestCount++>",
            "dst": "<requestCount>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::class-in-ternary",
      "category": "classes",
      "code": "const StrategyClass = Math.random() > 0.5\n  ? class Aggressive { execute() { return 'fast'; } }\n  : class Conservative { execute() { return 'slow'; } };",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<StrategyClass>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Math.random() > 0.5>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.random()>",
          "metadata": {
            "callee": "Math.random"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0.5>",
          "metadata": {
            "value": 0.5,
            "literalType": "number"
          }
        },
        {
          "type": "CLASS",
          "id": "<Aggressive>",
          "metadata": {
            "anonymous": false
          }
        },
        {
          "type": "METHOD",
          "id": "<Aggressive.execute>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fast'>",
          "metadata": {
            "value": "fast",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<Conservative>",
          "metadata": {
            "anonymous": false
          }
        },
        {
          "type": "METHOD",
          "id": "<Conservative.execute>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'slow'>",
          "metadata": {
            "value": "slow",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ternary>",
            "dst": "<Math.random() > 0.5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary>",
            "dst": "<Aggressive>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Aggressive>",
            "dst": "<Aggressive.execute>",
            "type": "CONTAINS"
          },
          {
            "src": "<Aggressive.execute>",
            "dst": "<'fast'>",
            "type": "RETURNS"
          },
          {
            "src": "<Conservative>",
            "dst": "<Conservative.execute>",
            "type": "CONTAINS"
          },
          {
            "src": "<Conservative.execute>",
            "dst": "<'slow'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<StrategyClass>",
            "dst": "<ternary>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ternary>",
            "dst": "<Conservative>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<Math.random()>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.random() > 0.5>",
            "dst": "<0.5>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.random()>",
            "dst": "<Math.random>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-factory-multiplier",
      "category": "closures",
      "code": "function createMultiplier(factor) {\n  return (x) => x * factor;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createMultiplier>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<factor>"
        },
        {
          "type": "FUNCTION",
          "id": "<createMultiplier:returnFn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * factor>",
          "metadata": {
            "operator": "*"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createMultiplier>",
            "dst": "<factor>",
            "type": "HAS_BODY"
          },
          {
            "src": "<createMultiplier>",
            "dst": "<createMultiplier:returnFn>",
            "type": "RETURNS"
          },
          {
            "src": "<createMultiplier:returnFn>",
            "dst": "<x>",
            "type": "HAS_BODY"
          },
          {
            "src": "<createMultiplier:returnFn>",
            "dst": "<x * factor>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<createMultiplier:returnFn>",
            "dst": "<factor>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<x * factor>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * factor>",
            "dst": "<factor>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::super-in-static-method",
      "category": "classes",
      "code": "class StaticParent {\n  static defaultConfig() { return { timeout: 5000 }; }\n  static instances = [];\n}\n\nclass StaticChild extends StaticParent {\n  static defaultConfig() {\n    const base = super.defaultConfig(); // super = StaticParent (constructor, not prototype)\n    return { ...base, retries: 3 };\n  }\n\n  static allInstances = [...super.instances]; // super in static field initializer\n}\n\n// --- super in field initializers ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<StaticParent>"
        },
        {
          "type": "METHOD",
          "id": "<StaticParent.defaultConfig>",
          "metadata": {
            "kind": "static",
            "static": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ timeout: 5000 }>",
          "metadata": {
            "value": "{ timeout: 5000 }",
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<StaticParent.instances>",
          "metadata": {
            "kind": "static",
            "static": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "CLASS",
          "id": "<StaticChild>"
        },
        {
          "type": "METHOD",
          "id": "<StaticChild.defaultConfig>",
          "metadata": {
            "kind": "static",
            "static": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<base>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<super.defaultConfig()>",
          "metadata": {
            "callee": "super.defaultConfig",
            "superCall": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...base, retries: 3 }>",
          "metadata": {
            "operator": "spread"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<StaticChild.allInstances>",
          "metadata": {
            "kind": "static",
            "static": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[...super.instances]>",
          "metadata": {
            "operator": "spread"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<super.instances>",
          "metadata": {
            "objectName": "super",
            "propertyName": "instances",
            "superAccess": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<StaticParent>",
            "dst": "<StaticParent.defaultConfig>",
            "type": "CONTAINS"
          },
          {
            "src": "<StaticParent>",
            "dst": "<StaticParent.instances>",
            "type": "CONTAINS"
          },
          {
            "src": "<StaticParent.defaultConfig>",
            "dst": "<{ timeout: 5000 }>",
            "type": "RETURNS"
          },
          {
            "src": "<StaticChild>",
            "dst": "<StaticChild.defaultConfig>",
            "type": "CONTAINS"
          },
          {
            "src": "<StaticChild>",
            "dst": "<StaticChild.allInstances>",
            "type": "CONTAINS"
          },
          {
            "src": "<StaticChild.defaultConfig>",
            "dst": "<base>",
            "type": "CONTAINS"
          },
          {
            "src": "<StaticChild.defaultConfig>",
            "dst": "<{ ...base, retries: 3 }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<StaticParent.instances>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<base>",
            "dst": "<super.defaultConfig()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<StaticChild.allInstances>",
            "dst": "<[...super.instances]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<StaticChild>",
            "dst": "<StaticParent>",
            "type": "EXTENDS"
          },
          {
            "src": "<super.defaultConfig()>",
            "dst": "<StaticParent.defaultConfig>",
            "type": "CALLS"
          },
          {
            "src": "<{ ...base, retries: 3 }>",
            "dst": "<base>",
            "type": "READS_FROM"
          },
          {
            "src": "<[...super.instances]>",
            "dst": "<super.instances>",
            "type": "READS_FROM"
          },
          {
            "src": "<super.instances>",
            "dst": "<StaticParent.instances>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::for-await-sync-iterable",
      "category": "async-generators",
      "code": "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array  each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forAwaitSyncIterable>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-await>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "value": [
              1,
              2,
              3
            ],
            "literalType": "array"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(item)>",
          "metadata": {
            "callee": "push",
            "method": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return results>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<for-await>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await>",
            "dst": "<[1, 2, 3]>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await>",
            "dst": "<results.push(item)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<return results>",
            "type": "CONTAINS"
          },
          {
            "src": "<forAwaitSyncIterable>",
            "dst": "<return results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(item)>",
            "dst": "<results>",
            "type": "CALLS_ON"
          },
          {
            "src": "<return results>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-factory-counter",
      "category": "closures",
      "code": "function createCounter(initial = 0) {\n  let count = initial;\n  return {\n    increment() { return ++count; },\n    decrement() { return --count; },\n    value() { return count; },\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createCounter>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<initial>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<count>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<object-literal>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<increment>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<++count>",
          "metadata": {
            "operator": "++",
            "prefix": true
          }
        },
        {
          "type": "METHOD",
          "id": "<decrement>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<--count>",
          "metadata": {
            "operator": "--",
            "prefix": true
          }
        },
        {
          "type": "METHOD",
          "id": "<value>",
          "metadata": {
            "kind": "method"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createCounter>",
            "dst": "<initial>",
            "type": "CONTAINS"
          },
          {
            "src": "<initial>",
            "dst": "<0>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<createCounter>",
            "dst": "<count>",
            "type": "CONTAINS"
          },
          {
            "src": "<createCounter>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<increment>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<decrement>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<value>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<increment>",
            "dst": "<++count>",
            "type": "RETURNS"
          },
          {
            "src": "<decrement>",
            "dst": "<--count>",
            "type": "RETURNS"
          },
          {
            "src": "<value>",
            "dst": "<count>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<count>",
            "dst": "<initial>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<++count>",
            "dst": "<count>",
            "type": "MODIFIES"
          },
          {
            "src": "<--count>",
            "dst": "<count>",
            "type": "MODIFIES"
          },
          {
            "src": "<increment>",
            "dst": "<count>",
            "type": "CAPTURES"
          },
          {
            "src": "<decrement>",
            "dst": "<count>",
            "type": "CAPTURES"
          },
          {
            "src": "<value>",
            "dst": "<count>",
            "type": "CAPTURES"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "classes::private-field-proxy-trap",
      "category": "classes",
      "code": "class SecureService {\n  #secret = 42;\n  getSecret() { return this.#secret; }\n}\n\nfunction proxyPrivateDemo() {\n  const instance = new SecureService();\n  const proxy = new Proxy(instance, {});\n  // proxy.getSecret()  TypeError: #secret not accessible through Proxy\n  return { instance, proxy };\n}\n\n// --- Class expressions in various positions ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<SecureService>"
        },
        {
          "type": "PROPERTY",
          "id": "<#secret>",
          "metadata": {
            "name": "secret",
            "visibility": "private"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<SecureService.getSecret>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.#secret>",
          "metadata": {
            "property": "secret",
            "isPrivate": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<proxyPrivateDemo>"
        },
        {
          "type": "VARIABLE",
          "id": "<instance>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new SecureService()>",
          "metadata": {
            "callee": "SecureService",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<proxy>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Proxy(instance, {})>",
          "metadata": {
            "callee": "Proxy",
            "isConstructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ instance, proxy }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<SecureService>",
            "dst": "<#secret>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<SecureService>",
            "dst": "<SecureService.getSecret>",
            "type": "CONTAINS"
          },
          {
            "src": "<SecureService.getSecret>",
            "dst": "<this.#secret>",
            "type": "RETURNS"
          },
          {
            "src": "<proxyPrivateDemo>",
            "dst": "<instance>",
            "type": "CONTAINS"
          },
          {
            "src": "<proxyPrivateDemo>",
            "dst": "<proxy>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Proxy(instance, {})>",
            "dst": "<instance>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Proxy(instance, {})>",
            "dst": "<{}>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<proxyPrivateDemo>",
            "dst": "<{ instance, proxy }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<#secret>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<instance>",
            "dst": "<new SecureService()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<proxy>",
            "dst": "<new Proxy(instance, {})>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this.#secret>",
            "dst": "<#secret>",
            "type": "READS_FROM"
          },
          {
            "src": "<new SecureService()>",
            "dst": "<SecureService>",
            "type": "CALLS"
          },
          {
            "src": "<{ instance, proxy }>",
            "dst": "<instance>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ instance, proxy }>",
            "dst": "<proxy>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-shared-state",
      "category": "closures",
      "code": "let sharedCache = {};\n\nfunction setCache(key, value) {\n  sharedCache[key] = value;\n}\n\nfunction getCache(key) {\n  return sharedCache[key];\n}\n\nfunction clearCache() {\n  sharedCache = {};\n}\n\n// --- Factory functions returning closures ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<sharedCache>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<setCache>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<sharedCache[key]>",
          "metadata": {
            "objectName": "sharedCache",
            "computed": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getCache>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key2>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<sharedCache[key2]>",
          "metadata": {
            "objectName": "sharedCache",
            "computed": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<clearCache>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}2>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<setCache>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<setCache>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<getCache>",
            "dst": "<key2>",
            "type": "CONTAINS"
          },
          {
            "src": "<getCache>",
            "dst": "<sharedCache[key2]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<sharedCache>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<setCache>",
            "dst": "<sharedCache>",
            "type": "CAPTURES"
          },
          {
            "src": "<sharedCache[key]>",
            "dst": "<value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<setCache>",
            "dst": "<sharedCache[key]>",
            "type": "WRITES_TO"
          },
          {
            "src": "<getCache>",
            "dst": "<sharedCache>",
            "type": "CAPTURES"
          },
          {
            "src": "<clearCache>",
            "dst": "<sharedCache>",
            "type": "CAPTURES"
          },
          {
            "src": "<sharedCache>",
            "dst": "<{}2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<clearCache>",
            "dst": "<sharedCache>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<sharedCache[key]>",
            "dst": "<sharedCache>",
            "type": "READS_FROM"
          },
          {
            "src": "<sharedCache[key]>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<sharedCache[key2]>",
            "dst": "<sharedCache>",
            "type": "READS_FROM"
          },
          {
            "src": "<sharedCache[key2]>",
            "dst": "<key2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-factory-accumulator",
      "category": "closures",
      "code": "function createAccumulator() {\n  const items = [];\n  return {\n    add(item) { items.push(item); },\n    getAll() { return [...items]; },\n    count() { return items.length; },\n  };\n}\n\n// --- Closure over loop variable ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createAccumulator>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<items>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<object-literal>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<add>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "CALL",
          "id": "<items.push(item)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<items.push>",
          "metadata": {
            "objectName": "items",
            "propertyName": "push"
          }
        },
        {
          "type": "METHOD",
          "id": "<getAll>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[...items]>",
          "metadata": {
            "type": "spread",
            "operator": "..."
          }
        },
        {
          "type": "METHOD",
          "id": "<count>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<items.length>",
          "metadata": {
            "objectName": "items",
            "propertyName": "length"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createAccumulator>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<createAccumulator>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<add>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<getAll>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<count>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<add>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<add>",
            "dst": "<items.push(item)>",
            "type": "CONTAINS"
          },
          {
            "src": "<items.push(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getAll>",
            "dst": "<[...items]>",
            "type": "RETURNS"
          },
          {
            "src": "<count>",
            "dst": "<items.length>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<items>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<add>",
            "dst": "<items>",
            "type": "CAPTURES"
          },
          {
            "src": "<getAll>",
            "dst": "<items>",
            "type": "CAPTURES"
          },
          {
            "src": "<count>",
            "dst": "<items>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<items.push(item)>",
            "dst": "<items.push>",
            "type": "CALLS"
          },
          {
            "src": "<items.push>",
            "dst": "<items>",
            "type": "READS_FROM"
          },
          {
            "src": "<[...items]>",
            "dst": "<items>",
            "type": "READS_FROM"
          },
          {
            "src": "<items.length>",
            "dst": "<items>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-nested-deep",
      "category": "closures",
      "code": "function outermost(a) {\n  return function middle(b) {\n    return function innermost(c) {\n      return a + b + c;\n    };\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<outermost>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "FUNCTION",
          "id": "<middle>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "FUNCTION",
          "id": "<innermost>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<c>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b + c>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<outermost>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<outermost>",
            "dst": "<middle>",
            "type": "RETURNS"
          },
          {
            "src": "<middle>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<middle>",
            "dst": "<innermost>",
            "type": "RETURNS"
          },
          {
            "src": "<innermost>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<innermost>",
            "dst": "<a + b + c>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<middle>",
            "dst": "<a>",
            "type": "CAPTURES"
          },
          {
            "src": "<innermost>",
            "dst": "<a>",
            "type": "CAPTURES"
          },
          {
            "src": "<innermost>",
            "dst": "<b>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<a + b + c>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b + c>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b + c>",
            "dst": "<c>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "classes::new-target-arrow-capture",
      "category": "classes",
      "code": "class AbstractFactory {\n  constructor() {\n    // new.target captured by arrow  like this/super, lexically bound\n    const getTarget = () => new.target;\n\n    if (getTarget() === AbstractFactory) {\n      throw new Error('AbstractFactory is abstract  use a subclass');\n    }\n\n    // Store for lazy cloning  arrow captures new.target from constructor\n    this._clone = () => new (new.target)();\n  }\n}\n\nclass ConcreteFactory extends AbstractFactory {\n  constructor() {\n    super(); // new.target === ConcreteFactory inside AbstractFactory\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<AbstractFactory>"
        },
        {
          "type": "METHOD",
          "id": "<AbstractFactory.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getTarget>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getTarget:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<new.target>",
          "metadata": {
            "property": "target",
            "meta": "new"
          }
        },
        {
          "type": "CALL",
          "id": "<getTarget()>",
          "metadata": {
            "callee": "getTarget"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<getTarget() === AbstractFactory>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-abstract-check>"
        },
        {
          "type": "CALL",
          "id": "<throw new Error(...)>",
          "metadata": {
            "callee": "Error",
            "isThrow": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'AbstractFactory is abstract  use a subclass'>",
          "metadata": {
            "value": "AbstractFactory is abstract  use a subclass",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this._clone>",
          "metadata": {
            "objectName": "this",
            "property": "_clone"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<_clone:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "CALL",
          "id": "<new (new.target)()>",
          "metadata": {
            "isConstructorCall": true
          }
        },
        {
          "type": "CLASS",
          "id": "<ConcreteFactory>"
        },
        {
          "type": "METHOD",
          "id": "<ConcreteFactory.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "CALL",
          "id": "<super()>",
          "metadata": {
            "callee": "super",
            "isSuperCall": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<AbstractFactory>",
            "dst": "<AbstractFactory.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<AbstractFactory.constructor>",
            "dst": "<getTarget>",
            "type": "DECLARES"
          },
          {
            "src": "<getTarget:fn>",
            "dst": "<new.target>",
            "type": "RETURNS"
          },
          {
            "src": "<AbstractFactory.constructor>",
            "dst": "<if-abstract-check>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-abstract-check>",
            "dst": "<getTarget() === AbstractFactory>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-abstract-check>",
            "dst": "<throw new Error(...)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<throw new Error(...)>",
            "dst": "<'AbstractFactory is abstract  use a subclass'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<_clone:fn>",
            "dst": "<new (new.target)()>",
            "type": "RETURNS"
          },
          {
            "src": "<ConcreteFactory>",
            "dst": "<ConcreteFactory.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<ConcreteFactory.constructor>",
            "dst": "<super()>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<getTarget>",
            "dst": "<getTarget:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<getTarget:fn>",
            "dst": "<new.target>",
            "type": "CAPTURES"
          },
          {
            "src": "<AbstractFactory.constructor>",
            "dst": "<this._clone>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this._clone>",
            "dst": "<_clone:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<_clone:fn>",
            "dst": "<new.target>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<getTarget() === AbstractFactory>",
            "dst": "<getTarget()>",
            "type": "READS_FROM"
          },
          {
            "src": "<getTarget() === AbstractFactory>",
            "dst": "<AbstractFactory>",
            "type": "READS_FROM"
          },
          {
            "src": "<getTarget()>",
            "dst": "<getTarget>",
            "type": "CALLS"
          },
          {
            "src": "<new (new.target)()>",
            "dst": "<new.target>",
            "type": "CALLS"
          },
          {
            "src": "<ConcreteFactory>",
            "dst": "<AbstractFactory>",
            "type": "EXTENDS"
          },
          {
            "src": "<super()>",
            "dst": "<AbstractFactory.constructor>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-loop-let-fix",
      "category": "closures",
      "code": "function closureLoopLetFix() {\n  const funcs = [];\n  for (let i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // each returns 0,1,2,3,4\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<closureLoopLetFix>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<funcs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 5>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "CALL",
          "id": "<funcs.push(...)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<anonymous-closure>",
          "metadata": {
            "async": false,
            "generator": false,
            "anonymous": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<funcs.push>",
          "metadata": {
            "property": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<closureLoopLetFix>",
            "dst": "<funcs>",
            "type": "CONTAINS"
          },
          {
            "src": "<closureLoopLetFix>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<funcs.push(...)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<funcs.push(...)>",
            "dst": "<anonymous-closure>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<anonymous-closure>",
            "dst": "<i>",
            "type": "RETURNS"
          },
          {
            "src": "<closureLoopLetFix>",
            "dst": "<funcs>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<funcs>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<anonymous-closure>",
            "dst": "<i>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<i < 5>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          },
          {
            "src": "<funcs.push(...)>",
            "dst": "<funcs.push>",
            "type": "CALLS"
          },
          {
            "src": "<funcs.push>",
            "dst": "<funcs>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-generator-destructure-default",
      "category": "async-generators",
      "code": "async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<processStream>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<source>"
        },
        {
          "type": "LOOP",
          "id": "<for-await-of>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<priority>",
          "metadata": {
            "kind": "const",
            "destructured": true,
            "nested": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'normal'>",
          "metadata": {
            "value": "normal",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...data, priority }>",
          "metadata": {
            "type": "object-spread"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield { ...data, priority }>",
          "metadata": {
            "type": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<processStream>",
            "dst": "<source>",
            "type": "HAS_BODY"
          },
          {
            "src": "<processStream>",
            "dst": "<for-await-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<source>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await-of>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<priority>",
            "type": "CONTAINS"
          },
          {
            "src": "<priority>",
            "dst": "<'normal'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<{ ...data, priority }>",
            "dst": "<data>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<yield { ...data, priority }>",
            "dst": "<{ ...data, priority }>",
            "type": "YIELDS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<yield { ...data, priority }>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<{ ...data, priority }>",
            "dst": "<priority>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::this-module-level",
      "category": "closures",
      "code": "// In ESM: `this` is `undefined` at top level\nconst thisAtModuleLevel = this; // undefined in ESM, module.exports in CJS\n\n// --- Named function expression as argument (self-referencing) ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<thisAtModuleLevel>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<this>",
          "metadata": {
            "property": "this",
            "context": "module-level",
            "value": "undefined in ESM, module.exports in CJS"
          }
        },
        {
          "type": "MODULE",
          "id": "<module>",
          "metadata": {
            "type": "ESM"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<thisAtModuleLevel>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<thisAtModuleLevel>",
            "dst": "<this>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this>",
            "dst": "<module>",
            "type": "DEPENDS_ON"
          }
        ]
      }
    },
    {
      "constructId": "closures::this-method-context",
      "category": "closures",
      "code": "const obj = {\n  name: 'context',\n  getName() {\n    return this.name;\n  },\n  getNameArrow: () => {\n    return this.name; // `this` is module/global, not obj\n  },\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<obj-literal>",
          "metadata": {
            "objectLiteral": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'context'>",
          "metadata": {
            "value": "context",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<getName>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name-method>",
          "metadata": {
            "objectName": "this",
            "propertyName": "name"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getNameArrow>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name-arrow>",
          "metadata": {
            "objectName": "this",
            "propertyName": "name"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<obj-literal>",
            "dst": "<'context'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<obj-literal>",
            "dst": "<getName>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<obj-literal>",
            "dst": "<getNameArrow>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<getName>",
            "dst": "<this.name-method>",
            "type": "RETURNS"
          },
          {
            "src": "<getNameArrow>",
            "dst": "<this.name-arrow>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<obj-literal>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this.name-method>",
            "dst": "<obj-literal>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-loop-var-bug",
      "category": "closures",
      "code": "function closureLoopVarBug() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // all return 5\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<closureLoopVarBug>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<funcs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 5>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "CALL",
          "id": "<funcs.push(...)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<anonymous-closure>",
          "metadata": {
            "async": false,
            "generator": false,
            "anonymous": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return i>",
          "metadata": {
            "operator": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<closureLoopVarBug>",
            "dst": "<funcs>",
            "type": "CONTAINS"
          },
          {
            "src": "<closureLoopVarBug>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<funcs.push(...)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<funcs.push(...)>",
            "dst": "<anonymous-closure>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<anonymous-closure>",
            "dst": "<return i>",
            "type": "RETURNS"
          },
          {
            "src": "<closureLoopVarBug>",
            "dst": "<funcs>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<funcs>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<anonymous-closure>",
            "dst": "<i>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<i < 5>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          },
          {
            "src": "<funcs.push(...)>",
            "dst": "<funcs>",
            "type": "CALLS_ON"
          },
          {
            "src": "<return i>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-loop-iife-fix",
      "category": "closures",
      "code": "function closureLoopIifeFix() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push((function (captured) {\n      return function () { return captured; };\n    })(i));\n  }\n  return funcs;\n}\n\n// --- Nested closures (3+ levels) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<closureLoopIifeFix>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<funcs>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 5>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "CALL",
          "id": "<funcs.push(...)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<iife>",
          "metadata": {
            "async": false,
            "generator": false,
            "iife": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<captured>"
        },
        {
          "type": "FUNCTION",
          "id": "<inner-closure>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<iife-call>",
          "metadata": {
            "callee": "iife"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<closureLoopIifeFix>",
            "dst": "<funcs>",
            "type": "CONTAINS"
          },
          {
            "src": "<closureLoopIifeFix>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<funcs.push(...)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<funcs.push(...)>",
            "dst": "<iife-call>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<iife-call>",
            "dst": "<i>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<iife>",
            "dst": "<captured>",
            "type": "CONTAINS"
          },
          {
            "src": "<iife>",
            "dst": "<inner-closure>",
            "type": "RETURNS"
          },
          {
            "src": "<inner-closure>",
            "dst": "<captured>",
            "type": "RETURNS"
          },
          {
            "src": "<closureLoopIifeFix>",
            "dst": "<funcs>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<funcs>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<captured>",
            "dst": "<i>",
            "type": "CAPTURES"
          },
          {
            "src": "<inner-closure>",
            "dst": "<captured>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<i < 5>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          },
          {
            "src": "<funcs.push(...)>",
            "dst": "<funcs>",
            "type": "CALLS_ON"
          },
          {
            "src": "<iife-call>",
            "dst": "<iife>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-module-pattern",
      "category": "closures",
      "code": "const counterModule = (function () {\n  let count = 0;\n  return {\n    increment() { count++; },\n    decrement() { count--; },\n    getCount() { return count; },\n  };\n})();\n\n// --- Memoization via closure ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<counterModule>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<counterModule:iife>",
          "metadata": {
            "iife": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<count>",
          "metadata": {
            "kind": "let",
            "closureVariable": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<counterModule:object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<increment>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<count++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "METHOD",
          "id": "<decrement>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<count-->",
          "metadata": {
            "operator": "--"
          }
        },
        {
          "type": "METHOD",
          "id": "<getCount>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<counterModule:iife-call>",
          "metadata": {
            "callee": "counterModule:iife"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<counterModule:iife>",
            "dst": "<count>",
            "type": "DECLARES"
          },
          {
            "src": "<counterModule:iife>",
            "dst": "<counterModule:object>",
            "type": "RETURNS"
          },
          {
            "src": "<counterModule:object>",
            "dst": "<increment>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<counterModule:object>",
            "dst": "<decrement>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<counterModule:object>",
            "dst": "<getCount>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<increment>",
            "dst": "<count++>",
            "type": "CONTAINS"
          },
          {
            "src": "<decrement>",
            "dst": "<count-->",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<counterModule>",
            "dst": "<counterModule:iife-call>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<count>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<count++>",
            "dst": "<count>",
            "type": "MODIFIES"
          },
          {
            "src": "<count-->",
            "dst": "<count>",
            "type": "MODIFIES"
          },
          {
            "src": "<increment>",
            "dst": "<count>",
            "type": "CAPTURES"
          },
          {
            "src": "<decrement>",
            "dst": "<count>",
            "type": "CAPTURES"
          },
          {
            "src": "<getCount>",
            "dst": "<count>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<counterModule:iife-call>",
            "dst": "<counterModule:iife>",
            "type": "CALLS"
          },
          {
            "src": "<getCount>",
            "dst": "<count>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::this-bind",
      "category": "closures",
      "code": "function thisBind() {\n  function greet(greeting) {\n    return `${greeting}, ${this.name}`;\n  }\n  const user = { name: 'Alice' };\n  const bound = greet.bind(user);\n  return bound('Hello');\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<thisBind>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "FUNCTION",
          "id": "<greet>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<greeting>"
        },
        {
          "type": "EXPRESSION",
          "id": "<`${greeting}, ${this.name}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this",
            "property": "name"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<user>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ name: 'Alice' }>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Alice'>",
          "metadata": {
            "value": "Alice",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<bound>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<greet.bind(user)>",
          "metadata": {
            "callee": "bind",
            "method": true
          }
        },
        {
          "type": "CALL",
          "id": "<bound('Hello')>",
          "metadata": {
            "callee": "bound"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Hello'>",
          "metadata": {
            "value": "Hello",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<thisBind>",
            "dst": "<greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<greet>",
            "dst": "<greeting>",
            "type": "DECLARES"
          },
          {
            "src": "<greet>",
            "dst": "<`${greeting}, ${this.name}`>",
            "type": "RETURNS"
          },
          {
            "src": "<thisBind>",
            "dst": "<user>",
            "type": "DECLARES"
          },
          {
            "src": "<{ name: 'Alice' }>",
            "dst": "<'Alice'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<thisBind>",
            "dst": "<bound>",
            "type": "DECLARES"
          },
          {
            "src": "<greet.bind(user)>",
            "dst": "<user>",
            "type": "BINDS_THIS_TO"
          },
          {
            "src": "<thisBind>",
            "dst": "<bound('Hello')>",
            "type": "RETURNS"
          },
          {
            "src": "<bound('Hello')>",
            "dst": "<'Hello'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<user>",
            "dst": "<{ name: 'Alice' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<bound>",
            "dst": "<greet.bind(user)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`${greeting}, ${this.name}`>",
            "dst": "<greeting>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${greeting}, ${this.name}`>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<bound('Hello')>",
            "dst": "<bound>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::this-in-class-callback",
      "category": "closures",
      "code": "class EventHandler {\n  constructor(name) {\n    this.name = name;\n    this.handleBound = this.handle.bind(this);\n  }\n\n  handle(event) {\n    return `${this.name}: ${event}`;\n  }\n\n  handleArrow = (event) => {\n    return `${this.name}: ${event}`;\n  };\n}\n\n// --- Closure as private scope ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<EventHandler>"
        },
        {
          "type": "METHOD",
          "id": "<EventHandler.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.handleBound>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "CALL",
          "id": "<this.handle.bind(this)>",
          "metadata": {
            "callee": "bind"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.handle>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<EventHandler.handle>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<event>"
        },
        {
          "type": "EXPRESSION",
          "id": "<`${this.name}: ${event}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "METHOD",
          "id": "<EventHandler.handleArrow>",
          "metadata": {
            "kind": "arrow-method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<event:arrow>"
        },
        {
          "type": "EXPRESSION",
          "id": "<`${this.name}: ${event}`:arrow>",
          "metadata": {
            "type": "template-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<EventHandler>",
            "dst": "<EventHandler.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<EventHandler>",
            "dst": "<EventHandler.handle>",
            "type": "CONTAINS"
          },
          {
            "src": "<EventHandler>",
            "dst": "<EventHandler.handleArrow>",
            "type": "CONTAINS"
          },
          {
            "src": "<EventHandler.constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.handle.bind(this)>",
            "dst": "<this>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<EventHandler.handle>",
            "dst": "<event>",
            "type": "CONTAINS"
          },
          {
            "src": "<EventHandler.handle>",
            "dst": "<`${this.name}: ${event}`>",
            "type": "RETURNS"
          },
          {
            "src": "<EventHandler.handleArrow>",
            "dst": "<event:arrow>",
            "type": "CONTAINS"
          },
          {
            "src": "<EventHandler.handleArrow>",
            "dst": "<`${this.name}: ${event}`:arrow>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.handleBound>",
            "dst": "<this.handle.bind(this)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<EventHandler.handleArrow>",
            "dst": "<this>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<this.handle.bind(this)>",
            "dst": "<this.handle>",
            "type": "CALLS"
          },
          {
            "src": "<`${this.name}: ${event}`>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${this.name}: ${event}`>",
            "dst": "<event>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${this.name}: ${event}`:arrow>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${this.name}: ${event}`:arrow>",
            "dst": "<event:arrow>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::named-func-expr-as-argument",
      "category": "closures",
      "code": "let retryDone = false;\nsetTimeout(function retry() {\n  if (!retryDone) setTimeout(retry, 1000); // self-reference for recursive scheduling\n}, 1000);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<retryDone>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout(function retry() {...}, 1000)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<retry>",
          "metadata": {
            "named": true,
            "expression": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1000>",
          "metadata": {
            "value": 1000,
            "literalType": "number"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if (!retryDone)>",
          "metadata": {
            "condition": "!retryDone"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!retryDone>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout(retry, 1000)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1000-inner>",
          "metadata": {
            "value": 1000,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<setTimeout(function retry() {...}, 1000)>",
            "dst": "<retry>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(function retry() {...}, 1000)>",
            "dst": "<1000>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<retry>",
            "dst": "<if (!retryDone)>",
            "type": "CONTAINS"
          },
          {
            "src": "<if (!retryDone)>",
            "dst": "<!retryDone>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if (!retryDone)>",
            "dst": "<setTimeout(retry, 1000)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<setTimeout(retry, 1000)>",
            "dst": "<1000-inner>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<retryDone>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<retry>",
            "dst": "<retryDone>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<!retryDone>",
            "dst": "<retryDone>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-nested-mutation",
      "category": "closures",
      "code": "function createTracker() {\n  let total = 0;\n  function addGroup(groupName) {\n    let groupTotal = 0;\n    return function addItem(value) {\n      groupTotal += value;\n      total += value;\n      return { groupName, groupTotal, total };\n    };\n  }\n  return { addGroup, getTotal: () => total };\n}\n\n// --- this binding ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createTracker>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<total>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<addGroup>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<groupName>"
        },
        {
          "type": "VARIABLE",
          "id": "<groupTotal>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-inner>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<addItem>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "EXPRESSION",
          "id": "<groupTotal += value>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<total += value>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ groupName, groupTotal, total }>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getTotal>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ addGroup, getTotal: () => total }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createTracker>",
            "dst": "<total>",
            "type": "CONTAINS"
          },
          {
            "src": "<createTracker>",
            "dst": "<addGroup>",
            "type": "CONTAINS"
          },
          {
            "src": "<addGroup>",
            "dst": "<groupName>",
            "type": "CONTAINS"
          },
          {
            "src": "<addGroup>",
            "dst": "<groupTotal>",
            "type": "CONTAINS"
          },
          {
            "src": "<addGroup>",
            "dst": "<addItem>",
            "type": "CONTAINS"
          },
          {
            "src": "<addGroup>",
            "dst": "<addItem>",
            "type": "RETURNS"
          },
          {
            "src": "<addItem>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<addItem>",
            "dst": "<groupTotal += value>",
            "type": "CONTAINS"
          },
          {
            "src": "<addItem>",
            "dst": "<total += value>",
            "type": "CONTAINS"
          },
          {
            "src": "<addItem>",
            "dst": "<{ groupName, groupTotal, total }>",
            "type": "RETURNS"
          },
          {
            "src": "<createTracker>",
            "dst": "<getTotal>",
            "type": "CONTAINS"
          },
          {
            "src": "<createTracker>",
            "dst": "<{ addGroup, getTotal: () => total }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<total>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<groupTotal>",
            "dst": "<0-inner>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<groupTotal += value>",
            "dst": "<groupTotal>",
            "type": "WRITES_TO"
          },
          {
            "src": "<total += value>",
            "dst": "<total>",
            "type": "WRITES_TO"
          },
          {
            "src": "<addItem>",
            "dst": "<total>",
            "type": "CAPTURES"
          },
          {
            "src": "<addItem>",
            "dst": "<groupTotal>",
            "type": "CAPTURES"
          },
          {
            "src": "<addItem>",
            "dst": "<groupName>",
            "type": "CAPTURES"
          },
          {
            "src": "<getTotal>",
            "dst": "<total>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<groupTotal += value>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<total += value>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ groupName, groupTotal, total }>",
            "dst": "<groupName>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ groupName, groupTotal, total }>",
            "dst": "<groupTotal>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ groupName, groupTotal, total }>",
            "dst": "<total>",
            "type": "READS_FROM"
          },
          {
            "src": "<getTotal>",
            "dst": "<total>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ addGroup, getTotal: () => total }>",
            "dst": "<addGroup>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ addGroup, getTotal: () => total }>",
            "dst": "<getTotal>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "closures::this-call-apply",
      "category": "closures",
      "code": "function thisCallApply() {\n  function introduce(role) {\n    return `${this.name} is ${role}`;\n  }\n  const person = { name: 'Bob' };\n  const viaCall = introduce.call(person, 'admin');\n  const viaApply = introduce.apply(person, ['admin']);\n  return { viaCall, viaApply };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<thisCallApply>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "FUNCTION",
          "id": "<introduce>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<role>"
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<person>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Bob'>",
          "metadata": {
            "value": "Bob",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<viaCall>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<introduce.call>",
          "metadata": {
            "method": "call",
            "thisBinding": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'admin'>",
          "metadata": {
            "value": "admin",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<viaApply>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<introduce.apply>",
          "metadata": {
            "method": "apply",
            "thisBinding": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<array-literal>",
          "metadata": {
            "type": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<return-object>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<thisCallApply>",
            "dst": "<introduce>",
            "type": "CONTAINS"
          },
          {
            "src": "<introduce>",
            "dst": "<role>",
            "type": "CONTAINS"
          },
          {
            "src": "<introduce>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<thisCallApply>",
            "dst": "<person>",
            "type": "CONTAINS"
          },
          {
            "src": "<object-literal>",
            "dst": "<'Bob'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<thisCallApply>",
            "dst": "<viaCall>",
            "type": "CONTAINS"
          },
          {
            "src": "<introduce.call>",
            "dst": "<person>",
            "type": "BINDS_THIS_TO"
          },
          {
            "src": "<introduce.call>",
            "dst": "<'admin'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<thisCallApply>",
            "dst": "<viaApply>",
            "type": "CONTAINS"
          },
          {
            "src": "<introduce.apply>",
            "dst": "<person>",
            "type": "BINDS_THIS_TO"
          },
          {
            "src": "<introduce.apply>",
            "dst": "<array-literal>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<array-literal>",
            "dst": "<'admin'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<thisCallApply>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<viaCall>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<viaApply>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<person>",
            "dst": "<object-literal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<viaCall>",
            "dst": "<introduce.call>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<viaApply>",
            "dst": "<introduce.apply>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<template-literal>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<role>",
            "type": "READS_FROM"
          },
          {
            "src": "<introduce.call>",
            "dst": "<introduce>",
            "type": "CALLS"
          },
          {
            "src": "<introduce.apply>",
            "dst": "<introduce>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-once",
      "category": "closures",
      "code": "function once(fn) {\n  let called = false;\n  let result;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<once>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "VARIABLE",
          "id": "<called>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<once:inner>",
          "metadata": {
            "anonymous": true,
            "arrowFunction": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<...args>",
          "metadata": {
            "restParameter": true
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-not-called>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!called>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<called = true>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "CALL",
          "id": "<fn.apply(this, args)>",
          "metadata": {
            "method": "apply"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<result = fn.apply(this, args)>",
          "metadata": {
            "operator": "="
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<once>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<once>",
            "dst": "<called>",
            "type": "DECLARES"
          },
          {
            "src": "<once>",
            "dst": "<result>",
            "type": "DECLARES"
          },
          {
            "src": "<once>",
            "dst": "<once:inner>",
            "type": "RETURNS"
          },
          {
            "src": "<once:inner>",
            "dst": "<...args>",
            "type": "HAS_BODY"
          },
          {
            "src": "<once:inner>",
            "dst": "<if-not-called>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-not-called>",
            "dst": "<!called>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-not-called>",
            "dst": "<called = true>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<if-not-called>",
            "dst": "<result = fn.apply(this, args)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<fn.apply(this, args)>",
            "dst": "<...args>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<once:inner>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<called>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<called = true>",
            "dst": "<called>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result = fn.apply(this, args)>",
            "dst": "<result>",
            "type": "WRITES_TO"
          },
          {
            "src": "<once:inner>",
            "dst": "<called>",
            "type": "CAPTURES"
          },
          {
            "src": "<once:inner>",
            "dst": "<result>",
            "type": "CAPTURES"
          },
          {
            "src": "<once:inner>",
            "dst": "<fn>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<!called>",
            "dst": "<called>",
            "type": "READS_FROM"
          },
          {
            "src": "<called = true>",
            "dst": "<true>",
            "type": "READS_FROM"
          },
          {
            "src": "<result = fn.apply(this, args)>",
            "dst": "<fn.apply(this, args)>",
            "type": "READS_FROM"
          },
          {
            "src": "<fn.apply(this, args)>",
            "dst": "<fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::hoist-function-decl",
      "category": "coercion-hoisting",
      "code": "function functionHoisting() {\n  const result = hoisted(); // works  function declarations are fully hoisted\n  function hoisted() { return 'hoisted'; }\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<functionHoisting>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<hoisted()>",
          "metadata": {
            "callee": "hoisted"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<hoisted>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hoisted'>",
          "metadata": {
            "value": "hoisted",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<functionHoisting>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<functionHoisting>",
            "dst": "<hoisted>",
            "type": "CONTAINS"
          },
          {
            "src": "<hoisted>",
            "dst": "<'hoisted'>",
            "type": "RETURNS"
          },
          {
            "src": "<functionHoisting>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<hoisted()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<hoisted()>",
            "dst": "<hoisted>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "closures::closure-memoize",
      "category": "closures",
      "code": "function memoize(fn) {\n  const cache = new Map();\n  return function (...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// --- Once (call-at-most-once) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<memoize>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "VARIABLE",
          "id": "<cache>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map()>",
          "metadata": {
            "callee": "Map",
            "constructor": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<memoize:returnFn>",
          "metadata": {
            "anonymous": true,
            "restParams": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<...args>"
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<JSON.stringify(args)>",
          "metadata": {
            "callee": "JSON.stringify"
          }
        },
        {
          "type": "CALL",
          "id": "<cache.has(key)>",
          "metadata": {
            "callee": "has"
          }
        },
        {
          "type": "CALL",
          "id": "<cache.get(key)>",
          "metadata": {
            "callee": "get"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fn.apply(this, args)>",
          "metadata": {
            "callee": "apply"
          }
        },
        {
          "type": "CALL",
          "id": "<cache.set(key, result)>",
          "metadata": {
            "callee": "set"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<memoize>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<memoize>",
            "dst": "<cache>",
            "type": "CONTAINS"
          },
          {
            "src": "<memoize>",
            "dst": "<memoize:returnFn>",
            "type": "RETURNS"
          },
          {
            "src": "<memoize:returnFn>",
            "dst": "<...args>",
            "type": "HAS_BODY"
          },
          {
            "src": "<memoize:returnFn>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSON.stringify(args)>",
            "dst": "<...args>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<memoize:returnFn>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<fn.apply(this, args)>",
            "dst": "<...args>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cache.has(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cache.get(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cache.set(key, result)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cache.set(key, result)>",
            "dst": "<result>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<cache>",
            "dst": "<new Map()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<key>",
            "dst": "<JSON.stringify(args)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<result>",
            "dst": "<fn.apply(this, args)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<memoize:returnFn>",
            "dst": "<cache>",
            "type": "CAPTURES"
          },
          {
            "src": "<memoize:returnFn>",
            "dst": "<fn>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<fn.apply(this, args)>",
            "dst": "<fn>",
            "type": "CALLS"
          },
          {
            "src": "<cache.has(key)>",
            "dst": "<cache>",
            "type": "CALLS_ON"
          },
          {
            "src": "<cache.get(key)>",
            "dst": "<cache>",
            "type": "CALLS_ON"
          },
          {
            "src": "<cache.set(key, result)>",
            "dst": "<cache>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "closures::this-lost-in-callback",
      "category": "closures",
      "code": "function thisLostInCallback() {\n  const timer = {\n    seconds: 0,\n    start() {\n      // `this` lost: regular function callback\n      setTimeout(function () {\n        this.seconds++; // `this` is undefined/global\n      }, 1000);\n    },\n    startFixed() {\n      // `this` preserved: arrow function callback\n      setTimeout(() => {\n        this.seconds++;\n      }, 1000);\n    },\n  };\n  return timer;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<thisLostInCallback>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<timer>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<timer-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<timer.seconds>",
          "metadata": {
            "objectName": "timer",
            "propertyName": "seconds"
          }
        },
        {
          "type": "METHOD",
          "id": "<timer.start>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout-regular>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<setTimeout-callback-regular>",
          "metadata": {
            "async": false,
            "generator": false,
            "anonymous": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.seconds-regular>",
          "metadata": {
            "objectName": "this",
            "propertyName": "seconds"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.seconds++-regular>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1000-1>",
          "metadata": {
            "value": 1000,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<timer.startFixed>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout-arrow>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<setTimeout-callback-arrow>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.seconds-arrow>",
          "metadata": {
            "objectName": "this",
            "propertyName": "seconds"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.seconds++-arrow>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1000-2>",
          "metadata": {
            "value": 1000,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<thisLostInCallback>",
            "dst": "<timer>",
            "type": "CONTAINS"
          },
          {
            "src": "<timer-object>",
            "dst": "<timer.seconds>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<timer-object>",
            "dst": "<timer.start>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<timer-object>",
            "dst": "<timer.startFixed>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<timer.start>",
            "dst": "<setTimeout-regular>",
            "type": "CONTAINS"
          },
          {
            "src": "<setTimeout-regular>",
            "dst": "<setTimeout-callback-regular>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout-regular>",
            "dst": "<1000-1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout-callback-regular>",
            "dst": "<this.seconds++-regular>",
            "type": "CONTAINS"
          },
          {
            "src": "<timer.startFixed>",
            "dst": "<setTimeout-arrow>",
            "type": "CONTAINS"
          },
          {
            "src": "<setTimeout-arrow>",
            "dst": "<setTimeout-callback-arrow>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout-arrow>",
            "dst": "<1000-2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout-callback-arrow>",
            "dst": "<this.seconds++-arrow>",
            "type": "CONTAINS"
          },
          {
            "src": "<thisLostInCallback>",
            "dst": "<timer>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<timer>",
            "dst": "<timer-object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<timer.seconds>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.seconds++-regular>",
            "dst": "<this.seconds-regular>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.seconds++-arrow>",
            "dst": "<this.seconds-arrow>",
            "type": "WRITES_TO"
          },
          {
            "src": "<setTimeout-callback-arrow>",
            "dst": "<timer-object>",
            "type": "CAPTURES"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "coercion-hoisting::hoist-var",
      "category": "coercion-hoisting",
      "code": "function varHoisting() {\n  console.log(x); // undefined  hoisted, not initialized\n  var x = 10;\n  console.log(x); // 10\n  return x;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<varHoisting>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(x):1>",
          "metadata": {
            "callee": "console.log",
            "line": 2
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(x):2>",
          "metadata": {
            "callee": "console.log",
            "line": 4
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<varHoisting>",
            "dst": "<x>",
            "type": "DECLARES"
          },
          {
            "src": "<console.log(x):1>",
            "dst": "<x>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.log(x):2>",
            "dst": "<x>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<varHoisting>",
            "dst": "<x>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<x>",
            "dst": "<10>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(x):1>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<console.log(x):2>",
            "dst": "<console.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::yield-yield-chained",
      "category": "async-generators",
      "code": "function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<chainedYield>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield yield 1>",
          "metadata": {
            "type": "nested-yield"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<inner-yield>",
          "metadata": {
            "position": "inner",
            "operator": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<outer-yield>",
          "metadata": {
            "position": "outer",
            "operator": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<chainedYield>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<chainedYield>",
            "dst": "<yield yield 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield yield 1>",
            "dst": "<outer-yield>",
            "type": "CONTAINS"
          },
          {
            "src": "<outer-yield>",
            "dst": "<inner-yield>",
            "type": "YIELDS"
          },
          {
            "src": "<inner-yield>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<chainedYield>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<yield yield 1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "coercion-hoisting::hoist-function-expr-not",
      "category": "coercion-hoisting",
      "code": "function functionExprNotHoisted() {\n  try {\n    notHoisted(); // TypeError: notHoisted is not a function\n  } catch (e) {\n    // var notHoisted is hoisted as undefined, but assignment is not\n  }\n  var notHoisted = function () { return 'not hoisted'; };\n  return notHoisted();\n}\n\n// --- Temporal Dead Zone (TDZ) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<functionExprNotHoisted>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<notHoisted()>",
          "metadata": {
            "callee": "notHoisted"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "VARIABLE",
          "id": "<notHoisted>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<notHoisted:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'not hoisted'>",
          "metadata": {
            "value": "not hoisted",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<notHoisted()_return>",
          "metadata": {
            "callee": "notHoisted"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<functionExprNotHoisted>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<try-block>",
            "dst": "<notHoisted()>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<functionExprNotHoisted>",
            "dst": "<notHoisted>",
            "type": "DECLARES"
          },
          {
            "src": "<notHoisted:fn>",
            "dst": "<'not hoisted'>",
            "type": "RETURNS"
          },
          {
            "src": "<functionExprNotHoisted>",
            "dst": "<notHoisted()_return>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<notHoisted>",
            "dst": "<notHoisted:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<notHoisted()>",
            "dst": "<notHoisted>",
            "type": "CALLS"
          },
          {
            "src": "<notHoisted()_return>",
            "dst": "<notHoisted>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::tdz-let",
      "category": "coercion-hoisting",
      "code": "function tdzLet() {\n  try {\n    console.log(x); // ReferenceError  TDZ\n  } catch (e) {\n    // let x exists but cannot be accessed before declaration\n  }\n  let x = 10;\n  return x;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tdzLet>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CALL",
          "id": "<console.log(x)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "let",
            "inTDZ": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tdzLet>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<try-block>",
            "dst": "<console.log(x)>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<console.log(x)>",
            "dst": "<x>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tdzLet>",
            "dst": "<x>",
            "type": "DECLARES"
          },
          {
            "src": "<tdzLet>",
            "dst": "<x>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<x>",
            "dst": "<10>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<console.log(x)>",
            "dst": "<catch-block>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(x)>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<console.log(x)>",
            "dst": "<x>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::tdz-class",
      "category": "coercion-hoisting",
      "code": "function tdzClass() {\n  try {\n    new MyClass(); // ReferenceError  class TDZ\n  } catch (e) {\n    // class declarations have TDZ like let/const\n  }\n  class MyClass {}\n  return new MyClass();\n}\n\n// --- Variable shadowing ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tdzClass>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<new MyClass()>",
          "metadata": {
            "constructor": true
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CLASS",
          "id": "<MyClass>"
        },
        {
          "type": "CALL",
          "id": "<new MyClass():return>",
          "metadata": {
            "constructor": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tdzClass>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<new MyClass()>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<tdzClass>",
            "dst": "<MyClass>",
            "type": "DECLARES"
          },
          {
            "src": "<tdzClass>",
            "dst": "<new MyClass():return>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<new MyClass()>",
            "dst": "<MyClass>",
            "type": "CALLS"
          },
          {
            "src": "<new MyClass():return>",
            "dst": "<MyClass>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::coerce-symbol-toprimitive",
      "category": "coercion-hoisting",
      "code": "const toPrimitive = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return 10;\n    if (hint === 'string') return 'ten';\n    return true;\n  },\n};\n\n// --- Hoisting ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<toPrimitive>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<[Symbol.toPrimitive]>",
          "metadata": {
            "computed": true,
            "wellKnownSymbol": "toPrimitive"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<hint>"
        },
        {
          "type": "BRANCH",
          "id": "<if-number>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<hint === 'number'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'number'>",
          "metadata": {
            "value": "number",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-string>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<hint === 'string'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'string'>",
          "metadata": {
            "value": "string",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'ten'>",
          "metadata": {
            "value": "ten",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<object-literal>",
            "dst": "<[Symbol.toPrimitive]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<[Symbol.toPrimitive]>",
            "dst": "<hint>",
            "type": "CONTAINS"
          },
          {
            "src": "<[Symbol.toPrimitive]>",
            "dst": "<if-number>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-number>",
            "dst": "<hint === 'number'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-number>",
            "dst": "<10>",
            "type": "RETURNS"
          },
          {
            "src": "<[Symbol.toPrimitive]>",
            "dst": "<if-string>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-string>",
            "dst": "<hint === 'string'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-string>",
            "dst": "<'ten'>",
            "type": "RETURNS"
          },
          {
            "src": "<[Symbol.toPrimitive]>",
            "dst": "<true>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<toPrimitive>",
            "dst": "<object-literal>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<hint === 'number'>",
            "dst": "<hint>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'number'>",
            "dst": "<'number'>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'string'>",
            "dst": "<hint>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'string'>",
            "dst": "<'string'>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::tdz-const",
      "category": "coercion-hoisting",
      "code": "function tdzConst() {\n  try {\n    console.log(C); // ReferenceError  TDZ\n  } catch (e) {\n    // const C in TDZ\n  }\n  const C = 42;\n  return C;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tdzConst>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CALL",
          "id": "<console.log(C)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<C>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tdzConst>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<tdzConst>",
            "dst": "<catch-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<console.log(C)>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(C)>",
            "dst": "<C>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tdzConst>",
            "dst": "<C>",
            "type": "DECLARES"
          },
          {
            "src": "<tdzConst>",
            "dst": "<C>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<C>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(C)>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<console.log(C)>",
            "dst": "<C>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::coerce-valueof-tostring",
      "category": "coercion-hoisting",
      "code": "const customCoerce = {\n  valueOf() { return 42; },\n  toString() { return 'custom'; },\n};\n\nconst usedInMath = customCoerce + 1;        // 43 (valueOf)\nconst usedInTemplate = `${customCoerce}`;   // 'custom' (toString)",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<customCoerce>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<customCoerce:obj>"
        },
        {
          "type": "METHOD",
          "id": "<valueOf>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<toString>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'custom'>",
          "metadata": {
            "value": "custom",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<usedInMath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<customCoerce + 1>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<usedInTemplate>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`${customCoerce}`>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<customCoerce:obj>",
            "dst": "<valueOf>",
            "type": "CONTAINS"
          },
          {
            "src": "<customCoerce:obj>",
            "dst": "<toString>",
            "type": "CONTAINS"
          },
          {
            "src": "<valueOf>",
            "dst": "<42>",
            "type": "RETURNS"
          },
          {
            "src": "<toString>",
            "dst": "<'custom'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<customCoerce>",
            "dst": "<customCoerce:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<usedInMath>",
            "dst": "<customCoerce + 1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<usedInTemplate>",
            "dst": "<`${customCoerce}`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<customCoerce + 1>",
            "dst": "<customCoerce>",
            "type": "READS_FROM"
          },
          {
            "src": "<customCoerce + 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<customCoerce + 1>",
            "dst": "<valueOf>",
            "type": "CALLS"
          },
          {
            "src": "<`${customCoerce}`>",
            "dst": "<customCoerce>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${customCoerce}`>",
            "dst": "<toString>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::shadow-param-scope",
      "category": "coercion-hoisting",
      "code": "function paramShadowing(x) {\n  const x2 = x;\n  if (true) {\n    const x = 'shadowed'; // shadows parameter\n    console.log(x); // 'shadowed'\n  }\n  return x; // original param\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<paramShadowing>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x:param>",
          "metadata": {
            "name": "x"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x2>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "SCOPE",
          "id": "<if-block-scope>",
          "metadata": {
            "scopeType": "block"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x:shadowed>",
          "metadata": {
            "kind": "const",
            "name": "x",
            "shadows": "x:param"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'shadowed'>",
          "metadata": {
            "value": "shadowed",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(x)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<paramShadowing>",
            "dst": "<x:param>",
            "type": "CONTAINS"
          },
          {
            "src": "<paramShadowing>",
            "dst": "<x2>",
            "type": "CONTAINS"
          },
          {
            "src": "<paramShadowing>",
            "dst": "<if-block-scope>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-block-scope>",
            "dst": "<x:shadowed>",
            "type": "CONTAINS"
          },
          {
            "src": "<x:shadowed>",
            "dst": "<x:param>",
            "type": "SHADOWS"
          },
          {
            "src": "<console.log(x)>",
            "dst": "<x:shadowed>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<paramShadowing>",
            "dst": "<x:param>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<x2>",
            "dst": "<x:param>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<x:shadowed>",
            "dst": "<'shadowed'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(x)>",
            "dst": "<console.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::eval-direct",
      "category": "coercion-hoisting",
      "code": "function directEval(code) {\n  return eval(code);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<directEval>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<code>"
        },
        {
          "type": "CALL",
          "id": "<eval(code)>",
          "metadata": {
            "callee": "eval",
            "evalType": "direct"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<eval>",
          "metadata": {
            "builtin": true,
            "dangerous": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<directEval>",
            "type": "DECLARES"
          },
          {
            "src": "<directEval>",
            "dst": "<code>",
            "type": "CONTAINS"
          },
          {
            "src": "<directEval>",
            "dst": "<eval(code)>",
            "type": "RETURNS"
          },
          {
            "src": "<eval(code)>",
            "dst": "<code>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<eval>",
            "dst": "<directEval>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<eval(code)>",
            "dst": "<eval>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::eval-indirect",
      "category": "coercion-hoisting",
      "code": "function indirectEval(code) {\n  const evaluate = eval;\n  return evaluate(code);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<indirectEval>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<code>"
        },
        {
          "type": "VARIABLE",
          "id": "<evaluate>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<eval>",
          "metadata": {
            "builtin": true,
            "global": true
          }
        },
        {
          "type": "CALL",
          "id": "<evaluate(code)>",
          "metadata": {
            "indirect": true,
            "dynamic": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<indirectEval>",
            "dst": "<code>",
            "type": "CONTAINS"
          },
          {
            "src": "<indirectEval>",
            "dst": "<evaluate>",
            "type": "CONTAINS"
          },
          {
            "src": "<indirectEval>",
            "dst": "<evaluate(code)>",
            "type": "RETURNS"
          },
          {
            "src": "<evaluate(code)>",
            "dst": "<code>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<evaluate>",
            "dst": "<eval>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<evaluate(code)>",
            "dst": "<evaluate>",
            "type": "CALLS"
          },
          {
            "src": "<evaluate>",
            "dst": "<eval>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::eval-var-injection",
      "category": "coercion-hoisting",
      "code": "function evalVarInjection() {\n  eval('var injected = 42');\n  return injected; // 42  eval injected into function scope\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<evalVarInjection>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<eval('var injected = 42')>",
          "metadata": {
            "callee": "eval"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'var injected = 42'>",
          "metadata": {
            "value": "var injected = 42",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<injected>",
          "metadata": {
            "kind": "var",
            "evalInjected": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<evalVarInjection>",
            "type": "DECLARES"
          },
          {
            "src": "<evalVarInjection>",
            "dst": "<eval('var injected = 42')>",
            "type": "CONTAINS"
          },
          {
            "src": "<eval('var injected = 42')>",
            "dst": "<'var injected = 42'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<evalVarInjection>",
            "dst": "<injected>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<eval('var injected = 42')>",
            "dst": "<injected>",
            "type": "MODIFIES"
          },
          {
            "src": "<injected>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<eval('var injected = 42')>",
            "dst": "<eval>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::shadow-catch-scope",
      "category": "coercion-hoisting",
      "code": "function catchShadowing() {\n  const error = 'not an error';\n  try {\n    throw new Error('real error');\n  } catch (error) {\n    console.log(error.message); // 'real error'  shadows outer \"error\"\n  }\n  return error; // 'not an error'\n}\n\n// --- eval ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<catchShadowing>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<error:outer>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'not an error'>",
          "metadata": {
            "value": "not an error",
            "literalType": "string"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<error:catch>",
          "metadata": {
            "kind": "catch-parameter"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('real error')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'real error'>",
          "metadata": {
            "value": "real error",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(error.message)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<error.message>",
          "metadata": {
            "property": "message"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<catchShadowing>",
            "dst": "<error:outer>",
            "type": "CONTAINS"
          },
          {
            "src": "<catchShadowing>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<catchShadowing>",
            "dst": "<catch-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<error:catch>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Error('real error')>",
            "dst": "<'real error'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<console.log(error.message)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(error.message)>",
            "dst": "<error.message>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catchShadowing>",
            "dst": "<error:outer>",
            "type": "RETURNS"
          },
          {
            "src": "<error:catch>",
            "dst": "<error:outer>",
            "type": "SHADOWS"
          }
        ],
        "postFile": [
          {
            "src": "<error:outer>",
            "dst": "<'not an error'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<try-block>",
            "dst": "<new Error('real error')>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<error.message>",
            "dst": "<error:catch>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::contextual-keyword-as-identifier",
      "category": "coercion-hoisting",
      "code": "function contextualKeywords() {\n  var async = 1;       // valid  \"async\" is not a reserved word\n  // var yield = 3;    // SyntaxError in strict/ESM  valid in sloppy scripts\n  // var let = 2;      // SyntaxError in strict  valid with var in sloppy\n  return async;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<contextualKeywords>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<async>",
          "metadata": {
            "kind": "var",
            "contextualKeyword": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<contextualKeywords>",
            "type": "DECLARES"
          },
          {
            "src": "<contextualKeywords>",
            "dst": "<async>",
            "type": "CONTAINS"
          },
          {
            "src": "<contextualKeywords>",
            "dst": "<async>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<async>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "coercion-hoisting::eval-function-injection",
      "category": "coercion-hoisting",
      "code": "function evalFunctionInjection() {\n  eval('function surprise() { return \"boo\"; }');\n  return surprise(); // \"boo\"\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<evalFunctionInjection>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<eval('function surprise() { return \"boo\"; }')>",
          "metadata": {
            "callee": "eval"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'function surprise() { return \"boo\"; }'>",
          "metadata": {
            "value": "function surprise() { return \"boo\"; }",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<surprise>",
          "metadata": {
            "async": false,
            "generator": false,
            "dynamicallyInjected": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<\"boo\">",
          "metadata": {
            "value": "boo",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<surprise()>",
          "metadata": {
            "callee": "surprise"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<evalFunctionInjection>",
            "dst": "<eval('function surprise() { return \"boo\"; }')>",
            "type": "CONTAINS"
          },
          {
            "src": "<eval('function surprise() { return \"boo\"; }')>",
            "dst": "<'function surprise() { return \"boo\"; }'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<eval('function surprise() { return \"boo\"; }')>",
            "dst": "<surprise>",
            "type": "DECLARES"
          },
          {
            "src": "<surprise>",
            "dst": "<\"boo\">",
            "type": "RETURNS"
          },
          {
            "src": "<evalFunctionInjection>",
            "dst": "<surprise()>",
            "type": "CONTAINS"
          },
          {
            "src": "<evalFunctionInjection>",
            "dst": "<surprise()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<surprise()>",
            "dst": "<surprise>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::eval-new-function",
      "category": "coercion-hoisting",
      "code": "function newFunction(body) {\n  const fn = new Function('a', 'b', body);\n  return fn(1, 2);\n}\n\n// --- Comma operator for side effects ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<newFunction>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<body>"
        },
        {
          "type": "VARIABLE",
          "id": "<fn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Function('a', 'b', body)>",
          "metadata": {
            "callee": "Function",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'a'>",
          "metadata": {
            "value": "a",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'b'>",
          "metadata": {
            "value": "b",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<fn(1, 2)>",
          "metadata": {
            "callee": "fn"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<newFunction>",
            "dst": "<body>",
            "type": "HAS_BODY"
          },
          {
            "src": "<newFunction>",
            "dst": "<fn>",
            "type": "DECLARES"
          },
          {
            "src": "<new Function('a', 'b', body)>",
            "dst": "<'a'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Function('a', 'b', body)>",
            "dst": "<'b'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Function('a', 'b', body)>",
            "dst": "<body>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<newFunction>",
            "dst": "<fn(1, 2)>",
            "type": "RETURNS"
          },
          {
            "src": "<fn(1, 2)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fn(1, 2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<fn>",
            "dst": "<new Function('a', 'b', body)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<fn(1, 2)>",
            "dst": "<fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::coerce-comma-sequence",
      "category": "coercion-hoisting",
      "code": "function commaSequence() {\n  let x = 0;\n  const result = (x++, x++, x++, x);\n  return result; // 3\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<commaSequence>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<comma-sequence>",
          "metadata": {
            "operator": ","
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x++[1]>",
          "metadata": {
            "operator": "++",
            "position": "postfix"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x++[2]>",
          "metadata": {
            "operator": "++",
            "position": "postfix"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x++[3]>",
          "metadata": {
            "operator": "++",
            "position": "postfix"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x-final>",
          "metadata": {
            "type": "identifier"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<commaSequence>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaSequence>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<comma-sequence>",
            "dst": "<x++[1]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<comma-sequence>",
            "dst": "<x++[2]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<comma-sequence>",
            "dst": "<x++[3]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<comma-sequence>",
            "dst": "<x-final>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<commaSequence>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<x>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<result>",
            "dst": "<comma-sequence>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<x++[1]>",
            "dst": "<x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<x++[2]>",
            "dst": "<x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<x++[3]>",
            "dst": "<x>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<x++[1]>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x++[2]>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x++[3]>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x-final>",
            "dst": "<x>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::shadow-block-scope",
      "category": "coercion-hoisting",
      "code": "const outerConst = 'outer';\n\nfunction shadowingExample() {\n  const outerConst = 'shadowed'; // shadows module-level\n  if (true) {\n    const outerConst = 'inner-shadowed'; // shadows function-level\n    console.log(outerConst); // 'inner-shadowed'\n  }\n  return outerConst; // 'shadowed'\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<outerConst:module>",
          "metadata": {
            "kind": "const",
            "scope": "module"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'outer'>",
          "metadata": {
            "value": "outer",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<shadowingExample>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "SCOPE",
          "id": "<shadowingExample:scope>",
          "metadata": {
            "scopeType": "function"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<outerConst:function>",
          "metadata": {
            "kind": "const",
            "scope": "function"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'shadowed'>",
          "metadata": {
            "value": "shadowed",
            "literalType": "string"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-true>",
          "metadata": {
            "condition": "true"
          }
        },
        {
          "type": "SCOPE",
          "id": "<if-block:scope>",
          "metadata": {
            "scopeType": "block"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<outerConst:block>",
          "metadata": {
            "kind": "const",
            "scope": "block"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'inner-shadowed'>",
          "metadata": {
            "value": "inner-shadowed",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(outerConst)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<shadowingExample:scope>",
            "dst": "<outerConst:function>",
            "type": "DECLARES"
          },
          {
            "src": "<outerConst:function>",
            "dst": "<outerConst:module>",
            "type": "SHADOWS"
          },
          {
            "src": "<shadowingExample>",
            "dst": "<shadowingExample:scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<shadowingExample>",
            "dst": "<if-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-true>",
            "dst": "<if-block:scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<if-block:scope>",
            "dst": "<outerConst:block>",
            "type": "DECLARES"
          },
          {
            "src": "<outerConst:block>",
            "dst": "<outerConst:function>",
            "type": "SHADOWS"
          },
          {
            "src": "<if-true>",
            "dst": "<console.log(outerConst)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(outerConst)>",
            "dst": "<outerConst:block>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<shadowingExample>",
            "dst": "<outerConst:function>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<outerConst:function>",
            "dst": "<'shadowed'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<outerConst:block>",
            "dst": "<'inner-shadowed'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(outerConst)>",
            "dst": "<console.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::var-decl-uninit",
      "category": "declarations",
      "code": "var uninitialized;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<uninitialized>",
          "metadata": {
            "kind": "var"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<uninitialized>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "coercion-hoisting::block-label-ambiguity",
      "category": "coercion-hoisting",
      "code": "function blockLabelAmbiguity() {\n  // { a: 1 } in statement position is a block with labeled expression, NOT an object\n  // Parentheses force expression context:\n  const obj = eval('({ a: 1, b: 2 })'); // object literal\n  // eval('{ a: 1, b: 2 }');            // SyntaxError  block + label + illegal comma\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<blockLabelAmbiguity>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<eval('({ a: 1, b: 2 })')>",
          "metadata": {
            "callee": "eval"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'({ a: 1, b: 2 })'>",
          "metadata": {
            "value": "({ a: 1, b: 2 })",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<eval>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<blockLabelAmbiguity>",
            "type": "DECLARES"
          },
          {
            "src": "<blockLabelAmbiguity>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<eval('({ a: 1, b: 2 })')>",
            "dst": "<'({ a: 1, b: 2 })'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<blockLabelAmbiguity>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<eval('({ a: 1, b: 2 })')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<eval('({ a: 1, b: 2 })')>",
            "dst": "<eval>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "async-generators::async-destructure-await-default",
      "category": "async-generators",
      "code": "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getConfigValue>",
          "metadata": {
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "VARIABLE",
          "id": "<asyncDestructureHandler>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncDestructureHandler:fn>",
          "metadata": {
            "async": true,
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<destructured-param>",
          "metadata": {
            "destructured": true,
            "defaultValue": "{}"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<timeout>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<retries>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "CALL",
          "id": "<getConfigValue('timeout')>",
          "metadata": {
            "callee": "getConfigValue",
            "awaited": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'timeout'>",
          "metadata": {
            "value": "timeout",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<getConfigValue('retries')>",
          "metadata": {
            "callee": "getConfigValue",
            "awaited": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'retries'>",
          "metadata": {
            "value": "retries",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ timeout, retries }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getConfigValue>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<getConfigValue>",
            "dst": "<key>",
            "type": "RETURNS"
          },
          {
            "src": "<asyncDestructureHandler:fn>",
            "dst": "<destructured-param>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructured-param>",
            "dst": "<timeout>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<destructured-param>",
            "dst": "<retries>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<timeout>",
            "dst": "<getConfigValue('timeout')>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<retries>",
            "dst": "<getConfigValue('retries')>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<getConfigValue('timeout')>",
            "dst": "<'timeout'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getConfigValue('retries')>",
            "dst": "<'retries'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<asyncDestructureHandler:fn>",
            "dst": "<{ timeout, retries }>",
            "type": "RETURNS"
          },
          {
            "src": "<getConfigValue('timeout')>",
            "dst": "<timeout>",
            "type": "AWAITS"
          },
          {
            "src": "<getConfigValue('retries')>",
            "dst": "<retries>",
            "type": "AWAITS"
          }
        ],
        "postFile": [
          {
            "src": "<asyncDestructureHandler>",
            "dst": "<asyncDestructureHandler:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<getConfigValue('timeout')>",
            "dst": "<getConfigValue>",
            "type": "CALLS"
          },
          {
            "src": "<getConfigValue('retries')>",
            "dst": "<getConfigValue>",
            "type": "CALLS"
          },
          {
            "src": "<{ timeout, retries }>",
            "dst": "<timeout>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ timeout, retries }>",
            "dst": "<retries>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::typeof-tdz-trap",
      "category": "coercion-hoisting",
      "code": "function typeofTdzTrap() {\n  try {\n    const result = typeof x; // ReferenceError  x is in TDZ, unlike undeclared\n  } catch (e) {\n    // typeof on TDZ variable THROWS, unlike typeof on undeclared\n  }\n  let x = 5;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<typeofTdzTrap>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof x>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<typeofTdzTrap>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<try-block>",
            "dst": "<result>",
            "type": "DECLARES"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "DECLARES"
          },
          {
            "src": "<typeofTdzTrap>",
            "dst": "<x>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<typeof x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<x>",
            "dst": "<5>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<typeof x>",
            "dst": "<catch-block>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<typeof x>",
            "dst": "<x>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::var-function-collision",
      "category": "coercion-hoisting",
      "code": "function varFunctionCollision() {\n  console.log(typeof collision); // \"function\"  function hoists over var\n  var collision = 1;\n  function collision() { return 2; }\n  console.log(typeof collision); // \"number\"  assignment runs after\n  return collision;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<varFunctionCollision>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(typeof collision)1>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof collision1>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<collision:var>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<collision:fn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(typeof collision)2>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof collision2>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<console.log>",
          "metadata": {
            "source": "console"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<varFunctionCollision>",
            "dst": "<console.log(typeof collision)1>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(typeof collision)1>",
            "dst": "<typeof collision1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<varFunctionCollision>",
            "dst": "<collision:var>",
            "type": "DECLARES"
          },
          {
            "src": "<varFunctionCollision>",
            "dst": "<collision:fn>",
            "type": "DECLARES"
          },
          {
            "src": "<collision:fn>",
            "dst": "<2>",
            "type": "RETURNS"
          },
          {
            "src": "<varFunctionCollision>",
            "dst": "<console.log(typeof collision)2>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(typeof collision)2>",
            "dst": "<typeof collision2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<varFunctionCollision>",
            "dst": "<collision:var>",
            "type": "RETURNS"
          },
          {
            "src": "<collision:fn>",
            "dst": "<collision:var>",
            "type": "SHADOWS"
          }
        ],
        "postFile": [
          {
            "src": "<collision:var>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(typeof collision)1>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<typeof collision1>",
            "dst": "<collision:fn>",
            "type": "READS_FROM"
          },
          {
            "src": "<console.log(typeof collision)2>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<typeof collision2>",
            "dst": "<collision:var>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::var-decl-init",
      "category": "declarations",
      "code": "var mutableVar = 'hello';",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<mutableVar>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hello'>",
          "metadata": {
            "value": "hello",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<mutableVar>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<mutableVar>",
            "dst": "<'hello'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::let-decl-init",
      "category": "declarations",
      "code": "let reassignable = 42;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<reassignable>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<reassignable>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<reassignable>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::let-decl-uninit",
      "category": "declarations",
      "code": "let uninitializedLet;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<uninitializedLet>",
          "metadata": {
            "kind": "let"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<uninitializedLet>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "coercion-hoisting::var-in-catch-clobber",
      "category": "coercion-hoisting",
      "code": "function varInCatchClobber() {\n  try {\n    throw new Error('oops');\n  } catch (e) {\n    var e = 'overwritten';  // var hoists to function scope, shares binding with catch param\n  }\n  return e; // 'overwritten' in sloppy; in strict var still hoists but catch e is separate\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<varInCatchClobber>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<new Error('oops')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'oops'>",
          "metadata": {
            "value": "oops",
            "literalType": "string"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e:catch>",
          "metadata": {
            "catchParameter": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<e:var>",
          "metadata": {
            "kind": "var",
            "hoisted": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'overwritten'>",
          "metadata": {
            "value": "overwritten",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return e>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<varInCatchClobber>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Error('oops')>",
            "dst": "<'oops'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<varInCatchClobber>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<e:catch>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<e:var>",
            "type": "CONTAINS"
          },
          {
            "src": "<varInCatchClobber>",
            "dst": "<return e>",
            "type": "RETURNS"
          },
          {
            "src": "<varInCatchClobber>",
            "dst": "<e:var>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<try-block>",
            "dst": "<new Error('oops')>",
            "type": "THROWS"
          },
          {
            "src": "<e:var>",
            "dst": "<'overwritten'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<return e>",
            "dst": "<e:var>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::primitive-autoboxing",
      "category": "coercion-hoisting",
      "code": "function primitiveAutoboxing() {\n  const str = 'hello';\n  const upper = str.toUpperCase(); // auto-boxes to String object\n  str.customProp = 1; // sets on TEMPORARY boxed String, immediately GC'd\n  const lost = str.customProp; // undefined\n\n  const num = 42;\n  const fixed = num.toFixed(2); // auto-boxes to Number\n\n  return { upper, lost, fixed };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<primitiveAutoboxing>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<str>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hello'>",
          "metadata": {
            "value": "hello",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<upper>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<str.toUpperCase()>",
          "metadata": {
            "method": "toUpperCase"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<str.customProp>",
          "metadata": {
            "property": "customProp"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<lost>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<str.customProp:read>",
          "metadata": {
            "property": "customProp"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<num>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fixed>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<num.toFixed(2)>",
          "metadata": {
            "method": "toFixed"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ upper, lost, fixed }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<primitiveAutoboxing>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<primitiveAutoboxing>",
            "dst": "<upper>",
            "type": "CONTAINS"
          },
          {
            "src": "<str.customProp>",
            "dst": "<str>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<primitiveAutoboxing>",
            "dst": "<lost>",
            "type": "CONTAINS"
          },
          {
            "src": "<str.customProp:read>",
            "dst": "<str>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<primitiveAutoboxing>",
            "dst": "<num>",
            "type": "CONTAINS"
          },
          {
            "src": "<primitiveAutoboxing>",
            "dst": "<fixed>",
            "type": "CONTAINS"
          },
          {
            "src": "<num.toFixed(2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<primitiveAutoboxing>",
            "dst": "<{ upper, lost, fixed }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<str>",
            "dst": "<'hello'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<upper>",
            "dst": "<str.toUpperCase()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<str.customProp>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<lost>",
            "dst": "<str.customProp:read>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<num>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fixed>",
            "dst": "<num.toFixed(2)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<str.toUpperCase()>",
            "dst": "<str>",
            "type": "CALLS_ON"
          },
          {
            "src": "<num.toFixed(2)>",
            "dst": "<num>",
            "type": "CALLS_ON"
          },
          {
            "src": "<{ upper, lost, fixed }>",
            "dst": "<upper>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ upper, lost, fixed }>",
            "dst": "<lost>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ upper, lost, fixed }>",
            "dst": "<fixed>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::block-function-declaration-strict",
      "category": "coercion-hoisting",
      "code": "// NOTE: behavior differs between strict (ESM) and sloppy (script) mode.\n// This file is ESM (strict), so the function is block-scoped.\n// In sloppy mode (.cjs / <script>), the function would leak to function scope (Annex B).\nfunction blockFunctionDemo() {\n  let result = 'before';\n\n  if (true) {\n    function blockFn() { return 'inside'; }  // block-scoped in strict/ESM\n    result = blockFn();\n  }\n\n  // blockFn is NOT accessible here in strict mode\n  // In sloppy mode it WOULD be accessible (Annex B hoisting)\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<blockFunctionDemo>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'before'>",
          "metadata": {
            "value": "before",
            "literalType": "string"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-true>",
          "metadata": {
            "condition": "true"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "SCOPE",
          "id": "<if-block-scope>"
        },
        {
          "type": "FUNCTION",
          "id": "<blockFn>",
          "metadata": {
            "async": false,
            "generator": false,
            "blockScoped": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'inside'>",
          "metadata": {
            "value": "inside",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<blockFn()>",
          "metadata": {
            "callee": "blockFn"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<result = blockFn()>",
          "metadata": {
            "operator": "="
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<blockFunctionDemo>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<blockFunctionDemo>",
            "dst": "<if-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-true>",
            "dst": "<if-block-scope>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-block-scope>",
            "dst": "<blockFn>",
            "type": "DECLARES"
          },
          {
            "src": "<blockFn>",
            "dst": "<'inside'>",
            "type": "RETURNS"
          },
          {
            "src": "<if-block-scope>",
            "dst": "<blockFn()>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-block-scope>",
            "dst": "<result = blockFn()>",
            "type": "CONTAINS"
          },
          {
            "src": "<blockFunctionDemo>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<'before'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<result = blockFn()>",
            "dst": "<result>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result = blockFn()>",
            "dst": "<blockFn()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<blockFn()>",
            "dst": "<blockFn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::var-redeclares-parameter",
      "category": "coercion-hoisting",
      "code": "function varRedeclaresParameter(x, y) {\n  var x = x || 'default'; // same binding as parameter x  NOT a new variable\n  var y;                    // re-declares y but does NOT reset it\n  return { x, y };\n}\n// varRedeclaresParameter(null, 42)  { x: 'default', y: 42 }\n// Contrast: let x = ... inside would be SyntaxError (cannot re-declare param)",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<varRedeclaresParameter>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>",
          "metadata": {
            "redeclaredAsVar": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<y>",
          "metadata": {
            "redeclaredAsVar": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x || 'default'>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'default'>",
          "metadata": {
            "value": "default",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ x, y }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<varRedeclaresParameter>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<varRedeclaresParameter>",
            "dst": "<y>",
            "type": "CONTAINS"
          },
          {
            "src": "<varRedeclaresParameter>",
            "dst": "<{ x, y }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<x>",
            "dst": "<x || 'default'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x || 'default'>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x || 'default'>",
            "dst": "<'default'>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ x, y }>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ x, y }>",
            "dst": "<y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::const-decl-bool-literal",
      "category": "declarations",
      "code": "const immutable = true;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<immutable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<immutable>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<immutable>",
            "dst": "<true>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::const-decl-bigint-literal",
      "category": "declarations",
      "code": "const bigNumber = 42n;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<bigNumber>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42n>",
          "metadata": {
            "value": "42n",
            "literalType": "bigint"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<bigNumber>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<bigNumber>",
            "dst": "<42n>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::var-decl-multi",
      "category": "declarations",
      "code": "var multi1 = 1, multi2 = 2, multi3 = 3;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<multi1>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<multi2>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<multi3>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<multi1>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<multi2>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<multi3>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<multi1>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<multi2>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<multi3>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::const-decl-object-literal",
      "category": "declarations",
      "code": "const objectConst = { key: 'value' };",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<objectConst>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<objectConst:object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'key'>",
          "metadata": {
            "value": "key",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'value'>",
          "metadata": {
            "value": "value",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<objectConst>",
            "type": "DECLARES"
          },
          {
            "src": "<objectConst:object>",
            "dst": "<'key'>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<objectConst>",
            "dst": "<objectConst:object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<'key'>",
            "dst": "<'value'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::const-decl-call-result-1",
      "category": "declarations",
      "code": "const uniqueKey = Symbol('description');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<uniqueKey>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Symbol('description')>",
          "metadata": {
            "callee": "Symbol"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'description'>",
          "metadata": {
            "value": "description",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<uniqueKey>",
            "type": "DECLARES"
          },
          {
            "src": "<Symbol('description')>",
            "dst": "<'description'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<uniqueKey>",
            "dst": "<Symbol('description')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Symbol('description')>",
            "dst": "<Symbol>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::const-decl-array-literal",
      "category": "declarations",
      "code": "const arrayConst = [1, 2, 3];",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrayConst>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrayConst>",
            "type": "DECLARES"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [
          {
            "src": "<arrayConst>",
            "dst": "<[1, 2, 3]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "coercion-hoisting::eval-let-scope",
      "category": "coercion-hoisting",
      "code": "function evalLetScope() {\n  eval('let y = 2');   // y is block-scoped to the eval itself\n  try {\n    return y;          // ReferenceError  y doesn't exist here\n  } catch (e) {\n    return 'y not accessible';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<evalLetScope>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<eval('let y = 2')>",
          "metadata": {
            "callee": "eval"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'let y = 2'>",
          "metadata": {
            "value": "let y = 2",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<y>",
          "metadata": {
            "kind": "let",
            "evalScoped": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "EXPRESSION",
          "id": "<return y>",
          "metadata": {
            "expressionType": "return"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'y not accessible'>",
          "metadata": {
            "value": "y not accessible",
            "literalType": "string"
          }
        },
        {
          "type": "SCOPE",
          "id": "<eval-scope>",
          "metadata": {
            "scopeType": "eval-lexical"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<evalLetScope>",
            "dst": "<eval('let y = 2')>",
            "type": "CONTAINS"
          },
          {
            "src": "<eval('let y = 2')>",
            "dst": "<'let y = 2'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<eval('let y = 2')>",
            "dst": "<eval-scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<eval-scope>",
            "dst": "<y>",
            "type": "DECLARES"
          },
          {
            "src": "<evalLetScope>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<evalLetScope>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<try-block>",
            "dst": "<return y>",
            "type": "CONTAINS"
          },
          {
            "src": "<evalLetScope>",
            "dst": "<return y>",
            "type": "RETURNS"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<evalLetScope>",
            "dst": "<'y not accessible'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<y>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<return y>",
            "dst": "<y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::func-decl",
      "category": "declarations",
      "code": "function regularFunction(param1, param2) {\n  return param1 + param2;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<regularFunction>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<param1>"
        },
        {
          "type": "PARAMETER",
          "id": "<param2>"
        },
        {
          "type": "EXPRESSION",
          "id": "<param1 + param2>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<regularFunction>",
            "type": "DECLARES"
          },
          {
            "src": "<regularFunction>",
            "dst": "<param1>",
            "type": "CONTAINS"
          },
          {
            "src": "<regularFunction>",
            "dst": "<param2>",
            "type": "CONTAINS"
          },
          {
            "src": "<regularFunction>",
            "dst": "<param1 + param2>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<param1 + param2>",
            "dst": "<param1>",
            "type": "READS_FROM"
          },
          {
            "src": "<param1 + param2>",
            "dst": "<param2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::const-decl-call-result",
      "category": "declarations",
      "code": "const bigComputed = BigInt(Number.MAX_SAFE_INTEGER);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<bigComputed>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<BigInt(Number.MAX_SAFE_INTEGER)>",
          "metadata": {
            "callee": "BigInt"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Number.MAX_SAFE_INTEGER>",
          "metadata": {
            "objectName": "Number",
            "propertyName": "MAX_SAFE_INTEGER"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<bigComputed>",
            "type": "DECLARES"
          },
          {
            "src": "<BigInt(Number.MAX_SAFE_INTEGER)>",
            "dst": "<Number.MAX_SAFE_INTEGER>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<bigComputed>",
            "dst": "<BigInt(Number.MAX_SAFE_INTEGER)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<BigInt(Number.MAX_SAFE_INTEGER)>",
            "dst": "<BigInt>",
            "type": "CALLS"
          },
          {
            "src": "<Number.MAX_SAFE_INTEGER>",
            "dst": "<Number>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::func-decl-rest-params",
      "category": "declarations",
      "code": "function withRestParams(...args) {\n  return args.length;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withRestParams>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<args>",
          "metadata": {
            "restParameter": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<args.length>",
          "metadata": {
            "property": "length"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<withRestParams>",
            "type": "DECLARES"
          },
          {
            "src": "<withRestParams>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<withRestParams>",
            "dst": "<args.length>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<args.length>",
            "dst": "<args>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::const-decl-method-call-result",
      "category": "declarations",
      "code": "const globalSymbol = Symbol.for('shared');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<globalSymbol>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Symbol.for('shared')>",
          "metadata": {
            "callee": "Symbol.for"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Symbol.for>",
          "metadata": {
            "objectName": "Symbol",
            "propertyName": "for"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'shared'>",
          "metadata": {
            "value": "shared",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Symbol>",
          "metadata": {
            "name": "Symbol",
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<globalSymbol>",
            "type": "DECLARES"
          },
          {
            "src": "<Symbol.for('shared')>",
            "dst": "<'shared'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<globalSymbol>",
            "dst": "<Symbol.for('shared')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Symbol.for('shared')>",
            "dst": "<Symbol.for>",
            "type": "CALLS"
          },
          {
            "src": "<Symbol.for>",
            "dst": "<Symbol>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::object-as-map-key-tostring",
      "category": "coercion-hoisting",
      "code": "function objectAsMapKey() {\n  const cache = {};\n  const obj = {};\n  cache[obj] = 'value';           // key is \"[object Object]\"\n  cache[{ a: 1 }] = 'another';   // SAME key \"[object Object]\"  overwrites!\n  return cache;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<objectAsMapKey>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cache>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<obj-literal>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<cache[obj]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'value'>",
          "metadata": {
            "value": "value",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<cache[{ a: 1 }]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1 }>",
          "metadata": {
            "value": "{ a: 1 }",
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'another'>",
          "metadata": {
            "value": "another",
            "literalType": "string"
          }
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<obj-toString>",
          "metadata": {
            "description": "Object coerced to string '[object Object]'",
            "from": "object",
            "to": "string",
            "result": "[object Object]"
          }
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<inline-obj-toString>",
          "metadata": {
            "description": "Object coerced to string '[object Object]'",
            "from": "object",
            "to": "string",
            "result": "[object Object]"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<objectAsMapKey>",
            "dst": "<cache>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectAsMapKey>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectAsMapKey>",
            "dst": "<cache>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<cache>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<obj-literal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<cache[obj]>",
            "dst": "<'value'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<cache[{ a: 1 }]>",
            "dst": "<'another'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<cache[obj]>",
            "dst": "<cache>",
            "type": "READS_FROM"
          },
          {
            "src": "<cache[obj]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<obj-toString>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<cache[obj]>",
            "dst": "<obj-toString>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<cache[{ a: 1 }]>",
            "dst": "<cache>",
            "type": "READS_FROM"
          },
          {
            "src": "<cache[{ a: 1 }]>",
            "dst": "<{ a: 1 }>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a: 1 }>",
            "dst": "<inline-obj-toString>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<cache[{ a: 1 }]>",
            "dst": "<inline-obj-toString>",
            "type": "DEPENDS_ON"
          }
        ]
      }
    },
    {
      "constructId": "declarations::const-decl-regex-literal",
      "category": "declarations",
      "code": "const regexSimple = /hello/;\nconst regexFlags = /pattern/gi;\nconst regexComplex = /^start.*end$/ms;\n\n// Function Declarations",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<regexSimple>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</hello/>",
          "metadata": {
            "value": "/hello/",
            "literalType": "regex",
            "pattern": "hello",
            "flags": ""
          }
        },
        {
          "type": "VARIABLE",
          "id": "<regexFlags>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</pattern/gi>",
          "metadata": {
            "value": "/pattern/gi",
            "literalType": "regex",
            "pattern": "pattern",
            "flags": "gi"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<regexComplex>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</^start.*end$/ms>",
          "metadata": {
            "value": "/^start.*end$/ms",
            "literalType": "regex",
            "pattern": "^start.*end$",
            "flags": "ms"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<regexSimple>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<regexFlags>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<regexComplex>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<regexSimple>",
            "dst": "</hello/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<regexFlags>",
            "dst": "</pattern/gi>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<regexComplex>",
            "dst": "</^start.*end$/ms>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::func-decl-defaults",
      "category": "declarations",
      "code": "function withDefaults(a = 10, b = 'default') {\n  return `${a}${b}`;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withDefaults>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<b>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'default'>",
          "metadata": {
            "value": "default",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`${a}${b}`>",
          "metadata": {
            "type": "template-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withDefaults>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<withDefaults>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<a>",
            "dst": "<10>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<b>",
            "dst": "<'default'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<withDefaults>",
            "dst": "<`${a}${b}`>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<`${a}${b}`>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${a}${b}`>",
            "dst": "<b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "coercion-hoisting::export-named-list",
      "category": "coercion-hoisting",
      "code": "export {\n  stringCoercion,\n  numberCoercion,\n  booleanCoercion,\n  equalityCoercion,\n  customCoerce,\n  usedInMath,\n  usedInTemplate,\n  toPrimitive,\n  varHoisting,\n  functionHoisting,\n  functionExprNotHoisted,\n  tdzLet,\n  tdzConst,\n  tdzClass,\n  outerConst,\n  shadowingExample,\n  paramShadowing,\n  catchShadowing,\n  directEval,\n  indirectEval,\n  newFunction,\n  commaSequence,\n  evalVarInjection,\n  evalFunctionInjection,\n  primitiveAutoboxing,\n  varFunctionCollision,\n  contextualKeywords,\n  objectAsMapKey,\n  blockFunctionDemo,\n  varInCatchClobber,\n  typeofTdzTrap,\n  evalLetScope,\n  blockLabelAmbiguity,\n  varRedeclaresParameter,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named-list"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-named-list>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<stringCoercion>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<numberCoercion>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<booleanCoercion>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<equalityCoercion>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<customCoerce>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<usedInMath>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<usedInTemplate>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<toPrimitive>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<varHoisting>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<functionHoisting>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<functionExprNotHoisted>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<tdzLet>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<tdzConst>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<tdzClass>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<outerConst>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<shadowingExample>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<paramShadowing>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<catchShadowing>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<directEval>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<indirectEval>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<newFunction>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<commaSequence>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<evalVarInjection>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<evalFunctionInjection>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<primitiveAutoboxing>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<varFunctionCollision>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<contextualKeywords>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<objectAsMapKey>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<blockFunctionDemo>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<varInCatchClobber>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<typeofTdzTrap>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<evalLetScope>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<blockLabelAmbiguity>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<varRedeclaresParameter>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::func-expr-named",
      "category": "declarations",
      "code": "const namedExpression = function multiply(x, y) {\n  return x * y;\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<namedExpression>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<multiply>",
          "metadata": {
            "named": true,
            "expression": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "PARAMETER",
          "id": "<y>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * y>",
          "metadata": {
            "operator": "*"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<namedExpression>",
            "type": "DECLARES"
          },
          {
            "src": "<multiply>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<multiply>",
            "dst": "<y>",
            "type": "CONTAINS"
          },
          {
            "src": "<multiply>",
            "dst": "<x * y>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<namedExpression>",
            "dst": "<multiply>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x * y>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * y>",
            "dst": "<y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::arrow-single-param",
      "category": "declarations",
      "code": "const arrowSingleParam = x => x * 2;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrowSingleParam>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrowSingleParam:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrowSingleParam>",
            "type": "DECLARES"
          },
          {
            "src": "<arrowSingleParam:fn>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowSingleParam:fn>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arrowSingleParam>",
            "dst": "<arrowSingleParam:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::arrow-block-body",
      "category": "declarations",
      "code": "const arrowBlock = (a, b) => {\n  return a + b;\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrowBlock>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrowBlock:fn>",
          "metadata": {
            "arrowFunction": true,
            "hasBlockBody": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrowBlock>",
            "type": "DECLARES"
          },
          {
            "src": "<arrowBlock:fn>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowBlock:fn>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowBlock:fn>",
            "dst": "<a + b>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arrowBlock>",
            "dst": "<arrowBlock:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a + b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::arrow-expression-body",
      "category": "declarations",
      "code": "const arrowExpression = (a, b) => a + b;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrowExpression>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrowExpression:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrowExpression>",
            "type": "DECLARES"
          },
          {
            "src": "<arrowExpression:fn>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowExpression:fn>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowExpression:fn>",
            "dst": "<a + b>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arrowExpression>",
            "dst": "<arrowExpression:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a + b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::arrow-no-params",
      "category": "declarations",
      "code": "const arrowNoParams = () => 42;\n\n// Generator Functions",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrowNoParams>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrowNoParams:fn>",
          "metadata": {
            "arrowFunction": true,
            "parameterCount": 0
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrowNoParams>",
            "type": "DECLARES"
          },
          {
            "src": "<arrowNoParams:fn>",
            "dst": "<42>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arrowNoParams>",
            "dst": "<arrowNoParams:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::func-expr-anonymous",
      "category": "declarations",
      "code": "const anonymousExpression = function (x) {\n  return x * 2;\n};\n\n// Arrow Functions",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<anonymousExpression>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<anonymousExpression:fn>",
          "metadata": {
            "anonymous": true,
            "functionExpression": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<anonymousExpression>",
            "type": "DECLARES"
          },
          {
            "src": "<anonymousExpression:fn>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymousExpression:fn>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<anonymousExpression>",
            "dst": "<anonymousExpression:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::func-decl-mixed-params",
      "category": "declarations",
      "code": "function withMixedParams(required, optional = null, ...rest) {\n  return [required, optional, ...rest];\n}\n\n// Function Expressions",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withMixedParams>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<required>",
          "metadata": {
            "parameterType": "required"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<optional>",
          "metadata": {
            "parameterType": "optional"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<rest>",
          "metadata": {
            "parameterType": "rest"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[required, optional, ...rest]>",
          "metadata": {
            "expressionType": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withMixedParams>",
            "dst": "<required>",
            "type": "CONTAINS"
          },
          {
            "src": "<withMixedParams>",
            "dst": "<optional>",
            "type": "CONTAINS"
          },
          {
            "src": "<withMixedParams>",
            "dst": "<rest>",
            "type": "CONTAINS"
          },
          {
            "src": "<optional>",
            "dst": "<null>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<withMixedParams>",
            "dst": "<[required, optional, ...rest]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<[required, optional, ...rest]>",
            "dst": "<required>",
            "type": "READS_FROM"
          },
          {
            "src": "<[required, optional, ...rest]>",
            "dst": "<optional>",
            "type": "READS_FROM"
          },
          {
            "src": "<[required, optional, ...rest]>",
            "dst": "<rest>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-parse",
      "category": "builtins",
      "code": "function jsonParse(str) {\n  return JSON.parse(str);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonParse>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "CALL",
          "id": "<JSON.parse(str)>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.parse>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "parse"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<JSON>",
          "metadata": {
            "builtin": true,
            "global": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<jsonParse>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<jsonParse>",
            "dst": "<JSON.parse(str)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.parse(str)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<JSON.parse(str)>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<JSON.parse>",
            "dst": "<JSON>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::generator-decl",
      "category": "declarations",
      "code": "function* numberGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<numberGenerator>",
          "metadata": {
            "async": false,
            "generator": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<numberGenerator>",
            "type": "DECLARES"
          },
          {
            "src": "<numberGenerator>",
            "dst": "<1>",
            "type": "YIELDS"
          },
          {
            "src": "<numberGenerator>",
            "dst": "<2>",
            "type": "YIELDS"
          },
          {
            "src": "<numberGenerator>",
            "dst": "<3>",
            "type": "YIELDS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "declarations::async-func-decl",
      "category": "declarations",
      "code": "async function asyncFunction() {\n  return await Promise.resolve(42);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<asyncFunction>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(42)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(42)>",
          "metadata": {
            "operator": "await"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<asyncFunction>",
            "type": "DECLARES"
          },
          {
            "src": "<asyncFunction>",
            "dst": "<await Promise.resolve(42)>",
            "type": "RETURNS"
          },
          {
            "src": "<await Promise.resolve(42)>",
            "dst": "<Promise.resolve(42)>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Promise.resolve(42)>",
            "dst": "<Promise.resolve>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::generator-delegation",
      "category": "declarations",
      "code": "function* delegatingGenerator() {\n  yield* numberGenerator();\n  yield 4;\n}\n\n// Async Functions",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<delegatingGenerator>",
          "metadata": {
            "async": false,
            "generator": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield* numberGenerator()>",
          "metadata": {
            "type": "yield-delegation"
          }
        },
        {
          "type": "CALL",
          "id": "<numberGenerator()>",
          "metadata": {
            "callee": "numberGenerator"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield 4>",
          "metadata": {
            "type": "yield"
          }
        },
        {
          "type": "LITERAL",
          "id": "<4>",
          "metadata": {
            "value": 4,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<delegatingGenerator>",
            "type": "DECLARES"
          },
          {
            "src": "<delegatingGenerator>",
            "dst": "<yield* numberGenerator()>",
            "type": "CONTAINS"
          },
          {
            "src": "<delegatingGenerator>",
            "dst": "<yield 4>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield* numberGenerator()>",
            "dst": "<numberGenerator()>",
            "type": "DELEGATES_TO"
          },
          {
            "src": "<yield 4>",
            "dst": "<4>",
            "type": "YIELDS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<numberGenerator()>",
            "dst": "<numberGenerator>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::iife",
      "category": "declarations",
      "code": "const iifeResult = (function () {\n  return 'iife';\n})();",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<iifeResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<iife:fn>",
          "metadata": {
            "anonymous": true,
            "iife": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'iife'>",
          "metadata": {
            "value": "iife",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<iife:call>",
          "metadata": {
            "immediateInvocation": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<iifeResult>",
            "type": "DECLARES"
          },
          {
            "src": "<iife:fn>",
            "dst": "<'iife'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<iifeResult>",
            "dst": "<iife:call>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<iife:call>",
            "dst": "<iife:fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::iife-arrow",
      "category": "declarations",
      "code": "const arrowIifeResult = (() => {\n  return 'arrow iife';\n})();\n\n// Named Exports",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrowIifeResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow-iife:fn>",
          "metadata": {
            "arrowFunction": true,
            "iife": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'arrow iife'>",
          "metadata": {
            "value": "arrow iife",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<arrow-iife:call>",
          "metadata": {
            "iife": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrowIifeResult>",
            "type": "DECLARES"
          },
          {
            "src": "<arrow-iife:fn>",
            "dst": "<'arrow iife'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arrowIifeResult>",
            "dst": "<arrow-iife:call>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arrow-iife:call>",
            "dst": "<arrow-iife:fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::async-arrow",
      "category": "declarations",
      "code": "const asyncArrow = async () => {\n  return await Promise.resolve('async arrow');\n};\n\n// Async Generator Functions",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncArrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncArrow:fn>",
          "metadata": {
            "arrowFunction": true,
            "async": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve('async arrow')>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve('async arrow')>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'async arrow'>",
          "metadata": {
            "value": "async arrow",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Promise.resolve>",
          "metadata": {
            "source": "global Promise API"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<asyncArrow>",
            "type": "DECLARES"
          },
          {
            "src": "<asyncArrow:fn>",
            "dst": "<await Promise.resolve('async arrow')>",
            "type": "RETURNS"
          },
          {
            "src": "<await Promise.resolve('async arrow')>",
            "dst": "<Promise.resolve('async arrow')>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve('async arrow')>",
            "dst": "<'async arrow'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<asyncArrow>",
            "dst": "<asyncArrow:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Promise.resolve('async arrow')>",
            "dst": "<Promise.resolve>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::arrow-return-object-literal",
      "category": "declarations",
      "code": "const arrowReturnsObject = (x) => ({ key: x, value: x * 2 });\n// Without parens: (x) => { key: x }  parsed as block with label \"key\"!",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<arrowReturnsObject>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrowReturnsObject:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<arrowReturnsObject>",
            "type": "DECLARES"
          },
          {
            "src": "<arrowReturnsObject:fn>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowReturnsObject:fn>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<x>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<x * 2>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<arrowReturnsObject>",
            "dst": "<arrowReturnsObject:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::param-default-scope-quirk",
      "category": "declarations",
      "code": "let outerX = 'outer';\nfunction paramDefaultScope(a = () => outerX, outerX) {\n  return a();\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<outerX>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'outer'>",
          "metadata": {
            "value": "outer",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<paramDefaultScope>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<a:default>",
          "metadata": {
            "arrowFunction": true,
            "isDefaultValue": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<outerX:param>",
          "metadata": {
            "shadowsOuter": true
          }
        },
        {
          "type": "CALL",
          "id": "<a()>",
          "metadata": {
            "callee": "a"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<paramDefaultScope>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<paramDefaultScope>",
            "dst": "<outerX:param>",
            "type": "CONTAINS"
          },
          {
            "src": "<a>",
            "dst": "<a:default>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<paramDefaultScope>",
            "dst": "<a()>",
            "type": "RETURNS"
          },
          {
            "src": "<outerX:param>",
            "dst": "<outerX>",
            "type": "SHADOWS"
          }
        ],
        "postFile": [
          {
            "src": "<outerX>",
            "dst": "<'outer'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a:default>",
            "dst": "<outerX>",
            "type": "READS_FROM"
          },
          {
            "src": "<a()>",
            "dst": "<a>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::async-iife",
      "category": "declarations",
      "code": "const asyncIifeResult = (async () => {\n  return await Promise.resolve('async iife');\n})();",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncIifeResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<async-iife:fn>",
          "metadata": {
            "async": true,
            "arrowFunction": true,
            "iife": true
          }
        },
        {
          "type": "CALL",
          "id": "<async-iife:call>",
          "metadata": {
            "callee": "async-iife:fn",
            "iife": true
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve('async iife')>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'async iife'>",
          "metadata": {
            "value": "async iife",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve('async iife')>",
          "metadata": {
            "operator": "await"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<async-iife:fn>",
            "dst": "<await Promise.resolve('async iife')>",
            "type": "RETURNS"
          },
          {
            "src": "<await Promise.resolve('async iife')>",
            "dst": "<Promise.resolve('async iife')>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve('async iife')>",
            "dst": "<'async iife'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<asyncIifeResult>",
            "dst": "<async-iife:call>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<async-iife:call>",
            "dst": "<async-iife:fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::async-generator-decl",
      "category": "declarations",
      "code": "async function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\n// IIFE (Immediately Invoked Function Expression)",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<asyncGenerator>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield await Promise.resolve(1)>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(1)>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(1)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield await Promise.resolve(2)>",
          "metadata": {
            "operator": "yield"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await Promise.resolve(2)>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve(2)>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Promise>",
          "metadata": {
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncGenerator>",
            "dst": "<yield await Promise.resolve(1)>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncGenerator>",
            "dst": "<yield await Promise.resolve(2)>",
            "type": "CONTAINS"
          },
          {
            "src": "<yield await Promise.resolve(1)>",
            "dst": "<await Promise.resolve(1)>",
            "type": "YIELDS"
          },
          {
            "src": "<await Promise.resolve(1)>",
            "dst": "<Promise.resolve(1)>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve(1)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<yield await Promise.resolve(2)>",
            "dst": "<await Promise.resolve(2)>",
            "type": "YIELDS"
          },
          {
            "src": "<await Promise.resolve(2)>",
            "dst": "<Promise.resolve(2)>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve(2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Promise.resolve(1)>",
            "dst": "<Promise>",
            "type": "CALLS_ON"
          },
          {
            "src": "<Promise.resolve(2)>",
            "dst": "<Promise>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "declarations::param-default-depends-on-prior",
      "category": "declarations",
      "code": "function paramDefaultChain(a, b = a * 2, c = a + b) {\n  return { a, b, c };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<paramDefaultChain>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<c>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b, c }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<paramDefaultChain>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<paramDefaultChain>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<paramDefaultChain>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<b>",
            "dst": "<a * 2>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<c>",
            "dst": "<a + b>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<paramDefaultChain>",
            "dst": "<{ a, b, c }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<a * 2>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<c>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::new-target-in-function",
      "category": "declarations",
      "code": "function FlexibleConstructor(name) {\n  if (!new.target) {\n    return new FlexibleConstructor(name); // redirect if called without new\n  }\n  this.name = name;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<FlexibleConstructor>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "BRANCH",
          "id": "<if-new-target>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!new.target>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<new.target>"
        },
        {
          "type": "CALL",
          "id": "<new FlexibleConstructor(name)>",
          "metadata": {
            "callee": "FlexibleConstructor",
            "withNew": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<FlexibleConstructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<FlexibleConstructor>",
            "dst": "<if-new-target>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-new-target>",
            "dst": "<!new.target>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-new-target>",
            "dst": "<new FlexibleConstructor(name)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<new FlexibleConstructor(name)>",
            "dst": "<name>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<if-new-target>",
            "dst": "<new FlexibleConstructor(name)>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<FlexibleConstructor>",
            "dst": "<this.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<!new.target>",
            "dst": "<new.target>",
            "type": "READS_FROM"
          },
          {
            "src": "<new FlexibleConstructor(name)>",
            "dst": "<FlexibleConstructor>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::func-expr-recursive-self-ref",
      "category": "declarations",
      "code": "const factorialNamedExpr = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1); // fact visible ONLY inside\n};\n// typeof fact === 'undefined'  internal name not in enclosing scope",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<factorialNamedExpr>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<fact>",
          "metadata": {
            "namedExpression": true,
            "internalName": "fact"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<n>"
        },
        {
          "type": "EXPRESSION",
          "id": "<n <= 1>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1-return>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n * fact(n - 1)>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "CALL",
          "id": "<fact(n - 1)>",
          "metadata": {
            "callee": "fact"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n - 1>",
          "metadata": {
            "operator": "-"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fact>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<fact>",
            "dst": "<n <= 1>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<fact>",
            "dst": "<1-return>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<fact(n - 1)>",
            "dst": "<n - 1>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<factorialNamedExpr>",
            "dst": "<fact>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fact>",
            "dst": "<n * fact(n - 1)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<n <= 1>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n <= 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<n * fact(n - 1)>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n * fact(n - 1)>",
            "dst": "<fact(n - 1)>",
            "type": "READS_FROM"
          },
          {
            "src": "<fact(n - 1)>",
            "dst": "<fact>",
            "type": "CALLS"
          },
          {
            "src": "<n - 1>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<n - 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "error-handling::error-custom-class",
      "category": "error-handling",
      "code": "class AppError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<AppError>"
        },
        {
          "type": "METHOD",
          "id": "<AppError.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<message>"
        },
        {
          "type": "PARAMETER",
          "id": "<code>"
        },
        {
          "type": "CALL",
          "id": "<super(message)>",
          "metadata": {
            "callee": "super"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'AppError'>",
          "metadata": {
            "value": "AppError",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.code>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<AppError>",
            "dst": "<AppError.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<AppError.constructor>",
            "dst": "<message>",
            "type": "CONTAINS"
          },
          {
            "src": "<AppError.constructor>",
            "dst": "<code>",
            "type": "CONTAINS"
          },
          {
            "src": "<super(message)>",
            "dst": "<message>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<AppError.constructor>",
            "dst": "<super(message)>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<this.name>",
            "dst": "<'AppError'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<AppError.constructor>",
            "dst": "<this.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.code>",
            "dst": "<code>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<AppError.constructor>",
            "dst": "<this.code>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<AppError>",
            "dst": "<Error>",
            "type": "EXTENDS"
          },
          {
            "src": "<super(message)>",
            "dst": "<Error>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::let-const-multi-declaration",
      "category": "declarations",
      "code": "const constMultiA = 1, constMultiB = constMultiA + 1, constMultiC = constMultiA + constMultiB;\nlet letMultiX = 0, letMultiY = letMultiX + 1;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<constMultiA>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<constMultiB>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<constMultiA + 1>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<constMultiC>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<constMultiA + constMultiB>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<letMultiX>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<letMultiY>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<letMultiX + 1>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<constMultiA>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<constMultiB>",
            "dst": "<constMultiA + 1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<constMultiC>",
            "dst": "<constMultiA + constMultiB>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<letMultiX>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<letMultiY>",
            "dst": "<letMultiX + 1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<constMultiA + 1>",
            "dst": "<constMultiA>",
            "type": "READS_FROM"
          },
          {
            "src": "<constMultiA + constMultiB>",
            "dst": "<constMultiA>",
            "type": "READS_FROM"
          },
          {
            "src": "<constMultiA + constMultiB>",
            "dst": "<constMultiB>",
            "type": "READS_FROM"
          },
          {
            "src": "<letMultiX + 1>",
            "dst": "<letMultiX>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-parse-reviver",
      "category": "builtins",
      "code": "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonParseReviver>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "CALL",
          "id": "<JSON.parse(str, reviver)>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.parse>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "parse"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<reviver>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "BRANCH",
          "id": "<if-date-check>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<key === 'date'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'date'>",
          "metadata": {
            "value": "date",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new Date(value)>",
          "metadata": {
            "callee": "Date",
            "isConstructor": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Date>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<jsonParseReviver>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<jsonParseReviver>",
            "dst": "<JSON.parse(str, reviver)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.parse(str, reviver)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.parse(str, reviver)>",
            "dst": "<reviver>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reviver>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<reviver>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<reviver>",
            "dst": "<if-date-check>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-date-check>",
            "dst": "<key === 'date'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-date-check>",
            "dst": "<new Date(value)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<new Date(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-date-check>",
            "dst": "<value>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<JSON.parse(str, reviver)>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<key === 'date'>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<key === 'date'>",
            "dst": "<'date'>",
            "type": "READS_FROM"
          },
          {
            "src": "<new Date(value)>",
            "dst": "<Date>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-stringify",
      "category": "builtins",
      "code": "function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonStringify>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<JSON.stringify(obj)>",
          "metadata": {
            "callee": "JSON.stringify"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.stringify>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "stringify"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<JSON>",
          "metadata": {
            "builtin": true,
            "global": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<jsonStringify>",
            "type": "DECLARES"
          },
          {
            "src": "<jsonStringify>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<jsonStringify>",
            "dst": "<JSON.stringify(obj)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.stringify(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.stringify>",
            "dst": "<JSON>",
            "type": "ACCESSES_PRIVATE"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<JSON.stringify(obj)>",
            "dst": "<JSON.stringify>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::numeric-separators",
      "category": "declarations",
      "code": "const TIMEOUT_MS = 30_000;\nconst MAX_SAFE = 9_007_199_254_740_991;\nconst HEX_COLOR = 0xFF_EC_D9;\nconst BIT_MASK = 0b1111_0000_1010_0101;\nconst BIG_NUM = 1_000_000_000n;\nconst FLOAT_SEP = 1_000.123_456;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<TIMEOUT_MS>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<30_000>",
          "metadata": {
            "value": 30000,
            "literalType": "number",
            "hasNumericSeparators": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<MAX_SAFE>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<9_007_199_254_740_991>",
          "metadata": {
            "value": 9007199254740991,
            "literalType": "number",
            "hasNumericSeparators": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<HEX_COLOR>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0xFF_EC_D9>",
          "metadata": {
            "value": 16772313,
            "literalType": "number",
            "base": "hex",
            "hasNumericSeparators": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<BIT_MASK>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0b1111_0000_1010_0101>",
          "metadata": {
            "value": 61605,
            "literalType": "number",
            "base": "binary",
            "hasNumericSeparators": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<BIG_NUM>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1_000_000_000n>",
          "metadata": {
            "value": "1000000000",
            "literalType": "bigint",
            "hasNumericSeparators": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<FLOAT_SEP>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1_000.123_456>",
          "metadata": {
            "value": 1000.123456,
            "literalType": "number",
            "hasNumericSeparators": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<TIMEOUT_MS>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<MAX_SAFE>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<HEX_COLOR>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<BIT_MASK>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<BIG_NUM>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<FLOAT_SEP>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<TIMEOUT_MS>",
            "dst": "<30_000>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<MAX_SAFE>",
            "dst": "<9_007_199_254_740_991>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<HEX_COLOR>",
            "dst": "<0xFF_EC_D9>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<BIT_MASK>",
            "dst": "<0b1111_0000_1010_0101>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<BIG_NUM>",
            "dst": "<1_000_000_000n>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<FLOAT_SEP>",
            "dst": "<1_000.123_456>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "error-handling::error-cause",
      "category": "error-handling",
      "code": "async function fetchWithCause(url) {\n  try {\n    const response = await fetch(url);\n    return await response.json();\n  } catch (err) {\n    throw new Error(`Failed to fetch ${url}`, { cause: err });\n  }\n}\n\n// --- Error wrapping / re-throw ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fetchWithCause>",
          "metadata": {
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url)>",
          "metadata": {
            "callee": "fetch",
            "async": true
          }
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "async": true
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "CALL",
          "id": "<new Error>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Failed to fetch '>",
          "metadata": {
            "value": "Failed to fetch ",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Failed to fetch ${url}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ cause: err }>",
          "metadata": {
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetchWithCause>",
            "dst": "<url>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fetchWithCause>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<try-block>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<fetchWithCause>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Error>",
            "dst": "<`Failed to fetch ${url}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error>",
            "dst": "<{ cause: err }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<`Failed to fetch ${url}`>",
            "dst": "<'Failed to fetch '>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<response>",
            "dst": "<fetch(url)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<catch-block>",
            "dst": "<new Error>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "CALLS_ON"
          },
          {
            "src": "<`Failed to fetch ${url}`>",
            "dst": "<url>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ cause: err }>",
            "dst": "<err>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "error-handling::error-wrap-rethrow",
      "category": "error-handling",
      "code": "function parseConfig(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch (err) {\n    throw new AppError(`Invalid config: ${err.message}`, 'PARSE_ERROR');\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<parseConfig>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<raw>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<JSON.parse(raw)>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<err>",
          "metadata": {
            "catchParameter": true
          }
        },
        {
          "type": "CALL",
          "id": "<new AppError>",
          "metadata": {
            "callee": "AppError",
            "constructor": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Invalid config: ${err.message}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'PARSE_ERROR'>",
          "metadata": {
            "value": "PARSE_ERROR",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<err.message>",
          "metadata": {
            "objectName": "err",
            "property": "message"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<JSON.parse>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<AppError>",
          "metadata": {
            "source": "unknown"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<parseConfig>",
            "dst": "<raw>",
            "type": "CONTAINS"
          },
          {
            "src": "<parseConfig>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<parseConfig>",
            "dst": "<catch-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<JSON.parse(raw)>",
            "type": "CONTAINS"
          },
          {
            "src": "<parseConfig>",
            "dst": "<JSON.parse(raw)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.parse(raw)>",
            "dst": "<raw>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<new AppError>",
            "dst": "<`Invalid config: ${err.message}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new AppError>",
            "dst": "<'PARSE_ERROR'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<try-block>",
            "type": "CATCHES_FROM"
          }
        ],
        "postFile": [
          {
            "src": "<catch-block>",
            "dst": "<new AppError>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<JSON.parse(raw)>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<new AppError>",
            "dst": "<AppError>",
            "type": "CALLS"
          },
          {
            "src": "<`Invalid config: ${err.message}`>",
            "dst": "<err.message>",
            "type": "READS_FROM"
          },
          {
            "src": "<err.message>",
            "dst": "<err>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "error-handling::error-async-catch-all",
      "category": "error-handling",
      "code": "async function safeExecute(asyncFn) {\n  try {\n    return { ok: true, value: await asyncFn() };\n  } catch (err) {\n    return { ok: false, error: err };\n  }\n}\n\n// --- Promise rejection handling ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<safeExecute>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<asyncFn>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<safeExecute:try>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<safeExecute:catch>"
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "EXPRESSION",
          "id": "<await asyncFn()>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<asyncFn()>",
          "metadata": {
            "callee": "asyncFn"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ ok: true, value: await asyncFn() }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ ok: false, error: err }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<safeExecute>",
            "dst": "<asyncFn>",
            "type": "CONTAINS"
          },
          {
            "src": "<safeExecute>",
            "dst": "<safeExecute:try>",
            "type": "HAS_BODY"
          },
          {
            "src": "<safeExecute>",
            "dst": "<safeExecute:catch>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<safeExecute:catch>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<safeExecute:try>",
            "dst": "<{ ok: true, value: await asyncFn() }>",
            "type": "RETURNS"
          },
          {
            "src": "<safeExecute:catch>",
            "dst": "<{ ok: false, error: err }>",
            "type": "RETURNS"
          },
          {
            "src": "<await asyncFn()>",
            "dst": "<asyncFn()>",
            "type": "AWAITS"
          },
          {
            "src": "<{ ok: true, value: await asyncFn() }>",
            "dst": "<true>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ ok: true, value: await asyncFn() }>",
            "dst": "<await asyncFn()>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ ok: false, error: err }>",
            "dst": "<false>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ ok: false, error: err }>",
            "dst": "<err>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<safeExecute:catch>",
            "dst": "<err>",
            "type": "CATCHES_FROM"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<asyncFn()>",
            "dst": "<asyncFn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "declarations::param-default-from-destructured",
      "category": "declarations",
      "code": "function paramDefaultFromDestructured({width, height}, area = width * height) {\n  return { width, height, area };\n}\n\n// Also with nested destructuring feeding later default:\nfunction queryBuilder({table, schema = 'public'}, fullName = `${schema}.${table}`) {\n  return `SELECT * FROM ${fullName}`;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<paramDefaultFromDestructured>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<{width, height}>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<width>",
          "metadata": {
            "destructuredFrom": "{width, height}"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<height>",
          "metadata": {
            "destructuredFrom": "{width, height}"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<area>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<width * height>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ width, height, area }>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<queryBuilder>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<{table, schema = 'public'}>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<table>",
          "metadata": {
            "destructuredFrom": "{table, schema = 'public'}"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<schema>",
          "metadata": {
            "destructuredFrom": "{table, schema = 'public'}",
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'public'>",
          "metadata": {
            "value": "public",
            "literalType": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fullName>",
          "metadata": {
            "hasDefault": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`${schema}.${table}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`SELECT * FROM ${fullName}`>",
          "metadata": {
            "type": "template-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<paramDefaultFromDestructured>",
            "dst": "<{width, height}>",
            "type": "CONTAINS"
          },
          {
            "src": "<paramDefaultFromDestructured>",
            "dst": "<area>",
            "type": "CONTAINS"
          },
          {
            "src": "<{width, height}>",
            "dst": "<width>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<{width, height}>",
            "dst": "<height>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<area>",
            "dst": "<width * height>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<paramDefaultFromDestructured>",
            "dst": "<{ width, height, area }>",
            "type": "RETURNS"
          },
          {
            "src": "<queryBuilder>",
            "dst": "<{table, schema = 'public'}>",
            "type": "CONTAINS"
          },
          {
            "src": "<queryBuilder>",
            "dst": "<fullName>",
            "type": "CONTAINS"
          },
          {
            "src": "<{table, schema = 'public'}>",
            "dst": "<table>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<{table, schema = 'public'}>",
            "dst": "<schema>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<schema>",
            "dst": "<'public'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<fullName>",
            "dst": "<`${schema}.${table}`>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<queryBuilder>",
            "dst": "<`SELECT * FROM ${fullName}`>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<width * height>",
            "dst": "<width>",
            "type": "READS_FROM"
          },
          {
            "src": "<width * height>",
            "dst": "<height>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ width, height, area }>",
            "dst": "<width>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ width, height, area }>",
            "dst": "<height>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ width, height, area }>",
            "dst": "<area>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${schema}.${table}`>",
            "dst": "<schema>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${schema}.${table}`>",
            "dst": "<table>",
            "type": "READS_FROM"
          },
          {
            "src": "<`SELECT * FROM ${fullName}`>",
            "dst": "<fullName>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "declarations::export-named-list",
      "category": "declarations",
      "code": "export {\n  mutableVar,\n  reassignable,\n  immutable,\n  objectConst,\n  arrayConst,\n  bigNumber,\n  uniqueKey,\n  globalSymbol,\n  regexSimple,\n  regularFunction,\n  withDefaults,\n  withRestParams,\n  withMixedParams,\n  namedExpression,\n  anonymousExpression,\n  arrowBlock,\n  arrowExpression,\n  arrowSingleParam,\n  arrowNoParams,\n  numberGenerator,\n  delegatingGenerator,\n  asyncFunction,\n  asyncArrow,\n  asyncGenerator,\n  iifeResult,\n  arrowIifeResult,\n  paramDefaultChain,\n  paramDefaultScope,\n  arrowReturnsObject,\n  asyncIifeResult,\n  constMultiC,\n  letMultiY,\n  factorialNamedExpr,\n  FlexibleConstructor,\n  paramDefaultFromDestructured,\n  queryBuilder,\n  TIMEOUT_MS,\n  MAX_SAFE,\n  HEX_COLOR,\n  BIT_MASK,\n  BIG_NUM,\n  FLOAT_SEP,\n  functionNameInference,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-named-list>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<mutableVar>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<reassignable>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<immutable>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<objectConst>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrayConst>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<bigNumber>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<uniqueKey>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<globalSymbol>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<regexSimple>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<regularFunction>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<withDefaults>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<withRestParams>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<withMixedParams>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<namedExpression>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<anonymousExpression>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrowBlock>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrowExpression>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrowSingleParam>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrowNoParams>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<numberGenerator>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<delegatingGenerator>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<asyncFunction>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<asyncArrow>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<asyncGenerator>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<iifeResult>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrowIifeResult>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<paramDefaultChain>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<paramDefaultScope>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<arrowReturnsObject>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<asyncIifeResult>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<constMultiC>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<letMultiY>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<factorialNamedExpr>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<FlexibleConstructor>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<paramDefaultFromDestructured>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<queryBuilder>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<TIMEOUT_MS>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<MAX_SAFE>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<HEX_COLOR>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<BIT_MASK>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<BIG_NUM>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<FLOAT_SEP>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<functionNameInference>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "error-handling::error-promise-catch",
      "category": "error-handling",
      "code": "function promiseErrorHandling() {\n  return Promise.reject(new Error('boom'))\n    .catch(err => {\n      console.error('Caught:', err.message);\n      return 'recovered';\n    });\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<promiseErrorHandling>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.reject(new Error('boom'))>",
          "metadata": {
            "callee": "Promise.reject"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('boom')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'boom'>",
          "metadata": {
            "value": "boom",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<.catch(err => {...})>",
          "metadata": {
            "callee": "catch",
            "method": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<catch-handler>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "CALL",
          "id": "<console.error('Caught:', err.message)>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Caught:'>",
          "metadata": {
            "value": "Caught:",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<err.message>",
          "metadata": {
            "objectName": "err",
            "property": "message"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'recovered'>",
          "metadata": {
            "value": "recovered",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<promiseErrorHandling>",
            "dst": "<Promise.reject(new Error('boom'))>",
            "type": "RETURNS"
          },
          {
            "src": "<Promise.reject(new Error('boom'))>",
            "dst": "<new Error('boom')>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('boom')>",
            "dst": "<'boom'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Promise.reject(new Error('boom'))>",
            "dst": "<.catch(err => {...})>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<.catch(err => {...})>",
            "dst": "<catch-handler>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-handler>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-handler>",
            "dst": "<console.error('Caught:', err.message)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.error('Caught:', err.message)>",
            "dst": "<'Caught:'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.error('Caught:', err.message)>",
            "dst": "<err.message>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-handler>",
            "dst": "<'recovered'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<err.message>",
            "dst": "<err>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-json-stringify-replacer",
      "category": "builtins",
      "code": "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<jsonStringifyReplacer>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<JSON.stringify(obj, replacer, 2)>",
          "metadata": {
            "callee": "JSON.stringify"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.stringify>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "stringify"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<replacer>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value === 'function'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'function'>",
          "metadata": {
            "value": "function",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<undefined>",
          "metadata": {
            "value": "undefined",
            "literalType": "undefined"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-typeof-function>",
          "metadata": {
            "branchType": "if"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<jsonStringifyReplacer>",
            "dst": "<obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<jsonStringifyReplacer>",
            "dst": "<JSON.stringify(obj, replacer, 2)>",
            "type": "RETURNS"
          },
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<replacer>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<replacer>",
            "dst": "<key>",
            "type": "HAS_BODY"
          },
          {
            "src": "<replacer>",
            "dst": "<value>",
            "type": "HAS_BODY"
          },
          {
            "src": "<replacer>",
            "dst": "<if-typeof-function>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-typeof-function>",
            "dst": "<typeof value === 'function'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-typeof-function>",
            "dst": "<undefined>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<if-typeof-function>",
            "dst": "<value>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<JSON.stringify(obj, replacer, 2)>",
            "dst": "<JSON.stringify>",
            "type": "CALLS"
          },
          {
            "src": "<typeof value === 'function'>",
            "dst": "<typeof value>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value === 'function'>",
            "dst": "<'function'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value>",
            "dst": "<value>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "error-handling::error-rethrow-conditional",
      "category": "error-handling",
      "code": "function processData(data) {\n  try {\n    return transform(data);\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err; // re-throw known errors as-is\n    }\n    throw new AppError(`Unexpected: ${err.message}`, 'INTERNAL');\n  }\n}\n\nfunction transform(data) {\n  if (!data) throw new ValidationError('data', 'Data is required');\n  return data;\n}\n\n// --- instanceof checks in catch ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<processData>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<processData:try>"
        },
        {
          "type": "CALL",
          "id": "<transform(data)>",
          "metadata": {
            "callee": "transform"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<processData:catch>"
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "BRANCH",
          "id": "<err instanceof ValidationError>"
        },
        {
          "type": "EXPRESSION",
          "id": "<err instanceof ValidationError>",
          "metadata": {
            "operator": "instanceof"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw err>",
          "metadata": {
            "throwType": "rethrow"
          }
        },
        {
          "type": "CALL",
          "id": "<new AppError(...)>",
          "metadata": {
            "callee": "AppError",
            "constructor": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw new AppError(...)>",
          "metadata": {
            "throwType": "new"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<transform>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<transform:data>"
        },
        {
          "type": "BRANCH",
          "id": "<transform:if>"
        },
        {
          "type": "EXPRESSION",
          "id": "<!data>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "CALL",
          "id": "<new ValidationError(...)>",
          "metadata": {
            "callee": "ValidationError",
            "constructor": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw new ValidationError(...)>",
          "metadata": {
            "throwType": "new"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<processData>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<processData>",
            "dst": "<processData:try>",
            "type": "CONTAINS"
          },
          {
            "src": "<processData:try>",
            "dst": "<transform(data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<processData:try>",
            "dst": "<transform(data)>",
            "type": "RETURNS"
          },
          {
            "src": "<transform(data)>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<processData>",
            "dst": "<processData:catch>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<processData:catch>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<processData:catch>",
            "dst": "<err instanceof ValidationError>",
            "type": "CONTAINS"
          },
          {
            "src": "<err instanceof ValidationError>",
            "dst": "<err instanceof ValidationError>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<err instanceof ValidationError>",
            "dst": "<throw err>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<transform>",
            "dst": "<transform:data>",
            "type": "CONTAINS"
          },
          {
            "src": "<transform>",
            "dst": "<transform:if>",
            "type": "CONTAINS"
          },
          {
            "src": "<transform:if>",
            "dst": "<!data>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<transform:if>",
            "dst": "<throw new ValidationError(...)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<transform>",
            "dst": "<transform:data>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<throw err>",
            "dst": "<err>",
            "type": "THROWS"
          },
          {
            "src": "<err instanceof ValidationError>",
            "dst": "<throw new AppError(...)>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<throw new AppError(...)>",
            "dst": "<new AppError(...)>",
            "type": "THROWS"
          },
          {
            "src": "<throw new ValidationError(...)>",
            "dst": "<new ValidationError(...)>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<transform(data)>",
            "dst": "<transform>",
            "type": "CALLS"
          },
          {
            "src": "<err instanceof ValidationError>",
            "dst": "<err>",
            "type": "READS_FROM"
          },
          {
            "src": "<new AppError(...)>",
            "dst": "<err>",
            "type": "READS_FROM"
          },
          {
            "src": "<!data>",
            "dst": "<transform:data>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "error-handling::error-custom-hierarchy",
      "category": "error-handling",
      "code": "class ValidationError extends AppError {\n  constructor(field, message) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource, id) {\n    super(`${resource} not found: ${id}`, 'NOT_FOUND');\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.id = id;\n  }\n}\n\n// --- Error cause (ES2022) ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ValidationError>"
        },
        {
          "type": "METHOD",
          "id": "<ValidationError.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<field>"
        },
        {
          "type": "PARAMETER",
          "id": "<message>"
        },
        {
          "type": "CALL",
          "id": "<super(message, 'VALIDATION_ERROR')>",
          "metadata": {
            "callee": "super"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'VALIDATION_ERROR'>",
          "metadata": {
            "value": "VALIDATION_ERROR",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this",
            "property": "name"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'ValidationError'>",
          "metadata": {
            "value": "ValidationError",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.field>",
          "metadata": {
            "objectName": "this",
            "property": "field"
          }
        },
        {
          "type": "CLASS",
          "id": "<NotFoundError>"
        },
        {
          "type": "METHOD",
          "id": "<NotFoundError.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<resource>"
        },
        {
          "type": "PARAMETER",
          "id": "<id>"
        },
        {
          "type": "EXPRESSION",
          "id": "<`${resource} not found: ${id}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<super(`${resource} not found: ${id}`, 'NOT_FOUND')>",
          "metadata": {
            "callee": "super"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'NOT_FOUND'>",
          "metadata": {
            "value": "NOT_FOUND",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name2>",
          "metadata": {
            "objectName": "this",
            "property": "name"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'NotFoundError'>",
          "metadata": {
            "value": "NotFoundError",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.resource>",
          "metadata": {
            "objectName": "this",
            "property": "resource"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.id>",
          "metadata": {
            "objectName": "this",
            "property": "id"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ValidationError>",
            "dst": "<ValidationError.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<ValidationError.constructor>",
            "dst": "<field>",
            "type": "CONTAINS"
          },
          {
            "src": "<ValidationError.constructor>",
            "dst": "<message>",
            "type": "CONTAINS"
          },
          {
            "src": "<ValidationError.constructor>",
            "dst": "<super(message, 'VALIDATION_ERROR')>",
            "type": "CONTAINS"
          },
          {
            "src": "<super(message, 'VALIDATION_ERROR')>",
            "dst": "<message>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<super(message, 'VALIDATION_ERROR')>",
            "dst": "<'VALIDATION_ERROR'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<NotFoundError>",
            "dst": "<NotFoundError.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<NotFoundError.constructor>",
            "dst": "<resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<NotFoundError.constructor>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<NotFoundError.constructor>",
            "dst": "<super(`${resource} not found: ${id}`, 'NOT_FOUND')>",
            "type": "CONTAINS"
          },
          {
            "src": "<super(`${resource} not found: ${id}`, 'NOT_FOUND')>",
            "dst": "<`${resource} not found: ${id}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<super(`${resource} not found: ${id}`, 'NOT_FOUND')>",
            "dst": "<'NOT_FOUND'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<this.name>",
            "dst": "<'ValidationError'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.field>",
            "dst": "<field>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.name2>",
            "dst": "<'NotFoundError'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.resource>",
            "dst": "<resource>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.id>",
            "dst": "<id>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`${resource} not found: ${id}`>",
            "dst": "<resource>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${resource} not found: ${id}`>",
            "dst": "<id>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "error-handling::export-named-list",
      "category": "error-handling",
      "code": "export {\n  AppError,\n  ValidationError,\n  NotFoundError,\n  fetchWithCause,\n  parseConfig,\n  processData,\n  handleError,\n  pipeline,\n  safeExecute,\n  promiseErrorHandling,\n  chainedErrors,\n  aggregatedErrors,\n  withCleanup,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<AppError>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<ValidationError>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<NotFoundError>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fetchWithCause>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<parseConfig>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<processData>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<handleError>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<pipeline>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<safeExecute>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<promiseErrorHandling>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<chainedErrors>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<aggregatedErrors>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<withCleanup>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<AppError>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<ValidationError>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<NotFoundError>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<fetchWithCause>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<parseConfig>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<processData>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<handleError>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<pipeline>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<safeExecute>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<promiseErrorHandling>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<chainedErrors>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<aggregatedErrors>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<withCleanup>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "error-handling::error-aggregate",
      "category": "error-handling",
      "code": "function aggregatedErrors() {\n  const errors = [\n    new Error('first'),\n    new Error('second'),\n    new Error('third'),\n  ];\n  throw new AggregateError(errors, 'Multiple failures');\n}\n\n// --- Finally for cleanup ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<aggregatedErrors>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<errors>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<['first', 'second', 'third']>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('first')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'first'>",
          "metadata": {
            "value": "first",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('second')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'second'>",
          "metadata": {
            "value": "second",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('third')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'third'>",
          "metadata": {
            "value": "third",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new AggregateError(errors, 'Multiple failures')>",
          "metadata": {
            "callee": "AggregateError",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Multiple failures'>",
          "metadata": {
            "value": "Multiple failures",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Error>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<AggregateError>",
          "metadata": {
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<aggregatedErrors>",
            "dst": "<errors>",
            "type": "CONTAINS"
          },
          {
            "src": "<['first', 'second', 'third']>",
            "dst": "<new Error('first')>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['first', 'second', 'third']>",
            "dst": "<new Error('second')>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['first', 'second', 'third']>",
            "dst": "<new Error('third')>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<new Error('first')>",
            "dst": "<'first'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('second')>",
            "dst": "<'second'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('third')>",
            "dst": "<'third'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new AggregateError(errors, 'Multiple failures')>",
            "dst": "<errors>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new AggregateError(errors, 'Multiple failures')>",
            "dst": "<'Multiple failures'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<errors>",
            "dst": "<['first', 'second', 'third']>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<aggregatedErrors>",
            "dst": "<new AggregateError(errors, 'Multiple failures')>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<new Error('first')>",
            "dst": "<Error>",
            "type": "CALLS"
          },
          {
            "src": "<new Error('second')>",
            "dst": "<Error>",
            "type": "CALLS"
          },
          {
            "src": "<new Error('third')>",
            "dst": "<Error>",
            "type": "CALLS"
          },
          {
            "src": "<new AggregateError(errors, 'Multiple failures')>",
            "dst": "<AggregateError>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::delete-op",
      "category": "expressions",
      "code": "function deleteOperator() {\n  const obj = { a: 1, b: 2 };\n  delete obj.a;\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deleteOperator>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1, b: 2 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<delete obj.a>",
          "metadata": {
            "operator": "delete"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.a>",
          "metadata": {
            "property": "a"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deleteOperator>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1, b: 2 }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ a: 1, b: 2 }>",
            "dst": "<2>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<deleteOperator>",
            "dst": "<delete obj.a>",
            "type": "CONTAINS"
          },
          {
            "src": "<delete obj.a>",
            "dst": "<obj.a>",
            "type": "DELETES"
          },
          {
            "src": "<deleteOperator>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{ a: 1, b: 2 }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj.a>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::update-expr",
      "category": "expressions",
      "code": "function updateExpressions() {\n  let x = 0;\n  x++;\n  x--;\n  ++x;\n  --x;\n  return x;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<updateExpressions>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x++>",
          "metadata": {
            "operator": "++",
            "prefix": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x-->",
          "metadata": {
            "operator": "--",
            "prefix": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<++x>",
          "metadata": {
            "operator": "++",
            "prefix": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<--x>",
          "metadata": {
            "operator": "--",
            "prefix": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<updateExpressions>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<updateExpressions>",
            "dst": "<x>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<x>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<x++>",
            "dst": "<x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<x-->",
            "dst": "<x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<++x>",
            "dst": "<x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<--x>",
            "dst": "<x>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<x++>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x-->",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<++x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<--x>",
            "dst": "<x>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::logical-ops",
      "category": "expressions",
      "code": "function logicalOperators(a, b) {\n  const and = a && b;\n  const or = a || b;\n  const nullish = a ?? b;\n  const not = !a;\n  return { and, or, nullish, not };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<logicalOperators>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "VARIABLE",
          "id": "<and>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a && b>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<or>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a || b>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<nullish>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a ?? b>",
          "metadata": {
            "operator": "??"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<not>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!a>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ and, or, nullish, not }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<logicalOperators>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalOperators>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalOperators>",
            "dst": "<and>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalOperators>",
            "dst": "<or>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalOperators>",
            "dst": "<nullish>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalOperators>",
            "dst": "<not>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalOperators>",
            "dst": "<{ and, or, nullish, not }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<and>",
            "dst": "<a && b>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<or>",
            "dst": "<a || b>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<nullish>",
            "dst": "<a ?? b>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<not>",
            "dst": "<!a>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a && b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a && b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<a || b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a || b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<a ?? b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a ?? b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<!a>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ and, or, nullish, not }>",
            "dst": "<and>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ and, or, nullish, not }>",
            "dst": "<or>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ and, or, nullish, not }>",
            "dst": "<nullish>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ and, or, nullish, not }>",
            "dst": "<not>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::tagged-template-usage",
      "category": "expressions",
      "code": "const tagged = tag`Hello ${'world'} number ${42}`;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<tagged>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<tag`Hello ${'world'} number ${42}`>",
          "metadata": {
            "callType": "tagged-template"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Hello '>",
          "metadata": {
            "value": "Hello ",
            "literalType": "string",
            "templatePart": "static"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'world'>",
          "metadata": {
            "value": "world",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<' number '>",
          "metadata": {
            "value": " number ",
            "literalType": "string",
            "templatePart": "static"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string",
            "templatePart": "static"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<tagged>",
            "type": "DECLARES"
          },
          {
            "src": "<tag`Hello ${'world'} number ${42}`>",
            "dst": "<'Hello '>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tag`Hello ${'world'} number ${42}`>",
            "dst": "<' number '>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tag`Hello ${'world'} number ${42}`>",
            "dst": "<''>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tag`Hello ${'world'} number ${42}`>",
            "dst": "<'world'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tag`Hello ${'world'} number ${42}`>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<tagged>",
            "dst": "<tag`Hello ${'world'} number ${42}`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<tag`Hello ${'world'} number ${42}`>",
            "dst": "<tag>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::tagged-template-fn",
      "category": "expressions",
      "code": "function tag(strings, ...values) {\n  return strings.raw.join('') + values.join('');\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tag>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings>"
        },
        {
          "type": "PARAMETER",
          "id": "<values>",
          "metadata": {
            "restParameter": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<strings.raw>",
          "metadata": {
            "property": "raw"
          }
        },
        {
          "type": "CALL",
          "id": "<strings.raw.join('')>",
          "metadata": {
            "callee": "join",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<values.join('')>",
          "metadata": {
            "callee": "join",
            "method": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<strings.raw.join('') + values.join('')>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tag>",
            "dst": "<strings>",
            "type": "HAS_BODY"
          },
          {
            "src": "<tag>",
            "dst": "<values>",
            "type": "HAS_BODY"
          },
          {
            "src": "<strings.raw.join('')>",
            "dst": "<''>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<values.join('')>",
            "dst": "<''>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tag>",
            "dst": "<strings.raw.join('') + values.join('')>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<strings.raw>",
            "dst": "<strings>",
            "type": "READS_FROM"
          },
          {
            "src": "<strings.raw.join('')>",
            "dst": "<strings.raw>",
            "type": "CALLS_ON"
          },
          {
            "src": "<values.join('')>",
            "dst": "<values>",
            "type": "CALLS_ON"
          },
          {
            "src": "<strings.raw.join('') + values.join('')>",
            "dst": "<strings.raw.join('')>",
            "type": "READS_FROM"
          },
          {
            "src": "<strings.raw.join('') + values.join('')>",
            "dst": "<values.join('')>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::optional-chaining",
      "category": "expressions",
      "code": "function optionalChaining(obj) {\n  const prop = obj?.nested?.deep;\n  const method = obj?.method?.();\n  const computed = obj?.items?.[0];\n  return { prop, method, computed };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<optionalChaining>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<prop>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj?.nested?.deep>",
          "metadata": {
            "type": "optional_chain",
            "chainLength": 3
          }
        },
        {
          "type": "VARIABLE",
          "id": "<method>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj?.method?.()>",
          "metadata": {
            "type": "optional_chain_call",
            "chainLength": 2,
            "hasCall": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<computed>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj?.items?.[0]>",
          "metadata": {
            "type": "optional_chain_computed",
            "chainLength": 2,
            "hasComputed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ prop, method, computed }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<optionalChaining>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChaining>",
            "dst": "<prop>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChaining>",
            "dst": "<method>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChaining>",
            "dst": "<computed>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChaining>",
            "dst": "<{ prop, method, computed }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<prop>",
            "dst": "<obj?.nested?.deep>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<method>",
            "dst": "<obj?.method?.()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<computed>",
            "dst": "<obj?.items?.[0]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj?.nested?.deep>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj?.method?.()>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj?.items?.[0]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj?.items?.[0]>",
            "dst": "<0>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ prop, method, computed }>",
            "dst": "<prop>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ prop, method, computed }>",
            "dst": "<method>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ prop, method, computed }>",
            "dst": "<computed>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::unary-ops",
      "category": "expressions",
      "code": "function unaryOperators(x) {\n  const pos = +x;\n  const neg = -x;\n  const logNot = !x;\n  const bitNot = ~x;\n  const typeOfX = typeof x;\n  const voidX = void x;\n  return { pos, neg, logNot, bitNot, typeOfX, voidX };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<unaryOperators>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "VARIABLE",
          "id": "<pos>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<+x>",
          "metadata": {
            "operator": "+",
            "unary": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<neg>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<-x>",
          "metadata": {
            "operator": "-",
            "unary": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<logNot>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!x>",
          "metadata": {
            "operator": "!",
            "unary": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<bitNot>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<~x>",
          "metadata": {
            "operator": "~",
            "unary": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<typeOfX>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof x>",
          "metadata": {
            "operator": "typeof",
            "unary": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<voidX>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<void x>",
          "metadata": {
            "operator": "void",
            "unary": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<unaryOperators>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<pos>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<neg>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<logNot>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<bitNot>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<typeOfX>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<voidX>",
            "type": "CONTAINS"
          },
          {
            "src": "<unaryOperators>",
            "dst": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<pos>",
            "dst": "<+x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<neg>",
            "dst": "<-x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<logNot>",
            "dst": "<!x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<bitNot>",
            "dst": "<~x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<typeOfX>",
            "dst": "<typeof x>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<voidX>",
            "dst": "<void x>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<+x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<-x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<!x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<~x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<void x>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "dst": "<pos>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "dst": "<neg>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "dst": "<logNot>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "dst": "<bitNot>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "dst": "<typeOfX>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ pos, neg, logNot, bitNot, typeOfX, voidX }>",
            "dst": "<voidX>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-map-constructor",
      "category": "builtins",
      "code": "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<mapFromEntries>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<map>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map([...])>",
          "metadata": {
            "callee": "Map",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<[['x', 10], ['y', 20]]>",
          "metadata": {
            "value": "[['x', 10], ['y', 20]]",
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<['x', 10]>",
          "metadata": {
            "value": "['x', 10]",
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'x'>",
          "metadata": {
            "value": "x",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<['y', 20]>",
          "metadata": {
            "value": "['y', 20]",
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'y'>",
          "metadata": {
            "value": "y",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<20>",
          "metadata": {
            "value": 20,
            "literalType": "number"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Map>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<mapFromEntries>",
            "dst": "<map>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Map([...])>",
            "dst": "<[['x', 10], ['y', 20]]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<[['x', 10], ['y', 20]]>",
            "dst": "<['x', 10]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[['x', 10], ['y', 20]]>",
            "dst": "<['y', 20]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['x', 10]>",
            "dst": "<'x'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['x', 10]>",
            "dst": "<10>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['y', 20]>",
            "dst": "<'y'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['y', 20]>",
            "dst": "<20>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<mapFromEntries>",
            "dst": "<map>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<map>",
            "dst": "<new Map([...])>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new Map([...])>",
            "dst": "<Map>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::chained-assignment-mixed",
      "category": "expressions",
      "code": "function chainedAssignmentMixed() {\n  const obj = {};\n  obj.x = obj.y = [];\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<chainedAssignmentMixed>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.x>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "x"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.y>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "y"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj.x = obj.y = []>",
          "metadata": {
            "operator": "chained-assignment"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<chainedAssignmentMixed>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<chainedAssignmentMixed>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.y>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.x>",
            "dst": "<obj.y>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.x = obj.y = []>",
            "dst": "<obj.x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.x = obj.y = []>",
            "dst": "<obj.y>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<obj.x = obj.y = []>",
            "dst": "<[]>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::chained-assignment",
      "category": "expressions",
      "code": "function chainedAssignment() {\n  let a, b, c;\n  a = b = c = 42;\n  return { a, b, c };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<chainedAssignment>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<c>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b, c }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<chainedAssignment>",
            "dst": "<a>",
            "type": "DECLARES"
          },
          {
            "src": "<chainedAssignment>",
            "dst": "<b>",
            "type": "DECLARES"
          },
          {
            "src": "<chainedAssignment>",
            "dst": "<c>",
            "type": "DECLARES"
          },
          {
            "src": "<chainedAssignment>",
            "dst": "<{ a, b, c }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<c>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<c>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a>",
            "dst": "<b>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ a, b, c }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<c>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::ternary",
      "category": "expressions",
      "code": "function ternaryOperator(condition, value) {\n  const simple = condition ? 'yes' : 'no';\n  const nested = condition ? (value > 5 ? 'high' : 'low') : 'none';\n  return { simple, nested };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<ternaryOperator>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<condition>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "VARIABLE",
          "id": "<simple>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<condition ? 'yes' : 'no'>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'yes'>",
          "metadata": {
            "value": "yes",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'no'>",
          "metadata": {
            "value": "no",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<nested>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<condition ? (value > 5 ? 'high' : 'low') : 'none'>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<value > 5 ? 'high' : 'low'>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<value > 5>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'high'>",
          "metadata": {
            "value": "high",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'low'>",
          "metadata": {
            "value": "low",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'none'>",
          "metadata": {
            "value": "none",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ simple, nested }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ternaryOperator>",
            "dst": "<condition>",
            "type": "CONTAINS"
          },
          {
            "src": "<ternaryOperator>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<ternaryOperator>",
            "dst": "<simple>",
            "type": "CONTAINS"
          },
          {
            "src": "<ternaryOperator>",
            "dst": "<nested>",
            "type": "CONTAINS"
          },
          {
            "src": "<condition ? 'yes' : 'no'>",
            "dst": "<condition>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<condition ? 'yes' : 'no'>",
            "dst": "<'yes'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<condition ? (value > 5 ? 'high' : 'low') : 'none'>",
            "dst": "<condition>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<condition ? (value > 5 ? 'high' : 'low') : 'none'>",
            "dst": "<value > 5 ? 'high' : 'low'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<value > 5 ? 'high' : 'low'>",
            "dst": "<value > 5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<value > 5 ? 'high' : 'low'>",
            "dst": "<'high'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ternaryOperator>",
            "dst": "<{ simple, nested }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ simple, nested }>",
            "dst": "<simple>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ simple, nested }>",
            "dst": "<nested>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<simple>",
            "dst": "<condition ? 'yes' : 'no'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<condition ? 'yes' : 'no'>",
            "dst": "<'no'>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<nested>",
            "dst": "<condition ? (value > 5 ? 'high' : 'low') : 'none'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<condition ? (value > 5 ? 'high' : 'low') : 'none'>",
            "dst": "<'none'>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<value > 5 ? 'high' : 'low'>",
            "dst": "<'low'>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<value > 5>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<value > 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::grouping",
      "category": "expressions",
      "code": "function groupingOperator(a, b, c) {\n  const withGrouping = (a + b) * c;\n  const withoutGrouping = a + b * c;\n  return { withGrouping, withoutGrouping };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<groupingOperator>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "PARAMETER",
          "id": "<c>"
        },
        {
          "type": "VARIABLE",
          "id": "<withGrouping>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<(a + b) * c>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b>",
          "metadata": {
            "operator": "+",
            "grouped": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<withoutGrouping>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a + b * c>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<b * c>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ withGrouping, withoutGrouping }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<groupingOperator>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<groupingOperator>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<groupingOperator>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<groupingOperator>",
            "dst": "<withGrouping>",
            "type": "CONTAINS"
          },
          {
            "src": "<groupingOperator>",
            "dst": "<withoutGrouping>",
            "type": "CONTAINS"
          },
          {
            "src": "<groupingOperator>",
            "dst": "<{ withGrouping, withoutGrouping }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<withGrouping>",
            "dst": "<(a + b) * c>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<withoutGrouping>",
            "dst": "<a + b * c>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<(a + b) * c>",
            "dst": "<a + b>",
            "type": "READS_FROM"
          },
          {
            "src": "<(a + b) * c>",
            "dst": "<c>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b * c>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a + b * c>",
            "dst": "<b * c>",
            "type": "READS_FROM"
          },
          {
            "src": "<b * c>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<b * c>",
            "dst": "<c>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ withGrouping, withoutGrouping }>",
            "dst": "<withGrouping>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ withGrouping, withoutGrouping }>",
            "dst": "<withoutGrouping>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::comma-in-return",
      "category": "expressions",
      "code": "function commaInReturn() {\n  return (1, 2, 3);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<commaInReturn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<(1, 2, 3)>",
          "metadata": {
            "operator": "comma",
            "sequenceLength": 3
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<commaInReturn>",
            "type": "DECLARES"
          },
          {
            "src": "<commaInReturn>",
            "dst": "<(1, 2, 3)>",
            "type": "RETURNS"
          },
          {
            "src": "<(1, 2, 3)>",
            "dst": "<1>",
            "type": "CONTAINS"
          },
          {
            "src": "<(1, 2, 3)>",
            "dst": "<2>",
            "type": "CONTAINS"
          },
          {
            "src": "<(1, 2, 3)>",
            "dst": "<3>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "expressions::tagged-template-raw",
      "category": "expressions",
      "code": "function rawTemplate(strings) {\n  return strings.raw[0];\n}\nconst rawResult = rawTemplate`\\n`;",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<rawTemplate>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<strings.raw[0]>",
          "metadata": {
            "objectName": "strings",
            "propertyChain": [
              "raw",
              "0"
            ]
          }
        },
        {
          "type": "VARIABLE",
          "id": "<rawResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<rawTemplate`\\n`>",
          "metadata": {
            "tag": "rawTemplate",
            "rawString": "\\n"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<rawTemplate>",
            "type": "DECLARES"
          },
          {
            "src": "<rawTemplate>",
            "dst": "<strings>",
            "type": "CONTAINS"
          },
          {
            "src": "<rawTemplate>",
            "dst": "<strings.raw[0]>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<rawResult>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<rawResult>",
            "dst": "<rawTemplate`\\n`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<strings.raw[0]>",
            "dst": "<strings>",
            "type": "READS_FROM"
          },
          {
            "src": "<rawTemplate`\\n`>",
            "dst": "<rawTemplate>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::void-promise",
      "category": "expressions",
      "code": "void async function () { await Promise.resolve('ping'); }();",
      "expectedNodes": [
        {
          "type": "EXPRESSION",
          "id": "<void-expression>",
          "metadata": {
            "operator": "void"
          }
        },
        {
          "type": "CALL",
          "id": "<iife-call>",
          "metadata": {
            "immediatelyInvoked": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<async-iife>",
          "metadata": {
            "async": true,
            "anonymous": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await-expression>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.resolve('ping')>",
          "metadata": {
            "callee": "Promise.resolve"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Promise.resolve>",
          "metadata": {
            "objectName": "Promise",
            "propertyName": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'ping'>",
          "metadata": {
            "value": "ping",
            "literalType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Promise>",
          "metadata": {
            "name": "Promise",
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<void-expression>",
            "dst": "<iife-call>",
            "type": "CONTAINS"
          },
          {
            "src": "<async-iife>",
            "dst": "<await-expression>",
            "type": "CONTAINS"
          },
          {
            "src": "<await-expression>",
            "dst": "<Promise.resolve('ping')>",
            "type": "AWAITS"
          },
          {
            "src": "<Promise.resolve('ping')>",
            "dst": "<'ping'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<iife-call>",
            "dst": "<async-iife>",
            "type": "CALLS"
          },
          {
            "src": "<Promise.resolve('ping')>",
            "dst": "<Promise.resolve>",
            "type": "CALLS"
          },
          {
            "src": "<Promise.resolve>",
            "dst": "<Promise>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::void-iife",
      "category": "expressions",
      "code": "void function () { console.log('fire and forget'); }();",
      "expectedNodes": [
        {
          "type": "EXPRESSION",
          "id": "<void-expression>",
          "metadata": {
            "operator": "void"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<anonymous-fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "CALL",
          "id": "<iife-call>",
          "metadata": {
            "immediatelyInvoked": true
          }
        },
        {
          "type": "CALL",
          "id": "<console.log('fire and forget')>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fire and forget'>",
          "metadata": {
            "value": "fire and forget",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<void-expression>",
            "dst": "<iife-call>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-fn>",
            "dst": "<console.log('fire and forget')>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log('fire and forget')>",
            "dst": "<'fire and forget'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<iife-call>",
            "dst": "<anonymous-fn>",
            "type": "CALLS"
          },
          {
            "src": "<console.log('fire and forget')>",
            "dst": "<console.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::new-constructor-return-non-this",
      "category": "expressions",
      "code": "function NonThisConstructor() {\n  return { custom: true }; // returns different object than `this`\n}\nconst nonThisInstance = new NonThisConstructor(); // NOT instanceof NonThisConstructor!",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<NonThisConstructor>",
          "metadata": {
            "async": false,
            "generator": false,
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ custom: true }>",
          "metadata": {
            "value": "{ custom: true }",
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<nonThisInstance>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new NonThisConstructor()>",
          "metadata": {
            "callee": "NonThisConstructor",
            "constructorCall": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<NonThisConstructor>",
            "type": "DECLARES"
          },
          {
            "src": "<NonThisConstructor>",
            "dst": "<{ custom: true }>",
            "type": "RETURNS"
          },
          {
            "src": "<MODULE>",
            "dst": "<nonThisInstance>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<nonThisInstance>",
            "dst": "<new NonThisConstructor()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new NonThisConstructor()>",
            "dst": "<NonThisConstructor>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::comma-in-arrow-body",
      "category": "expressions",
      "code": "const commaArrow = (x) => (console.log(x), x * 2);",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<commaArrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<commaArrow:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<(console.log(x), x * 2)>",
          "metadata": {
            "operator": ","
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(x)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<commaArrow:fn>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaArrow:fn>",
            "dst": "<(console.log(x), x * 2)>",
            "type": "RETURNS"
          },
          {
            "src": "<(console.log(x), x * 2)>",
            "dst": "<console.log(x)>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<(console.log(x), x * 2)>",
            "dst": "<x * 2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<console.log(x)>",
            "dst": "<x>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<commaArrow>",
            "dst": "<commaArrow:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::comma-in-array-subscript",
      "category": "expressions",
      "code": "function commaSubscript() {\n  const matrix = [[1, 2], [3, 4]];\n  const result = matrix[0, 1]; // comma evaluates to 1  matrix[1]\n  return result; // [3, 4]\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<commaSubscript>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<matrix>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[[1, 2], [3, 4]]>",
          "metadata": {
            "value": "[[1, 2], [3, 4]]",
            "literalType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<matrix[0, 1]>",
          "metadata": {
            "accessType": "computed"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<0, 1>",
          "metadata": {
            "operator": "comma"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": "0",
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": "1",
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<commaSubscript>",
            "dst": "<matrix>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaSubscript>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<0, 1>",
            "dst": "<0>",
            "type": "CONTAINS"
          },
          {
            "src": "<0, 1>",
            "dst": "<1>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaSubscript>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<matrix>",
            "dst": "<[[1, 2], [3, 4]]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<result>",
            "dst": "<matrix[0, 1]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<matrix[0, 1]>",
            "dst": "<matrix>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::conditional-method-call",
      "category": "expressions",
      "code": "function conditionalMethodCall(input) {\n  const value = (typeof input === 'string' ? input : String(input)).trim();\n  return value;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<conditionalMethodCall>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input>"
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof input === 'string'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof input>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'string'>",
          "metadata": {
            "value": "string",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<String(input)>",
          "metadata": {
            "callee": "String"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<conditional>",
          "metadata": {
            "type": "conditional"
          }
        },
        {
          "type": "CALL",
          "id": "<.trim()>",
          "metadata": {
            "callee": "trim",
            "method": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<conditionalMethodCall>",
            "dst": "<input>",
            "type": "CONTAINS"
          },
          {
            "src": "<conditionalMethodCall>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<conditional>",
            "dst": "<typeof input === 'string'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<conditional>",
            "dst": "<input>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<String(input)>",
            "dst": "<input>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<conditionalMethodCall>",
            "dst": "<value>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<value>",
            "dst": "<.trim()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<conditional>",
            "dst": "<String(input)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<.trim()>",
            "dst": "<conditional>",
            "type": "CALLS_ON"
          },
          {
            "src": "<typeof input === 'string'>",
            "dst": "<typeof input>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof input === 'string'>",
            "dst": "<'string'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof input>",
            "dst": "<input>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::typeof-undeclared",
      "category": "expressions",
      "code": "function typeofUndeclared() {\n  const safe = typeof undeclaredVar; // \"undefined\"  NO ReferenceError\n  return safe;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<typeofUndeclared>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<safe>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof undeclaredVar>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<undeclaredVar>",
          "metadata": {
            "undeclared": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'undefined'>",
          "metadata": {
            "value": "undefined",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<typeofUndeclared>",
            "type": "DECLARES"
          },
          {
            "src": "<typeofUndeclared>",
            "dst": "<safe>",
            "type": "CONTAINS"
          },
          {
            "src": "<typeofUndeclared>",
            "dst": "<safe>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<safe>",
            "dst": "<typeof undeclaredVar>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<typeof undeclaredVar>",
            "dst": "<undeclaredVar>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof undeclaredVar>",
            "dst": "<'undefined'>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "expressions::new-precedence-trap",
      "category": "expressions",
      "code": "function newPrecedence() {\n  const withParens = new Date().getTime();       // (new Date()).getTime()\n  // new Date.getTime()                          // new (Date.getTime)()  TypeError!\n  const noParens = new Map;                      // valid  no parens needed\n  return { withParens, noParens };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<newPrecedence>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<withParens>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Date()>",
          "metadata": {
            "isConstructor": true
          }
        },
        {
          "type": "CALL",
          "id": "<getTime()>",
          "metadata": {
            "isConstructor": false
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Date().getTime>",
          "metadata": {
            "property": "getTime"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<noParens>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map>",
          "metadata": {
            "isConstructor": true,
            "noParens": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ withParens, noParens }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Date>",
          "metadata": {
            "builtin": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Map>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<newPrecedence>",
            "dst": "<withParens>",
            "type": "CONTAINS"
          },
          {
            "src": "<newPrecedence>",
            "dst": "<noParens>",
            "type": "CONTAINS"
          },
          {
            "src": "<newPrecedence>",
            "dst": "<{ withParens, noParens }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<withParens>",
            "dst": "<getTime()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<noParens>",
            "dst": "<new Map>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<getTime()>",
            "dst": "<Date().getTime>",
            "type": "CALLS"
          },
          {
            "src": "<Date().getTime>",
            "dst": "<new Date()>",
            "type": "CALLS_ON"
          },
          {
            "src": "<new Date()>",
            "dst": "<Date>",
            "type": "CALLS"
          },
          {
            "src": "<new Map>",
            "dst": "<Map>",
            "type": "CALLS"
          },
          {
            "src": "<{ withParens, noParens }>",
            "dst": "<withParens>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ withParens, noParens }>",
            "dst": "<noParens>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::nullish-coalescing-chain",
      "category": "expressions",
      "code": "function nullishChain(a, b, c, defaultValue) {\n  const value = a ?? b ?? c ?? defaultValue;\n  return value;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<nullishChain>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<a>"
        },
        {
          "type": "PARAMETER",
          "id": "<b>"
        },
        {
          "type": "PARAMETER",
          "id": "<c>"
        },
        {
          "type": "PARAMETER",
          "id": "<defaultValue>"
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a ?? b ?? c ?? defaultValue>",
          "metadata": {
            "operator": "??",
            "chainLength": 4
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<nullishChain>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<nullishChain>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<nullishChain>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<nullishChain>",
            "dst": "<defaultValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<nullishChain>",
            "dst": "<value>",
            "type": "DECLARES"
          },
          {
            "src": "<nullishChain>",
            "dst": "<value>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<value>",
            "dst": "<a ?? b ?? c ?? defaultValue>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a ?? b ?? c ?? defaultValue>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<a ?? b ?? c ?? defaultValue>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<a ?? b ?? c ?? defaultValue>",
            "dst": "<c>",
            "type": "READS_FROM"
          },
          {
            "src": "<a ?? b ?? c ?? defaultValue>",
            "dst": "<defaultValue>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::new-member-expression",
      "category": "expressions",
      "code": "function newMemberExpression(mod) {\n  const instance = new mod.MyClass();\n  const nested = new mod.sub.Factory();\n  return { instance, nested };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<newMemberExpression>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<mod>"
        },
        {
          "type": "VARIABLE",
          "id": "<instance>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<new mod.MyClass()>",
          "metadata": {
            "operator": "new"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<mod.MyClass>",
          "metadata": {
            "objectName": "mod",
            "propertyName": "MyClass"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<nested>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<new mod.sub.Factory()>",
          "metadata": {
            "operator": "new"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<mod.sub.Factory>",
          "metadata": {
            "objectName": "mod.sub",
            "propertyName": "Factory"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<mod.sub>",
          "metadata": {
            "objectName": "mod",
            "propertyName": "sub"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ instance, nested }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<newMemberExpression>",
            "dst": "<mod>",
            "type": "CONTAINS"
          },
          {
            "src": "<newMemberExpression>",
            "dst": "<instance>",
            "type": "DECLARES"
          },
          {
            "src": "<newMemberExpression>",
            "dst": "<nested>",
            "type": "DECLARES"
          },
          {
            "src": "<newMemberExpression>",
            "dst": "<{ instance, nested }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<instance>",
            "dst": "<new mod.MyClass()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<nested>",
            "dst": "<new mod.sub.Factory()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new mod.MyClass()>",
            "dst": "<mod.MyClass>",
            "type": "CALLS"
          },
          {
            "src": "<mod.MyClass>",
            "dst": "<mod>",
            "type": "READS_FROM"
          },
          {
            "src": "<new mod.sub.Factory()>",
            "dst": "<mod.sub.Factory>",
            "type": "CALLS"
          },
          {
            "src": "<mod.sub.Factory>",
            "dst": "<mod.sub>",
            "type": "READS_FROM"
          },
          {
            "src": "<mod.sub>",
            "dst": "<mod>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ instance, nested }>",
            "dst": "<instance>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ instance, nested }>",
            "dst": "<nested>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::comma-in-condition",
      "category": "expressions",
      "code": "function commaInWhile() {\n  let i = 0, total = 0;\n  while ((total += i, ++i < 5)) {\n    // comma in condition\n  }\n  return total; // 10\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<commaInWhile>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<total>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0_2>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<comma-condition>",
          "metadata": {
            "operator": ","
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<total += i>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<++i>",
          "metadata": {
            "operator": "++",
            "prefix": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<++i < 5>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return total>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<commaInWhile>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaInWhile>",
            "dst": "<total>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaInWhile>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<while>",
            "dst": "<comma-condition>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<comma-condition>",
            "dst": "<total += i>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<comma-condition>",
            "dst": "<++i < 5>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<++i < 5>",
            "dst": "<++i>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<++i < 5>",
            "dst": "<5>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<commaInWhile>",
            "dst": "<return total>",
            "type": "CONTAINS"
          },
          {
            "src": "<commaInWhile>",
            "dst": "<return total>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<total>",
            "dst": "<0_2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<total += i>",
            "dst": "<total>",
            "type": "WRITES_TO"
          },
          {
            "src": "<++i>",
            "dst": "<i>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<total += i>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<return total>",
            "dst": "<total>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::reflect-construct-factory",
      "category": "expressions",
      "code": "function createInstance(Cls, args) {\n  return Reflect.construct(Cls, args); // factory pattern  construct without `new`\n}\n\n// --- Tagged template returning non-string ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createInstance>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<Cls>"
        },
        {
          "type": "PARAMETER",
          "id": "<args>"
        },
        {
          "type": "CALL",
          "id": "<Reflect.construct(Cls, args)>",
          "metadata": {
            "callee": "Reflect.construct"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Reflect.construct>",
          "metadata": {
            "objectName": "Reflect",
            "propertyName": "construct"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Reflect>",
          "metadata": {
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createInstance>",
            "dst": "<Cls>",
            "type": "CONTAINS"
          },
          {
            "src": "<createInstance>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<createInstance>",
            "dst": "<Reflect.construct(Cls, args)>",
            "type": "RETURNS"
          },
          {
            "src": "<Reflect.construct(Cls, args)>",
            "dst": "<Cls>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.construct(Cls, args)>",
            "dst": "<args>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Reflect.construct(Cls, args)>",
            "dst": "<Reflect.construct>",
            "type": "CALLS"
          },
          {
            "src": "<Reflect.construct>",
            "dst": "<Reflect>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::assignment-in-if",
      "category": "expressions",
      "code": "function assignmentInIf(compute) {\n  let result;\n  if (result = compute()) {            // assignment + truthiness check\n    return result;\n  }\n  return null;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<assignmentInIf>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<compute>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-assignment>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<result = compute()>",
          "metadata": {
            "operator": "=",
            "isAssignmentExpression": true
          }
        },
        {
          "type": "CALL",
          "id": "<compute()>",
          "metadata": {
            "callee": "compute"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<assignmentInIf>",
            "dst": "<compute>",
            "type": "CONTAINS"
          },
          {
            "src": "<assignmentInIf>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<assignmentInIf>",
            "dst": "<if-assignment>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-assignment>",
            "dst": "<result = compute()>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-assignment>",
            "dst": "<result>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<assignmentInIf>",
            "dst": "<result>",
            "type": "RETURNS"
          },
          {
            "src": "<assignmentInIf>",
            "dst": "<null>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result = compute()>",
            "dst": "<result>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result = compute()>",
            "dst": "<compute()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<compute()>",
            "dst": "<compute>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::conditional-tag-template",
      "category": "expressions",
      "code": "function conditionalTagTemplate(dangerous) {\n  const escape = dangerous ? (s) => s[0].toUpperCase() : (s) => s[0];\n  const result = escape`hello`;\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<conditionalTagTemplate>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<dangerous>"
        },
        {
          "type": "VARIABLE",
          "id": "<escape>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<(s) => s[0].toUpperCase()>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<s1>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<s[0]>",
          "metadata": {
            "objectName": "s",
            "property": "0"
          }
        },
        {
          "type": "CALL",
          "id": "<s[0].toUpperCase()>",
          "metadata": {
            "callee": "toUpperCase"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<(s) => s[0]>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<s2>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<s2[0]>",
          "metadata": {
            "objectName": "s",
            "property": "0"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<escape`hello`>",
          "metadata": {
            "callee": "escape",
            "taggedTemplate": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<`hello`>",
          "metadata": {
            "value": "hello",
            "literalType": "template"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<conditionalTagTemplate>",
            "dst": "<dangerous>",
            "type": "CONTAINS"
          },
          {
            "src": "<conditionalTagTemplate>",
            "dst": "<escape>",
            "type": "CONTAINS"
          },
          {
            "src": "<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>",
            "dst": "<(s) => s[0].toUpperCase()>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<(s) => s[0].toUpperCase()>",
            "dst": "<s1>",
            "type": "CONTAINS"
          },
          {
            "src": "<(s) => s[0].toUpperCase()>",
            "dst": "<s[0].toUpperCase()>",
            "type": "RETURNS"
          },
          {
            "src": "<(s) => s[0]>",
            "dst": "<s2>",
            "type": "CONTAINS"
          },
          {
            "src": "<(s) => s[0]>",
            "dst": "<s2[0]>",
            "type": "RETURNS"
          },
          {
            "src": "<conditionalTagTemplate>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<escape`hello`>",
            "dst": "<`hello`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<conditionalTagTemplate>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<escape>",
            "dst": "<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>",
            "dst": "<(s) => s[0]>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<result>",
            "dst": "<escape`hello`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>",
            "dst": "<dangerous>",
            "type": "READS_FROM"
          },
          {
            "src": "<s[0].toUpperCase()>",
            "dst": "<s[0]>",
            "type": "CALLS"
          },
          {
            "src": "<s[0]>",
            "dst": "<s1>",
            "type": "READS_FROM"
          },
          {
            "src": "<s2[0]>",
            "dst": "<s2>",
            "type": "READS_FROM"
          },
          {
            "src": "<escape`hello`>",
            "dst": "<escape>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::reflect-construct-newtarget",
      "category": "expressions",
      "code": "class ReflectBase {\n  constructor() {\n    this.constructedBy = new.target.name;\n  }\n}\nclass ReflectDerived extends ReflectBase {}\n\nfunction reflectConstructDemo() {\n  const normal = new ReflectDerived();                       // constructedBy: 'ReflectDerived'\n  const spoofed = Reflect.construct(ReflectBase, [], ReflectDerived); // constructedBy: 'ReflectDerived' but runs Base constructor\n  return { normal, spoofed };\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ReflectBase>"
        },
        {
          "type": "METHOD",
          "id": "<ReflectBase.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.constructedBy>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<new.target.name>",
          "metadata": {
            "metaProperty": "new.target"
          }
        },
        {
          "type": "CLASS",
          "id": "<ReflectDerived>"
        },
        {
          "type": "FUNCTION",
          "id": "<reflectConstructDemo>"
        },
        {
          "type": "VARIABLE",
          "id": "<normal>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new ReflectDerived()>",
          "metadata": {
            "callee": "ReflectDerived",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<spoofed>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Reflect.construct(ReflectBase, [], ReflectDerived)>",
          "metadata": {
            "callee": "Reflect.construct"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ normal, spoofed }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ReflectBase>",
            "dst": "<ReflectBase.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<reflectConstructDemo>",
            "dst": "<normal>",
            "type": "CONTAINS"
          },
          {
            "src": "<reflectConstructDemo>",
            "dst": "<spoofed>",
            "type": "CONTAINS"
          },
          {
            "src": "<Reflect.construct(ReflectBase, [], ReflectDerived)>",
            "dst": "<ReflectBase>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.construct(ReflectBase, [], ReflectDerived)>",
            "dst": "<[]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.construct(ReflectBase, [], ReflectDerived)>",
            "dst": "<ReflectDerived>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reflectConstructDemo>",
            "dst": "<{ normal, spoofed }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<this.constructedBy>",
            "dst": "<new.target.name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ReflectBase.constructor>",
            "dst": "<this.constructedBy>",
            "type": "WRITES_TO"
          },
          {
            "src": "<normal>",
            "dst": "<new ReflectDerived()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<spoofed>",
            "dst": "<Reflect.construct(ReflectBase, [], ReflectDerived)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<ReflectBase.constructor>",
            "dst": "<new.target.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<ReflectDerived>",
            "dst": "<ReflectBase>",
            "type": "EXTENDS"
          },
          {
            "src": "<new ReflectDerived()>",
            "dst": "<ReflectDerived>",
            "type": "CALLS"
          },
          {
            "src": "<{ normal, spoofed }>",
            "dst": "<normal>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ normal, spoofed }>",
            "dst": "<spoofed>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::logical-assign-property",
      "category": "expressions",
      "code": "function logicalAssignProperty() {\n  const config = { timeout: 0, retries: null, debug: false };\n  config.timeout ||= 5000;    // 5000  0 is falsy\n  config.retries ??= 3;       // 3  null is nullish\n  config.debug &&= true;      // false  short-circuits\n  return config;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<logicalAssignProperty>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<config>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<timeout-prop>",
          "metadata": {
            "key": "timeout"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<retries-prop>",
          "metadata": {
            "key": "retries"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<debug-prop>",
          "metadata": {
            "key": "debug"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<config.timeout ||= 5000>",
          "metadata": {
            "operator": "||="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<config.timeout>",
          "metadata": {
            "property": "timeout"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5000>",
          "metadata": {
            "value": 5000,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<config.retries ??= 3>",
          "metadata": {
            "operator": "??="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<config.retries>",
          "metadata": {
            "property": "retries"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<config.debug &&= true>",
          "metadata": {
            "operator": "&&="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<config.debug>",
          "metadata": {
            "property": "debug"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<logicalAssignProperty>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<object-literal>",
            "dst": "<timeout-prop>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<retries-prop>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<debug-prop>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<logicalAssignProperty>",
            "dst": "<config.timeout ||= 5000>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalAssignProperty>",
            "dst": "<config.retries ??= 3>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalAssignProperty>",
            "dst": "<config.debug &&= true>",
            "type": "CONTAINS"
          },
          {
            "src": "<logicalAssignProperty>",
            "dst": "<config>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<config>",
            "dst": "<object-literal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<timeout-prop>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<retries-prop>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<debug-prop>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config.timeout ||= 5000>",
            "dst": "<config.timeout>",
            "type": "WRITES_TO"
          },
          {
            "src": "<config.timeout ||= 5000>",
            "dst": "<5000>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config.retries ??= 3>",
            "dst": "<config.retries>",
            "type": "WRITES_TO"
          },
          {
            "src": "<config.retries ??= 3>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config.debug &&= true>",
            "dst": "<config.debug>",
            "type": "WRITES_TO"
          },
          {
            "src": "<config.debug &&= true>",
            "dst": "<true>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<config.timeout ||= 5000>",
            "dst": "<config.timeout>",
            "type": "READS_FROM"
          },
          {
            "src": "<config.retries ??= 3>",
            "dst": "<config.retries>",
            "type": "READS_FROM"
          },
          {
            "src": "<config.debug &&= true>",
            "dst": "<config.debug>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::tagged-template-chained",
      "category": "expressions",
      "code": "function chainTag(strings) {\n  return (strings2) => strings[0] + strings2[0];\n}\nconst chainedResult = chainTag`hello``world`;",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<chainTag>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings>"
        },
        {
          "type": "FUNCTION",
          "id": "<chainTag:inner>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings2>"
        },
        {
          "type": "EXPRESSION",
          "id": "<strings[0] + strings2[0]>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<strings[0]>",
          "metadata": {
            "property": "0"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<strings2[0]>",
          "metadata": {
            "property": "0"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<chainedResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<chainTag`hello`>",
          "metadata": {
            "callType": "tagged-template"
          }
        },
        {
          "type": "LITERAL",
          "id": "<`hello`>",
          "metadata": {
            "value": "hello",
            "literalType": "template"
          }
        },
        {
          "type": "CALL",
          "id": "<chainTag`hello``world`>",
          "metadata": {
            "callType": "tagged-template"
          }
        },
        {
          "type": "LITERAL",
          "id": "<`world`>",
          "metadata": {
            "value": "world",
            "literalType": "template"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<chainTag>",
            "dst": "<strings>",
            "type": "HAS_BODY"
          },
          {
            "src": "<chainTag>",
            "dst": "<chainTag:inner>",
            "type": "RETURNS"
          },
          {
            "src": "<chainTag:inner>",
            "dst": "<strings2>",
            "type": "HAS_BODY"
          },
          {
            "src": "<chainTag:inner>",
            "dst": "<strings[0] + strings2[0]>",
            "type": "RETURNS"
          },
          {
            "src": "<chainTag`hello`>",
            "dst": "<`hello`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<chainTag`hello``world`>",
            "dst": "<`world`>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<chainedResult>",
            "dst": "<chainTag`hello``world`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<strings[0] + strings2[0]>",
            "dst": "<strings[0]>",
            "type": "READS_FROM"
          },
          {
            "src": "<strings[0] + strings2[0]>",
            "dst": "<strings2[0]>",
            "type": "READS_FROM"
          },
          {
            "src": "<strings[0]>",
            "dst": "<strings>",
            "type": "READS_FROM"
          },
          {
            "src": "<strings2[0]>",
            "dst": "<strings2>",
            "type": "READS_FROM"
          },
          {
            "src": "<chainTag`hello`>",
            "dst": "<chainTag>",
            "type": "CALLS"
          },
          {
            "src": "<chainTag`hello``world`>",
            "dst": "<chainTag`hello`>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::tagged-template-returns-class",
      "category": "expressions",
      "code": "const styledDiv = {\n  div(strings, ...exprs) {\n    return class StyledComponent {\n      styles = strings.join('');\n    };\n  },\n};\nconst Component = styledDiv.div`color: red; font-size: 14px;`;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<styledDiv>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<styledDiv:obj>"
        },
        {
          "type": "METHOD",
          "id": "<div>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings>"
        },
        {
          "type": "PARAMETER",
          "id": "<exprs>",
          "metadata": {
            "rest": true
          }
        },
        {
          "type": "CLASS",
          "id": "<StyledComponent>"
        },
        {
          "type": "PROPERTY",
          "id": "<styles>",
          "metadata": {
            "kind": "field"
          }
        },
        {
          "type": "CALL",
          "id": "<strings.join('')>",
          "metadata": {
            "callee": "join"
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Component>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<styledDiv.div`color: red; font-size: 14px;`>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<styledDiv.div>"
        },
        {
          "type": "LITERAL",
          "id": "<`color: red; font-size: 14px;`>",
          "metadata": {
            "value": "color: red; font-size: 14px;",
            "literalType": "template"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<styledDiv:obj>",
            "dst": "<div>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<div>",
            "dst": "<strings>",
            "type": "CONTAINS"
          },
          {
            "src": "<div>",
            "dst": "<exprs>",
            "type": "CONTAINS"
          },
          {
            "src": "<div>",
            "dst": "<StyledComponent>",
            "type": "RETURNS"
          },
          {
            "src": "<StyledComponent>",
            "dst": "<styles>",
            "type": "CONTAINS"
          },
          {
            "src": "<strings.join('')>",
            "dst": "<''>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<styledDiv.div`color: red; font-size: 14px;`>",
            "dst": "<`color: red; font-size: 14px;`>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<styledDiv>",
            "dst": "<styledDiv:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<styles>",
            "dst": "<strings.join('')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Component>",
            "dst": "<styledDiv.div`color: red; font-size: 14px;`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<strings.join('')>",
            "dst": "<strings>",
            "type": "CALLS_ON"
          },
          {
            "src": "<styledDiv.div`color: red; font-size: 14px;`>",
            "dst": "<styledDiv.div>",
            "type": "CALLS"
          },
          {
            "src": "<styledDiv.div>",
            "dst": "<styledDiv>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::optional-chaining-syntax-errors",
      "category": "expressions",
      "code": "// SyntaxError cases  cannot appear in valid AST:\n// obj?.prop = value;    // cannot assign through ?.\n// obj?.['key'] = value; // cannot assign through ?.\n// arr?.[0] = value;     // cannot assign through ?.\n// super?.method();      // super doesn't support optional chaining\n// obj?.tag`template`;   // tagged templates don't support optional chaining",
      "expectedNodes": [
        {
          "type": "EXPRESSION",
          "id": "<obj?.prop = value>",
          "metadata": {
            "errorType": "invalid-optional-chaining-assignment",
            "description": "Cannot assign through optional chaining"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj?.['key'] = value>",
          "metadata": {
            "errorType": "invalid-optional-chaining-assignment",
            "description": "Cannot assign through optional chaining"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<arr?.[0] = value>",
          "metadata": {
            "errorType": "invalid-optional-chaining-assignment",
            "description": "Cannot assign through optional chaining"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<super?.method()>",
          "metadata": {
            "errorType": "invalid-super-optional-chaining",
            "description": "super doesn't support optional chaining"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj?.tag`template`>",
          "metadata": {
            "errorType": "invalid-optional-chaining-tagged-template",
            "description": "Tagged templates don't support optional chaining"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<obj?.prop = value>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<obj?.['key'] = value>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<arr?.[0] = value>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<super?.method()>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<obj?.tag`template`>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "expressions::tagged-template-returns-object",
      "category": "expressions",
      "code": "function sql(strings, ...values) {\n  return { text: strings.join('?'), params: values }; // returns object, not string!\n}\nconst userId = 42;\nconst query = sql`SELECT * FROM users WHERE id = ${userId}`;",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sql>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings>"
        },
        {
          "type": "PARAMETER",
          "id": "<values>",
          "metadata": {
            "rest": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'text'>",
          "metadata": {
            "value": "text",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<strings.join('?')>",
          "metadata": {
            "callee": "strings.join"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'?'>",
          "metadata": {
            "value": "?",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'params'>",
          "metadata": {
            "value": "params",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ text: strings.join('?'), params: values }>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<userId>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<query>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<sql`SELECT * FROM users WHERE id = ${userId}`>",
          "metadata": {
            "callee": "sql",
            "callType": "tagged-template"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'SELECT * FROM users WHERE id = '>",
          "metadata": {
            "value": "SELECT * FROM users WHERE id = ",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<sql>",
            "dst": "<strings>",
            "type": "HAS_BODY"
          },
          {
            "src": "<sql>",
            "dst": "<values>",
            "type": "HAS_BODY"
          },
          {
            "src": "<sql>",
            "dst": "<{ text: strings.join('?'), params: values }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ text: strings.join('?'), params: values }>",
            "dst": "<'text'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ text: strings.join('?'), params: values }>",
            "dst": "<strings.join('?')>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ text: strings.join('?'), params: values }>",
            "dst": "<'params'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ text: strings.join('?'), params: values }>",
            "dst": "<values>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<strings.join('?')>",
            "dst": "<'?'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<sql`SELECT * FROM users WHERE id = ${userId}`>",
            "dst": "<'SELECT * FROM users WHERE id = '>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<sql`SELECT * FROM users WHERE id = ${userId}`>",
            "dst": "<''>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<sql`SELECT * FROM users WHERE id = ${userId}`>",
            "dst": "<userId>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<userId>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<query>",
            "dst": "<sql`SELECT * FROM users WHERE id = ${userId}`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<strings.join('?')>",
            "dst": "<strings>",
            "type": "CALLS_ON"
          },
          {
            "src": "<sql`SELECT * FROM users WHERE id = ${userId}`>",
            "dst": "<sql>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::short-circuit-guard-call",
      "category": "expressions",
      "code": "function shortCircuitGuard(callback, data) {\n  callback && callback(data);           // guard + call\n  const result = callback?.(data);      // optional call equivalent\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<shortCircuitGuard>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<callback>"
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "EXPRESSION",
          "id": "<callback && callback(data)>",
          "metadata": {
            "operator": "&&",
            "shortCircuit": true
          }
        },
        {
          "type": "CALL",
          "id": "<callback(data)>",
          "metadata": {
            "callee": "callback"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<callback?.(data)>",
          "metadata": {
            "callee": "callback",
            "optional": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<shortCircuitGuard>",
            "dst": "<callback>",
            "type": "CONTAINS"
          },
          {
            "src": "<shortCircuitGuard>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<shortCircuitGuard>",
            "dst": "<callback && callback(data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<callback && callback(data)>",
            "dst": "<callback(data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<callback(data)>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<shortCircuitGuard>",
            "dst": "<result>",
            "type": "DECLARES"
          },
          {
            "src": "<callback?.(data)>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<shortCircuitGuard>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<callback?.(data)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<callback && callback(data)>",
            "dst": "<callback>",
            "type": "READS_FROM"
          },
          {
            "src": "<callback(data)>",
            "dst": "<callback>",
            "type": "CALLS"
          },
          {
            "src": "<callback?.(data)>",
            "dst": "<callback>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::in-operator-array",
      "category": "expressions",
      "code": "function inOperatorArray() {\n  const hasIndex = 0 in [1, 2, 3];     // true  checks INDEX, not value\n  const hasStr = '0' in [1, 2, 3];     // true  coerced to string\n  const noIndex = 5 in [1, 2, 3];      // false\n  return { hasIndex, hasStr, noIndex };\n}\n\n// --- Reflect.construct with newTarget (constructor spoofing) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<inOperatorArray>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasIndex>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<0 in [1, 2, 3]>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasStr>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'0' in [1, 2, 3]>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'0'>",
          "metadata": {
            "value": "0",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<noIndex>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<5 in [1, 2, 3]>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ hasIndex, hasStr, noIndex }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<inOperatorArray>",
            "dst": "<hasIndex>",
            "type": "CONTAINS"
          },
          {
            "src": "<inOperatorArray>",
            "dst": "<hasStr>",
            "type": "CONTAINS"
          },
          {
            "src": "<inOperatorArray>",
            "dst": "<noIndex>",
            "type": "CONTAINS"
          },
          {
            "src": "<0 in [1, 2, 3]>",
            "dst": "<0>",
            "type": "USES"
          },
          {
            "src": "<0 in [1, 2, 3]>",
            "dst": "<[1, 2, 3]>",
            "type": "USES"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<'0' in [1, 2, 3]>",
            "dst": "<'0'>",
            "type": "USES"
          },
          {
            "src": "<'0' in [1, 2, 3]>",
            "dst": "<[1, 2, 3]>",
            "type": "USES"
          },
          {
            "src": "<5 in [1, 2, 3]>",
            "dst": "<5>",
            "type": "USES"
          },
          {
            "src": "<5 in [1, 2, 3]>",
            "dst": "<[1, 2, 3]>",
            "type": "USES"
          },
          {
            "src": "<inOperatorArray>",
            "dst": "<{ hasIndex, hasStr, noIndex }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ hasIndex, hasStr, noIndex }>",
            "dst": "<hasIndex>",
            "type": "USES"
          },
          {
            "src": "<{ hasIndex, hasStr, noIndex }>",
            "dst": "<hasStr>",
            "type": "USES"
          },
          {
            "src": "<{ hasIndex, hasStr, noIndex }>",
            "dst": "<noIndex>",
            "type": "USES"
          }
        ],
        "postFile": [
          {
            "src": "<hasIndex>",
            "dst": "<0 in [1, 2, 3]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasStr>",
            "dst": "<'0' in [1, 2, 3]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<noIndex>",
            "dst": "<5 in [1, 2, 3]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "expressions::await-comma-expression",
      "category": "expressions",
      "code": "async function awaitCommaExpression(sideEffect, fetchData) {\n  const result = await (sideEffect(), fetchData());\n  // sideEffect() runs sync, fetchData() is awaited\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<awaitCommaExpression>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<sideEffect>"
        },
        {
          "type": "PARAMETER",
          "id": "<fetchData>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await (sideEffect(), fetchData())>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<(sideEffect(), fetchData())>",
          "metadata": {
            "operator": ","
          }
        },
        {
          "type": "CALL",
          "id": "<sideEffect()>",
          "metadata": {
            "callee": "sideEffect"
          }
        },
        {
          "type": "CALL",
          "id": "<fetchData()>",
          "metadata": {
            "callee": "fetchData"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<awaitCommaExpression>",
            "dst": "<sideEffect>",
            "type": "CONTAINS"
          },
          {
            "src": "<awaitCommaExpression>",
            "dst": "<fetchData>",
            "type": "CONTAINS"
          },
          {
            "src": "<awaitCommaExpression>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<await (sideEffect(), fetchData())>",
            "dst": "<(sideEffect(), fetchData())>",
            "type": "AWAITS"
          },
          {
            "src": "<(sideEffect(), fetchData())>",
            "dst": "<sideEffect()>",
            "type": "CONTAINS"
          },
          {
            "src": "<(sideEffect(), fetchData())>",
            "dst": "<fetchData()>",
            "type": "CONTAINS"
          },
          {
            "src": "<awaitCommaExpression>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<await (sideEffect(), fetchData())>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<sideEffect()>",
            "dst": "<sideEffect>",
            "type": "CALLS"
          },
          {
            "src": "<fetchData()>",
            "dst": "<fetchData>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "expressions::new-with-spread",
      "category": "expressions",
      "code": "function newWithSpread() {\n  const args = [2024, 0, 15];\n  const date = new Date(...args);\n\n  function instantiate(Cls, ctorArgs) {\n    return new Cls(...ctorArgs);       // dynamic class + spread\n  }\n\n  return { date, instantiate };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<newWithSpread>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<args>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[2024, 0, 15]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2024>",
          "metadata": {
            "value": 2024,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<15>",
          "metadata": {
            "value": 15,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<date>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Date(...args)>",
          "metadata": {
            "callee": "Date",
            "isConstructor": true,
            "hasSpread": true
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Date>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<instantiate>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<Cls>"
        },
        {
          "type": "PARAMETER",
          "id": "<ctorArgs>"
        },
        {
          "type": "CALL",
          "id": "<new Cls(...ctorArgs)>",
          "metadata": {
            "callee": "dynamic",
            "isConstructor": true,
            "hasSpread": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ date, instantiate }>",
          "metadata": {
            "expressionType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<newWithSpread>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<[2024, 0, 15]>",
            "dst": "<2024>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[2024, 0, 15]>",
            "dst": "<0>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[2024, 0, 15]>",
            "dst": "<15>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<newWithSpread>",
            "dst": "<date>",
            "type": "CONTAINS"
          },
          {
            "src": "<newWithSpread>",
            "dst": "<instantiate>",
            "type": "CONTAINS"
          },
          {
            "src": "<instantiate>",
            "dst": "<Cls>",
            "type": "CONTAINS"
          },
          {
            "src": "<instantiate>",
            "dst": "<ctorArgs>",
            "type": "CONTAINS"
          },
          {
            "src": "<instantiate>",
            "dst": "<new Cls(...ctorArgs)>",
            "type": "RETURNS"
          },
          {
            "src": "<newWithSpread>",
            "dst": "<{ date, instantiate }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ date, instantiate }>",
            "dst": "<date>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ date, instantiate }>",
            "dst": "<instantiate>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<args>",
            "dst": "<[2024, 0, 15]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<date>",
            "dst": "<new Date(...args)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new Date(...args)>",
            "dst": "<Date>",
            "type": "CALLS"
          },
          {
            "src": "<new Date(...args)>",
            "dst": "<args>",
            "type": "READS_FROM"
          },
          {
            "src": "<new Cls(...ctorArgs)>",
            "dst": "<Cls>",
            "type": "CALLS"
          },
          {
            "src": "<new Cls(...ctorArgs)>",
            "dst": "<ctorArgs>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::nullish-logical-mixing-error",
      "category": "expressions",
      "code": "// SyntaxError  cannot mix ?? with || or && without explicit parentheses:\n// a ?? b || c;    // SyntaxError\n// a || b ?? c;    // SyntaxError\n// a ?? b && c;    // SyntaxError\n// Must use: (a ?? b) || c  or  a ?? (b || c)",
      "expectedNodes": [
        {
          "type": "SIDE_EFFECT",
          "id": "<nullish-logical-mixing-error>",
          "metadata": {
            "errorType": "operator precedence ambiguity",
            "operators": [
              "??",
              "||",
              "&&"
            ]
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a ?? b || c>",
          "metadata": {
            "invalid": true,
            "reason": "mixed nullish coalescing with logical OR"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a || b ?? c>",
          "metadata": {
            "invalid": true,
            "reason": "mixed logical OR with nullish coalescing"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a ?? b && c>",
          "metadata": {
            "invalid": true,
            "reason": "mixed nullish coalescing with logical AND"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<(a ?? b) || c>",
          "metadata": {
            "valid": true,
            "reason": "explicit parentheses resolve precedence"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<a ?? (b || c)>",
          "metadata": {
            "valid": true,
            "reason": "explicit parentheses resolve precedence"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<nullish-logical-mixing-error>",
            "dst": "<a ?? b || c>",
            "type": "THROWS"
          },
          {
            "src": "<nullish-logical-mixing-error>",
            "dst": "<a || b ?? c>",
            "type": "THROWS"
          },
          {
            "src": "<nullish-logical-mixing-error>",
            "dst": "<a ?? b && c>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<(a ?? b) || c>",
            "dst": "<nullish-logical-mixing-error>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<a ?? (b || c)>",
            "dst": "<nullish-logical-mixing-error>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "expressions::assignment-in-condition",
      "category": "expressions",
      "code": "function assignmentInCondition(regex, str) {\n  const matches = [];\n  let match;\n  while (match = regex.exec(str)) {   // assignment AS condition (no explicit comparison)\n    matches.push(match[0]);\n  }\n  return matches;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<assignmentInCondition>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<regex>"
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "VARIABLE",
          "id": "<matches>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<match>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<match = regex.exec(str)>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "CALL",
          "id": "<regex.exec(str)>",
          "metadata": {
            "callee": "exec"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<regex.exec>",
          "metadata": {
            "objectName": "regex",
            "propertyName": "exec"
          }
        },
        {
          "type": "CALL",
          "id": "<matches.push(match[0])>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<matches.push>",
          "metadata": {
            "objectName": "matches",
            "propertyName": "push"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<match[0]>",
          "metadata": {
            "operator": "[]"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": "0",
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<assignmentInCondition>",
            "dst": "<regex>",
            "type": "CONTAINS"
          },
          {
            "src": "<assignmentInCondition>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<assignmentInCondition>",
            "dst": "<matches>",
            "type": "CONTAINS"
          },
          {
            "src": "<assignmentInCondition>",
            "dst": "<match>",
            "type": "CONTAINS"
          },
          {
            "src": "<assignmentInCondition>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<while>",
            "dst": "<match = regex.exec(str)>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<regex.exec(str)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<while>",
            "dst": "<matches.push(match[0])>",
            "type": "HAS_BODY"
          },
          {
            "src": "<matches.push(match[0])>",
            "dst": "<match[0]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<assignmentInCondition>",
            "dst": "<matches>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<matches>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<match = regex.exec(str)>",
            "dst": "<match>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<match = regex.exec(str)>",
            "dst": "<regex.exec(str)>",
            "type": "READS_FROM"
          },
          {
            "src": "<regex.exec(str)>",
            "dst": "<regex.exec>",
            "type": "CALLS"
          },
          {
            "src": "<regex.exec>",
            "dst": "<regex>",
            "type": "READS_FROM"
          },
          {
            "src": "<matches.push(match[0])>",
            "dst": "<matches.push>",
            "type": "CALLS"
          },
          {
            "src": "<matches.push>",
            "dst": "<matches>",
            "type": "READS_FROM"
          },
          {
            "src": "<match[0]>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<match[0]>",
            "dst": "<0>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "hashbang-entry::export-named-list",
      "category": "hashbang-entry",
      "code": "export { hashbangMain };",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-hashbangMain>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hashbangMain>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-hashbangMain>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-hashbangMain>",
            "dst": "<hashbangMain>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "index::import-named",
      "category": "index",
      "code": "import { helperFunction, HELPER_CONST } from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-modules-helpers>",
          "metadata": {
            "source": "./modules-helpers.js"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<helperFunction>",
          "metadata": {
            "imported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<HELPER_CONST>",
          "metadata": {
            "imported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-modules-helpers>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-modules-helpers>",
            "dst": "<helperFunction>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-modules-helpers>",
            "dst": "<HELPER_CONST>",
            "type": "IMPORTS"
          },
          {
            "src": "<module>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::import-default",
      "category": "index",
      "code": "import defaultExport from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-modules-helpers>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importType": "default"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<defaultExport>",
          "metadata": {
            "imported": true,
            "importType": "default"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-modules-helpers>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<defaultExport>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-modules-helpers>",
            "dst": "<defaultExport>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-modules-helpers>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::async-arrow-returns-object",
      "category": "expressions",
      "code": "const asyncArrowObject = async (data, processFn) => ({\n  id: data.id,\n  result: await processFn(data),\n  timestamp: Date.now(),\n});\n// Without parens: async (data) => { id: data.id }  parsed as block + label!",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<asyncArrowObject>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<asyncArrowObject:fn>",
          "metadata": {
            "arrowFunction": true,
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "PARAMETER",
          "id": "<processFn>"
        },
        {
          "type": "EXPRESSION",
          "id": "<object-literal>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<data.id>"
        },
        {
          "type": "EXPRESSION",
          "id": "<await processFn(data)>",
          "metadata": {
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<processFn(data)>",
          "metadata": {
            "callee": "processFn"
          }
        },
        {
          "type": "CALL",
          "id": "<Date.now()>",
          "metadata": {
            "callee": "Date.now"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Date.now>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncArrowObject:fn>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncArrowObject:fn>",
            "dst": "<processFn>",
            "type": "CONTAINS"
          },
          {
            "src": "<asyncArrowObject:fn>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<data.id>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<await processFn(data)>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<Date.now()>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<await processFn(data)>",
            "dst": "<processFn(data)>",
            "type": "AWAITS"
          },
          {
            "src": "<processFn(data)>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<asyncArrowObject>",
            "dst": "<asyncArrowObject:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<data.id>",
            "dst": "<data>",
            "type": "READS_FROM"
          },
          {
            "src": "<processFn(data)>",
            "dst": "<processFn>",
            "type": "CALLS"
          },
          {
            "src": "<Date.now()>",
            "dst": "<Date.now>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "index::import-aliased",
      "category": "index",
      "code": "import { HelperClass as Helper } from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-modules-helpers>",
          "metadata": {
            "source": "./modules-helpers.js"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Helper>",
          "metadata": {
            "imported": true,
            "importedAs": "HelperClass"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-modules-helpers>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<Helper>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-modules-helpers>",
            "dst": "<Helper>",
            "type": "IMPORTS"
          },
          {
            "src": "<module>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "hashbang-entry::hashbang-comment",
      "category": "hashbang-entry",
      "code": "// The #!/usr/bin/env node line above is a HashbangComment node in the AST.\n// It is the ONLY position where # is legal outside a string/comment/private-field.\n\nfunction hashbangMain(args) {\n  return { ran: true, args };\n}",
      "expectedNodes": [
        {
          "type": "EXTERNAL",
          "id": "<#!/usr/bin/env node>",
          "metadata": {
            "interpreter": "/usr/bin/env node",
            "role": "hashbang"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<hashbangMain>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<args>"
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ran: true, args }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<#!/usr/bin/env node>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<hashbangMain>",
            "type": "DECLARES"
          },
          {
            "src": "<hashbangMain>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<hashbangMain>",
            "dst": "<{ ran: true, args }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ ran: true, args }>",
            "dst": "<true>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<{ ran: true, args }>",
            "dst": "<args>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::getter-returns-function",
      "category": "expressions",
      "code": "function getterReturnsFunction() {\n  const obj = {\n    get handler() {\n      return (x) => x * 2;             // getter returns a function\n    },\n  };\n  const result = obj.handler(21);       // getter call + returned function call\n  return result; // 42\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getterReturnsFunction>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj-literal>"
        },
        {
          "type": "GETTER",
          "id": "<handler-getter>",
          "metadata": {
            "propertyName": "handler"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow-fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<obj.handler(21)>",
          "metadata": {
            "callee": "obj.handler"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.handler>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "handler"
          }
        },
        {
          "type": "LITERAL",
          "id": "<21>",
          "metadata": {
            "value": 21,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getterReturnsFunction>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj-literal>",
            "dst": "<handler-getter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<handler-getter>",
            "dst": "<arrow-fn>",
            "type": "RETURNS"
          },
          {
            "src": "<arrow-fn>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrow-fn>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          },
          {
            "src": "<getterReturnsFunction>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj.handler(21)>",
            "dst": "<21>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getterReturnsFunction>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<obj-literal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<result>",
            "dst": "<obj.handler(21)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.handler(21)>",
            "dst": "<obj.handler>",
            "type": "CALLS"
          },
          {
            "src": "<obj.handler>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::import-namespace",
      "category": "index",
      "code": "import * as allHelpers from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-allHelpers>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importType": "namespace"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<allHelpers>",
          "metadata": {
            "imported": true,
            "namespaceImport": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-allHelpers>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<allHelpers>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-allHelpers>",
            "dst": "<allHelpers>",
            "type": "IMPORTS"
          },
          {
            "src": "<module>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::import-default-as-named",
      "category": "index",
      "code": "import { default as mainFn } from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-modules-helpers>",
          "metadata": {
            "source": "./modules-helpers.js"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<mainFn>",
          "metadata": {
            "imported": true,
            "importedAs": "default"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-modules-helpers>",
            "dst": "<mainFn>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-modules-helpers>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::reexport-star",
      "category": "index",
      "code": "export * from './modules-reexport.js';",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-star>",
          "metadata": {
            "exportType": "star",
            "source": "./modules-reexport.js"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-reexport.js>",
          "metadata": {
            "path": "./modules-reexport.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [],
        "postProject": [
          {
            "src": "<export-star>",
            "dst": "<./modules-reexport.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::import-meta",
      "category": "index",
      "code": "const currentUrl = import.meta.url;\n\n// --- Module namespace object as first-class value ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<currentUrl>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<import.meta.url>",
          "metadata": {
            "objectName": "import.meta",
            "propertyName": "url"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<import.meta>",
          "metadata": {
            "kind": "module-metadata"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<currentUrl>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<currentUrl>",
            "dst": "<import.meta.url>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import.meta.url>",
            "dst": "<import.meta>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-weakset",
      "category": "builtins",
      "code": "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<weakSetUsage>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<ws>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new WeakSet()>",
          "metadata": {
            "callee": "WeakSet",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj1>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj2>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}2>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "CALL",
          "id": "<ws.add(obj1)>",
          "metadata": {
            "callee": "add",
            "method": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<has>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ws.has(obj1)>",
          "metadata": {
            "callee": "has",
            "method": true
          }
        },
        {
          "type": "CALL",
          "id": "<ws.delete(obj1)>",
          "metadata": {
            "callee": "delete",
            "method": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasAfter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ws.has(obj1)2>",
          "metadata": {
            "callee": "has",
            "method": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ has, hasAfter }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<weakSetUsage>",
            "dst": "<ws>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<obj1>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<obj2>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<has>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<hasAfter>",
            "type": "CONTAINS"
          },
          {
            "src": "<ws.add(obj1)>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ws.has(obj1)>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ws.delete(obj1)>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ws.has(obj1)2>",
            "dst": "<obj1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<weakSetUsage>",
            "dst": "<{ has, hasAfter }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<ws>",
            "dst": "<new WeakSet()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj1>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj2>",
            "dst": "<{}2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<has>",
            "dst": "<ws.has(obj1)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasAfter>",
            "dst": "<ws.has(obj1)2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new WeakSet()>",
            "dst": "<WeakSet>",
            "type": "CALLS"
          },
          {
            "src": "<ws.add(obj1)>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<ws.has(obj1)>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<ws.delete(obj1)>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<ws.has(obj1)2>",
            "dst": "<ws>",
            "type": "CALLS_ON"
          },
          {
            "src": "<{ has, hasAfter }>",
            "dst": "<has>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ has, hasAfter }>",
            "dst": "<hasAfter>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::tag-on-call-result",
      "category": "expressions",
      "code": "function tagOnCallResult() {\n  function getFormatter(type) {\n    return (strings, ...values) => ({ type, parts: strings, values });\n  }\n  const result = getFormatter('sql')`SELECT * FROM ${'users'}`;\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tagOnCallResult>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getFormatter>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<type>"
        },
        {
          "type": "FUNCTION",
          "id": "<getFormatter:arrow>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<strings>"
        },
        {
          "type": "PARAMETER",
          "id": "<...values>",
          "metadata": {
            "restParameter": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ type, parts: strings, values }>",
          "metadata": {
            "expressionType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<getFormatter('sql')>",
          "metadata": {
            "callee": "getFormatter"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'sql'>",
          "metadata": {
            "value": "sql",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<tagged_template_call>",
          "metadata": {
            "callee": "getFormatter('sql')",
            "callType": "tagged_template"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`SELECT * FROM ${'users'}`>",
          "metadata": {
            "expressionType": "template_literal"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'users'>",
          "metadata": {
            "value": "users",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tagOnCallResult>",
            "dst": "<getFormatter>",
            "type": "CONTAINS"
          },
          {
            "src": "<getFormatter>",
            "dst": "<type>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<getFormatter>",
            "dst": "<getFormatter:arrow>",
            "type": "RETURNS"
          },
          {
            "src": "<getFormatter:arrow>",
            "dst": "<strings>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<getFormatter:arrow>",
            "dst": "<...values>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<getFormatter:arrow>",
            "dst": "<{ type, parts: strings, values }>",
            "type": "RETURNS"
          },
          {
            "src": "<tagOnCallResult>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<getFormatter('sql')>",
            "dst": "<'sql'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<tagged_template_call>",
            "dst": "<`SELECT * FROM ${'users'}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<`SELECT * FROM ${'users'}`>",
            "dst": "<'users'>",
            "type": "CONTAINS"
          },
          {
            "src": "<tagOnCallResult>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<tagged_template_call>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ type, parts: strings, values }>",
            "dst": "<type>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ type, parts: strings, values }>",
            "dst": "<strings>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ type, parts: strings, values }>",
            "dst": "<...values>",
            "type": "READS_FROM"
          },
          {
            "src": "<getFormatter('sql')>",
            "dst": "<getFormatter>",
            "type": "CALLS"
          },
          {
            "src": "<tagged_template_call>",
            "dst": "<getFormatter('sql')>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-weakref",
      "category": "builtins",
      "code": "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<weakRefUsage>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<target>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ data: 'important' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<ref>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new WeakRef(target)>",
          "metadata": {
            "callee": "WeakRef",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<deref>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ref.deref()>",
          "metadata": {
            "callee": "deref",
            "isMethodCall": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<deref?.data>",
          "metadata": {
            "objectName": "deref",
            "propertyName": "data",
            "optional": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<weakRefUsage>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakRefUsage>",
            "dst": "<ref>",
            "type": "CONTAINS"
          },
          {
            "src": "<weakRefUsage>",
            "dst": "<deref>",
            "type": "CONTAINS"
          },
          {
            "src": "<new WeakRef(target)>",
            "dst": "<target>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<weakRefUsage>",
            "dst": "<deref?.data>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<target>",
            "dst": "<{ data: 'important' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ref>",
            "dst": "<new WeakRef(target)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<deref>",
            "dst": "<ref.deref()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<ref.deref()>",
            "dst": "<ref>",
            "type": "CALLS_ON"
          },
          {
            "src": "<deref?.data>",
            "dst": "<deref>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::import-dynamic",
      "category": "index",
      "code": "const dynamicModule = await import('./patterns.js');",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<dynamicModule>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import('./patterns.js')>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./patterns.js'>",
          "metadata": {
            "value": "./patterns.js",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<dynamicModule>",
            "type": "DECLARES"
          },
          {
            "src": "<import('./patterns.js')>",
            "dst": "<'./patterns.js'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<dynamicModule>",
            "dst": "<import('./patterns.js')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<module>",
            "dst": "<./patterns.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::deep-optional-chain",
      "category": "expressions",
      "code": "function deepOptionalChain(response) {\n  const value = response?.data?.items?.[0]?.getName?.();\n  const nested = response?.config?.headers?.['Content-Type']?.split?.('/');\n  return { value, nested };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deepOptionalChain>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<response>"
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<response?.data?.items?.[0]?.getName?.()>",
          "metadata": {
            "type": "optional_chain",
            "chainLength": 5
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response?.data>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<data?.items>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<items?.[0]>",
          "metadata": {
            "optional": true,
            "computed": true,
            "index": 0
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<[0]?.getName>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "CALL",
          "id": "<getName?.()>",
          "metadata": {
            "optional": true,
            "arguments": 0
          }
        },
        {
          "type": "VARIABLE",
          "id": "<nested>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<response?.config?.headers?.['Content-Type']?.split?.('/')>",
          "metadata": {
            "type": "optional_chain",
            "chainLength": 5
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<response?.config>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<config?.headers>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<headers?.['Content-Type']>",
          "metadata": {
            "optional": true,
            "computed": true,
            "key": "Content-Type"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<['Content-Type']?.split>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "CALL",
          "id": "<split?.('/')>",
          "metadata": {
            "optional": true,
            "arguments": 1
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/'>",
          "metadata": {
            "value": "/",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ value, nested }>",
          "metadata": {
            "type": "object_literal",
            "properties": 2
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deepOptionalChain>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<deepOptionalChain>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<deepOptionalChain>",
            "dst": "<nested>",
            "type": "CONTAINS"
          },
          {
            "src": "<response?.data?.items?.[0]?.getName?.()>",
            "dst": "<response?.data>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<data?.items>",
            "dst": "<response?.data>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<items?.[0]>",
            "dst": "<data?.items>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<[0]?.getName>",
            "dst": "<items?.[0]>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<getName?.()>",
            "dst": "<[0]?.getName>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<response?.config?.headers?.['Content-Type']?.split?.('/')>",
            "dst": "<response?.config>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<config?.headers>",
            "dst": "<response?.config>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<headers?.['Content-Type']>",
            "dst": "<config?.headers>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<['Content-Type']?.split>",
            "dst": "<headers?.['Content-Type']>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<split?.('/')>",
            "dst": "<['Content-Type']?.split>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<split?.('/')>",
            "dst": "<'/'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<deepOptionalChain>",
            "dst": "<{ value, nested }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<value>",
            "dst": "<response?.data?.items?.[0]?.getName?.()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<nested>",
            "dst": "<response?.config?.headers?.['Content-Type']?.split?.('/')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<response?.data>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<response?.config>",
            "dst": "<response>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ value, nested }>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ value, nested }>",
            "dst": "<nested>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::module-namespace-destructured",
      "category": "index",
      "code": "const { helperFunction: destructuredHelper } = allHelpers;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<destructuredHelper>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{helperFunction: destructuredHelper}>",
          "metadata": {
            "expressionType": "destructuring",
            "destructuringType": "object",
            "renamed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<allHelpers.helperFunction>",
          "metadata": {
            "objectName": "allHelpers",
            "propertyName": "helperFunction"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<destructuredHelper>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<destructuredHelper>",
            "dst": "<{helperFunction: destructuredHelper}>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{helperFunction: destructuredHelper}>",
            "dst": "<allHelpers>",
            "type": "READS_FROM"
          },
          {
            "src": "<{helperFunction: destructuredHelper}>",
            "dst": "<allHelpers.helperFunction>",
            "type": "READS_FROM"
          },
          {
            "src": "<allHelpers.helperFunction>",
            "dst": "<allHelpers>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::export-named-list",
      "category": "index",
      "code": "export { defaultExport, helperFunction, HELPER_CONST, Helper, allHelpers, mainFn, helperResult, destructuredHelper };",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<defaultExport>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<helperFunction>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<HELPER_CONST>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Helper>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<allHelpers>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<mainFn>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<helperResult>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<destructuredHelper>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<defaultExport>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<helperFunction>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<HELPER_CONST>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Helper>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<allHelpers>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<mainFn>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<helperResult>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<destructuredHelper>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "expressions::arrow-return-assignment",
      "category": "expressions",
      "code": "function arrowReturnAssignment() {\n  let cache = null;\n\n  // Arrow returning assignment  parenthesized to make it expression body\n  const setCache = (val) => (cache = val);\n  setCache(42);\n\n  // With destructuring assignment in arrow\n  let first, second;\n  const swap = () => ([first, second] = [second, first]);\n\n  return { cache, setCache, swap };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<arrowReturnAssignment>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cache>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<setCache>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<setCache:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<val>"
        },
        {
          "type": "EXPRESSION",
          "id": "<cache = val>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "CALL",
          "id": "<setCache(42)>",
          "metadata": {
            "callee": "setCache"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<second>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<swap>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<swap:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[first, second] = [second, first]>",
          "metadata": {
            "operator": "=",
            "destructuring": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[second, first]>",
          "metadata": {
            "arrayLiteral": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ cache, setCache, swap }>",
          "metadata": {
            "objectLiteral": true,
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<cache>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<setCache>",
            "type": "CONTAINS"
          },
          {
            "src": "<setCache:fn>",
            "dst": "<val>",
            "type": "CONTAINS"
          },
          {
            "src": "<setCache:fn>",
            "dst": "<cache = val>",
            "type": "RETURNS"
          },
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<setCache(42)>",
            "type": "CONTAINS"
          },
          {
            "src": "<setCache(42)>",
            "dst": "<42>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<first>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<second>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<swap>",
            "type": "CONTAINS"
          },
          {
            "src": "<swap:fn>",
            "dst": "<[first, second] = [second, first]>",
            "type": "RETURNS"
          },
          {
            "src": "<arrowReturnAssignment>",
            "dst": "<{ cache, setCache, swap }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<cache>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<setCache>",
            "dst": "<setCache:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<cache = val>",
            "dst": "<cache>",
            "type": "WRITES_TO"
          },
          {
            "src": "<swap>",
            "dst": "<swap:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<[first, second] = [second, first]>",
            "dst": "<first>",
            "type": "WRITES_TO"
          },
          {
            "src": "<[first, second] = [second, first]>",
            "dst": "<second>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<cache = val>",
            "dst": "<val>",
            "type": "READS_FROM"
          },
          {
            "src": "<setCache(42)>",
            "dst": "<setCache>",
            "type": "CALLS"
          },
          {
            "src": "<[first, second] = [second, first]>",
            "dst": "<[second, first]>",
            "type": "READS_FROM"
          },
          {
            "src": "<[second, first]>",
            "dst": "<second>",
            "type": "READS_FROM"
          },
          {
            "src": "<[second, first]>",
            "dst": "<first>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ cache, setCache, swap }>",
            "dst": "<cache>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ cache, setCache, swap }>",
            "dst": "<setCache>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ cache, setCache, swap }>",
            "dst": "<swap>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "expressions::void-as-undefined",
      "category": "expressions",
      "code": "function voidAsUndefined(val) {\n  // void 0 is shorter than undefined and immune to shadowing\n  const isUndef = val === void 0;\n\n  // void with side effect  expression runs, result discarded\n  let sideEffectRan = false;\n  void (sideEffectRan = true);\n\n  // void in ternary  explicit undefined branch\n  const result = val !== void 0 ? val : 'fallback';\n\n  return { isUndef, sideEffectRan, result };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<voidAsUndefined>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<val>"
        },
        {
          "type": "VARIABLE",
          "id": "<isUndef>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<val === void 0>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<void 0>",
          "metadata": {
            "operator": "void"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<sideEffectRan>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<void (sideEffectRan = true)>",
          "metadata": {
            "operator": "void"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<sideEffectRan = true>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<val !== void 0 ? val : 'fallback'>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<val !== void 0>",
          "metadata": {
            "operator": "!=="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<void 0 (ternary)>",
          "metadata": {
            "operator": "void"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0 (ternary)>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fallback'>",
          "metadata": {
            "value": "fallback",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ isUndef, sideEffectRan, result }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<voidAsUndefined>",
            "dst": "<val>",
            "type": "CONTAINS"
          },
          {
            "src": "<voidAsUndefined>",
            "dst": "<isUndef>",
            "type": "DECLARES"
          },
          {
            "src": "<voidAsUndefined>",
            "dst": "<sideEffectRan>",
            "type": "DECLARES"
          },
          {
            "src": "<voidAsUndefined>",
            "dst": "<result>",
            "type": "DECLARES"
          },
          {
            "src": "<val !== void 0 ? val : 'fallback'>",
            "dst": "<val !== void 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<val !== void 0 ? val : 'fallback'>",
            "dst": "<val>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<voidAsUndefined>",
            "dst": "<{ isUndef, sideEffectRan, result }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<isUndef>",
            "dst": "<val === void 0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<sideEffectRan>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<sideEffectRan = true>",
            "dst": "<sideEffectRan>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result>",
            "dst": "<val !== void 0 ? val : 'fallback'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<val !== void 0 ? val : 'fallback'>",
            "dst": "<'fallback'>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<val === void 0>",
            "dst": "<val>",
            "type": "READS_FROM"
          },
          {
            "src": "<val === void 0>",
            "dst": "<void 0>",
            "type": "READS_FROM"
          },
          {
            "src": "<void 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          },
          {
            "src": "<void (sideEffectRan = true)>",
            "dst": "<sideEffectRan = true>",
            "type": "READS_FROM"
          },
          {
            "src": "<sideEffectRan = true>",
            "dst": "<true>",
            "type": "READS_FROM"
          },
          {
            "src": "<val !== void 0>",
            "dst": "<val>",
            "type": "READS_FROM"
          },
          {
            "src": "<val !== void 0>",
            "dst": "<void 0 (ternary)>",
            "type": "READS_FROM"
          },
          {
            "src": "<void 0 (ternary)>",
            "dst": "<0 (ternary)>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ isUndef, sideEffectRan, result }>",
            "dst": "<isUndef>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ isUndef, sideEffectRan, result }>",
            "dst": "<sideEffectRan>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ isUndef, sideEffectRan, result }>",
            "dst": "<result>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-usage-spread",
      "category": "iterators",
      "code": "function spreadRange(start, end) {\n  return [...new Range(start, end)];\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<spreadRange>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "EXPRESSION",
          "id": "<...new Range(start, end)>",
          "metadata": {
            "operator": "spread"
          }
        },
        {
          "type": "CALL",
          "id": "<new Range(start, end)>",
          "metadata": {
            "callee": "Range",
            "isConstructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<spreadRange>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadRange>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadRange>",
            "dst": "<...new Range(start, end)>",
            "type": "RETURNS"
          },
          {
            "src": "<...new Range(start, end)>",
            "dst": "<new Range(start, end)>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<...new Range(start, end)>",
            "dst": "<[]>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<new Range(start, end)>",
            "dst": "<start>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Range(start, end)>",
            "dst": "<end>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "iterators::iter-usage-for-of",
      "category": "iterators",
      "code": "function consumeRange(start, end) {\n  const range = new Range(start, end);\n  const values = [];\n  for (const n of range) {\n    values.push(n);\n  }\n  return values;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<consumeRange>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "VARIABLE",
          "id": "<range>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Range(start, end)>",
          "metadata": {
            "callee": "Range",
            "isConstructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<values>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<n>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<values.push(n)>",
          "metadata": {
            "callee": "push",
            "method": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<consumeRange>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeRange>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeRange>",
            "dst": "<range>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Range(start, end)>",
            "dst": "<start>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Range(start, end)>",
            "dst": "<end>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<consumeRange>",
            "dst": "<values>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeRange>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<range>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<values.push(n)>",
            "type": "CONTAINS"
          },
          {
            "src": "<values.push(n)>",
            "dst": "<n>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<consumeRange>",
            "dst": "<values>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<range>",
            "dst": "<new Range(start, end)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<values>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "iterators::iter-usage-destructuring",
      "category": "iterators",
      "code": "function destructureRange(start, end) {\n  const [first, second, ...rest] = new Range(start, end);\n  return { first, second, rest };\n}\n\n// --- Iterator protocol manual ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureRange>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<second>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<rest>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Range(start, end)>",
          "metadata": {
            "callee": "Range",
            "isConstructor": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ first, second, rest }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureRange>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRange>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRange>",
            "dst": "<first>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRange>",
            "dst": "<second>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRange>",
            "dst": "<rest>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Range(start, end)>",
            "dst": "<start>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Range(start, end)>",
            "dst": "<end>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<destructureRange>",
            "dst": "<{ first, second, rest }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<first>",
            "dst": "<new Range(start, end)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<second>",
            "dst": "<new Range(start, end)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<rest>",
            "dst": "<new Range(start, end)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ first, second, rest }>",
            "dst": "<first>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, second, rest }>",
            "dst": "<second>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, second, rest }>",
            "dst": "<rest>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-finalization-registry",
      "category": "builtins",
      "code": "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<finalizationUsage>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<registry>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new FinalizationRegistry(...)>",
          "metadata": {
            "callee": "FinalizationRegistry",
            "constructor": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<cleanup-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<heldValue>"
        },
        {
          "type": "CALL",
          "id": "<console.log(...)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Cleaned up: ${heldValue}`>",
          "metadata": {
            "templateLiteral": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ id: 1 }>",
          "metadata": {
            "value": "{ id: 1 }",
            "literalType": "object"
          }
        },
        {
          "type": "CALL",
          "id": "<registry.register(obj, 'resource-1')>",
          "metadata": {
            "callee": "register"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'resource-1'>",
          "metadata": {
            "value": "resource-1",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<finalizationUsage>",
            "dst": "<registry>",
            "type": "CONTAINS"
          },
          {
            "src": "<finalizationUsage>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<new FinalizationRegistry(...)>",
            "dst": "<cleanup-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cleanup-callback>",
            "dst": "<heldValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<cleanup-callback>",
            "dst": "<console.log(...)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(...)>",
            "dst": "<`Cleaned up: ${heldValue}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finalizationUsage>",
            "dst": "<registry.register(obj, 'resource-1')>",
            "type": "CONTAINS"
          },
          {
            "src": "<registry.register(obj, 'resource-1')>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<registry.register(obj, 'resource-1')>",
            "dst": "<'resource-1'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finalizationUsage>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<registry>",
            "dst": "<new FinalizationRegistry(...)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<{ id: 1 }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`Cleaned up: ${heldValue}`>",
            "dst": "<heldValue>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "index::module-namespace-as-value",
      "category": "index",
      "code": "function useNamespaceAsValue(ns) {\n  const fn = ns[arguments[1]]; // dynamic dispatch through namespace\n  return typeof fn === 'function' ? fn() : undefined;\n}\nconst helperResult = useNamespaceAsValue(allHelpers, 'helperFunction');",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<useNamespaceAsValue>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<ns>"
        },
        {
          "type": "VARIABLE",
          "id": "<fn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<ns[arguments[1]]>",
          "metadata": {
            "dynamic": true,
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof fn === 'function'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof fn>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'function'>",
          "metadata": {
            "value": "function",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<fn()>",
          "metadata": {
            "dynamic": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<undefined>",
          "metadata": {
            "value": "undefined",
            "literalType": "undefined"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<helperResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<useNamespaceAsValue(allHelpers, 'helperFunction')>",
          "metadata": {
            "callee": "useNamespaceAsValue"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'helperFunction'>",
          "metadata": {
            "value": "helperFunction",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<useNamespaceAsValue>",
            "dst": "<ns>",
            "type": "CONTAINS"
          },
          {
            "src": "<useNamespaceAsValue>",
            "dst": "<typeof fn === 'function'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<useNamespaceAsValue>",
            "dst": "<fn()>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<useNamespaceAsValue(allHelpers, 'helperFunction')>",
            "dst": "<'helperFunction'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<fn>",
            "dst": "<ns[arguments[1]]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<useNamespaceAsValue>",
            "dst": "<undefined>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<helperResult>",
            "dst": "<useNamespaceAsValue(allHelpers, 'helperFunction')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<ns[arguments[1]]>",
            "dst": "<ns>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof fn === 'function'>",
            "dst": "<typeof fn>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof fn === 'function'>",
            "dst": "<'function'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof fn>",
            "dst": "<fn>",
            "type": "READS_FROM"
          },
          {
            "src": "<fn()>",
            "dst": "<fn>",
            "type": "CALLS"
          },
          {
            "src": "<useNamespaceAsValue(allHelpers, 'helperFunction')>",
            "dst": "<useNamespaceAsValue>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-generator-iterable",
      "category": "iterators",
      "code": "function* rangeGenerator(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\n// --- Custom async iterable ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<rangeGenerator>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i <= end>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield i>",
          "metadata": {
            "yieldType": "value"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<rangeGenerator>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<rangeGenerator>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<rangeGenerator>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<i <= end>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<yield i>",
            "type": "HAS_BODY"
          },
          {
            "src": "<yield i>",
            "dst": "<i>",
            "type": "YIELDS"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i <= end>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i <= end>",
            "dst": "<end>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-infinite",
      "category": "iterators",
      "code": "function naturals() {\n  let n = 1;\n  return {\n    [Symbol.iterator]() { return this; },\n    next() {\n      return { value: n++, done: false };\n    },\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<naturals>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<n>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<object-literal>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<[Symbol.iterator]>",
          "metadata": {
            "kind": "method",
            "computed": true
          }
        },
        {
          "type": "METHOD",
          "id": "<next>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<n++>",
          "metadata": {
            "operator": "++",
            "postfix": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<naturals>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<naturals>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<[Symbol.iterator]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<next>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<[Symbol.iterator]>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<next>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<n++>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<false>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<n>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<n++>",
            "dst": "<n>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<n++>",
            "dst": "<n>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-async-generator",
      "category": "iterators",
      "code": "async function* asyncMap(iterable, fn) {\n  for await (const item of iterable) {\n    yield fn(item);\n  }\n}\n\n// --- Composable iterators ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<asyncMap>",
          "metadata": {
            "async": true,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<iterable>"
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "LOOP",
          "id": "<for-await-of>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fn(item)>",
          "metadata": {
            "callee": "fn"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield fn(item)>",
          "metadata": {
            "operator": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<asyncMap>",
            "dst": "<iterable>",
            "type": "HAS_BODY"
          },
          {
            "src": "<asyncMap>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<asyncMap>",
            "dst": "<for-await-of>",
            "type": "HAS_BODY"
          },
          {
            "src": "<for-await-of>",
            "dst": "<iterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await-of>",
            "dst": "<yield fn(item)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fn(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<yield fn(item)>",
            "dst": "<fn(item)>",
            "type": "YIELDS"
          },
          {
            "src": "<asyncMap>",
            "dst": "<yield fn(item)>",
            "type": "YIELDS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<fn(item)>",
            "dst": "<fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-compose-chain",
      "category": "iterators",
      "code": "function* chainIter(...iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<chainIter>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<...iterables>",
          "metadata": {
            "rest": true
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<iterable>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield* iterable>",
          "metadata": {
            "operator": "yield*"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<chainIter>",
            "dst": "<...iterables>",
            "type": "CONTAINS"
          },
          {
            "src": "<chainIter>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<...iterables>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<iterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<yield* iterable>",
            "type": "HAS_BODY"
          },
          {
            "src": "<yield* iterable>",
            "dst": "<iterable>",
            "type": "DELEGATES_TO"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "iterators::iter-take",
      "category": "iterators",
      "code": "function take(iterable, count) {\n  const result = [];\n  let i = 0;\n  for (const value of iterable) {\n    if (i++ >= count) break;\n    result.push(value);\n  }\n  return result;\n}\n\n// --- Generator as iterable ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<take>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<iterable>"
        },
        {
          "type": "PARAMETER",
          "id": "<count>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-break>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++ >= count>",
          "metadata": {
            "operator": ">="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "CALL",
          "id": "<result.push(value)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<result.push>",
          "metadata": {
            "objectName": "result",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<take>",
            "dst": "<iterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<take>",
            "dst": "<count>",
            "type": "CONTAINS"
          },
          {
            "src": "<take>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<take>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<take>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<iterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<if-break>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-break>",
            "dst": "<i++ >= count>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-of>",
            "dst": "<result.push(value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<result.push(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<take>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i++ >= count>",
            "dst": "<i++>",
            "type": "READS_FROM"
          },
          {
            "src": "<i++ >= count>",
            "dst": "<count>",
            "type": "READS_FROM"
          },
          {
            "src": "<result.push(value)>",
            "dst": "<result.push>",
            "type": "CALLS"
          },
          {
            "src": "<result.push>",
            "dst": "<result>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-compose-map",
      "category": "iterators",
      "code": "function* mapIter(iterable, fn) {\n  for (const item of iterable) {\n    yield fn(item);\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<mapIter>",
          "metadata": {
            "generator": true,
            "async": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<iterable>"
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fn(item)>",
          "metadata": {
            "callee": "fn"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield fn(item)>",
          "metadata": {
            "operator": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<mapIter>",
            "dst": "<iterable>",
            "type": "HAS_BODY"
          },
          {
            "src": "<mapIter>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<mapIter>",
            "dst": "<for-of>",
            "type": "HAS_BODY"
          },
          {
            "src": "<for-of>",
            "dst": "<iterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<item>",
            "type": "HAS_BODY"
          },
          {
            "src": "<for-of>",
            "dst": "<yield fn(item)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fn(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<yield fn(item)>",
            "dst": "<fn(item)>",
            "type": "YIELDS"
          },
          {
            "src": "<mapIter>",
            "dst": "<yield fn(item)>",
            "type": "YIELDS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<fn(item)>",
            "dst": "<fn>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-manual-next",
      "category": "iterators",
      "code": "function manualIteration(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  const results = [];\n  let step = iterator.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = iterator.next();\n  }\n  return results;\n}\n\n// --- Iterator with return() ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<manualIteration>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<iterable>"
        },
        {
          "type": "VARIABLE",
          "id": "<iterator>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<iterable[Symbol.iterator]>",
          "metadata": {
            "property": "Symbol.iterator",
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<iterable[Symbol.iterator]()>",
          "metadata": {
            "callee": "iterable[Symbol.iterator]"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<step>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "CALL",
          "id": "<iterator.next()>",
          "metadata": {
            "callee": "iterator.next"
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!step.done>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<step.done>",
          "metadata": {
            "property": "done"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(step.value)>",
          "metadata": {
            "callee": "results.push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<step.value>",
          "metadata": {
            "property": "value"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<step = iterator.next()>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "CALL",
          "id": "<iterator.next()#2>",
          "metadata": {
            "callee": "iterator.next"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<manualIteration>",
            "dst": "<iterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualIteration>",
            "dst": "<iterator>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualIteration>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualIteration>",
            "dst": "<step>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualIteration>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<while>",
            "dst": "<!step.done>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while>",
            "dst": "<results.push(step.value)>",
            "type": "CONTAINS"
          },
          {
            "src": "<results.push(step.value)>",
            "dst": "<step.value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<while>",
            "dst": "<step = iterator.next()>",
            "type": "CONTAINS"
          },
          {
            "src": "<manualIteration>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<iterator>",
            "dst": "<iterable[Symbol.iterator]()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<step>",
            "dst": "<iterator.next()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<step = iterator.next()>",
            "dst": "<step>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<iterable[Symbol.iterator]()>",
            "dst": "<iterable[Symbol.iterator]>",
            "type": "CALLS"
          },
          {
            "src": "<iterable[Symbol.iterator]>",
            "dst": "<iterable>",
            "type": "READS_FROM"
          },
          {
            "src": "<iterator.next()>",
            "dst": "<iterator>",
            "type": "READS_FROM"
          },
          {
            "src": "<!step.done>",
            "dst": "<step.done>",
            "type": "READS_FROM"
          },
          {
            "src": "<step.done>",
            "dst": "<step>",
            "type": "READS_FROM"
          },
          {
            "src": "<results.push(step.value)>",
            "dst": "<results>",
            "type": "READS_FROM"
          },
          {
            "src": "<step.value>",
            "dst": "<step>",
            "type": "READS_FROM"
          },
          {
            "src": "<step = iterator.next()>",
            "dst": "<iterator.next()#2>",
            "type": "READS_FROM"
          },
          {
            "src": "<iterator.next()#2>",
            "dst": "<iterator>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-compose-filter",
      "category": "iterators",
      "code": "function* filterIter(iterable, predicate) {\n  for (const item of iterable) {\n    if (predicate(item)) yield item;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<filterIter>",
          "metadata": {
            "async": false,
            "generator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<iterable>"
        },
        {
          "type": "PARAMETER",
          "id": "<predicate>"
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-predicate>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "CALL",
          "id": "<predicate(item)>",
          "metadata": {
            "callee": "predicate"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<yield item>",
          "metadata": {
            "operator": "yield"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<filterIter>",
            "dst": "<iterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<filterIter>",
            "dst": "<predicate>",
            "type": "CONTAINS"
          },
          {
            "src": "<filterIter>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<iterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<if-predicate>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-predicate>",
            "dst": "<predicate(item)>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<predicate(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<if-predicate>",
            "dst": "<yield item>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<yield item>",
            "dst": "<item>",
            "type": "YIELDS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<predicate(item)>",
            "dst": "<predicate>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "iterators::iter-async-for-await",
      "category": "iterators",
      "code": "async function consumeAsyncRange(start, end) {\n  const values = [];\n  for await (const n of new AsyncRange(start, end, 0)) {\n    values.push(n);\n  }\n  return values;\n}\n\n// --- Async generator as async iterable ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<consumeAsyncRange>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>"
        },
        {
          "type": "PARAMETER",
          "id": "<end>"
        },
        {
          "type": "VARIABLE",
          "id": "<values>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-await>",
          "metadata": {
            "loopType": "for-await-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<n>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new AsyncRange(start, end, 0)>",
          "metadata": {
            "callee": "AsyncRange",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<values.push(n)>",
          "metadata": {
            "callee": "push",
            "method": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<values.push>",
          "metadata": {
            "objectName": "values",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<consumeAsyncRange>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncRange>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncRange>",
            "dst": "<values>",
            "type": "CONTAINS"
          },
          {
            "src": "<consumeAsyncRange>",
            "dst": "<for-await>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-await>",
            "dst": "<new AsyncRange(start, end, 0)>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-await>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<new AsyncRange(start, end, 0)>",
            "dst": "<start>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new AsyncRange(start, end, 0)>",
            "dst": "<end>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new AsyncRange(start, end, 0)>",
            "dst": "<0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<for-await>",
            "dst": "<values.push(n)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<values.push(n)>",
            "dst": "<n>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<consumeAsyncRange>",
            "dst": "<values>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<values>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<values.push(n)>",
            "dst": "<values.push>",
            "type": "CALLS"
          },
          {
            "src": "<values.push>",
            "dst": "<values>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-type-variable",
      "category": "jsdoc-types",
      "code": "/** @type {Map<string, Function>} */\nconst handlers = new Map();\n\n/** @type {string | null} */\nlet currentUser = null;\n\n/** @type {readonly number[]} */\nconst PRIMES = [2, 3, 5, 7, 11];",
      "expectedNodes": [
        {
          "type": "TYPE_REFERENCE",
          "id": "<Map<string, Function>>",
          "metadata": {
            "typeExpression": "Map<string, Function>"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<handlers>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map()>",
          "metadata": {
            "callee": "Map",
            "isConstructor": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string | null>",
          "metadata": {
            "typeExpression": "string | null"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<currentUser>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<readonly number[]>",
          "metadata": {
            "typeExpression": "readonly number[]"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<PRIMES>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[2, 3, 5, 7, 11]>",
          "metadata": {
            "value": [
              2,
              3,
              5,
              7,
              11
            ],
            "literalType": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<handlers>",
            "dst": "<new Map()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<currentUser>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<PRIMES>",
            "dst": "<[2, 3, 5, 7, 11]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<handlers>",
            "dst": "<Map<string, Function>>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<currentUser>",
            "dst": "<string | null>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<PRIMES>",
            "dst": "<readonly number[]>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-param-returns",
      "category": "jsdoc-types",
      "code": "/**\n * @param {string} name\n * @param {number} age\n * @returns {{ name: string, age: number }}\n */\nfunction createUser(name, age) {\n  return { name, age };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createUser>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PARAMETER",
          "id": "<age>"
        },
        {
          "type": "EXTERNAL",
          "id": "<@param-name>",
          "metadata": {
            "paramName": "name",
            "type": "string",
            "kind": "jsdoc-param"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<@param-age>",
          "metadata": {
            "paramName": "age",
            "type": "number",
            "kind": "jsdoc-param"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<@returns>",
          "metadata": {
            "type": "{ name: string, age: number }",
            "kind": "jsdoc-returns"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ name, age }>",
          "metadata": {
            "kind": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<createUser>",
            "type": "DECLARES"
          },
          {
            "src": "<createUser>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<createUser>",
            "dst": "<age>",
            "type": "CONTAINS"
          },
          {
            "src": "<createUser>",
            "dst": "<{ name, age }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<createUser>",
            "dst": "<@param-name>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<createUser>",
            "dst": "<@param-age>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<createUser>",
            "dst": "<@returns>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<@param-name>",
            "dst": "<name>",
            "type": "ALIASES"
          },
          {
            "src": "<@param-age>",
            "dst": "<age>",
            "type": "ALIASES"
          },
          {
            "src": "<@returns>",
            "dst": "<{ name, age }>",
            "type": "ALIASES"
          },
          {
            "src": "<{ name, age }>",
            "dst": "<name>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ name, age }>",
            "dst": "<age>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-enum",
      "category": "jsdoc-types",
      "code": "/** @enum {string} */\nconst Priority = {\n  Low: 'low',\n  Medium: 'medium',\n  High: 'high',\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<Priority>",
          "metadata": {
            "kind": "const",
            "jsdocType": "enum",
            "enumValueType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<Priority-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'low'>",
          "metadata": {
            "value": "low",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'medium'>",
          "metadata": {
            "value": "medium",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'high'>",
          "metadata": {
            "value": "high",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Priority-object>",
            "dst": "<'low'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Priority-object>",
            "dst": "<'medium'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Priority-object>",
            "dst": "<'high'>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<Priority>",
            "dst": "<Priority-object>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-typedef",
      "category": "jsdoc-types",
      "code": "/**\n * @typedef {Object} UserDef\n * @property {number} id\n * @property {string} name\n * @property {string} [email]\n */\n\n/** @type {UserDef} */\nconst admin = { id: 1, name: 'admin' };",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<UserDef>",
          "metadata": {
            "baseType": "Object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<UserDef.id>",
          "metadata": {
            "type": "number",
            "required": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<UserDef.name>",
          "metadata": {
            "type": "string",
            "required": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<UserDef.email>",
          "metadata": {
            "type": "string",
            "required": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<admin>",
          "metadata": {
            "kind": "const",
            "declaredType": "UserDef"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ id: 1, name: 'admin' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'admin'>",
          "metadata": {
            "value": "admin",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<UserDef>",
            "type": "DECLARES"
          },
          {
            "src": "<UserDef>",
            "dst": "<UserDef.id>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<UserDef>",
            "dst": "<UserDef.name>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<UserDef>",
            "dst": "<UserDef.email>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<module>",
            "dst": "<admin>",
            "type": "DECLARES"
          },
          {
            "src": "<{ id: 1, name: 'admin' }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ id: 1, name: 'admin' }>",
            "dst": "<'admin'>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<admin>",
            "dst": "<{ id: 1, name: 'admin' }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<admin>",
            "dst": "<UserDef>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "iterators::export-named-list",
      "category": "iterators",
      "code": "export {\n  Range,\n  consumeRange,\n  spreadRange,\n  destructureRange,\n  manualIteration,\n  createCleanupIterator,\n  naturals,\n  take,\n  rangeGenerator,\n  AsyncRange,\n  consumeAsyncRange,\n  asyncMap,\n  mapIter,\n  filterIter,\n  chainIter,\n  zipIter,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Range>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<consumeRange>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<spreadRange>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<destructureRange>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<manualIteration>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<createCleanupIterator>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<naturals>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<take>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<rangeGenerator>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<AsyncRange>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<consumeAsyncRange>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<asyncMap>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<mapIter>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<filterIter>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<chainIter>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<zipIter>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<Range>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<consumeRange>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<spreadRange>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<destructureRange>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<manualIteration>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<createCleanupIterator>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<naturals>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<take>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<rangeGenerator>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<AsyncRange>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<consumeAsyncRange>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<asyncMap>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<mapIter>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<filterIter>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<chainIter>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<zipIter>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-template-constraint",
      "category": "jsdoc-types",
      "code": "/**\n * @template {object} T\n * @param {T} target\n * @param {Partial<T>} overrides\n * @returns {T}\n */\nfunction applyDefaults(target, overrides) {\n  return { ...target, ...overrides };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<applyDefaults>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<target>"
        },
        {
          "type": "PARAMETER",
          "id": "<overrides>"
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...target, ...overrides }>",
          "metadata": {
            "operator": "spread"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": "object"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<target:T>",
          "metadata": {
            "parameterName": "target"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<overrides:Partial<T>>",
          "metadata": {
            "parameterName": "overrides",
            "typeExpression": "Partial<T>"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<returns:T>",
          "metadata": {
            "typeExpression": "T"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<object>",
          "metadata": {
            "value": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<applyDefaults>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<applyDefaults>",
            "dst": "<overrides>",
            "type": "CONTAINS"
          },
          {
            "src": "<applyDefaults>",
            "dst": "<{ ...target, ...overrides }>",
            "type": "RETURNS"
          },
          {
            "src": "<applyDefaults>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<T>",
            "dst": "<object>",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<applyDefaults>",
            "dst": "<returns:T>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<target:T>",
            "dst": "<T>",
            "type": "USES"
          },
          {
            "src": "<overrides:Partial<T>>",
            "dst": "<T>",
            "type": "USES"
          },
          {
            "src": "<returns:T>",
            "dst": "<T>",
            "type": "USES"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<{ ...target, ...overrides }>",
            "dst": "<target>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ ...target, ...overrides }>",
            "dst": "<overrides>",
            "type": "READS_FROM"
          },
          {
            "src": "<target>",
            "dst": "<target:T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<overrides>",
            "dst": "<overrides:Partial<T>>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-import-type",
      "category": "jsdoc-types",
      "code": "/** @type {import('./modules-helpers.js').HelperClass} */\nlet helperRef;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<helperRef>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<@type-helperRef>",
          "metadata": {
            "annotationType": "type",
            "isJSDocAnnotation": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<import('./modules-helpers.js').HelperClass>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importedType": "HelperClass",
            "isImportType": true
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<helperRef>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<helperRef>",
            "dst": "<@type-helperRef>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<@type-helperRef>",
            "dst": "<import('./modules-helpers.js').HelperClass>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<import('./modules-helpers.js').HelperClass>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-deprecated",
      "category": "jsdoc-types",
      "code": "/**\n * @deprecated Use newProcess() instead\n * @param {string} input\n * @returns {string}\n */\nfunction oldProcess(input) {\n  return input;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<oldProcess>",
          "metadata": {
            "async": false,
            "generator": false,
            "deprecated": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input>",
          "metadata": {
            "jsdocType": "string"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<oldProcess:jsdoc>",
          "metadata": {
            "deprecated": "Use newProcess() instead",
            "paramTypes": {
              "input": "string"
            },
            "returnType": "string",
            "kind": "jsdoc"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<oldProcess>",
            "type": "DECLARES"
          },
          {
            "src": "<oldProcess>",
            "dst": "<input>",
            "type": "CONTAINS"
          },
          {
            "src": "<oldProcess>",
            "dst": "<input>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<oldProcess:jsdoc>",
            "dst": "<oldProcess>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<oldProcess:jsdoc>",
            "dst": "<input>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-template",
      "category": "jsdoc-types",
      "code": "/**\n * @template T\n * @param {T[]} items\n * @returns {T | undefined}\n */\nfunction first(items) {\n  return items[0];\n}\n\n/**\n * @template K, V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} fallback\n * @returns {V}\n */\nfunction getOrDefault(map, key, fallback) {\n  return map.has(key) ? map.get(key) : fallback;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<first>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>",
          "metadata": {
            "typeAnnotation": "T[]"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<items[0]>",
          "metadata": {
            "property": "0",
            "accessType": "bracket"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getOrDefault>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K>",
          "metadata": {
            "name": "K"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<V>",
          "metadata": {
            "name": "V"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<map>",
          "metadata": {
            "typeAnnotation": "Map<K, V>"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>",
          "metadata": {
            "typeAnnotation": "K"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fallback>",
          "metadata": {
            "typeAnnotation": "V"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<map.has(key) ? map.get(key) : fallback>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "CALL",
          "id": "<map.has(key)>",
          "metadata": {
            "callee": "has"
          }
        },
        {
          "type": "CALL",
          "id": "<map.get(key)>",
          "metadata": {
            "callee": "get"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<first>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<first>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<first>",
            "dst": "<items[0]>",
            "type": "RETURNS"
          },
          {
            "src": "<getOrDefault>",
            "dst": "<K>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<getOrDefault>",
            "dst": "<V>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<getOrDefault>",
            "dst": "<map>",
            "type": "CONTAINS"
          },
          {
            "src": "<getOrDefault>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<getOrDefault>",
            "dst": "<fallback>",
            "type": "CONTAINS"
          },
          {
            "src": "<getOrDefault>",
            "dst": "<map.has(key) ? map.get(key) : fallback>",
            "type": "RETURNS"
          },
          {
            "src": "<map.has(key) ? map.get(key) : fallback>",
            "dst": "<map.has(key)>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<map.has(key) ? map.get(key) : fallback>",
            "dst": "<map.get(key)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<map.has(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<map.get(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<map.has(key) ? map.get(key) : fallback>",
            "dst": "<fallback>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<items>",
            "dst": "<T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<items[0]>",
            "dst": "<items>",
            "type": "READS_FROM"
          },
          {
            "src": "<map>",
            "dst": "<K>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<map>",
            "dst": "<V>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<key>",
            "dst": "<K>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<fallback>",
            "dst": "<V>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<map.has(key)>",
            "dst": "<map>",
            "type": "CALLS_ON"
          },
          {
            "src": "<map.get(key)>",
            "dst": "<map>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-this",
      "category": "jsdoc-types",
      "code": "/**\n * @this {{ name: string }}\n * @param {string} greeting\n * @returns {string}\n */\nfunction greetThis(greeting) {\n  return `${greeting}, ${this.name}`;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<greetThis>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<greeting>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<@this>",
          "metadata": {
            "typeAnnotation": "{ name: string }"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<@param-greeting>",
          "metadata": {
            "typeAnnotation": "string",
            "paramName": "greeting"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<@returns>",
          "metadata": {
            "typeAnnotation": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this",
            "propertyName": "name"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<greetThis>",
            "dst": "<greeting>",
            "type": "CONTAINS"
          },
          {
            "src": "<greetThis>",
            "dst": "<@returns>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<greetThis>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<greetThis>",
            "dst": "<@this>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<greetThis>",
            "dst": "<@param-greeting>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<@param-greeting>",
            "dst": "<greeting>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<template-literal>",
            "dst": "<greeting>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "legacy-patterns::amd-require-call",
      "category": "legacy-patterns",
      "code": "// require(['app/main', 'app/config'], function(main, config) {\n//   main.start(config);\n// });\n\n// --- UMD (Universal Module Definition) ---",
      "expectedNodes": [
        {
          "type": "CALL",
          "id": "<require-call>",
          "metadata": {
            "callee": "require",
            "amdStyle": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'app/main'>",
          "metadata": {
            "value": "app/main",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'app/config'>",
          "metadata": {
            "value": "app/config",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<amd-callback>",
          "metadata": {
            "arrowFunction": false,
            "amdCallback": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<main>"
        },
        {
          "type": "PARAMETER",
          "id": "<config>"
        },
        {
          "type": "CALL",
          "id": "<main.start(config)>",
          "metadata": {
            "callee": "main.start"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<main.start>",
          "metadata": {
            "objectName": "main",
            "propertyName": "start"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<require-call>",
            "dst": "<'app/main'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<require-call>",
            "dst": "<'app/config'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<require-call>",
            "dst": "<amd-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<amd-callback>",
            "dst": "<main>",
            "type": "CONTAINS"
          },
          {
            "src": "<amd-callback>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<amd-callback>",
            "dst": "<main.start(config)>",
            "type": "CONTAINS"
          },
          {
            "src": "<main.start(config)>",
            "dst": "<config>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<main>",
            "dst": "<'app/main'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config>",
            "dst": "<'app/config'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<main.start(config)>",
            "dst": "<main.start>",
            "type": "CALLS"
          },
          {
            "src": "<main.start>",
            "dst": "<main>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "jsdoc-types::export-named-list",
      "category": "jsdoc-types",
      "code": "export {\n  createUser,\n  handlers,\n  currentUser,\n  PRIMES,\n  admin,\n  first,\n  getOrDefault,\n  applyDefaults,\n  NumberRange,\n  Priority,\n  isPositive,\n  convert,\n  greetThis,\n  oldProcess,\n  DataStore,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<createUser>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<handlers>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<currentUser>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<PRIMES>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<admin>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getOrDefault>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<applyDefaults>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<NumberRange>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Priority>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<isPositive>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<convert>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<greetThis>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<oldProcess>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<DataStore>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<createUser>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<handlers>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<currentUser>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<PRIMES>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<admin>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<first>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<getOrDefault>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<applyDefaults>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<NumberRange>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Priority>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<isPositive>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<convert>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<greetThis>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<oldProcess>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<DataStore>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-callback",
      "category": "jsdoc-types",
      "code": "/**\n * @callback Predicate\n * @param {unknown} value\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst isPositive = (value) => typeof value === 'number' && value > 0;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Predicate>",
          "metadata": {
            "name": "Predicate",
            "jsDocCallback": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "jsDocType": "unknown"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Predicate:return>",
          "metadata": {
            "jsDocType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<isPositive>",
          "metadata": {
            "kind": "const",
            "jsDocType": "Predicate"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<isPositive:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<isPositive:value>"
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value === 'number' && value > 0>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value === 'number'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'number'>",
          "metadata": {
            "value": "number",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<value > 0>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Predicate>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<Predicate>",
            "dst": "<Predicate:return>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<isPositive:fn>",
            "dst": "<isPositive:value>",
            "type": "CONTAINS"
          },
          {
            "src": "<isPositive:fn>",
            "dst": "<typeof value === 'number' && value > 0>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<isPositive>",
            "dst": "<isPositive:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<isPositive>",
            "dst": "<Predicate>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<typeof value === 'number' && value > 0>",
            "dst": "<typeof value === 'number'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value === 'number' && value > 0>",
            "dst": "<value > 0>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value === 'number'>",
            "dst": "<typeof value>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value === 'number'>",
            "dst": "<'number'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value>",
            "dst": "<isPositive:value>",
            "type": "READS_FROM"
          },
          {
            "src": "<value > 0>",
            "dst": "<isPositive:value>",
            "type": "READS_FROM"
          },
          {
            "src": "<value > 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "legacy-patterns::amd-define-named",
      "category": "legacy-patterns",
      "code": "// define('myModule', ['dep1', 'dep2'], function(dep1, dep2) {\n//   return { init: function() {} };\n// });",
      "expectedNodes": [
        {
          "type": "CALL",
          "id": "<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>",
          "metadata": {
            "callee": "define",
            "amdPattern": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'myModule'>",
          "metadata": {
            "value": "myModule",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<['dep1', 'dep2']>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'dep1'>",
          "metadata": {
            "value": "dep1",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'dep2'>",
          "metadata": {
            "value": "dep2",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<factory-function>",
          "metadata": {
            "amdFactory": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<dep1>"
        },
        {
          "type": "PARAMETER",
          "id": "<dep2>"
        },
        {
          "type": "LITERAL",
          "id": "<{ init: function() {} }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<init>",
          "metadata": {
            "method": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>",
            "dst": "<'myModule'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>",
            "dst": "<['dep1', 'dep2']>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>",
            "dst": "<factory-function>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<['dep1', 'dep2']>",
            "dst": "<'dep1'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<['dep1', 'dep2']>",
            "dst": "<'dep2'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<factory-function>",
            "dst": "<dep1>",
            "type": "CONTAINS"
          },
          {
            "src": "<factory-function>",
            "dst": "<dep2>",
            "type": "CONTAINS"
          },
          {
            "src": "<factory-function>",
            "dst": "<{ init: function() {} }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ init: function() {} }>",
            "dst": "<init>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<dep1>",
            "dst": "<'dep1'>",
            "type": "DERIVES_FROM"
          },
          {
            "src": "<dep2>",
            "dst": "<'dep2'>",
            "type": "DERIVES_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "jsdoc-types::jsdoc-overload",
      "category": "jsdoc-types",
      "code": "/**\n * @overload\n * @param {string} value\n * @returns {number}\n */\n/**\n * @overload\n * @param {number} value\n * @returns {string}\n */\n/**\n * @param {string | number} value\n * @returns {number | string}\n */\nfunction convert(value) {\n  return typeof value === 'string' ? Number(value) : String(value);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<convert>",
          "metadata": {
            "async": false,
            "generator": false,
            "hasOverloads": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "typeName": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "typeName": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string | number>",
          "metadata": {
            "typeName": "string | number",
            "isUnion": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number | string>",
          "metadata": {
            "typeName": "number | string",
            "isUnion": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value === 'string'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "CALL",
          "id": "<Number(value)>",
          "metadata": {
            "callee": "Number"
          }
        },
        {
          "type": "CALL",
          "id": "<String(value)>",
          "metadata": {
            "callee": "String"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Number>",
          "metadata": {
            "name": "Number"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<String>",
          "metadata": {
            "name": "String"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<convert>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<convert>",
            "dst": "<number | string>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<convert>",
            "dst": "<ternary>",
            "type": "RETURNS"
          },
          {
            "src": "<ternary>",
            "dst": "<typeof value === 'string'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary>",
            "dst": "<Number(value)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Number(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<String(value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<ternary>",
            "dst": "<String(value)>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<value>",
            "dst": "<string | number>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<typeof value === 'string'>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<Number(value)>",
            "dst": "<Number>",
            "type": "CALLS"
          },
          {
            "src": "<String(value)>",
            "dst": "<String>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-implements",
      "category": "jsdoc-types",
      "code": "/** @implements {Iterable<number>} */\nclass NumberRange {\n  /** @param {number} start @param {number} end */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  [Symbol.iterator]() {\n    let i = this.start;\n    const end = this.end;\n    return { next() { return i <= end ? { value: i++, done: false } : { done: true }; } };\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<NumberRange>"
        },
        {
          "type": "INTERFACE",
          "id": "<Iterable<number>>",
          "metadata": {
            "interface": "Iterable",
            "typeParameter": "number",
            "source": "jsdoc"
          }
        },
        {
          "type": "METHOD",
          "id": "<NumberRange.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<start>",
          "metadata": {
            "jsdocType": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<end>",
          "metadata": {
            "jsdocType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.start>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.end>"
        },
        {
          "type": "METHOD",
          "id": "<NumberRange[Symbol.iterator]>",
          "metadata": {
            "kind": "method",
            "computed": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<end:local>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<return-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<next>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i <= end>",
          "metadata": {
            "operator": "<="
          }
        },
        {
          "type": "LITERAL",
          "id": "<iterator-result-value>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<iterator-result-done>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<NumberRange>",
            "dst": "<NumberRange.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<NumberRange>",
            "dst": "<NumberRange[Symbol.iterator]>",
            "type": "CONTAINS"
          },
          {
            "src": "<NumberRange.constructor>",
            "dst": "<start>",
            "type": "CONTAINS"
          },
          {
            "src": "<NumberRange.constructor>",
            "dst": "<end>",
            "type": "CONTAINS"
          },
          {
            "src": "<NumberRange[Symbol.iterator]>",
            "dst": "<i>",
            "type": "DECLARES"
          },
          {
            "src": "<NumberRange[Symbol.iterator]>",
            "dst": "<end:local>",
            "type": "DECLARES"
          },
          {
            "src": "<NumberRange[Symbol.iterator]>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<next>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<next>",
            "dst": "<i <= end>",
            "type": "CONTAINS"
          },
          {
            "src": "<next>",
            "dst": "<iterator-result-value>",
            "type": "RETURNS"
          },
          {
            "src": "<next>",
            "dst": "<iterator-result-done>",
            "type": "RETURNS"
          },
          {
            "src": "<iterator-result-value>",
            "dst": "<i++>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<NumberRange.constructor>",
            "dst": "<this.start>",
            "type": "WRITES_TO"
          },
          {
            "src": "<NumberRange.constructor>",
            "dst": "<this.end>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.start>",
            "dst": "<start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.end>",
            "dst": "<end>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<this.start>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<end:local>",
            "dst": "<this.end>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<NumberRange>",
            "dst": "<Iterable<number>>",
            "type": "IMPLEMENTS"
          },
          {
            "src": "<i <= end>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i <= end>",
            "dst": "<end:local>",
            "type": "READS_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "jsdoc-types::jsdoc-class-fields",
      "category": "jsdoc-types",
      "code": "class DataStore {\n  /** @type {Map<string, unknown>} */\n  store = new Map();\n\n  /** @private */\n  _cache = {};\n\n  /**\n   * @param {string} key\n   * @param {unknown} value\n   */\n  set(key, value) {\n    this.store.set(key, value);\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this.store.size;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<DataStore>"
        },
        {
          "type": "PROPERTY",
          "id": "<DataStore.store>",
          "metadata": {
            "visibility": "public",
            "jsdocType": "Map<string, unknown>"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map()>",
          "metadata": {
            "constructor": true,
            "callee": "Map"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<DataStore._cache>",
          "metadata": {
            "visibility": "private",
            "jsdocAnnotation": "@private"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<DataStore.set>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>",
          "metadata": {
            "jsdocType": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "jsdocType": "unknown"
          }
        },
        {
          "type": "CALL",
          "id": "<this.store.set(key, value)>",
          "metadata": {
            "callee": "set"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.store>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "GETTER",
          "id": "<DataStore.size>",
          "metadata": {
            "jsdocReturns": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.store.size>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<DataStore>",
            "dst": "<DataStore.store>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<DataStore>",
            "dst": "<DataStore._cache>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<DataStore>",
            "dst": "<DataStore.set>",
            "type": "CONTAINS"
          },
          {
            "src": "<DataStore>",
            "dst": "<DataStore.size>",
            "type": "CONTAINS"
          },
          {
            "src": "<DataStore.set>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<DataStore.set>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<DataStore.set>",
            "dst": "<this.store.set(key, value)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<this.store.set(key, value)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<this.store.set(key, value)>",
            "dst": "<value>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<DataStore.size>",
            "dst": "<this.store.size>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<DataStore.store>",
            "dst": "<new Map()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<DataStore._cache>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new Map()>",
            "dst": "<Map>",
            "type": "CALLS"
          },
          {
            "src": "<this.store.set(key, value)>",
            "dst": "<this.store>",
            "type": "CALLS_ON"
          },
          {
            "src": "<this.store>",
            "dst": "<DataStore.store>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.store.size>",
            "dst": "<this.store>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "legacy-patterns::global-namespace-init",
      "category": "legacy-patterns",
      "code": "var MyApp = MyApp || {};\nMyApp.utils = MyApp.utils || {};\nMyApp.utils.format = function (str) { return str.trim(); };",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<MyApp>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<MyApp || {}>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<MyApp.utils>",
          "metadata": {
            "objectName": "MyApp",
            "propertyName": "utils"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<MyApp.utils || {}>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{} (utils)>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<MyApp.utils.format>",
          "metadata": {
            "objectName": "MyApp.utils",
            "propertyName": "format"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<format>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "CALL",
          "id": "<str.trim()>",
          "metadata": {
            "callee": "trim"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<MyApp>",
            "type": "DECLARES"
          },
          {
            "src": "<format>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<format>",
            "dst": "<str.trim()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<MyApp>",
            "dst": "<MyApp || {}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<MyApp.utils>",
            "dst": "<MyApp.utils || {}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<MyApp.utils.format>",
            "dst": "<format>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<MyApp || {}>",
            "dst": "<MyApp>",
            "type": "READS_FROM"
          },
          {
            "src": "<MyApp || {}>",
            "dst": "<{}>",
            "type": "READS_FROM"
          },
          {
            "src": "<MyApp.utils || {}>",
            "dst": "<MyApp.utils>",
            "type": "READS_FROM"
          },
          {
            "src": "<MyApp.utils || {}>",
            "dst": "<{} (utils)>",
            "type": "READS_FROM"
          },
          {
            "src": "<str.trim()>",
            "dst": "<str>",
            "type": "CALLS_ON"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::amd-define-deps",
      "category": "legacy-patterns",
      "code": "// define(['jquery', 'underscore'], function($, _) {\n//   return {\n//     render: function(data) {\n//       return _.template($('#tpl').html())(data);\n//     }\n//   };\n// });",
      "expectedNodes": [
        {
          "type": "CALL",
          "id": "<define-call>",
          "metadata": {
            "callee": "define",
            "moduleSystem": "amd"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'jquery'>",
          "metadata": {
            "value": "jquery",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'underscore'>",
          "metadata": {
            "value": "underscore",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<factory-function>",
          "metadata": {
            "arrowFunction": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<$>"
        },
        {
          "type": "PARAMETER",
          "id": "<_>"
        },
        {
          "type": "LITERAL",
          "id": "<module-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<render>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "CALL",
          "id": "<_.template-call>",
          "metadata": {
            "callee": "_.template"
          }
        },
        {
          "type": "CALL",
          "id": "<$('#tpl').html()>",
          "metadata": {
            "callee": "$"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'#tpl'>",
          "metadata": {
            "value": "#tpl",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<template-invocation>",
          "metadata": {
            "dynamic": true
          }
        },
        {
          "type": "MODULE",
          "id": "<module>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<define-call>",
            "type": "CONTAINS"
          },
          {
            "src": "<define-call>",
            "dst": "<'jquery'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<define-call>",
            "dst": "<'underscore'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<define-call>",
            "dst": "<factory-function>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<factory-function>",
            "dst": "<$>",
            "type": "CONTAINS"
          },
          {
            "src": "<factory-function>",
            "dst": "<_>",
            "type": "CONTAINS"
          },
          {
            "src": "<factory-function>",
            "dst": "<module-object>",
            "type": "RETURNS"
          },
          {
            "src": "<module-object>",
            "dst": "<render>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<render>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<render>",
            "dst": "<template-invocation>",
            "type": "RETURNS"
          },
          {
            "src": "<_.template-call>",
            "dst": "<$('#tpl').html()>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$('#tpl').html()>",
            "dst": "<'#tpl'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<template-invocation>",
            "dst": "<data>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<template-invocation>",
            "dst": "<_.template-call>",
            "type": "CALLS"
          },
          {
            "src": "<_.template-call>",
            "dst": "<_>",
            "type": "READS_FROM"
          },
          {
            "src": "<$('#tpl').html()>",
            "dst": "<$>",
            "type": "CALLS"
          },
          {
            "src": "<$>",
            "dst": "<'jquery'>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<_>",
            "dst": "<'underscore'>",
            "type": "IMPORTS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::global-namespace-revealing",
      "category": "legacy-patterns",
      "code": "var RevealingModule = (function () {\n  var secret = 'hidden';\n  function getSecret() { return secret; }\n  function setSecret(s) { secret = s; }\n  return { get: getSecret, set: setSecret };\n})();\n\n// --- Polyfill Patterns ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<RevealingModule>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<IIFE>",
          "metadata": {
            "immediatelyInvoked": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<secret>",
          "metadata": {
            "kind": "var",
            "scope": "function"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hidden'>",
          "metadata": {
            "value": "hidden",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getSecret>",
          "metadata": {
            "scope": "function"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<setSecret>",
          "metadata": {
            "scope": "function"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<s>"
        },
        {
          "type": "EXPRESSION",
          "id": "<{ get: getSecret, set: setSecret }>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<IIFE-call>",
          "metadata": {
            "immediateInvocation": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<IIFE>",
            "dst": "<secret>",
            "type": "CONTAINS"
          },
          {
            "src": "<IIFE>",
            "dst": "<getSecret>",
            "type": "CONTAINS"
          },
          {
            "src": "<IIFE>",
            "dst": "<setSecret>",
            "type": "CONTAINS"
          },
          {
            "src": "<setSecret>",
            "dst": "<s>",
            "type": "CONTAINS"
          },
          {
            "src": "<getSecret>",
            "dst": "<secret>",
            "type": "RETURNS"
          },
          {
            "src": "<IIFE>",
            "dst": "<{ get: getSecret, set: setSecret }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ get: getSecret, set: setSecret }>",
            "dst": "<getSecret>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ get: getSecret, set: setSecret }>",
            "dst": "<setSecret>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<RevealingModule>",
            "dst": "<IIFE-call>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<secret>",
            "dst": "<'hidden'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<setSecret>",
            "dst": "<secret>",
            "type": "WRITES_TO"
          },
          {
            "src": "<secret>",
            "dst": "<s>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<getSecret>",
            "dst": "<secret>",
            "type": "CAPTURES"
          },
          {
            "src": "<setSecret>",
            "dst": "<secret>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<IIFE-call>",
            "dst": "<IIFE>",
            "type": "CALLS"
          },
          {
            "src": "<getSecret>",
            "dst": "<secret>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::babel-class-call-check",
      "category": "legacy-patterns",
      "code": "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<_classCallCheck>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<instance>"
        },
        {
          "type": "PARAMETER",
          "id": "<Constructor>"
        },
        {
          "type": "BRANCH",
          "id": "<instanceof-check>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!(instance instanceof Constructor)>",
          "metadata": {
            "operator": "!",
            "innerOperator": "instanceof"
          }
        },
        {
          "type": "CALL",
          "id": "<new TypeError(...)>",
          "metadata": {
            "callee": "TypeError",
            "isConstructorCall": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Cannot call a class as a function'>",
          "metadata": {
            "value": "Cannot call a class as a function",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<_classCallCheck>",
            "dst": "<instance>",
            "type": "CONTAINS"
          },
          {
            "src": "<_classCallCheck>",
            "dst": "<Constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<_classCallCheck>",
            "dst": "<instanceof-check>",
            "type": "CONTAINS"
          },
          {
            "src": "<instanceof-check>",
            "dst": "<!(instance instanceof Constructor)>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<instanceof-check>",
            "dst": "<new TypeError(...)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<new TypeError(...)>",
            "dst": "<'Cannot call a class as a function'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<instanceof-check>",
            "dst": "<new TypeError(...)>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<!(instance instanceof Constructor)>",
            "dst": "<instance>",
            "type": "READS_FROM"
          },
          {
            "src": "<!(instance instanceof Constructor)>",
            "dst": "<Constructor>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::global-namespace-iife",
      "category": "legacy-patterns",
      "code": "var MyApp2 = (function (ns) {\n  var _private = 0;\n  ns.increment = function () { return ++_private; };\n  ns.getValue = function () { return _private; };\n  return ns;\n}(MyApp2 || {}));",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<MyApp2>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<iife>",
          "metadata": {
            "iife": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<ns>"
        },
        {
          "type": "VARIABLE",
          "id": "<_private>",
          "metadata": {
            "kind": "var",
            "private": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<ns.increment>",
          "metadata": {
            "objectName": "ns",
            "propertyName": "increment"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<increment:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<++_private>",
          "metadata": {
            "operator": "++",
            "prefix": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<ns.getValue>",
          "metadata": {
            "objectName": "ns",
            "propertyName": "getValue"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getValue:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<MyApp2 || {}>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<iife>",
            "dst": "<ns>",
            "type": "CONTAINS"
          },
          {
            "src": "<iife>",
            "dst": "<_private>",
            "type": "CONTAINS"
          },
          {
            "src": "<increment:fn>",
            "dst": "<++_private>",
            "type": "RETURNS"
          },
          {
            "src": "<getValue:fn>",
            "dst": "<_private>",
            "type": "RETURNS"
          },
          {
            "src": "<iife>",
            "dst": "<ns>",
            "type": "RETURNS"
          },
          {
            "src": "<iife>",
            "dst": "<MyApp2 || {}>",
            "type": "RECEIVES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<MyApp2>",
            "dst": "<iife>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<_private>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ns.increment>",
            "dst": "<increment:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<++_private>",
            "dst": "<_private>",
            "type": "MODIFIES"
          },
          {
            "src": "<ns.getValue>",
            "dst": "<getValue:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<iife>",
            "dst": "<ns.increment>",
            "type": "WRITES_TO"
          },
          {
            "src": "<iife>",
            "dst": "<ns.getValue>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<getValue:fn>",
            "dst": "<_private>",
            "type": "READS_FROM"
          },
          {
            "src": "<MyApp2 || {}>",
            "dst": "<MyApp2>",
            "type": "READS_FROM"
          },
          {
            "src": "<MyApp2 || {}>",
            "dst": "<{}>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::babel-class-compiled",
      "category": "legacy-patterns",
      "code": "// Source: class Dog extends Animal { constructor(name) { super(name); } }\n// Compiled:\nvar Dog = (function (_Animal) {\n  _inherits(Dog, _Animal);\n  function Dog(name) {\n    _classCallCheck(this, Dog);\n    return _Animal.call(this, name);\n  }\n  return Dog;\n}(Animal));\n\n// --- TypeScript Compiled Output ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<Dog>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Dog:iife>",
          "metadata": {
            "iife": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<_Animal>"
        },
        {
          "type": "CALL",
          "id": "<_inherits(Dog, _Animal)>",
          "metadata": {
            "callee": "_inherits"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Dog:constructor>",
          "metadata": {
            "constructorFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "CALL",
          "id": "<_classCallCheck(this, Dog)>",
          "metadata": {
            "callee": "_classCallCheck"
          }
        },
        {
          "type": "CALL",
          "id": "<_Animal.call(this, name)>",
          "metadata": {
            "callee": "_Animal.call"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<_inherits>",
          "metadata": {
            "helper": "babel"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<_classCallCheck>",
          "metadata": {
            "helper": "babel"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Animal>",
          "metadata": {
            "parentClass": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Dog:iife>",
            "dst": "<_Animal>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog:iife>",
            "dst": "<_inherits(Dog, _Animal)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog:iife>",
            "dst": "<Dog:constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog:iife>",
            "dst": "<Dog:constructor>",
            "type": "RETURNS"
          },
          {
            "src": "<Dog:constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog:constructor>",
            "dst": "<_classCallCheck(this, Dog)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Dog:constructor>",
            "dst": "<_Animal.call(this, name)>",
            "type": "RETURNS"
          },
          {
            "src": "<_inherits(Dog, _Animal)>",
            "dst": "<Dog>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<_inherits(Dog, _Animal)>",
            "dst": "<_Animal>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<_classCallCheck(this, Dog)>",
            "dst": "<Dog>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<_Animal.call(this, name)>",
            "dst": "<name>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<Dog>",
            "dst": "<Dog:iife>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<_inherits(Dog, _Animal)>",
            "dst": "<_inherits>",
            "type": "CALLS"
          },
          {
            "src": "<_classCallCheck(this, Dog)>",
            "dst": "<_classCallCheck>",
            "type": "CALLS"
          },
          {
            "src": "<_Animal.call(this, name)>",
            "dst": "<_Animal>",
            "type": "CALLS"
          },
          {
            "src": "<Dog:iife>",
            "dst": "<Animal>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::babel-inherits",
      "category": "legacy-patterns",
      "code": "function _inherits(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true }\n  });\n  if (superClass) Object.setPrototypeOf(subClass, superClass);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<_inherits>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<subClass>"
        },
        {
          "type": "PARAMETER",
          "id": "<superClass>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<subClass.prototype>",
          "metadata": {
            "objectName": "subClass",
            "propertyName": "prototype"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.create>",
          "metadata": {
            "callee": "Object.create"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<superClass.prototype>",
          "metadata": {
            "objectName": "superClass",
            "propertyName": "prototype"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<superClass && superClass.prototype>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "LITERAL",
          "id": "<constructor-descriptor>",
          "metadata": {
            "value": "{ value: subClass, writable: true, configurable: true }",
            "literalType": "object"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-superClass>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.setPrototypeOf>",
          "metadata": {
            "callee": "Object.setPrototypeOf"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<_inherits>",
            "dst": "<subClass>",
            "type": "HAS_BODY"
          },
          {
            "src": "<_inherits>",
            "dst": "<superClass>",
            "type": "HAS_BODY"
          },
          {
            "src": "<Object.create>",
            "dst": "<superClass && superClass.prototype>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.create>",
            "dst": "<constructor-descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<_inherits>",
            "dst": "<if-superClass>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-superClass>",
            "dst": "<superClass>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-superClass>",
            "dst": "<Object.setPrototypeOf>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Object.setPrototypeOf>",
            "dst": "<subClass>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.setPrototypeOf>",
            "dst": "<superClass>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<subClass.prototype>",
            "dst": "<Object.create>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<superClass && superClass.prototype>",
            "dst": "<superClass>",
            "type": "READS_FROM"
          },
          {
            "src": "<superClass && superClass.prototype>",
            "dst": "<superClass.prototype>",
            "type": "READS_FROM"
          },
          {
            "src": "<superClass.prototype>",
            "dst": "<superClass>",
            "type": "READS_FROM"
          },
          {
            "src": "<constructor-descriptor>",
            "dst": "<subClass>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::polyfill-promise",
      "category": "legacy-patterns",
      "code": "if (typeof Promise === 'undefined') {\n  // Simplified polyfill shape  real ones are 200+ lines\n  function Promise(executor) {\n    this._state = 'pending';\n    this._value = undefined;\n    this._callbacks = [];\n    executor(this._resolve.bind(this), this._reject.bind(this));\n  }\n  Promise.prototype.then = function (onFulfilled, onRejected) { /* ... */ };\n  Promise.prototype._resolve = function (value) { /* ... */ };\n  Promise.prototype._reject = function (reason) { /* ... */ };\n}",
      "expectedNodes": [
        {
          "type": "BRANCH",
          "id": "<if-Promise-undefined>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof Promise === 'undefined'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Promise>",
          "metadata": {
            "isConstructor": true,
            "polyfill": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<executor>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this._state>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'pending'>",
          "metadata": {
            "value": "pending",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this._value>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<undefined>",
          "metadata": {
            "value": "undefined",
            "literalType": "undefined"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this._callbacks>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "CALL",
          "id": "<executor(this._resolve.bind(this), this._reject.bind(this))>",
          "metadata": {
            "callee": "executor"
          }
        },
        {
          "type": "CALL",
          "id": "<this._resolve.bind(this)>",
          "metadata": {
            "callee": "bind"
          }
        },
        {
          "type": "CALL",
          "id": "<this._reject.bind(this)>",
          "metadata": {
            "callee": "bind"
          }
        },
        {
          "type": "METHOD",
          "id": "<Promise.prototype.then>",
          "metadata": {
            "kind": "method",
            "prototypeMethod": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<onFulfilled>"
        },
        {
          "type": "PARAMETER",
          "id": "<onRejected>"
        },
        {
          "type": "METHOD",
          "id": "<Promise.prototype._resolve>",
          "metadata": {
            "kind": "method",
            "prototypeMethod": true,
            "private": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "METHOD",
          "id": "<Promise.prototype._reject>",
          "metadata": {
            "kind": "method",
            "prototypeMethod": true,
            "private": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<reason>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<if-Promise-undefined>",
            "dst": "<typeof Promise === 'undefined'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-Promise-undefined>",
            "dst": "<Promise>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Promise>",
            "dst": "<executor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Promise>",
            "dst": "<executor(this._resolve.bind(this), this._reject.bind(this))>",
            "type": "CONTAINS"
          },
          {
            "src": "<executor(this._resolve.bind(this), this._reject.bind(this))>",
            "dst": "<this._resolve.bind(this)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<executor(this._resolve.bind(this), this._reject.bind(this))>",
            "dst": "<this._reject.bind(this)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Promise.prototype.then>",
            "dst": "<onFulfilled>",
            "type": "CONTAINS"
          },
          {
            "src": "<Promise.prototype.then>",
            "dst": "<onRejected>",
            "type": "CONTAINS"
          },
          {
            "src": "<Promise.prototype._resolve>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<Promise.prototype._reject>",
            "dst": "<reason>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Promise>",
            "dst": "<this._state>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this._state>",
            "dst": "<'pending'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Promise>",
            "dst": "<this._value>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this._value>",
            "dst": "<undefined>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Promise>",
            "dst": "<this._callbacks>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this._callbacks>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<typeof Promise === 'undefined'>",
            "dst": "<Promise>",
            "type": "READS_FROM"
          },
          {
            "src": "<executor(this._resolve.bind(this), this._reject.bind(this))>",
            "dst": "<executor>",
            "type": "CALLS"
          },
          {
            "src": "<this._resolve.bind(this)>",
            "dst": "<Promise.prototype._resolve>",
            "type": "READS_FROM"
          },
          {
            "src": "<this._reject.bind(this)>",
            "dst": "<Promise.prototype._reject>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::jquery-extend-pattern",
      "category": "legacy-patterns",
      "code": "// $.extend(true, target, source1, source2); // deep merge\n// $.extend($.fn, { newPlugin: function() {} }); // add to prototype",
      "expectedNodes": [
        {
          "type": "CALL",
          "id": "<$.extend(true, target, source1, source2)>",
          "metadata": {
            "callee": "$.extend",
            "argumentCount": 4
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<$.extend>",
          "metadata": {
            "objectName": "$",
            "propertyName": "extend"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<target>"
        },
        {
          "type": "VARIABLE",
          "id": "<source1>"
        },
        {
          "type": "VARIABLE",
          "id": "<source2>"
        },
        {
          "type": "CALL",
          "id": "<$.extend($.fn, { newPlugin: function() {} })>",
          "metadata": {
            "callee": "$.extend",
            "argumentCount": 2
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<$.fn>",
          "metadata": {
            "objectName": "$",
            "propertyName": "fn"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ newPlugin: function() {} }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<newPlugin:fn>",
          "metadata": {
            "anonymous": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<$.extend(true, target, source1, source2)>",
            "dst": "<true>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$.extend(true, target, source1, source2)>",
            "dst": "<target>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$.extend(true, target, source1, source2)>",
            "dst": "<source1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$.extend(true, target, source1, source2)>",
            "dst": "<source2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$.extend($.fn, { newPlugin: function() {} })>",
            "dst": "<$.fn>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$.extend($.fn, { newPlugin: function() {} })>",
            "dst": "<{ newPlugin: function() {} }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<{ newPlugin: function() {} }>",
            "dst": "<newPlugin:fn>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<$.extend(true, target, source1, source2)>",
            "dst": "<target>",
            "type": "MODIFIES"
          },
          {
            "src": "<$.extend($.fn, { newPlugin: function() {} })>",
            "dst": "<$.fn>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<$.extend(true, target, source1, source2)>",
            "dst": "<$.extend>",
            "type": "CALLS"
          },
          {
            "src": "<$.extend($.fn, { newPlugin: function() {} })>",
            "dst": "<$.extend>",
            "type": "CALLS"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::polyfill-symbol-shim",
      "category": "legacy-patterns",
      "code": "if (typeof Symbol === 'undefined') {\n  var Symbol = function (description) {\n    return '__symbol_' + (description || '') + '_' + Math.random().toString(36);\n  };\n  Symbol.iterator = '@@iterator';\n}\n\n// --- Babel Compiled Output ---",
      "expectedNodes": [
        {
          "type": "BRANCH",
          "id": "<if-symbol-undefined>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof Symbol === 'undefined'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof Symbol>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'undefined'>",
          "metadata": {
            "value": "undefined",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Symbol>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Symbol:polyfill>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<description>"
        },
        {
          "type": "EXPRESSION",
          "id": "<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'__symbol_'>",
          "metadata": {
            "value": "__symbol_",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<description || ''>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'_'>",
          "metadata": {
            "value": "_",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.random().toString(36)>",
          "metadata": {
            "callee": "toString"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.random()>",
          "metadata": {
            "callee": "random"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Math.random>",
          "metadata": {
            "objectName": "Math"
          }
        },
        {
          "type": "LITERAL",
          "id": "<36>",
          "metadata": {
            "value": 36,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Symbol.iterator>",
          "metadata": {
            "objectName": "Symbol"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'@@iterator'>",
          "metadata": {
            "value": "@@iterator",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<if-symbol-undefined>",
            "dst": "<typeof Symbol === 'undefined'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-symbol-undefined>",
            "dst": "<Symbol>",
            "type": "DECLARES"
          },
          {
            "src": "<Symbol:polyfill>",
            "dst": "<description>",
            "type": "CONTAINS"
          },
          {
            "src": "<Symbol:polyfill>",
            "dst": "<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>",
            "type": "RETURNS"
          },
          {
            "src": "<Math.random().toString(36)>",
            "dst": "<36>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<Symbol>",
            "dst": "<Symbol:polyfill>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<if-symbol-undefined>",
            "dst": "<Symbol.iterator>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Symbol.iterator>",
            "dst": "<'@@iterator'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<typeof Symbol === 'undefined'>",
            "dst": "<typeof Symbol>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof Symbol === 'undefined'>",
            "dst": "<'undefined'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof Symbol>",
            "dst": "<Symbol>",
            "type": "READS_FROM"
          },
          {
            "src": "<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>",
            "dst": "<'__symbol_'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>",
            "dst": "<description || ''>",
            "type": "READS_FROM"
          },
          {
            "src": "<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>",
            "dst": "<'_'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>",
            "dst": "<Math.random().toString(36)>",
            "type": "READS_FROM"
          },
          {
            "src": "<description || ''>",
            "dst": "<description>",
            "type": "READS_FROM"
          },
          {
            "src": "<description || ''>",
            "dst": "<''>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.random().toString(36)>",
            "dst": "<Math.random()>",
            "type": "CALLS"
          },
          {
            "src": "<Math.random()>",
            "dst": "<Math.random>",
            "type": "CALLS"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::polyfill-prototype-method",
      "category": "legacy-patterns",
      "code": "if (!Array.prototype.flat) {\n  Array.prototype.flat = function (depth) {\n    depth = depth === undefined ? 1 : Math.floor(depth);\n    if (depth < 1) return Array.prototype.slice.call(this);\n    return Array.prototype.reduce.call(this, function (acc, val) {\n      return acc.concat(Array.isArray(val) && depth > 1 ? val.flat(depth - 1) : val);\n    }, []);\n  };\n}",
      "expectedNodes": [
        {
          "type": "BRANCH",
          "id": "<if-polyfill>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!Array.prototype.flat>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Array.prototype.flat>",
          "metadata": {
            "objectName": "Array.prototype",
            "propertyName": "flat"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<polyfill-flat>",
          "metadata": {
            "arrowFunction": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<depth>"
        },
        {
          "type": "EXPRESSION",
          "id": "<depth-ternary>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.floor>",
          "metadata": {
            "callee": "Math.floor"
          }
        },
        {
          "type": "BRANCH",
          "id": "<early-return>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "CALL",
          "id": "<slice-call>",
          "metadata": {
            "callee": "Array.prototype.slice.call"
          }
        },
        {
          "type": "CALL",
          "id": "<reduce-call>",
          "metadata": {
            "callee": "Array.prototype.reduce.call"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<reduce-callback>",
          "metadata": {
            "arrowFunction": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<acc>"
        },
        {
          "type": "PARAMETER",
          "id": "<val>"
        },
        {
          "type": "CALL",
          "id": "<concat-call>",
          "metadata": {
            "callee": "acc.concat"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<ternary-arg>",
          "metadata": {
            "operator": "?:"
          }
        },
        {
          "type": "CALL",
          "id": "<isArray-call>",
          "metadata": {
            "callee": "Array.isArray"
          }
        },
        {
          "type": "CALL",
          "id": "<recursive-flat>",
          "metadata": {
            "callee": "val.flat"
          }
        },
        {
          "type": "LITERAL",
          "id": "<empty-array>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<if-polyfill>",
            "dst": "<!Array.prototype.flat>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<polyfill-flat>",
            "dst": "<depth>",
            "type": "HAS_BODY"
          },
          {
            "src": "<depth-ternary>",
            "dst": "<1>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Math.floor>",
            "dst": "<depth>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<polyfill-flat>",
            "dst": "<early-return>",
            "type": "HAS_BODY"
          },
          {
            "src": "<early-return>",
            "dst": "<slice-call>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<polyfill-flat>",
            "dst": "<reduce-call>",
            "type": "RETURNS"
          },
          {
            "src": "<reduce-call>",
            "dst": "<reduce-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reduce-call>",
            "dst": "<empty-array>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reduce-callback>",
            "dst": "<acc>",
            "type": "HAS_BODY"
          },
          {
            "src": "<reduce-callback>",
            "dst": "<val>",
            "type": "HAS_BODY"
          },
          {
            "src": "<reduce-callback>",
            "dst": "<concat-call>",
            "type": "RETURNS"
          },
          {
            "src": "<concat-call>",
            "dst": "<ternary-arg>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ternary-arg>",
            "dst": "<isArray-call>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<ternary-arg>",
            "dst": "<recursive-flat>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<isArray-call>",
            "dst": "<val>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<Array.prototype.flat>",
            "dst": "<polyfill-flat>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<depth>",
            "dst": "<depth-ternary>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<depth-ternary>",
            "dst": "<Math.floor>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<ternary-arg>",
            "dst": "<val>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<!Array.prototype.flat>",
            "dst": "<Array.prototype.flat>",
            "type": "READS_FROM"
          },
          {
            "src": "<recursive-flat>",
            "dst": "<val>",
            "type": "CALLS_ON"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "modern-es::modern-array-at",
      "category": "modern-es",
      "code": "function arrayAt(arr) {\n  const first = arr.at(0);\n  const last = arr.at(-1);\n  const second = arr.at(1);\n  return { first, last, second };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<arrayAt>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<arr>"
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<arr.at(0)>",
          "metadata": {
            "callee": "at",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<last>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<arr.at(-1)>",
          "metadata": {
            "callee": "at",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<-1>",
          "metadata": {
            "value": -1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<second>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<arr.at(1)>",
          "metadata": {
            "callee": "at",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ first, last, second }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<arrayAt>",
            "dst": "<arr>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrayAt>",
            "dst": "<first>",
            "type": "CONTAINS"
          },
          {
            "src": "<arr.at(0)>",
            "dst": "<0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrayAt>",
            "dst": "<last>",
            "type": "CONTAINS"
          },
          {
            "src": "<arr.at(-1)>",
            "dst": "<-1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrayAt>",
            "dst": "<second>",
            "type": "CONTAINS"
          },
          {
            "src": "<arr.at(1)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrayAt>",
            "dst": "<{ first, last, second }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<first>",
            "dst": "<arr.at(0)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<last>",
            "dst": "<arr.at(-1)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<second>",
            "dst": "<arr.at(1)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arr.at(0)>",
            "dst": "<arr>",
            "type": "READS_FROM"
          },
          {
            "src": "<arr.at(-1)>",
            "dst": "<arr>",
            "type": "READS_FROM"
          },
          {
            "src": "<arr.at(1)>",
            "dst": "<arr>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, last, second }>",
            "dst": "<first>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, last, second }>",
            "dst": "<last>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, last, second }>",
            "dst": "<second>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "legacy-patterns::ts-compiled-spread",
      "category": "legacy-patterns",
      "code": "var __spreadArray = function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<__spreadArray>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<__spreadArray:fn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<to>"
        },
        {
          "type": "PARAMETER",
          "id": "<from>"
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<il>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<from.length>",
          "metadata": {
            "property": "length"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<j>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<to.length>",
          "metadata": {
            "property": "length"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < il>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<j++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<to[j] = from[i]>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<to[j]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<from[i]>",
          "metadata": {
            "computed": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<__spreadArray:fn>",
            "dst": "<to>",
            "type": "CONTAINS"
          },
          {
            "src": "<__spreadArray:fn>",
            "dst": "<from>",
            "type": "CONTAINS"
          },
          {
            "src": "<__spreadArray:fn>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<il>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<j>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < il>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<j++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<to[j] = from[i]>",
            "type": "HAS_BODY"
          },
          {
            "src": "<__spreadArray:fn>",
            "dst": "<to>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<__spreadArray>",
            "dst": "<__spreadArray:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<il>",
            "dst": "<from.length>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<j>",
            "dst": "<to.length>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<j++>",
            "dst": "<j>",
            "type": "MODIFIES"
          },
          {
            "src": "<to[j] = from[i]>",
            "dst": "<to[j]>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<from.length>",
            "dst": "<from>",
            "type": "READS_FROM"
          },
          {
            "src": "<to.length>",
            "dst": "<to>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < il>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < il>",
            "dst": "<il>",
            "type": "READS_FROM"
          },
          {
            "src": "<to[j] = from[i]>",
            "dst": "<from[i]>",
            "type": "READS_FROM"
          },
          {
            "src": "<to[j]>",
            "dst": "<to>",
            "type": "READS_FROM"
          },
          {
            "src": "<to[j]>",
            "dst": "<j>",
            "type": "READS_FROM"
          },
          {
            "src": "<from[i]>",
            "dst": "<from>",
            "type": "READS_FROM"
          },
          {
            "src": "<from[i]>",
            "dst": "<i>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "legacy-patterns::jquery-plugin-pattern",
      "category": "legacy-patterns",
      "code": "// $.fn.highlight = function(color) {\n//   return this.each(function() {\n//     $(this).css('background-color', color || 'yellow');\n//   });\n// };\n// Usage: $('p').highlight('red');",
      "expectedNodes": [
        {
          "type": "PROPERTY_ACCESS",
          "id": "<$.fn.highlight>",
          "metadata": {
            "objectName": "$",
            "propertyChain": [
              "fn",
              "highlight"
            ]
          }
        },
        {
          "type": "FUNCTION",
          "id": "<highlight:fn>",
          "metadata": {
            "arrowFunction": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<color>"
        },
        {
          "type": "CALL",
          "id": "<this.each(...)>",
          "metadata": {
            "callee": "each",
            "method": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<each-callback:fn>",
          "metadata": {
            "arrowFunction": false,
            "anonymous": true
          }
        },
        {
          "type": "CALL",
          "id": "<$(this)>",
          "metadata": {
            "callee": "$"
          }
        },
        {
          "type": "CALL",
          "id": "<$(this).css(...)>",
          "metadata": {
            "callee": "css",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'background-color'>",
          "metadata": {
            "value": "background-color",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<color || 'yellow'>",
          "metadata": {
            "operator": "||"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'yellow'>",
          "metadata": {
            "value": "yellow",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<$('p').highlight('red')>",
          "metadata": {
            "callee": "highlight",
            "method": true
          }
        },
        {
          "type": "CALL",
          "id": "<$('p')>",
          "metadata": {
            "callee": "$"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'p'>",
          "metadata": {
            "value": "p",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'red'>",
          "metadata": {
            "value": "red",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<highlight:fn>",
            "dst": "<color>",
            "type": "CONTAINS"
          },
          {
            "src": "<highlight:fn>",
            "dst": "<this.each(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<this.each(...)>",
            "dst": "<each-callback:fn>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<each-callback:fn>",
            "dst": "<$(this)>",
            "type": "CONTAINS"
          },
          {
            "src": "<$(this).css(...)>",
            "dst": "<'background-color'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$(this).css(...)>",
            "dst": "<color || 'yellow'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$('p')>",
            "dst": "<'p'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<$('p').highlight('red')>",
            "dst": "<'red'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<$.fn.highlight>",
            "dst": "<highlight:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<$(this).css(...)>",
            "dst": "<$(this)>",
            "type": "CALLS_ON"
          },
          {
            "src": "<color || 'yellow'>",
            "dst": "<color>",
            "type": "READS_FROM"
          },
          {
            "src": "<color || 'yellow'>",
            "dst": "<'yellow'>",
            "type": "READS_FROM"
          },
          {
            "src": "<$('p').highlight('red')>",
            "dst": "<$('p')>",
            "type": "CALLS_ON"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "modern-es::modern-map-groupby",
      "category": "modern-es",
      "code": "function mapGroupBy(items) {\n  return Map.groupBy(items, item => item.category);\n}\n\n// --- Promise.withResolvers (ES2024) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<mapGroupBy>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "CALL",
          "id": "<Map.groupBy(items, item => item.category)>",
          "metadata": {
            "callee": "Map.groupBy"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Map.groupBy>",
          "metadata": {
            "objectName": "Map",
            "propertyName": "groupBy"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<item => item.category>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<item.category>",
          "metadata": {
            "objectName": "item",
            "propertyName": "category"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<mapGroupBy>",
            "dst": "<items>",
            "type": "HAS_BODY"
          },
          {
            "src": "<mapGroupBy>",
            "dst": "<Map.groupBy(items, item => item.category)>",
            "type": "RETURNS"
          },
          {
            "src": "<Map.groupBy(items, item => item.category)>",
            "dst": "<items>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Map.groupBy(items, item => item.category)>",
            "dst": "<item => item.category>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<item => item.category>",
            "dst": "<item>",
            "type": "HAS_BODY"
          },
          {
            "src": "<item => item.category>",
            "dst": "<item.category>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Map.groupBy(items, item => item.category)>",
            "dst": "<Map.groupBy>",
            "type": "CALLS"
          },
          {
            "src": "<item.category>",
            "dst": "<item>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-object-hasown",
      "category": "modern-es",
      "code": "function hasOwnCheck(obj, key) {\n  return Object.hasOwn(obj, key);\n}\n\n// --- structuredClone (ES2022) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<hasOwnCheck>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "CALL",
          "id": "<Object.hasOwn(obj, key)>",
          "metadata": {
            "callee": "Object.hasOwn"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.hasOwn>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "hasOwn"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<hasOwnCheck>",
            "dst": "<obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<hasOwnCheck>",
            "dst": "<key>",
            "type": "HAS_BODY"
          },
          {
            "src": "<hasOwnCheck>",
            "dst": "<Object.hasOwn(obj, key)>",
            "type": "RETURNS"
          },
          {
            "src": "<Object.hasOwn(obj, key)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.hasOwn(obj, key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.hasOwn(obj, key)>",
            "dst": "<Object.hasOwn>",
            "type": "CALLS"
          },
          {
            "src": "<Object.hasOwn>",
            "dst": "<Object>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "legacy-patterns::jquery-deferred",
      "category": "legacy-patterns",
      "code": "// var dfd = $.Deferred();\n// dfd.done(function(data) { ... });\n// dfd.fail(function(err) { ... });\n// dfd.resolve(result); // or dfd.reject(error);\n\n// --- Script Concatenation / Namespace Export ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<dfd>",
          "metadata": {
            "kind": "var"
          }
        },
        {
          "type": "CALL",
          "id": "<$.Deferred()>",
          "metadata": {
            "callee": "$.Deferred"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<$.Deferred>",
          "metadata": {
            "objectName": "$",
            "propertyName": "Deferred"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<$>",
          "metadata": {
            "kind": "external"
          }
        },
        {
          "type": "CALL",
          "id": "<dfd.done(callback)>",
          "metadata": {
            "callee": "dfd.done"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<dfd.done>",
          "metadata": {
            "objectName": "dfd",
            "propertyName": "done"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<done-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>"
        },
        {
          "type": "CALL",
          "id": "<dfd.fail(callback)>",
          "metadata": {
            "callee": "dfd.fail"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<dfd.fail>",
          "metadata": {
            "objectName": "dfd",
            "propertyName": "fail"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<fail-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "CALL",
          "id": "<dfd.resolve(result)>",
          "metadata": {
            "callee": "dfd.resolve"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<dfd.resolve>",
          "metadata": {
            "objectName": "dfd",
            "propertyName": "resolve"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "reference"
          }
        },
        {
          "type": "CALL",
          "id": "<dfd.reject(error)>",
          "metadata": {
            "callee": "dfd.reject"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<dfd.reject>",
          "metadata": {
            "objectName": "dfd",
            "propertyName": "reject"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<error>",
          "metadata": {
            "kind": "reference"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<dfd.done(callback)>",
            "dst": "<done-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<done-callback>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<dfd.fail(callback)>",
            "dst": "<fail-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fail-callback>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<dfd.resolve(result)>",
            "dst": "<result>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<dfd.reject(error)>",
            "dst": "<error>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<dfd>",
            "dst": "<$.Deferred()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<$.Deferred()>",
            "dst": "<$.Deferred>",
            "type": "CALLS"
          },
          {
            "src": "<$.Deferred>",
            "dst": "<$>",
            "type": "READS_FROM"
          },
          {
            "src": "<dfd.done(callback)>",
            "dst": "<dfd.done>",
            "type": "CALLS"
          },
          {
            "src": "<dfd.done>",
            "dst": "<dfd>",
            "type": "READS_FROM"
          },
          {
            "src": "<dfd.fail(callback)>",
            "dst": "<dfd.fail>",
            "type": "CALLS"
          },
          {
            "src": "<dfd.fail>",
            "dst": "<dfd>",
            "type": "READS_FROM"
          },
          {
            "src": "<dfd.resolve(result)>",
            "dst": "<dfd.resolve>",
            "type": "CALLS"
          },
          {
            "src": "<dfd.resolve>",
            "dst": "<dfd>",
            "type": "READS_FROM"
          },
          {
            "src": "<dfd.reject(error)>",
            "dst": "<dfd.reject>",
            "type": "CALLS"
          },
          {
            "src": "<dfd.reject>",
            "dst": "<dfd>",
            "type": "READS_FROM"
          }
        ]
      },
      "moduleType": "cjs"
    },
    {
      "constructId": "modern-es::modern-object-groupby",
      "category": "modern-es",
      "code": "function objectGroupBy(items) {\n  return Object.groupBy(items, item => item.category);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<objectGroupBy>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "CALL",
          "id": "<Object.groupBy(items, item => item.category)>",
          "metadata": {
            "callee": "Object.groupBy"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.groupBy>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "groupBy"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<item => item.category>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<item.category>",
          "metadata": {
            "objectName": "item",
            "propertyName": "category"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<objectGroupBy>",
            "dst": "<items>",
            "type": "HAS_BODY"
          },
          {
            "src": "<objectGroupBy>",
            "dst": "<Object.groupBy(items, item => item.category)>",
            "type": "RETURNS"
          },
          {
            "src": "<Object.groupBy(items, item => item.category)>",
            "dst": "<items>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.groupBy(items, item => item.category)>",
            "dst": "<item => item.category>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<item => item.category>",
            "dst": "<item>",
            "type": "HAS_BODY"
          },
          {
            "src": "<item => item.category>",
            "dst": "<item.category>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.groupBy(items, item => item.category)>",
            "dst": "<Object.groupBy>",
            "type": "CALLS"
          },
          {
            "src": "<item.category>",
            "dst": "<item>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-array-findlast",
      "category": "modern-es",
      "code": "function arrayFindLast(arr) {\n  const last = arr.findLast(x => x > 3);\n  const lastIdx = arr.findLastIndex(x => x > 3);\n  return { last, lastIdx };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<arrayFindLast>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<arr>"
        },
        {
          "type": "VARIABLE",
          "id": "<last>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<arr.findLast(x => x > 3)>",
          "metadata": {
            "method": "findLast"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<findLast-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 3>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<lastIdx>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<arr.findLastIndex(x => x > 3)>",
          "metadata": {
            "method": "findLastIndex"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<findLastIndex-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x2>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x2 > 3>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3-2>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ last, lastIdx }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<arrayFindLast>",
            "dst": "<arr>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrayFindLast>",
            "dst": "<last>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrayFindLast>",
            "dst": "<lastIdx>",
            "type": "CONTAINS"
          },
          {
            "src": "<arr.findLast(x => x > 3)>",
            "dst": "<findLast-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<findLast-callback>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<findLast-callback>",
            "dst": "<x > 3>",
            "type": "RETURNS"
          },
          {
            "src": "<arr.findLastIndex(x => x > 3)>",
            "dst": "<findLastIndex-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<findLastIndex-callback>",
            "dst": "<x2>",
            "type": "CONTAINS"
          },
          {
            "src": "<findLastIndex-callback>",
            "dst": "<x2 > 3>",
            "type": "RETURNS"
          },
          {
            "src": "<arrayFindLast>",
            "dst": "<{ last, lastIdx }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<last>",
            "dst": "<arr.findLast(x => x > 3)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<lastIdx>",
            "dst": "<arr.findLastIndex(x => x > 3)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arr.findLast(x => x > 3)>",
            "dst": "<arr>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x > 3>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 3>",
            "dst": "<3>",
            "type": "READS_FROM"
          },
          {
            "src": "<arr.findLastIndex(x => x > 3)>",
            "dst": "<arr>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x2 > 3>",
            "dst": "<x2>",
            "type": "READS_FROM"
          },
          {
            "src": "<x2 > 3>",
            "dst": "<3-2>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ last, lastIdx }>",
            "dst": "<last>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ last, lastIdx }>",
            "dst": "<lastIdx>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-structured-clone",
      "category": "modern-es",
      "code": "function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Hashbang (ES2023) ---\n// Note: hashbang must be at very top of file, so this is just a reference\n// #!/usr/bin/env node  would be first line in a CLI script\n\n// --- RegExp: d flag / match indices (ES2022) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deepClone>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<structuredClone(obj)>",
          "metadata": {
            "callee": "structuredClone"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<structuredClone>",
          "metadata": {
            "source": "global",
            "type": "built-in"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deepClone>",
            "dst": "<obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<deepClone>",
            "dst": "<structuredClone(obj)>",
            "type": "RETURNS"
          },
          {
            "src": "<structuredClone(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<structuredClone(obj)>",
            "dst": "<structuredClone>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-symbol-tostringtag",
      "category": "modern-es",
      "code": "class CustomCollection {\n  get [Symbol.toStringTag]() {\n    return 'CustomCollection';\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<CustomCollection>"
        },
        {
          "type": "GETTER",
          "id": "<CustomCollection.[Symbol.toStringTag]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Symbol.toStringTag>",
          "metadata": {
            "objectName": "Symbol"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'CustomCollection'>",
          "metadata": {
            "value": "CustomCollection",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<CustomCollection>",
            "type": "DECLARES"
          },
          {
            "src": "<CustomCollection>",
            "dst": "<CustomCollection.[Symbol.toStringTag]>",
            "type": "CONTAINS"
          },
          {
            "src": "<CustomCollection.[Symbol.toStringTag]>",
            "dst": "<Symbol.toStringTag>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<CustomCollection.[Symbol.toStringTag]>",
            "dst": "<'CustomCollection'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::modern-promise-with-resolvers",
      "category": "modern-es",
      "code": "function createDeferred() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  return { promise, resolve, reject };\n}\n\n// --- Error.cause usage ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createDeferred>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.withResolvers()>",
          "metadata": {
            "callee": "Promise.withResolvers"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<promise>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resolve>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<reject>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Promise.withResolvers>",
          "metadata": {
            "objectName": "Promise",
            "propertyName": "withResolvers"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createDeferred>",
            "dst": "<Promise.withResolvers()>",
            "type": "CONTAINS"
          },
          {
            "src": "<createDeferred>",
            "dst": "<promise>",
            "type": "CONTAINS"
          },
          {
            "src": "<createDeferred>",
            "dst": "<resolve>",
            "type": "CONTAINS"
          },
          {
            "src": "<createDeferred>",
            "dst": "<reject>",
            "type": "CONTAINS"
          },
          {
            "src": "<createDeferred>",
            "dst": "<return-object>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<promise>",
            "dst": "<Promise.withResolvers()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<resolve>",
            "dst": "<Promise.withResolvers()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<reject>",
            "dst": "<Promise.withResolvers()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Promise.withResolvers()>",
            "dst": "<Promise.withResolvers>",
            "type": "CALLS"
          },
          {
            "src": "<return-object>",
            "dst": "<promise>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<resolve>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<reject>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-symbol-iterator",
      "category": "modern-es",
      "code": "class InfiniteOnes {\n  [Symbol.iterator]() {\n    return {\n      next() { return { value: 1, done: false }; },\n    };\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<InfiniteOnes>"
        },
        {
          "type": "METHOD",
          "id": "<InfiniteOnes[Symbol.iterator]>",
          "metadata": {
            "kind": "method",
            "computed": true,
            "symbol": "Symbol.iterator"
          }
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<next>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<return-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<InfiniteOnes>",
            "dst": "<InfiniteOnes[Symbol.iterator]>",
            "type": "CONTAINS"
          },
          {
            "src": "<InfiniteOnes[Symbol.iterator]>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<next>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<next>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<false>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::modern-error-cause",
      "category": "modern-es",
      "code": "function wrapError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    throw new Error('Wrapper failed', { cause: err });\n  }\n}\n\n// --- Object.hasOwn (ES2022) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<wrapError>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fn>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<fn()>",
          "metadata": {
            "callee": "fn"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<err>",
          "metadata": {
            "catchParameter": true
          }
        },
        {
          "type": "CALL",
          "id": "<new Error()>",
          "metadata": {
            "constructor": "Error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Wrapper failed'>",
          "metadata": {
            "value": "Wrapper failed",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ cause: err }>",
          "metadata": {
            "objectLiteral": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<wrapError>",
            "dst": "<fn>",
            "type": "HAS_BODY"
          },
          {
            "src": "<wrapError>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<try-block>",
            "dst": "<fn()>",
            "type": "CONTAINS"
          },
          {
            "src": "<wrapError>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Error()>",
            "dst": "<'Wrapper failed'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error()>",
            "dst": "<{ cause: err }>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<catch-block>",
            "dst": "<new Error()>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<fn()>",
            "dst": "<fn>",
            "type": "CALLS"
          },
          {
            "src": "<{ cause: err }>",
            "dst": "<err>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-symbol-species",
      "category": "modern-es",
      "code": "class SpecialArray extends Array {\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n\n// --- AbortController ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<SpecialArray>"
        },
        {
          "type": "GETTER",
          "id": "<SpecialArray[Symbol.species]>",
          "metadata": {
            "static": true,
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Symbol.species>",
          "metadata": {
            "symbol": "species"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Array>",
          "metadata": {
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<SpecialArray>",
            "type": "DECLARES"
          },
          {
            "src": "<SpecialArray>",
            "dst": "<SpecialArray[Symbol.species]>",
            "type": "CONTAINS"
          },
          {
            "src": "<SpecialArray[Symbol.species]>",
            "dst": "<Symbol.species>",
            "type": "USES"
          },
          {
            "src": "<SpecialArray[Symbol.species]>",
            "dst": "<Array>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<SpecialArray>",
            "dst": "<Array>",
            "type": "EXTENDS"
          },
          {
            "src": "<SpecialArray[Symbol.species]>",
            "dst": "<Array>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-using-sync",
      "category": "modern-es",
      "code": "function usingSyncExample() {\n  // Symbol.dispose  synchronous cleanup\n  const resource = {\n    data: 'important',\n    [Symbol.dispose]() {\n      this.data = null;\n    },\n  };\n  return resource;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<usingSyncExample>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resource>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<resource-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<data-property>",
          "metadata": {
            "name": "data"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'important'>",
          "metadata": {
            "value": "important",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<resource[Symbol.dispose]>",
          "metadata": {
            "kind": "method",
            "symbol": "Symbol.dispose"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.data>",
          "metadata": {
            "objectName": "this",
            "propertyName": "data"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<usingSyncExample>",
            "dst": "<resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<resource-object>",
            "dst": "<data-property>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<resource-object>",
            "dst": "<resource[Symbol.dispose]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<usingSyncExample>",
            "dst": "<resource>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<resource>",
            "dst": "<resource-object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<data-property>",
            "dst": "<'important'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<resource[Symbol.dispose]>",
            "dst": "<this.data>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.data>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::reexport-namespace",
      "category": "modern-es",
      "code": "// export * as utils from './modules-helpers.js';\n// (commented  would conflict with existing exports; syntax reference only)",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-namespace>",
          "metadata": {
            "exportType": "namespace",
            "alias": "utils"
          }
        },
        {
          "type": "IMPORT",
          "id": "<import-all>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importType": "namespace"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-namespace>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<export-namespace>",
            "dst": "<import-all>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<import-all>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<export-namespace>",
            "dst": "<utils>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-using-async",
      "category": "modern-es",
      "code": "async function usingAsyncExample() {\n  const resource = {\n    data: 'important',\n    async [Symbol.asyncDispose]() {\n      await new Promise(r => setTimeout(r, 10));\n      this.data = null;\n    },\n  };\n  return resource;\n}\n\n// --- Iterator helpers (ES2025) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<usingAsyncExample>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resource>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'important'>",
          "metadata": {
            "value": "important",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<resource[Symbol.asyncDispose]>",
          "metadata": {
            "async": true,
            "kind": "method",
            "computed": true,
            "symbol": "Symbol.asyncDispose"
          }
        },
        {
          "type": "CALL",
          "id": "<new Promise(r => setTimeout(r, 10))>",
          "metadata": {
            "callee": "Promise",
            "constructor": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<r => setTimeout(r, 10)>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<r>"
        },
        {
          "type": "CALL",
          "id": "<setTimeout(r, 10)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.data>",
          "metadata": {
            "objectName": "this",
            "property": "data"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<usingAsyncExample>",
            "dst": "<resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<resource>",
            "dst": "<'important'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<resource>",
            "dst": "<resource[Symbol.asyncDispose]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<resource[Symbol.asyncDispose]>",
            "dst": "<new Promise(r => setTimeout(r, 10))>",
            "type": "AWAITS"
          },
          {
            "src": "<new Promise(r => setTimeout(r, 10))>",
            "dst": "<r => setTimeout(r, 10)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<r => setTimeout(r, 10)>",
            "dst": "<r>",
            "type": "CONTAINS"
          },
          {
            "src": "<r => setTimeout(r, 10)>",
            "dst": "<setTimeout(r, 10)>",
            "type": "RETURNS"
          },
          {
            "src": "<setTimeout(r, 10)>",
            "dst": "<r>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(r, 10)>",
            "dst": "<10>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<usingAsyncExample>",
            "dst": "<resource>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<resource[Symbol.asyncDispose]>",
            "dst": "<this.data>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.data>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::using-in-for",
      "category": "modern-es",
      "code": "function usingInFor(readers) {\n  for (using reader of readers) {\n    reader.process();\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<usingInFor>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<readers>"
        },
        {
          "type": "LOOP",
          "id": "<for-of-using>",
          "metadata": {
            "loopType": "for-of",
            "usingDeclaration": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<reader>",
          "metadata": {
            "kind": "using"
          }
        },
        {
          "type": "CALL",
          "id": "<reader.process()>",
          "metadata": {
            "callee": "process"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<reader.process>",
          "metadata": {
            "objectName": "reader",
            "propertyName": "process"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<usingInFor>",
            "dst": "<readers>",
            "type": "CONTAINS"
          },
          {
            "src": "<usingInFor>",
            "dst": "<for-of-using>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of-using>",
            "dst": "<readers>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of-using>",
            "dst": "<reader>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of-using>",
            "dst": "<reader.process()>",
            "type": "HAS_BODY"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<reader.process()>",
            "dst": "<reader.process>",
            "type": "CALLS"
          },
          {
            "src": "<reader.process>",
            "dst": "<reader>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-symbol-toprimitive",
      "category": "modern-es",
      "code": "class Money {\n  constructor(amount, currency) {\n    this.amount = amount;\n    this.currency = currency;\n  }\n\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return this.amount;\n    if (hint === 'string') return `${this.amount} ${this.currency}`;\n    return this.amount;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Money>"
        },
        {
          "type": "METHOD",
          "id": "<Money.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<amount>"
        },
        {
          "type": "PARAMETER",
          "id": "<currency>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.amount>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.currency>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<Money.[Symbol.toPrimitive]>",
          "metadata": {
            "kind": "method",
            "computed": true,
            "symbol": "Symbol.toPrimitive"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<hint>"
        },
        {
          "type": "BRANCH",
          "id": "<hint === 'number'>",
          "metadata": {
            "condition": "hint === 'number'"
          }
        },
        {
          "type": "BRANCH",
          "id": "<hint === 'string'>",
          "metadata": {
            "condition": "hint === 'string'"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'number'>",
          "metadata": {
            "value": "number",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'string'>",
          "metadata": {
            "value": "string",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`${this.amount} ${this.currency}`>",
          "metadata": {
            "type": "template-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Money>",
            "dst": "<Money.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Money>",
            "dst": "<Money.[Symbol.toPrimitive]>",
            "type": "CONTAINS"
          },
          {
            "src": "<Money.constructor>",
            "dst": "<amount>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Money.constructor>",
            "dst": "<currency>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Money.[Symbol.toPrimitive]>",
            "dst": "<hint>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Money.[Symbol.toPrimitive]>",
            "dst": "<hint === 'number'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<Money.[Symbol.toPrimitive]>",
            "dst": "<hint === 'string'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<hint === 'number'>",
            "dst": "<this.amount>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<hint === 'string'>",
            "dst": "<`${this.amount} ${this.currency}`>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Money.[Symbol.toPrimitive]>",
            "dst": "<this.amount>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<this.amount>",
            "dst": "<amount>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.currency>",
            "dst": "<currency>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<hint === 'number'>",
            "dst": "<hint>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'number'>",
            "dst": "<'number'>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'string'>",
            "dst": "<hint>",
            "type": "READS_FROM"
          },
          {
            "src": "<hint === 'string'>",
            "dst": "<'string'>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${this.amount} ${this.currency}`>",
            "dst": "<this.amount>",
            "type": "READS_FROM"
          },
          {
            "src": "<`${this.amount} ${this.currency}`>",
            "dst": "<this.currency>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::import-attributes-json",
      "category": "modern-es",
      "code": "// import config from './config.json' with { type: 'json' };",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-config>",
          "metadata": {
            "source": "./config.json",
            "importType": "default",
            "attributes": {
              "type": "json"
            }
          }
        },
        {
          "type": "VARIABLE",
          "id": "<config>",
          "metadata": {
            "imported": true,
            "kind": "const"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./config.json>",
          "metadata": {
            "path": "./config.json",
            "type": "json"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-config>",
            "dst": "<config>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-config>",
            "dst": "<./config.json>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::class-accessor-keyword",
      "category": "modern-es",
      "code": "class Reactive {\n  accessor count = 0;\n}\n\n// --- Import Attributes (ES2025) ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Reactive>"
        },
        {
          "type": "PROPERTY",
          "id": "<Reactive.count>",
          "metadata": {
            "kind": "accessor"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Reactive>",
            "type": "DECLARES"
          },
          {
            "src": "<Reactive>",
            "dst": "<Reactive.count>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Reactive.count>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::modern-iterator-helpers",
      "category": "modern-es",
      "code": "function iteratorHelpers(arr) {\n  // Iterator.from, .map, .filter, .take, .drop, .flatMap, .reduce, .toArray, .forEach, .some, .every, .find\n  const iter = arr.values();\n  const mapped = iter.map(x => x * 2);\n  const taken = mapped.take(3);\n  return [...taken];\n}\n\n// --- Set methods (ES2025) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<iteratorHelpers>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<arr>"
        },
        {
          "type": "VARIABLE",
          "id": "<iter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<arr.values()>",
          "metadata": {
            "callee": "values",
            "method": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<mapped>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<iter.map(x => x * 2)>",
          "metadata": {
            "callee": "map",
            "method": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<x => x * 2>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<taken>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<mapped.take(3)>",
          "metadata": {
            "callee": "take",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[...taken]>",
          "metadata": {
            "operator": "spread"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<iteratorHelpers>",
            "dst": "<arr>",
            "type": "CONTAINS"
          },
          {
            "src": "<iteratorHelpers>",
            "dst": "<iter>",
            "type": "CONTAINS"
          },
          {
            "src": "<iteratorHelpers>",
            "dst": "<mapped>",
            "type": "CONTAINS"
          },
          {
            "src": "<iter.map(x => x * 2)>",
            "dst": "<x => x * 2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<x => x * 2>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<x => x * 2>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          },
          {
            "src": "<iteratorHelpers>",
            "dst": "<taken>",
            "type": "CONTAINS"
          },
          {
            "src": "<mapped.take(3)>",
            "dst": "<3>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<iteratorHelpers>",
            "dst": "<[...taken]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<iter>",
            "dst": "<arr.values()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<mapped>",
            "dst": "<iter.map(x => x * 2)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<taken>",
            "dst": "<mapped.take(3)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<arr.values()>",
            "dst": "<arr>",
            "type": "CALLS_ON"
          },
          {
            "src": "<iter.map(x => x * 2)>",
            "dst": "<iter>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<mapped.take(3)>",
            "dst": "<mapped>",
            "type": "CALLS_ON"
          },
          {
            "src": "<[...taken]>",
            "dst": "<taken>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-regex-named-groups",
      "category": "builtins",
      "code": "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<regexNamedGroups>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<dateStr>"
        },
        {
          "type": "VARIABLE",
          "id": "<pattern>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>",
          "metadata": {
            "value": "/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/",
            "literalType": "regex",
            "namedGroups": [
              "year",
              "month",
              "day"
            ]
          }
        },
        {
          "type": "VARIABLE",
          "id": "<match>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<dateStr.match(pattern)>",
          "metadata": {
            "callee": "match",
            "method": true
          }
        },
        {
          "type": "BRANCH",
          "id": "<if (!match)>",
          "metadata": {
            "condition": "!match"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<year>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<month>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<day>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<match.groups>",
          "metadata": {
            "objectName": "match",
            "propertyName": "groups"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ year, month, day }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<regexNamedGroups>",
            "dst": "<dateStr>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<pattern>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<match>",
            "type": "CONTAINS"
          },
          {
            "src": "<dateStr.match(pattern)>",
            "dst": "<pattern>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<if (!match)>",
            "type": "CONTAINS"
          },
          {
            "src": "<if (!match)>",
            "dst": "<match>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if (!match)>",
            "dst": "<null>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<year>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<month>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<day>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexNamedGroups>",
            "dst": "<{ year, month, day }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<pattern>",
            "dst": "</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<match>",
            "dst": "<dateStr.match(pattern)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<year>",
            "dst": "<match.groups>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<month>",
            "dst": "<match.groups>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<day>",
            "dst": "<match.groups>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<dateStr.match(pattern)>",
            "dst": "<dateStr>",
            "type": "READS_FROM"
          },
          {
            "src": "<match.groups>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ year, month, day }>",
            "dst": "<year>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ year, month, day }>",
            "dst": "<month>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ year, month, day }>",
            "dst": "<day>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::modern-regex-indices",
      "category": "modern-es",
      "code": "function regexIndices(str) {\n  const regex = /(?<word>\\w+)/gd;\n  const match = regex.exec(str);\n  if (!match) return null;\n  const { indices } = match;\n  return { match: match[0], start: indices[0][0], end: indices[0][1], groups: indices.groups };\n}\n\n// --- Top-level await (ES2022)  already in async-generators.js, reference only ---\n\n// --- Logical assignment already in expressions.js (&&=, ||=, ??=) ---\n\n// --- Private class fields / methods already in classes.js ---\n\n// --- Class static block already in classes.js ---\n\n// --- Symbols: well-known symbols ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<regexIndices>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<str>"
        },
        {
          "type": "VARIABLE",
          "id": "<regex>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<word>\\w+)/gd>",
          "metadata": {
            "value": "/(?<word>\\w+)/gd",
            "literalType": "regex",
            "flags": "gd",
            "namedGroups": [
              "word"
            ]
          }
        },
        {
          "type": "VARIABLE",
          "id": "<match>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<regex.exec(str)>",
          "metadata": {
            "callee": "exec"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if (!match)>",
          "metadata": {
            "condition": "!match"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<indices>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<match.indices>",
          "metadata": {
            "property": "indices"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<match[0]>",
          "metadata": {
            "property": "0",
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<indices[0][0]>",
          "metadata": {
            "property": "0",
            "computed": true,
            "chained": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<indices[0][1]>",
          "metadata": {
            "property": "1",
            "computed": true,
            "chained": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<indices.groups>",
          "metadata": {
            "property": "groups"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<regexIndices>",
            "dst": "<str>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexIndices>",
            "dst": "<regex>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexIndices>",
            "dst": "<match>",
            "type": "CONTAINS"
          },
          {
            "src": "<regex.exec(str)>",
            "dst": "<str>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<regexIndices>",
            "dst": "<if (!match)>",
            "type": "CONTAINS"
          },
          {
            "src": "<if (!match)>",
            "dst": "<null>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<regexIndices>",
            "dst": "<indices>",
            "type": "CONTAINS"
          },
          {
            "src": "<regexIndices>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<match[0]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<indices[0][0]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<indices[0][1]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<indices.groups>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<regex>",
            "dst": "</(?<word>\\w+)/gd>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<match>",
            "dst": "<regex.exec(str)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<indices>",
            "dst": "<match.indices>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<regex.exec(str)>",
            "dst": "<regex>",
            "type": "CALLS_ON"
          },
          {
            "src": "<if (!match)>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<match.indices>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<match[0]>",
            "dst": "<match>",
            "type": "READS_FROM"
          },
          {
            "src": "<indices[0][0]>",
            "dst": "<indices>",
            "type": "READS_FROM"
          },
          {
            "src": "<indices[0][1]>",
            "dst": "<indices>",
            "type": "READS_FROM"
          },
          {
            "src": "<indices.groups>",
            "dst": "<indices>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modules-default-anon::export-default-anonymous-function",
      "category": "modules-default-anon",
      "code": "export default function() {\n  return 'anonymous but hoisted';\n}\n\n// Only one `export default` per module  other forms as comments:",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<anonymous-default-function>",
          "metadata": {
            "anonymous": true,
            "hoisted": true
          }
        },
        {
          "type": "EXPORT",
          "id": "<default-export>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'anonymous but hoisted'>",
          "metadata": {
            "value": "anonymous but hoisted",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<default-export>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-default-function>",
            "dst": "<'anonymous but hoisted'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<default-export>",
            "dst": "<anonymous-default-function>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::import-attributes-reexport",
      "category": "modern-es",
      "code": "// export { default as schema } from './schema.json' with { type: 'json' };\n\n// --- import.meta.resolve() (ES2025) ---",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-schema>",
          "metadata": {
            "exportType": "named",
            "reexport": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<schema>",
          "metadata": {
            "exported": true,
            "importedAs": "default"
          }
        },
        {
          "type": "IMPORT",
          "id": "<import-schema.json>",
          "metadata": {
            "source": "./schema.json",
            "attributes": {
              "type": "json"
            }
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./schema.json>",
          "metadata": {
            "path": "./schema.json",
            "type": "json"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-schema>",
            "dst": "<schema>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<import-schema.json>",
            "dst": "<schema>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-schema.json>",
            "dst": "<./schema.json>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<export-schema>",
            "dst": "<import-schema.json>",
            "type": "DEPENDS_ON"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::import-attributes-css",
      "category": "modern-es",
      "code": "// import styles from './app.css' with { type: 'css' };",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-styles>",
          "metadata": {
            "source": "./app.css",
            "importType": "default"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<styles>",
          "metadata": {
            "imported": true,
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<type-css>",
          "metadata": {
            "value": "css",
            "context": "import_attribute_value"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-styles>",
            "type": "CONTAINS"
          },
          {
            "src": "<import-styles>",
            "dst": "<type-css>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<import-styles>",
            "dst": "<styles>",
            "type": "IMPORTS"
          },
          {
            "src": "<module>",
            "dst": "<./app.css>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modules-helpers::export-inline-function",
      "category": "modules-helpers",
      "code": "export function helperFunction() {\n  return 'help';\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<helperFunction>",
          "metadata": {
            "async": false,
            "generator": false,
            "exported": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'help'>",
          "metadata": {
            "value": "help",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<helperFunction>",
            "type": "DECLARES"
          },
          {
            "src": "<helperFunction>",
            "dst": "<'help'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<module>",
            "dst": "<helperFunction>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::modern-abort-controller",
      "category": "modern-es",
      "code": "async function fetchWithAbort(url, timeoutMs) {\n  const controller = new AbortController();\n  const { signal } = controller;\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal });\n    return await response.json();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// --- Disposable resources (ES2025) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fetchWithAbort>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "PARAMETER",
          "id": "<timeoutMs>"
        },
        {
          "type": "VARIABLE",
          "id": "<controller>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new AbortController()>",
          "metadata": {
            "callee": "AbortController",
            "constructor": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<signal>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<controller.signal>",
          "metadata": {
            "objectName": "controller",
            "propertyName": "signal"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<timeoutId>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout(...)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<timeout-callback>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "CALL",
          "id": "<controller.abort()>",
          "metadata": {
            "callee": "abort",
            "method": true
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<response>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch(url, { signal })>",
          "metadata": {
            "callee": "fetch",
            "async": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ signal }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "CALL",
          "id": "<response.json()>",
          "metadata": {
            "callee": "json",
            "method": true,
            "async": true
          }
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "CALL",
          "id": "<clearTimeout(timeoutId)>",
          "metadata": {
            "callee": "clearTimeout"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetchWithAbort>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithAbort>",
            "dst": "<timeoutMs>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithAbort>",
            "dst": "<controller>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithAbort>",
            "dst": "<signal>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithAbort>",
            "dst": "<timeoutId>",
            "type": "CONTAINS"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "<timeout-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "<timeoutMs>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<timeout-callback>",
            "dst": "<controller.abort()>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetchWithAbort>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<response>",
            "type": "CONTAINS"
          },
          {
            "src": "<fetch(url, { signal })>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetch(url, { signal })>",
            "dst": "<{ signal }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<response.json()>",
            "type": "RETURNS"
          },
          {
            "src": "<fetchWithAbort>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<finally-block>",
            "dst": "<clearTimeout(timeoutId)>",
            "type": "CONTAINS"
          },
          {
            "src": "<clearTimeout(timeoutId)>",
            "dst": "<timeoutId>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<controller>",
            "dst": "<new AbortController()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<signal>",
            "dst": "<controller.signal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<timeoutId>",
            "dst": "<setTimeout(...)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<response>",
            "dst": "<fetch(url, { signal })>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new AbortController()>",
            "dst": "AbortController",
            "type": "CALLS"
          },
          {
            "src": "<controller.signal>",
            "dst": "<controller>",
            "type": "READS_FROM"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "setTimeout",
            "type": "CALLS"
          },
          {
            "src": "<controller.abort()>",
            "dst": "<controller>",
            "type": "CALLS_ON"
          },
          {
            "src": "<fetch(url, { signal })>",
            "dst": "fetch",
            "type": "CALLS"
          },
          {
            "src": "<{ signal }>",
            "dst": "<signal>",
            "type": "READS_FROM"
          },
          {
            "src": "<response.json()>",
            "dst": "<response>",
            "type": "CALLS_ON"
          },
          {
            "src": "<clearTimeout(timeoutId)>",
            "dst": "clearTimeout",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "modules-default-anon::export-default-anonymous-class",
      "category": "modules-default-anon",
      "code": "// export default class { run() { return 'anonymous class'; } }",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<default-export>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "CLASS",
          "id": "<anonymous-class>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "METHOD",
          "id": "<anonymous-class.run>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'anonymous class'>",
          "metadata": {
            "value": "anonymous class",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<anonymous-class>",
            "dst": "<anonymous-class.run>",
            "type": "CONTAINS"
          },
          {
            "src": "<anonymous-class.run>",
            "dst": "<'anonymous class'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<default-export>",
            "dst": "<anonymous-class>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::using-declaration",
      "category": "modern-es",
      "code": "function usingDeclaration() {\n  function openFile(path) {\n    return {\n      path,\n      read() { return `contents of ${path}`; },\n      [Symbol.dispose]() { console.log(`closed ${path}`); },\n    };\n  }\n  using handle = openFile('/tmp/test');\n  return handle.read();\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<usingDeclaration>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "FUNCTION",
          "id": "<openFile>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<path>"
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<path-property>",
          "metadata": {
            "key": "path",
            "shorthand": true
          }
        },
        {
          "type": "METHOD",
          "id": "<read>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template"
          }
        },
        {
          "type": "METHOD",
          "id": "<Symbol.dispose>",
          "metadata": {
            "kind": "method",
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<console.log>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<dispose-template>",
          "metadata": {
            "type": "template"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<handle>",
          "metadata": {
            "kind": "using"
          }
        },
        {
          "type": "CALL",
          "id": "<openFile('/tmp/test')>",
          "metadata": {
            "callee": "openFile"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/tmp/test'>",
          "metadata": {
            "value": "/tmp/test",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<handle.read()>",
          "metadata": {
            "callee": "handle.read"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<usingDeclaration>",
            "dst": "<openFile>",
            "type": "CONTAINS"
          },
          {
            "src": "<openFile>",
            "dst": "<path>",
            "type": "CONTAINS"
          },
          {
            "src": "<openFile>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<path-property>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<read>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<read>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<Symbol.dispose>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Symbol.dispose>",
            "dst": "<console.log>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log>",
            "dst": "<dispose-template>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<usingDeclaration>",
            "dst": "<handle>",
            "type": "DECLARES"
          },
          {
            "src": "<openFile('/tmp/test')>",
            "dst": "<'/tmp/test'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<usingDeclaration>",
            "dst": "<handle.read()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<handle>",
            "dst": "<openFile('/tmp/test')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<path-property>",
            "dst": "<path>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<path>",
            "type": "READS_FROM"
          },
          {
            "src": "<dispose-template>",
            "dst": "<path>",
            "type": "READS_FROM"
          },
          {
            "src": "<openFile('/tmp/test')>",
            "dst": "<openFile>",
            "type": "CALLS"
          },
          {
            "src": "<handle.read()>",
            "dst": "<handle>",
            "type": "READS_FROM"
          },
          {
            "src": "<handle.read()>",
            "dst": "<read>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::import-attributes-dynamic",
      "category": "modern-es",
      "code": "// const data = await import('./data.json', { with: { type: 'json' } });",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await import('./data.json', { with: { type: 'json' } })>",
          "metadata": {
            "async": true,
            "operator": "await"
          }
        },
        {
          "type": "CALL",
          "id": "<import('./data.json', { with: { type: 'json' } })>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./data.json'>",
          "metadata": {
            "value": "./data.json",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ with: { type: 'json' } }>",
          "metadata": {
            "literalType": "object",
            "importAttributes": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<data>",
            "type": "DECLARES"
          },
          {
            "src": "<await import('./data.json', { with: { type: 'json' } })>",
            "dst": "<import('./data.json', { with: { type: 'json' } })>",
            "type": "AWAITS"
          },
          {
            "src": "<import('./data.json', { with: { type: 'json' } })>",
            "dst": "<{ with: { type: 'json' } }>",
            "type": "USES"
          }
        ],
        "postFile": [
          {
            "src": "<data>",
            "dst": "<await import('./data.json', { with: { type: 'json' } })>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import('./data.json', { with: { type: 'json' } })>",
            "dst": "<'./data.json'>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::using-await-declaration",
      "category": "modern-es",
      "code": "async function usingAwaitDeclaration() {\n  function openStream(url) {\n    return {\n      url,\n      async readAll() { return 'data'; },\n      async [Symbol.asyncDispose]() { console.log(`closed ${url}`); },\n    };\n  }\n  await using stream = await openStream('http://example.com');\n  return stream.readAll();\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<usingAwaitDeclaration>",
          "metadata": {
            "async": true,
            "generator": false
          }
        },
        {
          "type": "FUNCTION",
          "id": "<openStream>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<url>"
        },
        {
          "type": "LITERAL",
          "id": "<'data'>",
          "metadata": {
            "value": "data",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'http://example.com'>",
          "metadata": {
            "value": "http://example.com",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'closed '>",
          "metadata": {
            "value": "closed ",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<readAll>",
          "metadata": {
            "async": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Symbol.asyncDispose>",
          "metadata": {
            "async": true,
            "symbol": "Symbol.asyncDispose"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<object-literal>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<stream>",
          "metadata": {
            "kind": "await using",
            "disposable": true
          }
        },
        {
          "type": "CALL",
          "id": "<openStream('http://example.com')>",
          "metadata": {
            "callee": "openStream",
            "awaited": true
          }
        },
        {
          "type": "CALL",
          "id": "<stream.readAll()>",
          "metadata": {
            "callee": "readAll",
            "awaited": false
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(template)>",
          "metadata": {
            "callee": "console.log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<usingAwaitDeclaration>",
            "dst": "<openStream>",
            "type": "CONTAINS"
          },
          {
            "src": "<openStream>",
            "dst": "<url>",
            "type": "CONTAINS"
          },
          {
            "src": "<openStream>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<url>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<readAll>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<object-literal>",
            "dst": "<Symbol.asyncDispose>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<readAll>",
            "dst": "<'data'>",
            "type": "RETURNS"
          },
          {
            "src": "<Symbol.asyncDispose>",
            "dst": "<console.log(template)>",
            "type": "CONTAINS"
          },
          {
            "src": "<template-literal>",
            "dst": "<'closed '>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<template-literal>",
            "dst": "<url>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<console.log(template)>",
            "dst": "<template-literal>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<usingAwaitDeclaration>",
            "dst": "<stream>",
            "type": "DECLARES"
          },
          {
            "src": "<openStream('http://example.com')>",
            "dst": "<'http://example.com'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<usingAwaitDeclaration>",
            "dst": "<stream.readAll()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<stream>",
            "dst": "<openStream('http://example.com')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<openStream('http://example.com')>",
            "dst": "<openStream>",
            "type": "CALLS"
          },
          {
            "src": "<stream.readAll()>",
            "dst": "<stream>",
            "type": "READS_FROM"
          },
          {
            "src": "<stream.readAll()>",
            "dst": "<readAll>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "modules-helpers::export-inline-class",
      "category": "modules-helpers",
      "code": "export class HelperClass {\n  method() {\n    return true;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<HelperClass>"
        },
        {
          "type": "METHOD",
          "id": "<HelperClass.method>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<HelperClass>",
            "type": "DECLARES"
          },
          {
            "src": "<HelperClass>",
            "dst": "<HelperClass.method>",
            "type": "CONTAINS"
          },
          {
            "src": "<HelperClass.method>",
            "dst": "<true>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<module>",
            "dst": "<HelperClass>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-helpers::export-default-function",
      "category": "modules-helpers",
      "code": "export default function defaultHelper() {\n  return 'default';\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<defaultHelper>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-default>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'default'>",
          "metadata": {
            "value": "default",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<defaultHelper>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<export-default>",
            "type": "CONTAINS"
          },
          {
            "src": "<defaultHelper>",
            "dst": "<'default'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<export-default>",
            "dst": "<defaultHelper>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-helpers::export-inline-const",
      "category": "modules-helpers",
      "code": "export const HELPER_CONST = 42;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<HELPER_CONST>",
          "metadata": {
            "kind": "const",
            "exported": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-HELPER_CONST>",
          "metadata": {
            "exportType": "named"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<HELPER_CONST>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<export-HELPER_CONST>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<HELPER_CONST>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<export-HELPER_CONST>",
            "dst": "<HELPER_CONST>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-helpers::export-default-class",
      "category": "modules-helpers",
      "code": "// export default class Router { navigate() { return '/'; } }\n// Also valid: export default class { anonymous() {} }\n// (Only one default export per module  shown above as function)",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Router>",
          "metadata": {
            "exported": true,
            "exportType": "default"
          }
        },
        {
          "type": "METHOD",
          "id": "<Router.navigate>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/'>",
          "metadata": {
            "value": "/",
            "literalType": "string"
          }
        },
        {
          "type": "EXPORT",
          "id": "<default-export>",
          "metadata": {
            "exportType": "default"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<default-export>",
            "type": "CONTAINS"
          },
          {
            "src": "<Router>",
            "dst": "<Router.navigate>",
            "type": "CONTAINS"
          },
          {
            "src": "<Router.navigate>",
            "dst": "<'/'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<default-export>",
            "dst": "<Router>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-helpers::export-as-default",
      "category": "modules-helpers",
      "code": "// Alternative syntax for default export:\n// export { someFunction as default };\n// Semantically equivalent to export default, but uses named export syntax",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-as-default>",
          "metadata": {
            "exportType": "named",
            "isDefault": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<someFunction>",
          "metadata": {
            "exported": true,
            "exportedAs": "default"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-as-default>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-as-default>",
            "dst": "<someFunction>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<someFunction>",
            "dst": "<default>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "modules-default-anon::export-default-expression",
      "category": "modules-default-anon",
      "code": "// export default [1, 2, 3];\n// export default { key: 'value' };\n// export default 42;",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-default-array>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "value": "[1, 2, 3]",
            "literalType": "array"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-default-object>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ key: 'value' }>",
          "metadata": {
            "value": "{ key: 'value' }",
            "literalType": "object"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-default-number>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": "42",
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-default-array>",
            "dst": "<[1, 2, 3]>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-default-object>",
            "dst": "<{ key: 'value' }>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-default-number>",
            "dst": "<42>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modern-es::import-meta-resolve",
      "category": "modern-es",
      "code": "const workerUrl = import.meta.resolve('./modules-helpers.js');\n\nasync function loadOptional(specifier) {\n  try {\n    const url = import.meta.resolve(specifier);\n    return await import(url);\n  } catch {\n    return null;\n  }\n}\n\n// --- WeakRef and FinalizationRegistry ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<workerUrl>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import.meta.resolve('./modules-helpers.js')>",
          "metadata": {
            "callee": "import.meta.resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./modules-helpers.js'>",
          "metadata": {
            "value": "./modules-helpers.js",
            "literalType": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<loadOptional>",
          "metadata": {
            "async": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<specifier>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "VARIABLE",
          "id": "<url>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import.meta.resolve(specifier)>",
          "metadata": {
            "callee": "import.meta.resolve"
          }
        },
        {
          "type": "CALL",
          "id": "<import(url)>",
          "metadata": {
            "callee": "import",
            "dynamic": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<import.meta.resolve('./modules-helpers.js')>",
            "dst": "<'./modules-helpers.js'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<loadOptional>",
            "dst": "<specifier>",
            "type": "CONTAINS"
          },
          {
            "src": "<loadOptional>",
            "dst": "<try-block>",
            "type": "HAS_BODY"
          },
          {
            "src": "<loadOptional>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<import.meta.resolve(specifier)>",
            "dst": "<specifier>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<try-block>",
            "dst": "<import(url)>",
            "type": "RETURNS"
          },
          {
            "src": "<import(url)>",
            "dst": "<url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<null>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<workerUrl>",
            "dst": "<import.meta.resolve('./modules-helpers.js')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<url>",
            "dst": "<import.meta.resolve(specifier)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-helpers::export-default-expression",
      "category": "modules-helpers",
      "code": "// export default [1, 2, 3];\n// export default 42;\n// Any expression can be a default export",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-default-array>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "value": "[1, 2, 3]",
            "literalType": "array"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-default-number>",
          "metadata": {
            "exportType": "default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": "42",
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-default-array>",
            "dst": "<[1, 2, 3]>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-default-number>",
            "dst": "<42>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-reexport::reexport-named",
      "category": "modules-reexport",
      "code": "export { helperFunction } from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-helperFunction>",
          "metadata": {
            "exportType": "named",
            "reexport": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<helperFunction>",
          "metadata": {
            "reexported": true
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        },
        {
          "type": "MODULE",
          "id": "<module>",
          "metadata": {
            "implicit": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-helperFunction>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-helperFunction>",
            "dst": "<helperFunction>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<export-helperFunction>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<module>",
            "dst": "<./modules-helpers.js>",
            "type": "DEPENDS_ON"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::reexport-aliased",
      "category": "modules-reexport",
      "code": "export { HELPER_CONST as RENAMED_CONST } from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<reexport-aliased>",
          "metadata": {
            "source": "./modules-helpers.js",
            "kind": "reexport"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<RENAMED_CONST>",
          "metadata": {
            "exported": true,
            "reexportedAs": "HELPER_CONST"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<reexport-aliased>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<reexport-aliased>",
            "dst": "<RENAMED_CONST>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<module>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<reexport-aliased>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::finalization-registry",
      "category": "modern-es",
      "code": "const cleanupRegistry = new FinalizationRegistry((key) => {\n  console.log(`Object for key \"${key}\" was garbage collected`);\n});\n\nfunction trackObject(key, obj) {\n  cleanupRegistry.register(obj, key);\n}",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<cleanupRegistry>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new FinalizationRegistry>",
          "metadata": {
            "constructor": "FinalizationRegistry"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<cleanup-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "CALL",
          "id": "<console.log>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<template-literal>",
          "metadata": {
            "value": "Object for key \"${key}\" was garbage collected",
            "literalType": "template"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<trackObject>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<trackObject.key>"
        },
        {
          "type": "PARAMETER",
          "id": "<trackObject.obj>"
        },
        {
          "type": "CALL",
          "id": "<cleanupRegistry.register>",
          "metadata": {
            "method": "register"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<new FinalizationRegistry>",
            "dst": "<cleanup-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cleanup-callback>",
            "dst": "<key>",
            "type": "HAS_BODY"
          },
          {
            "src": "<cleanup-callback>",
            "dst": "<console.log>",
            "type": "HAS_BODY"
          },
          {
            "src": "<console.log>",
            "dst": "<template-literal>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<trackObject>",
            "dst": "<trackObject.key>",
            "type": "HAS_BODY"
          },
          {
            "src": "<trackObject>",
            "dst": "<trackObject.obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<trackObject>",
            "dst": "<cleanupRegistry.register>",
            "type": "HAS_BODY"
          },
          {
            "src": "<cleanupRegistry.register>",
            "dst": "<trackObject.obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cleanupRegistry.register>",
            "dst": "<trackObject.key>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<cleanupRegistry>",
            "dst": "<new FinalizationRegistry>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<template-literal>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<cleanupRegistry.register>",
            "dst": "<cleanupRegistry>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::reexport-default-as-named",
      "category": "modules-reexport",
      "code": "export { default as defaultFn } from './modules-helpers.js';",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-default-as-named>",
          "metadata": {
            "exportType": "named",
            "source": "./modules-helpers.js"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<defaultFn>",
          "metadata": {
            "exported": true,
            "reexported": true,
            "originalName": "default"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<./modules-helpers.js:default>",
          "metadata": {
            "module": "./modules-helpers.js",
            "exportName": "default"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-default-as-named>",
            "dst": "<defaultFn>",
            "type": "EXPORTS"
          },
          {
            "src": "<./modules-helpers.js>",
            "dst": "<./modules-helpers.js:default>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<export-default-as-named>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<defaultFn>",
            "dst": "<./modules-helpers.js:default>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::reexport-star",
      "category": "modules-reexport",
      "code": "export * from './declarations.js';",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-star>",
          "metadata": {
            "exportType": "star"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./declarations.js>",
          "metadata": {
            "path": "./declarations.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-star>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<export-star>",
            "dst": "<./declarations.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<module>",
            "dst": "<./declarations.js>",
            "type": "DEPENDS_ON"
          }
        ]
      }
    },
    {
      "constructId": "modules-helpers::export-multiple-names-same-binding",
      "category": "modules-helpers",
      "code": "const sharedValue = 'shared';\nexport { sharedValue, sharedValue as sharedAlias, sharedValue as sharedOther };",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<sharedValue>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'shared'>",
          "metadata": {
            "value": "shared",
            "literalType": "string"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-sharedValue>",
          "metadata": {
            "exportName": "sharedValue"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-sharedAlias>",
          "metadata": {
            "exportName": "sharedAlias",
            "localName": "sharedValue"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-sharedOther>",
          "metadata": {
            "exportName": "sharedOther",
            "localName": "sharedValue"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<sharedValue>",
            "dst": "<'shared'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<export-sharedValue>",
            "dst": "<sharedValue>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-sharedAlias>",
            "dst": "<sharedValue>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-sharedOther>",
            "dst": "<sharedValue>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "modules-reexport::reexport-namespace",
      "category": "modules-reexport",
      "code": "export * as helpers from './modules-helpers.js';\n\n// --- Multi-file module patterns (construct references only) ---",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-namespace>",
          "metadata": {
            "exportType": "namespace",
            "alias": "helpers"
          }
        },
        {
          "type": "IMPORT",
          "id": "<import-all>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importType": "namespace"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-namespace>",
            "dst": "<import-all>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<import-all>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modern-es::weakref-cache",
      "category": "modern-es",
      "code": "function createWeakCache() {\n  const cache = new Map();\n  return {\n    get(key, factory) {\n      const ref = cache.get(key);\n      const cached = ref?.deref();\n      if (cached) return cached;\n      const fresh = factory();\n      cache.set(key, new WeakRef(fresh));\n      return fresh;\n    },\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createWeakCache>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cache>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Map()>",
          "metadata": {
            "callee": "Map",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<object-literal>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<get>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<factory>"
        },
        {
          "type": "VARIABLE",
          "id": "<ref>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<cache.get(key)>",
          "metadata": {
            "callee": "get"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<cached>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<ref?.deref()>",
          "metadata": {
            "callee": "deref",
            "optional": true
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-cached>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fresh>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<factory()>",
          "metadata": {
            "callee": "factory"
          }
        },
        {
          "type": "CALL",
          "id": "<cache.set(key, new WeakRef(fresh))>",
          "metadata": {
            "callee": "set"
          }
        },
        {
          "type": "CALL",
          "id": "<new WeakRef(fresh)>",
          "metadata": {
            "callee": "WeakRef",
            "constructor": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createWeakCache>",
            "dst": "<cache>",
            "type": "CONTAINS"
          },
          {
            "src": "<createWeakCache>",
            "dst": "<object-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<object-literal>",
            "dst": "<get>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<get>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<get>",
            "dst": "<factory>",
            "type": "CONTAINS"
          },
          {
            "src": "<get>",
            "dst": "<ref>",
            "type": "CONTAINS"
          },
          {
            "src": "<cache.get(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<get>",
            "dst": "<cached>",
            "type": "CONTAINS"
          },
          {
            "src": "<get>",
            "dst": "<if-cached>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-cached>",
            "dst": "<cached>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-cached>",
            "dst": "<cached>",
            "type": "RETURNS"
          },
          {
            "src": "<get>",
            "dst": "<fresh>",
            "type": "CONTAINS"
          },
          {
            "src": "<get>",
            "dst": "<cache.set(key, new WeakRef(fresh))>",
            "type": "CONTAINS"
          },
          {
            "src": "<cache.set(key, new WeakRef(fresh))>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<cache.set(key, new WeakRef(fresh))>",
            "dst": "<new WeakRef(fresh)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new WeakRef(fresh)>",
            "dst": "<fresh>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<get>",
            "dst": "<fresh>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<cache>",
            "dst": "<new Map()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ref>",
            "dst": "<cache.get(key)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<cached>",
            "dst": "<ref?.deref()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fresh>",
            "dst": "<factory()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<cache.set(key, new WeakRef(fresh))>",
            "dst": "<cache>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<cache.get(key)>",
            "dst": "<cache>",
            "type": "READS_FROM"
          },
          {
            "src": "<ref?.deref()>",
            "dst": "<ref>",
            "type": "READS_FROM"
          },
          {
            "src": "<factory()>",
            "dst": "<factory>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "patterns::obj-destructuring-nested",
      "category": "patterns",
      "code": "function objectDestructuringNested() {\n  const data = { outer: { inner: { deep: 42 } } };\n  const { outer: { inner: { deep } } } = data;\n  return deep;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<objectDestructuringNested>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<data>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ outer: { inner: { deep: 42 } } }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ outer: { inner: { deep } } }>",
          "metadata": {
            "expressionType": "destructuring",
            "nested": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<deep>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<objectDestructuringNested>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ outer: { inner: { deep: 42 } } }>",
            "dst": "<42>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<objectDestructuringNested>",
            "dst": "<{ outer: { inner: { deep } } }>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectDestructuringNested>",
            "dst": "<deep>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<data>",
            "dst": "<{ outer: { inner: { deep: 42 } } }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<{ outer: { inner: { deep } } }>",
            "dst": "<deep>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ outer: { inner: { deep } } }>",
            "dst": "<data>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::star-import-namespace",
      "category": "modules-reexport",
      "code": "// import * as utils from './modules-helpers.js';\n// utils.helperFunction();          // method on namespace object\n// const { helperFunction } = utils; // destructured from namespace\n// const fn = utils['helperFunction']; // bracket access on namespace",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-utils>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importType": "namespace"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<utils>",
          "metadata": {
            "imported": true,
            "namespaceImport": true
          }
        },
        {
          "type": "CALL",
          "id": "<utils.helperFunction()>",
          "metadata": {
            "callee": "helperFunction"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<utils.helperFunction>",
          "metadata": {
            "objectName": "utils",
            "propertyName": "helperFunction"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<helperFunction>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<utils['helperFunction']>",
          "metadata": {
            "objectName": "utils",
            "propertyName": "helperFunction",
            "accessType": "bracket"
          }
        },
        {
          "type": "EXTERNAL_MODULE",
          "id": "<./modules-helpers.js>",
          "metadata": {
            "path": "./modules-helpers.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<helperFunction>",
            "dst": "<utils>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<fn>",
            "dst": "<utils['helperFunction']>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import-utils>",
            "dst": "<utils>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-utils>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<utils.helperFunction()>",
            "dst": "<utils.helperFunction>",
            "type": "CALLS"
          },
          {
            "src": "<utils.helperFunction>",
            "dst": "<utils>",
            "type": "READS_FROM"
          },
          {
            "src": "<utils['helperFunction']>",
            "dst": "<utils>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::param-destructuring-object",
      "category": "patterns",
      "code": "function withObjectParam({ name, age, role = 'guest' }) {\n  return `${name} (${age}) - ${role}`;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withObjectParam>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<destructured-param>",
          "metadata": {
            "destructured": true,
            "destructureType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<name>",
          "metadata": {
            "destructured": true,
            "kind": "parameter"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<age>",
          "metadata": {
            "destructured": true,
            "kind": "parameter"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<role>",
          "metadata": {
            "destructured": true,
            "kind": "parameter",
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'guest'>",
          "metadata": {
            "value": "guest",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withObjectParam>",
            "dst": "<destructured-param>",
            "type": "CONTAINS"
          },
          {
            "src": "<role>",
            "dst": "<'guest'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<withObjectParam>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<destructured-param>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructured-param>",
            "dst": "<age>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructured-param>",
            "dst": "<role>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<template-literal>",
            "dst": "<name>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<age>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<role>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::array-destructuring-swap",
      "category": "patterns",
      "code": "function arrayDestructuringSwap() {\n  let left = 'left';\n  let right = 'right';\n  [left, right] = [right, left];\n  return { left, right };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<arrayDestructuringSwap>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<left>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'left'>",
          "metadata": {
            "value": "left",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<right>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'right'>",
          "metadata": {
            "value": "right",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[left, right]>",
          "metadata": {
            "type": "destructuring-assignment"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[right, left]>",
          "metadata": {
            "type": "array-literal"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ left, right }>",
          "metadata": {
            "type": "object-literal",
            "shorthand": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<arrayDestructuringSwap>",
            "dst": "<left>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrayDestructuringSwap>",
            "dst": "<right>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrayDestructuringSwap>",
            "dst": "<{ left, right }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<left>",
            "dst": "<'left'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<right>",
            "dst": "<'right'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<[left, right]>",
            "dst": "<[right, left]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<[left, right]>",
            "dst": "<left>",
            "type": "WRITES_TO"
          },
          {
            "src": "<[left, right]>",
            "dst": "<right>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<[right, left]>",
            "dst": "<right>",
            "type": "READS_FROM"
          },
          {
            "src": "<[right, left]>",
            "dst": "<left>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ left, right }>",
            "dst": "<left>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ left, right }>",
            "dst": "<right>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::circular-import-live-binding",
      "category": "modules-reexport",
      "code": "// File A: export let count = 0; export function inc() { count++; }\n// File B: import { count, inc } from './a.js'; inc(); console.log(count); // 1  live binding!\n// Graph impact: imported let is NOT a copy  mutations in source module visible to importers",
      "expectedNodes": [
        {
          "type": "MODULE",
          "id": "<fileA>",
          "metadata": {
            "path": "./a.js"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<count>",
          "metadata": {
            "kind": "let",
            "exported": true,
            "mutable": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<inc>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<count++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "MODULE",
          "id": "<fileB>",
          "metadata": {
            "path": "./b.js"
          }
        },
        {
          "type": "IMPORT",
          "id": "<import-a>",
          "metadata": {
            "source": "./a.js"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<count:imported>",
          "metadata": {
            "imported": true,
            "liveBinding": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<inc:imported>",
          "metadata": {
            "imported": true
          }
        },
        {
          "type": "CALL",
          "id": "<inc()>",
          "metadata": {
            "callee": "inc"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(count)>",
          "metadata": {
            "callee": "console.log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fileA>",
            "dst": "<count>",
            "type": "DECLARES"
          },
          {
            "src": "<fileA>",
            "dst": "<inc>",
            "type": "DECLARES"
          },
          {
            "src": "<inc>",
            "dst": "<count++>",
            "type": "CONTAINS"
          },
          {
            "src": "<fileB>",
            "dst": "<import-a>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<count>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<count++>",
            "dst": "<count>",
            "type": "MODIFIES"
          },
          {
            "src": "<fileA>",
            "dst": "<count>",
            "type": "EXPORTS"
          },
          {
            "src": "<fileA>",
            "dst": "<inc>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<import-a>",
            "dst": "<count:imported>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-a>",
            "dst": "<inc:imported>",
            "type": "IMPORTS"
          },
          {
            "src": "<fileB>",
            "dst": "<fileA>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<count:imported>",
            "dst": "<count>",
            "type": "ALIASES"
          },
          {
            "src": "<inc:imported>",
            "dst": "<inc>",
            "type": "ALIASES"
          },
          {
            "src": "<inc()>",
            "dst": "<inc:imported>",
            "type": "CALLS"
          },
          {
            "src": "<console.log(count)>",
            "dst": "<count:imported>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::param-destructuring-array",
      "category": "patterns",
      "code": "function withArrayParam([first, second, ...rest]) {\n  return { first, second, rest };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withArrayParam>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<arrayParam>",
          "metadata": {
            "destructured": true,
            "destructureType": "array"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "destructuredFrom": "arrayParam",
            "destructureIndex": 0
          }
        },
        {
          "type": "VARIABLE",
          "id": "<second>",
          "metadata": {
            "destructuredFrom": "arrayParam",
            "destructureIndex": 1
          }
        },
        {
          "type": "VARIABLE",
          "id": "<rest>",
          "metadata": {
            "destructuredFrom": "arrayParam",
            "restParameter": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ first, second, rest }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withArrayParam>",
            "dst": "<arrayParam>",
            "type": "CONTAINS"
          },
          {
            "src": "<withArrayParam>",
            "dst": "<{ first, second, rest }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arrayParam>",
            "dst": "<first>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<arrayParam>",
            "dst": "<second>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<arrayParam>",
            "dst": "<rest>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ first, second, rest }>",
            "dst": "<first>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, second, rest }>",
            "dst": "<second>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, second, rest }>",
            "dst": "<rest>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::star-reexport-collision",
      "category": "modules-reexport",
      "code": "// a.js: export const x = 1;\n// b.js: export const x = 2;\n// barrel.js: export * from './a'; export * from './b'; // x is ambiguous!\n// Explicit re-export wins: export * from './a'; export { x } from './b';",
      "expectedNodes": [
        {
          "type": "MODULE",
          "id": "<a.js>",
          "metadata": {
            "path": "./a"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<a.js:x>",
          "metadata": {
            "kind": "const",
            "exported": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "MODULE",
          "id": "<b.js>",
          "metadata": {
            "path": "./b"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b.js:x>",
          "metadata": {
            "kind": "const",
            "exported": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "MODULE",
          "id": "<barrel.js>",
          "metadata": {
            "path": "./barrel"
          }
        },
        {
          "type": "EXPORT",
          "id": "<star-export-a>",
          "metadata": {
            "exportType": "star"
          }
        },
        {
          "type": "EXPORT",
          "id": "<star-export-b>",
          "metadata": {
            "exportType": "star"
          }
        },
        {
          "type": "EXPORT",
          "id": "<explicit-x-export>",
          "metadata": {
            "exportType": "named",
            "name": "x"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<a.js>",
            "dst": "<a.js:x>",
            "type": "DECLARES"
          },
          {
            "src": "<b.js>",
            "dst": "<b.js:x>",
            "type": "DECLARES"
          },
          {
            "src": "<barrel.js>",
            "dst": "<star-export-a>",
            "type": "CONTAINS"
          },
          {
            "src": "<barrel.js>",
            "dst": "<star-export-b>",
            "type": "CONTAINS"
          },
          {
            "src": "<barrel.js>",
            "dst": "<explicit-x-export>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<a.js:x>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a.js>",
            "dst": "<a.js:x>",
            "type": "EXPORTS"
          },
          {
            "src": "<b.js:x>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b.js>",
            "dst": "<b.js:x>",
            "type": "EXPORTS"
          },
          {
            "src": "<star-export-a>",
            "dst": "<a.js:x>",
            "type": "EXPORTS"
          },
          {
            "src": "<star-export-b>",
            "dst": "<b.js:x>",
            "type": "EXPORTS"
          },
          {
            "src": "<explicit-x-export>",
            "dst": "<b.js:x>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<star-export-a>",
            "dst": "<a.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<star-export-b>",
            "dst": "<b.js>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<explicit-x-export>",
            "dst": "<b.js>",
            "type": "IMPORTS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::param-destructuring-nested",
      "category": "patterns",
      "code": "function withNestedParam({ user: { name }, settings: { theme = 'light' } }) {\n  return { name, theme };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withNestedParam>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<destructured-param>",
          "metadata": {
            "destructured": true,
            "nested": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<name>",
          "metadata": {
            "destructured": true,
            "path": "user.name"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<theme>",
          "metadata": {
            "destructured": true,
            "path": "settings.theme",
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'light'>",
          "metadata": {
            "value": "light",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ name, theme }>",
          "metadata": {
            "type": "object",
            "shorthand": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withNestedParam>",
            "dst": "<destructured-param>",
            "type": "CONTAINS"
          },
          {
            "src": "<theme>",
            "dst": "<'light'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<withNestedParam>",
            "dst": "<{ name, theme }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<destructured-param>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructured-param>",
            "dst": "<theme>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ name, theme }>",
            "dst": "<name>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ name, theme }>",
            "dst": "<theme>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "modules-reexport::import-meta-url",
      "category": "modules-reexport",
      "code": "// const __filename = new URL(import.meta.url).pathname;\n// const __dirname = new URL('.', import.meta.url).pathname;\n// const workerUrl = new URL('./worker.js', import.meta.url); // implicit file dependency",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<__filename>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new URL(import.meta.url)>",
          "metadata": {
            "constructor": "URL"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<import.meta.url>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<new URL(import.meta.url).pathname>"
        },
        {
          "type": "VARIABLE",
          "id": "<__dirname>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new URL('.', import.meta.url)>",
          "metadata": {
            "constructor": "URL"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'.'>",
          "metadata": {
            "value": ".",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<new URL('.', import.meta.url).pathname>"
        },
        {
          "type": "VARIABLE",
          "id": "<workerUrl>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new URL('./worker.js', import.meta.url)>",
          "metadata": {
            "constructor": "URL"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./worker.js'>",
          "metadata": {
            "value": "./worker.js",
            "literalType": "string"
          }
        },
        {
          "type": "FILE",
          "id": "<./worker.js>",
          "metadata": {
            "path": "./worker.js"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<new URL(import.meta.url)>",
            "dst": "<import.meta.url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new URL('.', import.meta.url)>",
            "dst": "<'.'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new URL('.', import.meta.url)>",
            "dst": "<import.meta.url>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new URL('./worker.js', import.meta.url)>",
            "dst": "<'./worker.js'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new URL('./worker.js', import.meta.url)>",
            "dst": "<import.meta.url>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<__filename>",
            "dst": "<new URL(import.meta.url).pathname>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<__dirname>",
            "dst": "<new URL('.', import.meta.url).pathname>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<workerUrl>",
            "dst": "<new URL('./worker.js', import.meta.url)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new URL(import.meta.url).pathname>",
            "dst": "<new URL(import.meta.url)>",
            "type": "READS_FROM"
          },
          {
            "src": "<new URL('.', import.meta.url).pathname>",
            "dst": "<new URL('.', import.meta.url)>",
            "type": "READS_FROM"
          },
          {
            "src": "<./worker.js>",
            "dst": "<'./worker.js'>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "patterns::spread-calls",
      "category": "patterns",
      "code": "function spreadInCalls() {\n  const args = [1, 2, 3];\n  const max = Math.max(...args);\n  return max;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<spreadInCalls>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<args>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "literalType": "array",
            "elements": [
              1,
              2,
              3
            ]
          }
        },
        {
          "type": "VARIABLE",
          "id": "<max>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.max(...args)>",
          "metadata": {
            "callee": "Math.max",
            "hasSpread": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Math.max>",
          "metadata": {
            "objectName": "Math",
            "propertyName": "max"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...args>",
          "metadata": {
            "operator": "spread"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<spreadInCalls>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadInCalls>",
            "dst": "<max>",
            "type": "CONTAINS"
          },
          {
            "src": "<Math.max(...args)>",
            "dst": "<...args>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<...args>",
            "dst": "<args>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<spreadInCalls>",
            "dst": "<max>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<args>",
            "dst": "<[1, 2, 3]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<max>",
            "dst": "<Math.max(...args)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Math.max(...args)>",
            "dst": "<Math.max>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-assign-nested-target",
      "category": "patterns",
      "code": "function destructureAssignNestedTarget() {\n  const state = { user: { name: 'old' } };\n  let name;\n  ({ user: { name } } = state);\n  return name;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureAssignNestedTarget>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<state>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ user: { name: 'old' } }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'old'>",
          "metadata": {
            "value": "old",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<name>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ user: { name } } = state>",
          "metadata": {
            "expressionType": "assignment",
            "pattern": "destructuring"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<state.user.name>",
          "metadata": {
            "path": "user.name"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureAssignNestedTarget>",
            "dst": "<state>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureAssignNestedTarget>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ user: { name: 'old' } }>",
            "dst": "<'old'>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureAssignNestedTarget>",
            "dst": "<{ user: { name } } = state>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureAssignNestedTarget>",
            "dst": "<name>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<state>",
            "dst": "<{ user: { name: 'old' } }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<name>",
            "dst": "<state.user.name>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ user: { name } } = state>",
            "dst": "<state>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ user: { name } } = state>",
            "dst": "<state.user.name>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::spread-objects",
      "category": "patterns",
      "code": "function spreadInObjects() {\n  const base = { a: 1, b: 2 };\n  const extended = { ...base, c: 3, b: 'overridden' };\n  const clone = { ...base };\n  return { extended, clone };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<spreadInObjects>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<base>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1, b: 2 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<extended>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...base, c: 3, b: 'overridden' }>",
          "metadata": {
            "expressionType": "object-spread"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'overridden'>",
          "metadata": {
            "value": "overridden",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<clone>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...base }>",
          "metadata": {
            "expressionType": "object-spread"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ extended, clone }>",
          "metadata": {
            "expressionType": "object-shorthand"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<spreadInObjects>",
            "dst": "<base>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadInObjects>",
            "dst": "<extended>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadInObjects>",
            "dst": "<clone>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1, b: 2 }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ a: 1, b: 2 }>",
            "dst": "<2>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ ...base, c: 3, b: 'overridden' }>",
            "dst": "<base>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<{ ...base, c: 3, b: 'overridden' }>",
            "dst": "<3>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ ...base, c: 3, b: 'overridden' }>",
            "dst": "<'overridden'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ ...base }>",
            "dst": "<base>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<spreadInObjects>",
            "dst": "<{ extended, clone }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<base>",
            "dst": "<{ a: 1, b: 2 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<extended>",
            "dst": "<{ ...base, c: 3, b: 'overridden' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<clone>",
            "dst": "<{ ...base }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ extended, clone }>",
            "dst": "<extended>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ extended, clone }>",
            "dst": "<clone>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-empty",
      "category": "patterns",
      "code": "function destructureEmpty(obj, iter) {\n  const {} = obj;        // valid  no vars, triggers toString/valueOf\n  const [] = iter;       // valid  consumes iterator, creates nothing\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureEmpty>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<iter>"
        },
        {
          "type": "EXPRESSION",
          "id": "<{} = obj>",
          "metadata": {
            "pattern": "object",
            "empty": true,
            "destructuring": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[] = iter>",
          "metadata": {
            "pattern": "array",
            "empty": true,
            "destructuring": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<destructureEmpty>",
            "type": "DECLARES"
          },
          {
            "src": "<destructureEmpty>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureEmpty>",
            "dst": "<iter>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureEmpty>",
            "dst": "<{} = obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureEmpty>",
            "dst": "<[] = iter>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<{} = obj>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<[] = iter>",
            "dst": "<iter>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::spread-arrays",
      "category": "patterns",
      "code": "function spreadInArrays() {\n  const source = [1, 2, 3];\n  const extended = [0, ...source, 4, 5];\n  const clone = [...source];\n  return { extended, clone };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<spreadInArrays>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<source>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<extended>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[0, ...source, 4, 5]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...source>",
          "metadata": {
            "operator": "spread"
          }
        },
        {
          "type": "LITERAL",
          "id": "<4>",
          "metadata": {
            "value": 4,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<clone>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[...source]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...source:clone>",
          "metadata": {
            "operator": "spread"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ extended, clone }>",
          "metadata": {
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<spreadInArrays>",
            "dst": "<source>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadInArrays>",
            "dst": "<extended>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadInArrays>",
            "dst": "<clone>",
            "type": "CONTAINS"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3]>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[0, ...source, 4, 5]>",
            "dst": "<0>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[0, ...source, 4, 5]>",
            "dst": "<...source>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[0, ...source, 4, 5]>",
            "dst": "<4>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[0, ...source, 4, 5]>",
            "dst": "<5>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<...source>",
            "dst": "<source>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<[...source]>",
            "dst": "<...source:clone>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<...source:clone>",
            "dst": "<source>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<spreadInArrays>",
            "dst": "<{ extended, clone }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ extended, clone }>",
            "dst": "<extended>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ extended, clone }>",
            "dst": "<clone>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<source>",
            "dst": "<[1, 2, 3]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<extended>",
            "dst": "<[0, ...source, 4, 5]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<clone>",
            "dst": "<[...source]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "patterns::destructure-computed-key",
      "category": "patterns",
      "code": "function destructureComputedKey() {\n  const key = 'name';\n  const { [key]: value } = { name: 'Alice' };\n  return value;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureComputedKey>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ [key]: value }>",
          "metadata": {
            "pattern": "object",
            "computedKey": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ name: 'Alice' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Alice'>",
          "metadata": {
            "value": "Alice",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureComputedKey>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureComputedKey>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureComputedKey>",
            "dst": "<{ [key]: value }>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ name: 'Alice' }>",
            "dst": "<'Alice'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<destructureComputedKey>",
            "dst": "<value>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<key>",
            "dst": "<'name'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<{ [key]: value }>",
            "dst": "<{ name: 'Alice' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<{ [key]: value }>",
            "dst": "<value>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<{ [key]: value }>",
            "dst": "<key>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-nested-defaults-combined",
      "category": "patterns",
      "code": "function destructureNestedDefaults() {\n  const { a: { b = 10 } = {} } = {};\n  return b; // 10  default for inner AND outer\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureNestedDefaults>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<destructuring>",
          "metadata": {
            "kind": "const",
            "pattern": "nested-object-destructuring"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object",
            "role": "outer-default"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}:source>",
          "metadata": {
            "value": {},
            "literalType": "object",
            "role": "source"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return b>",
          "metadata": {
            "type": "return"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureNestedDefaults>",
            "dst": "<destructuring>",
            "type": "CONTAINS"
          },
          {
            "src": "<b>",
            "dst": "<10>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<destructuring>",
            "dst": "<{}>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<destructureNestedDefaults>",
            "dst": "<return b>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureNestedDefaults>",
            "dst": "<return b>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<destructuring>",
            "dst": "<b>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructuring>",
            "dst": "<{}:source>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<return b>",
            "dst": "<b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-assign-to-properties",
      "category": "patterns",
      "code": "function destructureAssignToProperties() {\n  const obj = {};\n  ({ a: obj.x, b: obj.y } = { a: 1, b: 2 });\n  return obj; // { x: 1, y: 2 }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureAssignToProperties>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure-assign>",
          "metadata": {
            "expressionType": "destructuring_assignment"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.x>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "x"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.y>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "y"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1, b: 2 }>",
          "metadata": {
            "value": {
              "a": 1,
              "b": 2
            },
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureAssignToProperties>",
            "dst": "<obj>",
            "type": "DECLARES"
          },
          {
            "src": "<destructureAssignToProperties>",
            "dst": "<destructure-assign>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1, b: 2 }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ a: 1, b: 2 }>",
            "dst": "<2>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<destructureAssignToProperties>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<destructure-assign>",
            "dst": "<obj.x>",
            "type": "WRITES_TO"
          },
          {
            "src": "<destructure-assign>",
            "dst": "<obj.y>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.x>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.y>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<destructure-assign>",
            "dst": "<{ a: 1, b: 2 }>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::spread-duplicate-key-override",
      "category": "patterns",
      "code": "function spreadDuplicateKeyOverride(overrides) {\n  // Key 'debug' at positions (1) and (3) with spread between  (3) always wins\n  const config = {\n    debug: false,       // (1) explicit default\n    ...overrides,       // (2) user overrides  may set debug\n    debug: true,        // (3) THIS ALWAYS WINS  overrides the override\n    timestamp: Date.now(),\n  };\n  return config;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<spreadDuplicateKeyOverride>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<overrides>"
        },
        {
          "type": "VARIABLE",
          "id": "<config>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<config-object>"
        },
        {
          "type": "PROPERTY",
          "id": "<debug-1>",
          "metadata": {
            "key": "debug",
            "position": 1
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...overrides>"
        },
        {
          "type": "PROPERTY",
          "id": "<debug-3>",
          "metadata": {
            "key": "debug",
            "position": 3
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<timestamp>",
          "metadata": {
            "key": "timestamp"
          }
        },
        {
          "type": "CALL",
          "id": "<Date.now()>",
          "metadata": {
            "callee": "Date.now"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Date.now>",
          "metadata": {
            "objectName": "Date",
            "propertyName": "now"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<spreadDuplicateKeyOverride>",
            "dst": "<overrides>",
            "type": "CONTAINS"
          },
          {
            "src": "<spreadDuplicateKeyOverride>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<config-object>",
            "dst": "<debug-1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<config-object>",
            "dst": "<...overrides>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<...overrides>",
            "dst": "<overrides>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<config-object>",
            "dst": "<debug-3>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<debug-3>",
            "dst": "<debug-1>",
            "type": "SHADOWS"
          },
          {
            "src": "<config-object>",
            "dst": "<timestamp>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<spreadDuplicateKeyOverride>",
            "dst": "<config>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<config>",
            "dst": "<config-object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<debug-1>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<debug-3>",
            "dst": "<true>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<timestamp>",
            "dst": "<Date.now()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Date.now()>",
            "dst": "<Date.now>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-computed-default-rename",
      "category": "patterns",
      "code": "function destructureComputedDefaultRename() {\n  const key = 'name';\n  const { [key]: renamed = 'anonymous' } = { name: 'Alice' };\n  const { [key]: missing = 'anonymous' } = {};\n  return { renamed, missing };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureComputedDefaultRename>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<renamed>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'anonymous'>",
          "metadata": {
            "value": "anonymous",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure1>",
          "metadata": {
            "type": "destructuring-assignment"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ name: 'Alice' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Alice'>",
          "metadata": {
            "value": "Alice",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<missing>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure2>",
          "metadata": {
            "type": "destructuring-assignment"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ renamed, missing }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureComputedDefaultRename>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureComputedDefaultRename>",
            "dst": "<renamed>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureComputedDefaultRename>",
            "dst": "<destructure1>",
            "type": "CONTAINS"
          },
          {
            "src": "<renamed>",
            "dst": "<'anonymous'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<{ name: 'Alice' }>",
            "dst": "<'Alice'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<destructureComputedDefaultRename>",
            "dst": "<missing>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureComputedDefaultRename>",
            "dst": "<destructure2>",
            "type": "CONTAINS"
          },
          {
            "src": "<missing>",
            "dst": "<'anonymous'>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<destructureComputedDefaultRename>",
            "dst": "<{ renamed, missing }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<key>",
            "dst": "<'name'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<renamed>",
            "dst": "<destructure1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<missing>",
            "dst": "<destructure2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<destructure1>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure1>",
            "dst": "<{ name: 'Alice' }>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure2>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure2>",
            "dst": "<{}>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ renamed, missing }>",
            "dst": "<renamed>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ renamed, missing }>",
            "dst": "<missing>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-nested-rest",
      "category": "patterns",
      "code": "function destructureNestedRest() {\n  const [first, ...[second, ...deep]] = [1, 2, 3, 4, 5];\n  // first=1, second=2, deep=[3,4,5]\n  return { first, second, deep };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureNestedRest>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[first, ...[second, ...deep]]>",
          "metadata": {
            "type": "destructuring_pattern",
            "pattern": "array",
            "nested": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<first>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<second>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<deep>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3, 4, 5]>",
          "metadata": {
            "value": [
              1,
              2,
              3,
              4,
              5
            ],
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<4>",
          "metadata": {
            "value": 4,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ first, second, deep }>",
          "metadata": {
            "type": "object",
            "shorthand": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureNestedRest>",
            "dst": "<[first, ...[second, ...deep]]>",
            "type": "CONTAINS"
          },
          {
            "src": "<[1, 2, 3, 4, 5]>",
            "dst": "<1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3, 4, 5]>",
            "dst": "<2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3, 4, 5]>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3, 4, 5]>",
            "dst": "<4>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[1, 2, 3, 4, 5]>",
            "dst": "<5>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<destructureNestedRest>",
            "dst": "<{ first, second, deep }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<[first, ...[second, ...deep]]>",
            "dst": "<[1, 2, 3, 4, 5]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<first>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<second>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<deep>",
            "dst": "<[3, 4, 5]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ first, second, deep }>",
            "dst": "<first>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, second, deep }>",
            "dst": "<second>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ first, second, deep }>",
            "dst": "<deep>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-dot-notation",
      "category": "property-access",
      "code": "function dotAccess(obj) {\n  const a = obj.name;\n  const b = obj.nested.deep.value;\n  return { a, b };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<dotAccess>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.name>",
          "metadata": {
            "property": "name"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.nested>",
          "metadata": {
            "property": "nested"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.nested.deep>",
          "metadata": {
            "property": "deep"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.nested.deep.value>",
          "metadata": {
            "property": "value"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b }>",
          "metadata": {
            "type": "object",
            "shorthand": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<dotAccess>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<dotAccess>",
            "dst": "<a>",
            "type": "DECLARES"
          },
          {
            "src": "<dotAccess>",
            "dst": "<b>",
            "type": "DECLARES"
          },
          {
            "src": "<dotAccess>",
            "dst": "<{ a, b }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<a>",
            "dst": "<obj.name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<obj.nested.deep.value>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj.name>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.nested>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.nested.deep>",
            "dst": "<obj.nested>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.nested.deep.value>",
            "dst": "<obj.nested.deep>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b }>",
            "dst": "<b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-deep-chain",
      "category": "property-access",
      "code": "function deepChain(root) {\n  return root.level1.level2.level3.value;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deepChain>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<root>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<root.level1>",
          "metadata": {
            "objectName": "root",
            "propertyName": "level1"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<root.level1.level2>",
          "metadata": {
            "objectName": "root.level1",
            "propertyName": "level2"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<root.level1.level2.level3>",
          "metadata": {
            "objectName": "root.level1.level2",
            "propertyName": "level3"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<root.level1.level2.level3.value>",
          "metadata": {
            "objectName": "root.level1.level2.level3",
            "propertyName": "value"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deepChain>",
            "dst": "<root>",
            "type": "CONTAINS"
          },
          {
            "src": "<deepChain>",
            "dst": "<root.level1.level2.level3.value>",
            "type": "RETURNS"
          },
          {
            "src": "<root.level1.level2>",
            "dst": "<root.level1>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<root.level1.level2.level3>",
            "dst": "<root.level1.level2>",
            "type": "CHAINS_FROM"
          },
          {
            "src": "<root.level1.level2.level3.value>",
            "dst": "<root.level1.level2.level3>",
            "type": "CHAINS_FROM"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<root.level1>",
            "dst": "<root>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-dynamic-access",
      "category": "property-access",
      "code": "function dynamicAccess(obj, keys) {\n  const results = {};\n  for (const key of keys) {\n    results[key] = obj[key];\n  }\n  return results;\n}\n\n// --- Property chain ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<dynamicAccess>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<keys>"
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<results[key]>",
          "metadata": {
            "dynamic": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key]>",
          "metadata": {
            "dynamic": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<dynamicAccess>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<dynamicAccess>",
            "dst": "<keys>",
            "type": "CONTAINS"
          },
          {
            "src": "<dynamicAccess>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<dynamicAccess>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<keys>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<dynamicAccess>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<results[key]>",
            "dst": "<obj[key]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<results[key]>",
            "dst": "<results>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<obj[key]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-bracket-notation",
      "category": "property-access",
      "code": "function bracketAccess(obj, key) {\n  const a = obj['name'];\n  const b = obj[key];\n  const c = obj['complex-key'];\n  return { a, b, c };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<bracketAccess>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj['name']>",
          "metadata": {
            "accessType": "bracket",
            "property": "name"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key]>",
          "metadata": {
            "accessType": "bracket",
            "property": "dynamic"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<c>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj['complex-key']>",
          "metadata": {
            "accessType": "bracket",
            "property": "complex-key"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'complex-key'>",
          "metadata": {
            "value": "complex-key",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b, c }>",
          "metadata": {
            "type": "object",
            "shorthand": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<bracketAccess>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAccess>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAccess>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAccess>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAccess>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj['name']>",
            "dst": "<'name'>",
            "type": "USES"
          },
          {
            "src": "<obj[key]>",
            "dst": "<key>",
            "type": "USES"
          },
          {
            "src": "<obj['complex-key']>",
            "dst": "<'complex-key'>",
            "type": "USES"
          },
          {
            "src": "<bracketAccess>",
            "dst": "<{ a, b, c }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<a>",
            "dst": "<obj['name']>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<obj[key]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<c>",
            "dst": "<obj['complex-key']>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj['name']>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj['complex-key']>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<c>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-dot-assign",
      "category": "property-access",
      "code": "function dotAssign(obj) {\n  obj.name = 'new';\n  obj.nested = {};\n  obj.nested.deep = 42;\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<dotAssign>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.name>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "name"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'new'>",
          "metadata": {
            "value": "new",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.nested>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "nested"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.nested.deep>",
          "metadata": {
            "objectName": "obj.nested",
            "propertyName": "deep"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<dotAssign>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<dotAssign>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj.name>",
            "dst": "<'new'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dotAssign>",
            "dst": "<obj.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.nested>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dotAssign>",
            "dst": "<obj.nested>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.nested.deep>",
            "dst": "<42>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dotAssign>",
            "dst": "<obj.nested.deep>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "property-access::prop-object-from-entries",
      "category": "property-access",
      "code": "function fromEntries(entries) {\n  return Object.fromEntries(entries);\n}\n\n// --- Object.assign ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<fromEntries>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<entries>"
        },
        {
          "type": "CALL",
          "id": "<Object.fromEntries(entries)>",
          "metadata": {
            "callee": "Object.fromEntries"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.fromEntries>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "fromEntries"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Object>",
          "metadata": {
            "builtIn": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fromEntries>",
            "dst": "<entries>",
            "type": "HAS_BODY"
          },
          {
            "src": "<fromEntries>",
            "dst": "<Object.fromEntries(entries)>",
            "type": "RETURNS"
          },
          {
            "src": "<Object.fromEntries(entries)>",
            "dst": "<entries>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.fromEntries(entries)>",
            "dst": "<Object.fromEntries>",
            "type": "CALLS"
          },
          {
            "src": "<Object.fromEntries>",
            "dst": "<Object>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-bracket-assign",
      "category": "property-access",
      "code": "function bracketAssign(obj, key, value) {\n  obj[key] = value;\n  obj['fixed-key'] = 'fixed';\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<bracketAssign>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key]>",
          "metadata": {
            "accessType": "bracket",
            "dynamic": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj['fixed-key']>",
          "metadata": {
            "accessType": "bracket",
            "dynamic": false,
            "key": "fixed-key"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'fixed'>",
          "metadata": {
            "value": "fixed",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<bracketAssign>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAssign>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAssign>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<bracketAssign>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj[key]>",
            "dst": "<value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj['fixed-key']>",
            "dst": "<'fixed'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj[key]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key]>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj['fixed-key']>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "patterns::destructure-rest-own-only",
      "category": "patterns",
      "code": "function destructureRestOwnOnly() {\n  const proto = { inherited: 1 };\n  const child = Object.create(proto);\n  child.own = 2;\n  child.also = 3;\n\n  const { own, ...rest } = child;\n  // rest === { also: 3 }  inherited NOT included in rest\n  // But:\n  const { inherited } = child; // 1  named destructuring DOES access prototype\n  return { own, rest, inherited };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureRestOwnOnly>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<proto>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ inherited: 1 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<child>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.create(proto)>",
          "metadata": {
            "callee": "Object.create"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<child.own>",
          "metadata": {
            "objectName": "child",
            "propertyName": "own"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<child.also>",
          "metadata": {
            "objectName": "child",
            "propertyName": "also"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ own, ...rest }>",
          "metadata": {
            "expressionType": "destructuring",
            "hasRest": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<own>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<rest>",
          "metadata": {
            "kind": "const",
            "destructured": true,
            "restParameter": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ inherited }>",
          "metadata": {
            "expressionType": "destructuring",
            "hasRest": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<inherited>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ own, rest, inherited }>",
          "metadata": {
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureRestOwnOnly>",
            "dst": "<proto>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRestOwnOnly>",
            "dst": "<child>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.create(proto)>",
            "dst": "<proto>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<destructureRestOwnOnly>",
            "dst": "<{ own, ...rest }>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRestOwnOnly>",
            "dst": "<{ inherited }>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureRestOwnOnly>",
            "dst": "<{ own, rest, inherited }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<proto>",
            "dst": "<{ inherited: 1 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<child>",
            "dst": "<Object.create(proto)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<child.own>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<child.also>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<own>",
            "dst": "<{ own, ...rest }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<rest>",
            "dst": "<{ own, ...rest }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<inherited>",
            "dst": "<{ inherited }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ own, ...rest }>",
            "dst": "<child>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ inherited }>",
            "dst": "<child>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ own, rest, inherited }>",
            "dst": "<own>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ own, rest, inherited }>",
            "dst": "<rest>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ own, rest, inherited }>",
            "dst": "<inherited>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-object-keys",
      "category": "property-access",
      "code": "function objectEnumeration(obj) {\n  const keys = Object.keys(obj);\n  const values = Object.values(obj);\n  const entries = Object.entries(obj);\n  return { keys, values, entries };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<objectEnumeration>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<keys>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.keys(obj)>",
          "metadata": {
            "callee": "Object.keys"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.keys>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "keys"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<values>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.values(obj)>",
          "metadata": {
            "callee": "Object.values"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.values>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "values"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<entries>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.entries(obj)>",
          "metadata": {
            "callee": "Object.entries"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.entries>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "entries"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ keys, values, entries }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<objectEnumeration>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectEnumeration>",
            "dst": "<keys>",
            "type": "DECLARES"
          },
          {
            "src": "<Object.keys(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<objectEnumeration>",
            "dst": "<values>",
            "type": "DECLARES"
          },
          {
            "src": "<Object.values(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<objectEnumeration>",
            "dst": "<entries>",
            "type": "DECLARES"
          },
          {
            "src": "<Object.entries(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<objectEnumeration>",
            "dst": "<{ keys, values, entries }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<keys>",
            "dst": "<Object.keys(obj)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<values>",
            "dst": "<Object.values(obj)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<entries>",
            "dst": "<Object.entries(obj)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Object.keys(obj)>",
            "dst": "<Object.keys>",
            "type": "CALLS"
          },
          {
            "src": "<Object.values(obj)>",
            "dst": "<Object.values>",
            "type": "CALLS"
          },
          {
            "src": "<Object.entries(obj)>",
            "dst": "<Object.entries>",
            "type": "CALLS"
          },
          {
            "src": "<{ keys, values, entries }>",
            "dst": "<keys>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ keys, values, entries }>",
            "dst": "<values>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ keys, values, entries }>",
            "dst": "<entries>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-freeze",
      "category": "property-access",
      "code": "function frozen() {\n  const obj = { a: 1, b: { c: 2 } };\n  Object.freeze(obj);\n  obj.a = 999;       // silently fails (or throws in strict)\n  obj.b.c = 999;     // succeeds  shallow freeze\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<frozen>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1, b: { c: 2 } }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ c: 2 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.freeze(obj)>",
          "metadata": {
            "callee": "Object.freeze"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.a>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "a"
          }
        },
        {
          "type": "LITERAL",
          "id": "<999>",
          "metadata": {
            "value": 999,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.b.c>",
          "metadata": {
            "objectName": "obj.b",
            "propertyName": "c"
          }
        },
        {
          "type": "LITERAL",
          "id": "<999-2>",
          "metadata": {
            "value": 999,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<frozen>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1, b: { c: 2 } }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ a: 1, b: { c: 2 } }>",
            "dst": "<{ c: 2 }>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ c: 2 }>",
            "dst": "<2>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<frozen>",
            "dst": "<Object.freeze(obj)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.freeze(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<frozen>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{ a: 1, b: { c: 2 } }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.a>",
            "dst": "<999>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.b.c>",
            "dst": "<999-2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj.a>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.b.c>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-structured-clone",
      "category": "property-access",
      "code": "function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Getter/setter side effects ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deepClone>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<structuredClone(obj)>",
          "metadata": {
            "callee": "structuredClone"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<structuredClone>",
          "metadata": {
            "global": true,
            "builtin": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deepClone>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<deepClone>",
            "dst": "<structuredClone(obj)>",
            "type": "RETURNS"
          },
          {
            "src": "<structuredClone(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<structuredClone(obj)>",
            "dst": "<structuredClone>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-optional-chain-mixed",
      "category": "property-access",
      "code": "function optionalChainMixed(obj) {\n  const a = obj?.level1?.level2;\n  const b = obj?.['dynamic-key']?.value;\n  const c = obj?.method?.();\n  const d = obj?.arr?.[0]?.name;\n  return { a, b, c, d };\n}\n\n// --- Property assignment patterns ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<optionalChainMixed>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj?.level1?.level2>",
          "metadata": {
            "optional": true,
            "chain": [
              "level1",
              "level2"
            ]
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj?.['dynamic-key']?.value>",
          "metadata": {
            "optional": true,
            "computed": true,
            "chain": [
              "dynamic-key",
              "value"
            ]
          }
        },
        {
          "type": "LITERAL",
          "id": "<'dynamic-key'>",
          "metadata": {
            "value": "dynamic-key",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<c>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<obj?.method?.()>",
          "metadata": {
            "optional": true,
            "callee": "method"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<d>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj?.arr?.[0]?.name>",
          "metadata": {
            "optional": true,
            "computed": true,
            "chain": [
              "arr",
              "0",
              "name"
            ]
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b, c, d }>",
          "metadata": {
            "type": "object",
            "shorthand": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<optionalChainMixed>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChainMixed>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChainMixed>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj?.['dynamic-key']?.value>",
            "dst": "<'dynamic-key'>",
            "type": "USES"
          },
          {
            "src": "<optionalChainMixed>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChainMixed>",
            "dst": "<d>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj?.arr?.[0]?.name>",
            "dst": "<0>",
            "type": "USES"
          },
          {
            "src": "<optionalChainMixed>",
            "dst": "<{ a, b, c, d }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<a>",
            "dst": "<obj?.level1?.level2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<obj?.['dynamic-key']?.value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<c>",
            "dst": "<obj?.method?.()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<d>",
            "dst": "<obj?.arr?.[0]?.name>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj?.level1?.level2>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj?.['dynamic-key']?.value>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj?.method?.()>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj?.arr?.[0]?.name>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c, d }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c, d }>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c, d }>",
            "dst": "<c>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c, d }>",
            "dst": "<d>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-seal",
      "category": "property-access",
      "code": "function sealed() {\n  const obj = { a: 1 };\n  Object.seal(obj);\n  obj.a = 2;         // allowed  existing property\n  obj.b = 3;         // silently fails  no new properties\n  delete obj.a;      // silently fails  cannot delete\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sealed>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.seal(obj)>",
          "metadata": {
            "callee": "Object.seal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.a>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "a"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.b>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "b"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<delete obj.a>",
          "metadata": {
            "operator": "delete"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<sealed>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1 }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Object.seal(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<sealed>",
            "dst": "<Object.seal(obj)>",
            "type": "CONTAINS"
          },
          {
            "src": "<sealed>",
            "dst": "<delete obj.a>",
            "type": "CONTAINS"
          },
          {
            "src": "<sealed>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{ a: 1 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.a>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.b>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<delete obj.a>",
            "dst": "<obj.a>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-delete",
      "category": "property-access",
      "code": "function propertyDeletion(obj) {\n  const hadKey = 'key' in obj;\n  delete obj.key;\n  const hasKey = 'key' in obj;\n  return { hadKey, hasKey };\n}\n\n// --- Property enumeration order ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<propertyDeletion>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<hadKey>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'key' in obj>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'key'>",
          "metadata": {
            "value": "key",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<delete obj.key>",
          "metadata": {
            "operator": "delete"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.key>",
          "metadata": {
            "property": "key"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasKey>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'key' in obj_2>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'key'_2>",
          "metadata": {
            "value": "key",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ hadKey, hasKey }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<propertyDeletion>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<propertyDeletion>",
            "dst": "<hadKey>",
            "type": "CONTAINS"
          },
          {
            "src": "<delete obj.key>",
            "dst": "<obj.key>",
            "type": "DELETES"
          },
          {
            "src": "<propertyDeletion>",
            "dst": "<hasKey>",
            "type": "CONTAINS"
          },
          {
            "src": "<propertyDeletion>",
            "dst": "<{ hadKey, hasKey }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<hadKey>",
            "dst": "<'key' in obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasKey>",
            "dst": "<'key' in obj_2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<'key' in obj>",
            "dst": "<'key'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'key' in obj>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.key>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<'key' in obj_2>",
            "dst": "<'key'_2>",
            "type": "READS_FROM"
          },
          {
            "src": "<'key' in obj_2>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ hadKey, hasKey }>",
            "dst": "<hadKey>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ hadKey, hasKey }>",
            "dst": "<hasKey>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-prevent-extensions",
      "category": "property-access",
      "code": "function preventExtensions() {\n  const obj = { a: 1 };\n  Object.preventExtensions(obj);\n  obj.b = 2;         // silently fails\n  obj.a = 99;        // allowed\n  delete obj.a;      // allowed\n  return obj;\n}\n\n// --- Property existence checks ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<preventExtensions>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<a>",
          "metadata": {
            "key": "a"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.preventExtensions(obj)>",
          "metadata": {
            "callee": "Object.preventExtensions"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.preventExtensions>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "preventExtensions"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.b>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "b"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.a>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "a"
          }
        },
        {
          "type": "LITERAL",
          "id": "<99>",
          "metadata": {
            "value": 99,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<delete obj.a>",
          "metadata": {
            "operator": "delete"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<preventExtensions>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1 }>",
            "dst": "<a>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Object.preventExtensions(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<preventExtensions>",
            "dst": "<Object.preventExtensions(obj)>",
            "type": "CONTAINS"
          },
          {
            "src": "<preventExtensions>",
            "dst": "<delete obj.a>",
            "type": "CONTAINS"
          },
          {
            "src": "<preventExtensions>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{ a: 1 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.b>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<preventExtensions>",
            "dst": "<obj.b>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.a>",
            "dst": "<99>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<preventExtensions>",
            "dst": "<obj.a>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<Object.preventExtensions(obj)>",
            "dst": "<Object.preventExtensions>",
            "type": "CALLS"
          },
          {
            "src": "<delete obj.a>",
            "dst": "<obj.a>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-compound-assign",
      "category": "property-access",
      "code": "function compoundPropertyAssign(obj) {\n  obj.count += 1;\n  obj.total -= 5;\n  obj.name += ' suffix';\n  obj.flags |= 0x04;\n  obj.mask &= 0xff;\n  return obj;\n}\n\n// --- Object.keys / values / entries ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<compoundPropertyAssign>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.count>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "count"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj.count += 1>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.total>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "total"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj.total -= 5>",
          "metadata": {
            "operator": "-="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.name>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "name"
          }
        },
        {
          "type": "LITERAL",
          "id": "<' suffix'>",
          "metadata": {
            "value": " suffix",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj.name += ' suffix'>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.flags>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "flags"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0x04>",
          "metadata": {
            "value": 4,
            "literalType": "number",
            "representation": "hex"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj.flags |= 0x04>",
          "metadata": {
            "operator": "|="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.mask>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "mask"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0xff>",
          "metadata": {
            "value": 255,
            "literalType": "number",
            "representation": "hex"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj.mask &= 0xff>",
          "metadata": {
            "operator": "&="
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj.count += 1>",
            "type": "CONTAINS"
          },
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj.total -= 5>",
            "type": "CONTAINS"
          },
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj.name += ' suffix'>",
            "type": "CONTAINS"
          },
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj.flags |= 0x04>",
            "type": "CONTAINS"
          },
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj.mask &= 0xff>",
            "type": "CONTAINS"
          },
          {
            "src": "<compoundPropertyAssign>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj.count += 1>",
            "dst": "<obj.count>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.total -= 5>",
            "dst": "<obj.total>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.name += ' suffix'>",
            "dst": "<obj.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.flags |= 0x04>",
            "dst": "<obj.flags>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.mask &= 0xff>",
            "dst": "<obj.mask>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<obj.count += 1>",
            "dst": "<obj.count>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.count += 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.total -= 5>",
            "dst": "<obj.total>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.total -= 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.name += ' suffix'>",
            "dst": "<obj.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.name += ' suffix'>",
            "dst": "<' suffix'>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.flags |= 0x04>",
            "dst": "<obj.flags>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.flags |= 0x04>",
            "dst": "<0x04>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.mask &= 0xff>",
            "dst": "<obj.mask>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.mask &= 0xff>",
            "dst": "<0xff>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-circular-object",
      "category": "property-access",
      "code": "function circularObject() {\n  const a = {};\n  const b = { ref: a };\n  a.ref = b;\n  return a;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<circularObject>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ ref: a }>",
          "metadata": {
            "value": "{ ref: a }",
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<a.ref>",
          "metadata": {
            "objectName": "a",
            "propertyName": "ref"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<circularObject>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<circularObject>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<circularObject>",
            "dst": "<a>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<a>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<{ ref: a }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<a.ref>",
            "dst": "<b>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<circularObject>",
            "dst": "<a.ref>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<{ ref: a }>",
            "dst": "<a>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-object-assign",
      "category": "property-access",
      "code": "function objectAssign() {\n  const target = { a: 1 };\n  const source1 = { b: 2 };\n  const source2 = { c: 3, a: 'overridden' };\n  return Object.assign(target, source1, source2);\n}\n\n// --- Object.freeze / seal / preventExtensions ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<objectAssign>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<target>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ a: 1 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<target.a>",
          "metadata": {
            "key": "a"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<source1>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ b: 2 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<source1.b>",
          "metadata": {
            "key": "b"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<source2>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ c: 3, a: 'overridden' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<source2.c>",
          "metadata": {
            "key": "c"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<source2.a>",
          "metadata": {
            "key": "a"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'overridden'>",
          "metadata": {
            "value": "overridden",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.assign(target, source1, source2)>",
          "metadata": {
            "callee": "Object.assign"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.assign>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "assign"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<objectAssign>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectAssign>",
            "dst": "<source1>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectAssign>",
            "dst": "<source2>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ a: 1 }>",
            "dst": "<target.a>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ b: 2 }>",
            "dst": "<source1.b>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ c: 3, a: 'overridden' }>",
            "dst": "<source2.c>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ c: 3, a: 'overridden' }>",
            "dst": "<source2.a>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Object.assign(target, source1, source2)>",
            "dst": "<target>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.assign(target, source1, source2)>",
            "dst": "<source1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.assign(target, source1, source2)>",
            "dst": "<source2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<objectAssign>",
            "dst": "<Object.assign(target, source1, source2)>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<target>",
            "dst": "<{ a: 1 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<target.a>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<source1>",
            "dst": "<{ b: 2 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<source1.b>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<source2>",
            "dst": "<{ c: 3, a: 'overridden' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<source2.c>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<source2.a>",
            "dst": "<'overridden'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Object.assign(target, source1, source2)>",
            "dst": "<Object.assign>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-proto-direct",
      "category": "property-access",
      "code": "function protoDirectAssign() {\n  const obj = {};\n  obj.__proto__ = { inherited: true };\n  return obj.inherited;\n}\n\n// --- Null-prototype dictionary ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<protoDirectAssign>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.__proto__>",
          "metadata": {
            "property": "__proto__"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ inherited: true }>",
          "metadata": {
            "value": "{ inherited: true }",
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.inherited>",
          "metadata": {
            "property": "inherited"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<protoDirectAssign>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<protoDirectAssign>",
            "dst": "<obj.inherited>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.__proto__>",
            "dst": "<{ inherited: true }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<protoDirectAssign>",
            "dst": "<obj.__proto__>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<protoDirectAssign>",
            "dst": "<obj.inherited>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::builtin-globalthis",
      "category": "builtins",
      "code": "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<globalThisAccess>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<g>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<globalThis>",
          "metadata": {
            "builtinType": "global"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasConsole>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'console' in globalThis>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'console'>",
          "metadata": {
            "value": "console",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ g, hasConsole }>",
          "metadata": {
            "type": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<globalThisAccess>",
            "dst": "<g>",
            "type": "CONTAINS"
          },
          {
            "src": "<globalThisAccess>",
            "dst": "<hasConsole>",
            "type": "CONTAINS"
          },
          {
            "src": "<globalThisAccess>",
            "dst": "<{ g, hasConsole }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<g>",
            "dst": "<globalThis>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasConsole>",
            "dst": "<'console' in globalThis>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<'console' in globalThis>",
            "dst": "<'console'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'console' in globalThis>",
            "dst": "<globalThis>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ g, hasConsole }>",
            "dst": "<g>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ g, hasConsole }>",
            "dst": "<hasConsole>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-enumeration-order",
      "category": "property-access",
      "code": "function enumerationOrder() {\n  const obj = {};\n  obj.b = 1;\n  obj.a = 2;\n  obj[1] = 3;\n  obj[0] = 4;\n  obj.c = 5;\n  // Integer keys first (sorted), then string keys (insertion order)\n  return Object.keys(obj); // ['0', '1', 'b', 'a', 'c']\n}\n\n// --- Getter/setter via Object.defineProperty ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<enumerationOrder>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.b>",
          "metadata": {
            "property": "b",
            "accessType": "assignment"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.a>",
          "metadata": {
            "property": "a",
            "accessType": "assignment"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[1]>",
          "metadata": {
            "property": "1",
            "accessType": "assignment",
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[0]>",
          "metadata": {
            "property": "0",
            "accessType": "assignment",
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<4>",
          "metadata": {
            "value": 4,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.c>",
          "metadata": {
            "property": "c",
            "accessType": "assignment"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.keys(obj)>",
          "metadata": {
            "callee": "Object.keys"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.keys>",
          "metadata": {
            "property": "keys",
            "accessType": "read"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<enumerationOrder>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.keys(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<enumerationOrder>",
            "dst": "<Object.keys(obj)>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.b>",
            "dst": "<obj>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.b>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.a>",
            "dst": "<obj>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.a>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj[1]>",
            "dst": "<obj>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj[1]>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj[0]>",
            "dst": "<obj>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj[0]>",
            "dst": "<4>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.c>",
            "dst": "<obj>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.c>",
            "dst": "<5>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Object.keys(obj)>",
            "dst": "<Object.keys>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-symbol-key",
      "category": "property-access",
      "code": "function symbolKey() {\n  const sym = Symbol('myKey');\n  const obj = { [sym]: 'symbol value' };\n  return obj[sym];\n}\n\n// --- __proto__ direct assignment ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<symbolKey>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<sym>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Symbol('myKey')>",
          "metadata": {
            "callee": "Symbol"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'myKey'>",
          "metadata": {
            "value": "myKey",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ [sym]: 'symbol value' }>",
          "metadata": {
            "expressionType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<[sym]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'symbol value'>",
          "metadata": {
            "value": "symbol value",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[sym]>",
          "metadata": {
            "computed": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<symbolKey>",
            "dst": "<sym>",
            "type": "CONTAINS"
          },
          {
            "src": "<symbolKey>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<Symbol('myKey')>",
            "dst": "<'myKey'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<{ [sym]: 'symbol value' }>",
            "dst": "<[sym]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<symbolKey>",
            "dst": "<obj[sym]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<sym>",
            "dst": "<Symbol('myKey')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<{ [sym]: 'symbol value' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<[sym]>",
            "dst": "<'symbol value'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<[sym]>",
            "dst": "<sym>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[sym]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[sym]>",
            "dst": "<sym>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-define-accessor",
      "category": "property-access",
      "code": "function defineAccessor() {\n  const obj = { _value: 0 };\n  Object.defineProperty(obj, 'value', {\n    get() { return this._value; },\n    set(v) { this._value = Math.max(0, v); },\n    enumerable: true,\n  });\n  return obj;\n}\n\n// --- Object.is ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<defineAccessor>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ _value: 0 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.defineProperty(obj, 'value', {...})>",
          "metadata": {
            "callee": "Object.defineProperty"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Object.defineProperty>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'value'>",
          "metadata": {
            "value": "value",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<descriptor>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "GETTER",
          "id": "<get>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this._value>",
          "metadata": {
            "objectName": "this",
            "propertyName": "_value"
          }
        },
        {
          "type": "SETTER",
          "id": "<set>"
        },
        {
          "type": "PARAMETER",
          "id": "<v>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this._value_assign>",
          "metadata": {
            "objectName": "this",
            "propertyName": "_value"
          }
        },
        {
          "type": "CALL",
          "id": "<Math.max(0, v)>",
          "metadata": {
            "callee": "Math.max"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<Math.max>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<defineAccessor>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ _value: 0 }>",
            "dst": "<0>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<defineAccessor>",
            "dst": "<Object.defineProperty(obj, 'value', {...})>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.defineProperty(obj, 'value', {...})>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperty(obj, 'value', {...})>",
            "dst": "<'value'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperty(obj, 'value', {...})>",
            "dst": "<descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<descriptor>",
            "dst": "<get>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<descriptor>",
            "dst": "<set>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<descriptor>",
            "dst": "<true>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<get>",
            "dst": "<this._value>",
            "type": "RETURNS"
          },
          {
            "src": "<set>",
            "dst": "<v>",
            "type": "CONTAINS"
          },
          {
            "src": "<Math.max(0, v)>",
            "dst": "<0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Math.max(0, v)>",
            "dst": "<v>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<defineAccessor>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<{ _value: 0 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this._value_assign>",
            "dst": "<Math.max(0, v)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<set>",
            "dst": "<this._value_assign>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<Object.defineProperty(obj, 'value', {...})>",
            "dst": "<Object.defineProperty>",
            "type": "CALLS"
          },
          {
            "src": "<Math.max(0, v)>",
            "dst": "<Math.max>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-object-is",
      "category": "property-access",
      "code": "function objectIsComparison() {\n  const a = Object.is(NaN, NaN);       // true (unlike ===)\n  const b = Object.is(0, -0);          // false (unlike ===)\n  const c = Object.is(1, 1);           // true\n  return { a, b, c };\n}\n\n// --- structuredClone ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<objectIsComparison>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.is(NaN, NaN)>",
          "metadata": {
            "callee": "Object.is"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.is>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "is"
          }
        },
        {
          "type": "LITERAL",
          "id": "<NaN>",
          "metadata": {
            "value": "NaN",
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.is(0, -0)>",
          "metadata": {
            "callee": "Object.is"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<-0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<c>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.is(1, 1)>",
          "metadata": {
            "callee": "Object.is"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b, c }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<objectIsComparison>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectIsComparison>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<objectIsComparison>",
            "dst": "<c>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.is(NaN, NaN)>",
            "dst": "<NaN>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.is(NaN, NaN)>",
            "dst": "<NaN>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.is(0, -0)>",
            "dst": "<0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.is(0, -0)>",
            "dst": "<-0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.is(1, 1)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.is(1, 1)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<objectIsComparison>",
            "dst": "<{ a, b, c }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<a>",
            "dst": "<Object.is(NaN, NaN)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<b>",
            "dst": "<Object.is(0, -0)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<c>",
            "dst": "<Object.is(1, 1)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Object.is(NaN, NaN)>",
            "dst": "<Object.is>",
            "type": "CALLS"
          },
          {
            "src": "<Object.is(0, -0)>",
            "dst": "<Object.is>",
            "type": "CALLS"
          },
          {
            "src": "<Object.is(1, 1)>",
            "dst": "<Object.is>",
            "type": "CALLS"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<b>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b, c }>",
            "dst": "<c>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::optional-chaining-delete",
      "category": "property-access",
      "code": "function optionalChainingDelete(obj) {\n  const result = delete obj?.prop; // true if obj is nullish (no-op), normal delete otherwise\n  return result;\n}\n\n// --- Getter side effects in destructuring and spread ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<optionalChainingDelete>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<delete obj?.prop>",
          "metadata": {
            "expressionType": "delete",
            "optionalChaining": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj?.prop>",
          "metadata": {
            "property": "prop",
            "optional": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<optionalChainingDelete>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<optionalChainingDelete>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<delete obj?.prop>",
            "dst": "<obj?.prop>",
            "type": "DELETES"
          },
          {
            "src": "<optionalChainingDelete>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<delete obj?.prop>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj?.prop>",
            "dst": "<obj>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-circular-class",
      "category": "property-access",
      "code": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n}\n\n// --- Symbol as property key ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<TreeNode>"
        },
        {
          "type": "METHOD",
          "id": "<TreeNode.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.value>",
          "metadata": {
            "objectName": "this",
            "propertyName": "value"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.parent>",
          "metadata": {
            "objectName": "this",
            "propertyName": "parent"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.children>",
          "metadata": {
            "objectName": "this",
            "propertyName": "children"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        },
        {
          "type": "METHOD",
          "id": "<TreeNode.addChild>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<child>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<child.parent>",
          "metadata": {
            "objectName": "child",
            "propertyName": "parent"
          }
        },
        {
          "type": "CALL",
          "id": "<this.children.push(child)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.children.push>",
          "metadata": {
            "objectName": "this.children",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<TreeNode>",
            "dst": "<TreeNode.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<TreeNode>",
            "dst": "<TreeNode.addChild>",
            "type": "CONTAINS"
          },
          {
            "src": "<TreeNode.constructor>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<TreeNode.addChild>",
            "dst": "<child>",
            "type": "CONTAINS"
          },
          {
            "src": "<TreeNode.addChild>",
            "dst": "<this.children.push(child)>",
            "type": "CONTAINS"
          },
          {
            "src": "<this.children.push(child)>",
            "dst": "<child>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<TreeNode.constructor>",
            "dst": "<this.value>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.value>",
            "dst": "<value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<TreeNode.constructor>",
            "dst": "<this.parent>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.parent>",
            "dst": "<null>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<TreeNode.constructor>",
            "dst": "<this.children>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.children>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<TreeNode.addChild>",
            "dst": "<child.parent>",
            "type": "WRITES_TO"
          },
          {
            "src": "<child.parent>",
            "dst": "<TreeNode.addChild>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this.children.push(child)>",
            "dst": "<this.children.push>",
            "type": "CALLS"
          },
          {
            "src": "<this.children.push>",
            "dst": "<this.children>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-null-proto-dict",
      "category": "property-access",
      "code": "function nullPrototypeDict() {\n  const dict = Object.create(null);\n  dict['key with spaces'] = 1;\n  dict['another-key'] = 2;\n  return dict;\n}\n\n// --- Proxy handler traps (full set) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<nullPrototypeDict>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<dict>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.create(null)>",
          "metadata": {
            "callee": "Object.create"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.create>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "create"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<dict['key with spaces']>",
          "metadata": {
            "objectName": "dict",
            "propertyName": "key with spaces",
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'key with spaces'>",
          "metadata": {
            "value": "key with spaces",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<dict['another-key']>",
          "metadata": {
            "objectName": "dict",
            "propertyName": "another-key",
            "computed": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'another-key'>",
          "metadata": {
            "value": "another-key",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<nullPrototypeDict>",
            "dst": "<dict>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.create(null)>",
            "dst": "<null>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<nullPrototypeDict>",
            "dst": "<dict>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<dict>",
            "dst": "<Object.create(null)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dict['key with spaces']>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<dict['another-key']>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Object.create(null)>",
            "dst": "<Object.create>",
            "type": "CALLS"
          },
          {
            "src": "<dict['key with spaces']>",
            "dst": "<dict>",
            "type": "READS_FROM"
          },
          {
            "src": "<dict['another-key']>",
            "dst": "<dict>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-getter-only-no-setter",
      "category": "property-access",
      "code": "function getterOnlyNoSetter() {\n  const obj = {\n    get value() { return 42; },\n  };\n  obj.value = 99; // silently fails in sloppy, throws in strict\n  return obj.value; // still 42\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getterOnlyNoSetter>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj-literal>"
        },
        {
          "type": "GETTER",
          "id": "<value-getter>",
          "metadata": {
            "propertyName": "value"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.value-write>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "value",
            "operation": "write"
          }
        },
        {
          "type": "LITERAL",
          "id": "<99>",
          "metadata": {
            "value": 99,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.value-read>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "value",
            "operation": "read"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getterOnlyNoSetter>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj-literal>",
            "dst": "<value-getter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<value-getter>",
            "dst": "<42>",
            "type": "RETURNS"
          },
          {
            "src": "<getterOnlyNoSetter>",
            "dst": "<obj.value-read>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<obj-literal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.value-write>",
            "dst": "<99>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj.value-write>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.value-read>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.value-read>",
            "dst": "<value-getter>",
            "type": "INVOKES"
          }
        ]
      }
    },
    {
      "constructId": "property-access::delete-array-hole",
      "category": "property-access",
      "code": "function deleteArrayHole(arr) {\n  delete arr[1];                 // creates a HOLE  arr.length unchanged\n  return arr;                    // [1, empty, 3] if arr was [1, 2, 3]\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deleteArrayHole>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<arr>"
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<delete arr[1]>",
          "metadata": {
            "operation": "delete",
            "target": "array element"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<arr[1]>",
          "metadata": {
            "accessType": "bracket",
            "property": "1"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deleteArrayHole>",
            "dst": "<arr>",
            "type": "DECLARES"
          },
          {
            "src": "<deleteArrayHole>",
            "dst": "<delete arr[1]>",
            "type": "CONTAINS"
          },
          {
            "src": "<delete arr[1]>",
            "dst": "<arr[1]>",
            "type": "DELETES"
          },
          {
            "src": "<arr[1]>",
            "dst": "<1>",
            "type": "USES"
          },
          {
            "src": "<deleteArrayHole>",
            "dst": "<arr>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<arr[1]>",
            "dst": "<arr>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-getter-side-effect",
      "category": "property-access",
      "code": "function getterSideEffect() {\n  let callCount = 0;\n  const obj = {\n    get value() {\n      callCount++;\n      return 42;\n    },\n    set value(v) {\n      console.log('set to', v);\n    },\n  };\n  const x = obj.value;   // triggers getter  side effect\n  obj.value = 10;         // triggers setter  side effect\n  return { x, callCount };\n}\n\n// --- Circular references ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getterSideEffect>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<callCount>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj:object>"
        },
        {
          "type": "GETTER",
          "id": "<obj.value:getter>"
        },
        {
          "type": "SETTER",
          "id": "<obj.value:setter>"
        },
        {
          "type": "PARAMETER",
          "id": "<v>"
        },
        {
          "type": "EXPRESSION",
          "id": "<callCount++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log('set to', v)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'set to'>",
          "metadata": {
            "value": "set to",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.value:read>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "value",
            "accessType": "read"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.value:write>",
          "metadata": {
            "objectName": "obj",
            "propertyName": "value",
            "accessType": "write"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getterSideEffect>",
            "dst": "<callCount>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterSideEffect>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj:object>",
            "dst": "<obj.value:getter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<obj:object>",
            "dst": "<obj.value:setter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<obj.value:getter>",
            "dst": "<callCount++>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj.value:getter>",
            "dst": "<42>",
            "type": "RETURNS"
          },
          {
            "src": "<obj.value:setter>",
            "dst": "<v>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj.value:setter>",
            "dst": "<console.log('set to', v)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log('set to', v)>",
            "dst": "<'set to'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.log('set to', v)>",
            "dst": "<v>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getterSideEffect>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterSideEffect>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<x>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<callCount>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<callCount>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<obj:object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<callCount++>",
            "dst": "<callCount>",
            "type": "MODIFIES"
          },
          {
            "src": "<x>",
            "dst": "<obj.value:read>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.value:write>",
            "dst": "<obj>",
            "type": "WRITES_TO"
          },
          {
            "src": "<obj.value:write>",
            "dst": "<10>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj.value:read>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj.value:read>",
            "dst": "<obj.value:getter>",
            "type": "INVOKES"
          },
          {
            "src": "<obj.value:write>",
            "dst": "<obj.value:setter>",
            "type": "INVOKES"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-static-method",
      "category": "prototypes",
      "code": "Person.create = function (name, age) {\n  return new Person(name, age);\n};\n\n// --- Prototypal inheritance ---",
      "expectedNodes": [
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Person.create>",
          "metadata": {
            "objectName": "Person",
            "propertyName": "create"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Person.create:fn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PARAMETER",
          "id": "<age>"
        },
        {
          "type": "CALL",
          "id": "<new Person(name, age)>",
          "metadata": {
            "callee": "Person",
            "isConstructorCall": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Person.create:fn>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<Person.create:fn>",
            "dst": "<age>",
            "type": "CONTAINS"
          },
          {
            "src": "<Person.create:fn>",
            "dst": "<new Person(name, age)>",
            "type": "RETURNS"
          },
          {
            "src": "<new Person(name, age)>",
            "dst": "<name>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Person(name, age)>",
            "dst": "<age>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<Person.create>",
            "dst": "<Person.create:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new Person(name, age)>",
            "dst": "<Person>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "property-access::delete-computed-property",
      "category": "property-access",
      "code": "function deleteComputed(obj, key) {\n  delete obj[key];               // computed delete  property name unknown at parse time\n  delete obj[key.toUpperCase()]; // delete with expression in key\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deleteComputed>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<key>"
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<delete obj[key]>",
          "metadata": {
            "operation": "delete",
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<delete obj[key.toUpperCase()]>",
          "metadata": {
            "operation": "delete",
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key.toUpperCase()]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "CALL",
          "id": "<key.toUpperCase()>",
          "metadata": {
            "callee": "toUpperCase"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<key.toUpperCase>",
          "metadata": {
            "computed": false,
            "property": "toUpperCase"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deleteComputed>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<deleteComputed>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<deleteComputed>",
            "dst": "<delete obj[key]>",
            "type": "CONTAINS"
          },
          {
            "src": "<deleteComputed>",
            "dst": "<delete obj[key.toUpperCase()]>",
            "type": "CONTAINS"
          },
          {
            "src": "<delete obj[key]>",
            "dst": "<obj[key]>",
            "type": "DELETES"
          },
          {
            "src": "<delete obj[key.toUpperCase()]>",
            "dst": "<obj[key.toUpperCase()]>",
            "type": "DELETES"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<obj[key]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key]>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key.toUpperCase()]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key.toUpperCase()]>",
            "dst": "<key.toUpperCase()>",
            "type": "READS_FROM"
          },
          {
            "src": "<key.toUpperCase()>",
            "dst": "<key.toUpperCase>",
            "type": "CALLS"
          },
          {
            "src": "<key.toUpperCase>",
            "dst": "<key>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-object-create-null",
      "category": "prototypes",
      "code": "const nullProto = Object.create(null);\nnullProto.key = 'value';\n\n// --- Prototype chain inspection ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<nullProto>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.create(null)>",
          "metadata": {
            "callee": "Object.create"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.create>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "create"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<nullProto.key>",
          "metadata": {
            "objectName": "nullProto",
            "propertyName": "key"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'value'>",
          "metadata": {
            "value": "value",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<nullProto>",
            "type": "DECLARES"
          },
          {
            "src": "<Object.create(null)>",
            "dst": "<null>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<nullProto>",
            "dst": "<Object.create(null)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<nullProto.key>",
            "dst": "<'value'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<MODULE>",
            "dst": "<nullProto.key>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<Object.create(null)>",
            "dst": "<Object.create>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-constructor-function",
      "category": "prototypes",
      "code": "function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function () {\n  return `Hi, I'm ${this.name}`;\n};\n\nPerson.prototype.toString = function () {\n  return `Person(${this.name}, ${this.age})`;\n};",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<Person>",
          "metadata": {
            "constructorFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PARAMETER",
          "id": "<age>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.age>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Person.prototype>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Person.prototype.greet>"
        },
        {
          "type": "FUNCTION",
          "id": "<greet:fn>",
          "metadata": {
            "prototypeMethod": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Hi, I'm ${this.name}`>",
          "metadata": {
            "templateLiteral": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Person.prototype.toString>"
        },
        {
          "type": "FUNCTION",
          "id": "<toString:fn>",
          "metadata": {
            "prototypeMethod": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Person(${this.name}, ${this.age})`>",
          "metadata": {
            "templateLiteral": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Person>",
            "dst": "<name>",
            "type": "HAS_BODY"
          },
          {
            "src": "<Person>",
            "dst": "<age>",
            "type": "HAS_BODY"
          },
          {
            "src": "<greet:fn>",
            "dst": "<`Hi, I'm ${this.name}`>",
            "type": "RETURNS"
          },
          {
            "src": "<toString:fn>",
            "dst": "<`Person(${this.name}, ${this.age})`>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Person>",
            "dst": "<this.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Person>",
            "dst": "<this.age>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.age>",
            "dst": "<age>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Person.prototype.greet>",
            "dst": "<greet:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Person.prototype.toString>",
            "dst": "<toString:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`Hi, I'm ${this.name}`>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<`Person(${this.name}, ${this.age})`>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<`Person(${this.name}, ${this.age})`>",
            "dst": "<this.age>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::getter-throws-in-destructuring",
      "category": "property-access",
      "code": "function getterThrowsInDestructuring() {\n  const dangerous = {\n    get boom() { throw new Error('trap!'); },\n    safe: 1,\n  };\n  try {\n    const { boom } = dangerous; // throws during destructuring\n  } catch (e) {\n    return e.message;\n  }\n}\n\n// --- Proxy wrapping a class constructor ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getterThrowsInDestructuring>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<dangerous>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<dangerous:object>"
        },
        {
          "type": "GETTER",
          "id": "<boom:getter>",
          "metadata": {
            "propertyName": "boom"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw new Error('trap!')>",
          "metadata": {
            "type": "throw"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('trap!')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'trap!'>",
          "metadata": {
            "value": "trap!",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<safe:property>",
          "metadata": {
            "propertyName": "safe"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "EXPRESSION",
          "id": "<{ boom } = dangerous>",
          "metadata": {
            "pattern": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<boom>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<e.message>",
          "metadata": {
            "property": "message"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getterThrowsInDestructuring>",
            "dst": "<dangerous>",
            "type": "CONTAINS"
          },
          {
            "src": "<dangerous:object>",
            "dst": "<boom:getter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<dangerous:object>",
            "dst": "<safe:property>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<boom:getter>",
            "dst": "<throw new Error('trap!')>",
            "type": "HAS_BODY"
          },
          {
            "src": "<new Error('trap!')>",
            "dst": "<'trap!'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getterThrowsInDestructuring>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<{ boom } = dangerous>",
            "type": "HAS_BODY"
          },
          {
            "src": "<{ boom } = dangerous>",
            "dst": "<boom>",
            "type": "DECLARES"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterThrowsInDestructuring>",
            "dst": "<e.message>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<dangerous>",
            "dst": "<dangerous:object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<throw new Error('trap!')>",
            "dst": "<new Error('trap!')>",
            "type": "THROWS"
          },
          {
            "src": "<safe:property>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ boom } = dangerous>",
            "dst": "<dangerous>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ boom } = dangerous>",
            "dst": "<boom:getter>",
            "type": "INVOKES"
          },
          {
            "src": "<e.message>",
            "dst": "<e>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "property-access::getter-destructuring-side-effect",
      "category": "property-access",
      "code": "function getterInDestructuring() {\n  let callCount = 0;\n  const sneaky = {\n    get value() { callCount++; return callCount; },\n  };\n  const { value } = sneaky;        // getter fires  callCount incremented\n  const copy = { ...sneaky };      // spread triggers ALL getters\n  return { value, copy, callCount };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getterInDestructuring>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<callCount>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<sneaky>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<sneaky:obj>"
        },
        {
          "type": "GETTER",
          "id": "<sneaky.value>",
          "metadata": {
            "propertyName": "value"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<callCount++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ value }>",
          "metadata": {
            "destructuringType": "object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<copy>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...sneaky>",
          "metadata": {
            "spreadType": "object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<copy:obj>"
        },
        {
          "type": "EXPRESSION",
          "id": "<return:obj>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getterInDestructuring>",
            "dst": "<callCount>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterInDestructuring>",
            "dst": "<sneaky>",
            "type": "CONTAINS"
          },
          {
            "src": "<sneaky:obj>",
            "dst": "<sneaky.value>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<sneaky.value>",
            "dst": "<callCount++>",
            "type": "RETURNS"
          },
          {
            "src": "<getterInDestructuring>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterInDestructuring>",
            "dst": "<copy>",
            "type": "CONTAINS"
          },
          {
            "src": "<copy:obj>",
            "dst": "<...sneaky>",
            "type": "CONTAINS"
          },
          {
            "src": "<...sneaky>",
            "dst": "<sneaky>",
            "type": "SPREADS_FROM"
          },
          {
            "src": "<getterInDestructuring>",
            "dst": "<return:obj>",
            "type": "RETURNS"
          },
          {
            "src": "<return:obj>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<return:obj>",
            "dst": "<copy>",
            "type": "CONTAINS"
          },
          {
            "src": "<return:obj>",
            "dst": "<callCount>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<callCount>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<sneaky>",
            "dst": "<sneaky:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<callCount++>",
            "dst": "<callCount>",
            "type": "MODIFIES"
          },
          {
            "src": "<value>",
            "dst": "<{ value }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<copy>",
            "dst": "<copy:obj>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<callCount++>",
            "dst": "<callCount>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ value }>",
            "dst": "<sneaky>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ value }>",
            "dst": "<sneaky.value>",
            "type": "INVOKES"
          },
          {
            "src": "<...sneaky>",
            "dst": "<sneaky.value>",
            "type": "INVOKES"
          }
        ]
      }
    },
    {
      "constructId": "property-access::prop-proxy-revocable",
      "category": "property-access",
      "code": "function proxyRevocable() {\n  const { proxy, revoke } = Proxy.revocable({}, {\n    get(t, prop) { return prop in t ? t[prop] : 'default'; },\n  });\n  proxy.x = 1;\n  const val = proxy.x;\n  revoke();\n  return val;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<proxyRevocable>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<proxy>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<revoke>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Proxy.revocable({}, handler)>",
          "metadata": {
            "callee": "Proxy.revocable"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<handler>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "METHOD",
          "id": "<handler.get>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<t>"
        },
        {
          "type": "PARAMETER",
          "id": "<prop>"
        },
        {
          "type": "EXPRESSION",
          "id": "<prop in t>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<t[prop]>"
        },
        {
          "type": "LITERAL",
          "id": "<'default'>",
          "metadata": {
            "value": "default",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<proxy.x>",
          "metadata": {
            "property": "x"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<val>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<proxy.x:read>",
          "metadata": {
            "property": "x",
            "operation": "read"
          }
        },
        {
          "type": "CALL",
          "id": "<revoke()>",
          "metadata": {
            "callee": "revoke"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<proxyRevocable>",
            "dst": "<proxy>",
            "type": "CONTAINS"
          },
          {
            "src": "<proxyRevocable>",
            "dst": "<revoke>",
            "type": "CONTAINS"
          },
          {
            "src": "<Proxy.revocable({}, handler)>",
            "dst": "<{}>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Proxy.revocable({}, handler)>",
            "dst": "<handler>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<handler>",
            "dst": "<handler.get>",
            "type": "CONTAINS"
          },
          {
            "src": "<handler.get>",
            "dst": "<t>",
            "type": "CONTAINS"
          },
          {
            "src": "<handler.get>",
            "dst": "<prop>",
            "type": "CONTAINS"
          },
          {
            "src": "<handler.get>",
            "dst": "<prop in t>",
            "type": "CONTAINS"
          },
          {
            "src": "<handler.get>",
            "dst": "<t[prop]>",
            "type": "RETURNS"
          },
          {
            "src": "<handler.get>",
            "dst": "<'default'>",
            "type": "RETURNS"
          },
          {
            "src": "<proxyRevocable>",
            "dst": "<val>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<proxy>",
            "dst": "<Proxy.revocable({}, handler)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<revoke>",
            "dst": "<Proxy.revocable({}, handler)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<proxy.x>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<val>",
            "dst": "<proxy.x:read>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<prop in t>",
            "dst": "<prop>",
            "type": "READS_FROM"
          },
          {
            "src": "<prop in t>",
            "dst": "<t>",
            "type": "READS_FROM"
          },
          {
            "src": "<t[prop]>",
            "dst": "<t>",
            "type": "READS_FROM"
          },
          {
            "src": "<t[prop]>",
            "dst": "<prop>",
            "type": "READS_FROM"
          },
          {
            "src": "<proxy.x>",
            "dst": "<proxy>",
            "type": "READS_FROM"
          },
          {
            "src": "<proxy.x:read>",
            "dst": "<proxy>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-set-prototype",
      "category": "prototypes",
      "code": "function reparent(obj, newParent) {\n  Object.setPrototypeOf(obj, newParent);\n  return obj;\n}\n\n// --- Mixin pattern ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<reparent>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<newParent>"
        },
        {
          "type": "CALL",
          "id": "<Object.setPrototypeOf(obj, newParent)>",
          "metadata": {
            "callee": "Object.setPrototypeOf"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.setPrototypeOf>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "setPrototypeOf"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<reparent>",
            "dst": "<obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<reparent>",
            "dst": "<newParent>",
            "type": "HAS_BODY"
          },
          {
            "src": "<reparent>",
            "dst": "<Object.setPrototypeOf(obj, newParent)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.setPrototypeOf(obj, newParent)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.setPrototypeOf(obj, newParent)>",
            "dst": "<newParent>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<reparent>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<obj>",
            "dst": "<newParent>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<Object.setPrototypeOf(obj, newParent)>",
            "dst": "<Object.setPrototypeOf>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "property-access::getter-computed-destructuring",
      "category": "property-access",
      "code": "function getterComputedDestructuring() {\n  let fired = false;\n  const obj = {\n    get secret() { fired = true; return 42; },\n  };\n  const key = 'secret';\n  const { [key]: extracted } = obj; // getter via computed key\n  return { extracted, fired };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getterComputedDestructuring>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<fired>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<obj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj-literal>"
        },
        {
          "type": "GETTER",
          "id": "<obj.secret>",
          "metadata": {
            "propertyName": "secret"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'secret'>",
          "metadata": {
            "value": "secret",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<extracted>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<destructure-obj>",
          "metadata": {
            "pattern": "object",
            "computed": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>"
        },
        {
          "type": "EXPRESSION",
          "id": "<return-expression>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getterComputedDestructuring>",
            "dst": "<fired>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterComputedDestructuring>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj-literal>",
            "dst": "<obj.secret>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<obj.secret>",
            "dst": "<42>",
            "type": "RETURNS"
          },
          {
            "src": "<getterComputedDestructuring>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<getterComputedDestructuring>",
            "dst": "<extracted>",
            "type": "CONTAINS"
          },
          {
            "src": "<return-object>",
            "dst": "<extracted>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<fired>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-expression>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<getterComputedDestructuring>",
            "dst": "<return-expression>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<fired>",
            "dst": "<false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj>",
            "dst": "<obj-literal>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<obj.secret>",
            "dst": "<fired>",
            "type": "WRITES_TO"
          },
          {
            "src": "<key>",
            "dst": "<'secret'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<extracted>",
            "dst": "<obj[key]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<obj.secret>",
            "dst": "<true>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<destructure-obj>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<destructure-obj>",
            "dst": "<extracted>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<obj[key]>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key]>",
            "dst": "<obj.secret>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-mixin-applied",
      "category": "prototypes",
      "code": "function Widget(name) {\n  this.name = name;\n}\napplyMixins(Widget, Serializable, EventEmitterMixin);\n\n// --- Property descriptors ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<Widget>",
          "metadata": {
            "async": false,
            "generator": false,
            "constructor": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "CALL",
          "id": "<applyMixins(Widget, Serializable, EventEmitterMixin)>",
          "metadata": {
            "callee": "applyMixins"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<applyMixins>"
        },
        {
          "type": "EXTERNAL",
          "id": "<Serializable>"
        },
        {
          "type": "EXTERNAL",
          "id": "<EventEmitterMixin>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Widget>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<applyMixins(Widget, Serializable, EventEmitterMixin)>",
            "dst": "<Widget>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<applyMixins(Widget, Serializable, EventEmitterMixin)>",
            "dst": "<Serializable>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<applyMixins(Widget, Serializable, EventEmitterMixin)>",
            "dst": "<EventEmitterMixin>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Widget>",
            "dst": "<this.name>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<applyMixins(Widget, Serializable, EventEmitterMixin)>",
            "dst": "<applyMixins>",
            "type": "CALLS"
          },
          {
            "src": "<Widget>",
            "dst": "<Serializable>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<Widget>",
            "dst": "<EventEmitterMixin>",
            "type": "DEPENDS_ON"
          }
        ]
      }
    },
    {
      "constructId": "builtins::regex-lookahead",
      "category": "builtins",
      "code": "const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<posLookahead>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\d+(?=px)/>",
          "metadata": {
            "value": "/\\d+(?=px)/",
            "literalType": "regex",
            "pattern": "\\d+(?=px)",
            "flags": ""
          }
        },
        {
          "type": "VARIABLE",
          "id": "<negLookahead>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\d+(?!px)/>",
          "metadata": {
            "value": "/\\d+(?!px)/",
            "literalType": "regex",
            "pattern": "\\d+(?!px)",
            "flags": ""
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<posLookahead>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<negLookahead>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<posLookahead>",
            "dst": "</\\d+(?=px)/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<negLookahead>",
            "dst": "</\\d+(?!px)/>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "property-access::proxy-class-constructor",
      "category": "property-access",
      "code": "class OriginalClass {\n  constructor(name) { this.name = name; }\n  greet() { return `Hi, ${this.name}`; }\n}\n\nconst TrackedClass = new Proxy(OriginalClass, {\n  construct(target, args, newTarget) {\n    return Reflect.construct(target, args, newTarget);\n  },\n});\n\nconst trackedInstance = new TrackedClass('Alice');\n\n// --- delete on computed properties ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<OriginalClass>"
        },
        {
          "type": "METHOD",
          "id": "<OriginalClass.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<OriginalClass.greet>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`Hi, ${this.name}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<TrackedClass>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Proxy(OriginalClass, {...})>",
          "metadata": {
            "callee": "Proxy",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<proxy-handler>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<construct>",
          "metadata": {
            "kind": "method",
            "proxyTrap": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<target>"
        },
        {
          "type": "PARAMETER",
          "id": "<args>"
        },
        {
          "type": "PARAMETER",
          "id": "<newTarget>"
        },
        {
          "type": "CALL",
          "id": "<Reflect.construct(target, args, newTarget)>",
          "metadata": {
            "callee": "Reflect.construct"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<trackedInstance>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new TrackedClass('Alice')>",
          "metadata": {
            "callee": "TrackedClass",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Alice'>",
          "metadata": {
            "value": "Alice",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<OriginalClass>",
            "dst": "<OriginalClass.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<OriginalClass>",
            "dst": "<OriginalClass.greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<OriginalClass.constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<OriginalClass.greet>",
            "dst": "<`Hi, ${this.name}`>",
            "type": "RETURNS"
          },
          {
            "src": "<new Proxy(OriginalClass, {...})>",
            "dst": "<OriginalClass>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Proxy(OriginalClass, {...})>",
            "dst": "<proxy-handler>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<proxy-handler>",
            "dst": "<construct>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<construct>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<construct>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<construct>",
            "dst": "<newTarget>",
            "type": "CONTAINS"
          },
          {
            "src": "<construct>",
            "dst": "<Reflect.construct(target, args, newTarget)>",
            "type": "RETURNS"
          },
          {
            "src": "<Reflect.construct(target, args, newTarget)>",
            "dst": "<target>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.construct(target, args, newTarget)>",
            "dst": "<args>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.construct(target, args, newTarget)>",
            "dst": "<newTarget>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new TrackedClass('Alice')>",
            "dst": "<'Alice'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<OriginalClass.constructor>",
            "dst": "<this.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<TrackedClass>",
            "dst": "<new Proxy(OriginalClass, {...})>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<trackedInstance>",
            "dst": "<new TrackedClass('Alice')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<`Hi, ${this.name}`>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<new TrackedClass('Alice')>",
            "dst": "<TrackedClass>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-define-property",
      "category": "prototypes",
      "code": "function createReadonly(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  });\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createReadonly>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<prop>"
        },
        {
          "type": "PARAMETER",
          "id": "<value>"
        },
        {
          "type": "CALL",
          "id": "<Object.defineProperty(obj, prop, {...})>",
          "metadata": {
            "callee": "Object.defineProperty"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.defineProperty>",
          "metadata": {
            "objectName": "Object"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<descriptor>",
          "metadata": {
            "expressionType": "object_literal",
            "properties": [
              "value",
              "writable",
              "enumerable",
              "configurable"
            ]
          }
        },
        {
          "type": "LITERAL",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<createReadonly>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<createReadonly>",
            "dst": "<prop>",
            "type": "CONTAINS"
          },
          {
            "src": "<createReadonly>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<createReadonly>",
            "dst": "<Object.defineProperty(obj, prop, {...})>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.defineProperty(obj, prop, {...})>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperty(obj, prop, {...})>",
            "dst": "<prop>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperty(obj, prop, {...})>",
            "dst": "<descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<descriptor>",
            "dst": "<value>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<descriptor>",
            "dst": "<false>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<descriptor>",
            "dst": "<true>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<createReadonly>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.defineProperty(obj, prop, {...})>",
            "dst": "<Object.defineProperty>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-property-descriptor-read",
      "category": "prototypes",
      "code": "function getDescriptor(obj, prop) {\n  return Object.getOwnPropertyDescriptor(obj, prop);\n}\n\nfunction getAllDescriptors(obj) {\n  return Object.getOwnPropertyDescriptors(obj);\n}\n\n// --- instanceof with Symbol.hasInstance ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getDescriptor>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "PARAMETER",
          "id": "<prop>"
        },
        {
          "type": "CALL",
          "id": "<Object.getOwnPropertyDescriptor(obj, prop)>",
          "metadata": {
            "callee": "Object.getOwnPropertyDescriptor"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.getOwnPropertyDescriptor>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "getOwnPropertyDescriptor"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<getAllDescriptors>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj2>"
        },
        {
          "type": "CALL",
          "id": "<Object.getOwnPropertyDescriptors(obj)>",
          "metadata": {
            "callee": "Object.getOwnPropertyDescriptors"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.getOwnPropertyDescriptors>",
          "metadata": {
            "objectName": "Object",
            "propertyName": "getOwnPropertyDescriptors"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<getDescriptor>",
            "dst": "<obj>",
            "type": "HAS_BODY"
          },
          {
            "src": "<getDescriptor>",
            "dst": "<prop>",
            "type": "HAS_BODY"
          },
          {
            "src": "<getDescriptor>",
            "dst": "<Object.getOwnPropertyDescriptor(obj, prop)>",
            "type": "RETURNS"
          },
          {
            "src": "<Object.getOwnPropertyDescriptor(obj, prop)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.getOwnPropertyDescriptor(obj, prop)>",
            "dst": "<prop>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<getAllDescriptors>",
            "dst": "<obj2>",
            "type": "HAS_BODY"
          },
          {
            "src": "<getAllDescriptors>",
            "dst": "<Object.getOwnPropertyDescriptors(obj)>",
            "type": "RETURNS"
          },
          {
            "src": "<Object.getOwnPropertyDescriptors(obj)>",
            "dst": "<obj2>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.getOwnPropertyDescriptor(obj, prop)>",
            "dst": "<Object.getOwnPropertyDescriptor>",
            "type": "CALLS"
          },
          {
            "src": "<Object.getOwnPropertyDescriptors(obj)>",
            "dst": "<Object.getOwnPropertyDescriptors>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-object-create",
      "category": "prototypes",
      "code": "const baseProto = {\n  type: 'base',\n  identify() {\n    return this.type;\n  },\n};\n\nconst derived = Object.create(baseProto);\nderived.type = 'derived';\nderived.extra = function () {\n  return 'extra';\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<baseProto>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<baseProto:object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<baseProto.type>",
          "metadata": {
            "name": "type"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'base'>",
          "metadata": {
            "value": "base",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<baseProto.identify>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.type>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<derived>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.create(baseProto)>",
          "metadata": {
            "callee": "Object.create"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<derived.type>",
          "metadata": {
            "name": "type"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'derived'>",
          "metadata": {
            "value": "derived",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<derived.extra>",
          "metadata": {
            "name": "extra"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<derived.extra:fn>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'extra'>",
          "metadata": {
            "value": "extra",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<baseProto:object>",
            "dst": "<baseProto.type>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<baseProto:object>",
            "dst": "<baseProto.identify>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<baseProto.identify>",
            "dst": "<this.type>",
            "type": "RETURNS"
          },
          {
            "src": "<Object.create(baseProto)>",
            "dst": "<baseProto>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<derived.extra:fn>",
            "dst": "<'extra'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<baseProto>",
            "dst": "<baseProto:object>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<baseProto.type>",
            "dst": "<'base'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<derived>",
            "dst": "<Object.create(baseProto)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<derived.type>",
            "dst": "<'derived'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<derived.extra>",
            "dst": "<derived.extra:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<baseProto.identify>",
            "dst": "<this.type>",
            "type": "READS_FROM"
          },
          {
            "src": "<derived>",
            "dst": "<baseProto>",
            "type": "EXTENDS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::monkey-patch-builtin",
      "category": "prototypes",
      "code": "Array.prototype.last = function () {\n  return this[this.length - 1];\n};\n[1, 2, 3].last();",
      "expectedNodes": [
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Array.prototype.last>",
          "metadata": {
            "objectName": "Array.prototype",
            "propertyName": "last"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<last:fn>",
          "metadata": {
            "arrowFunction": false
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this[this.length - 1]>",
          "metadata": {
            "objectName": "this",
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.length - 1>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.length>",
          "metadata": {
            "objectName": "this",
            "propertyName": "length"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3]>",
          "metadata": {
            "literalType": "array",
            "elements": [
              1,
              2,
              3
            ]
          }
        },
        {
          "type": "CALL",
          "id": "<[1, 2, 3].last()>",
          "metadata": {
            "callee": "last"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<last:fn>",
            "dst": "<this[this.length - 1]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Array.prototype.last>",
            "dst": "<last:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this[this.length - 1]>",
            "dst": "<this.length - 1>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.length - 1>",
            "dst": "<this.length>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.length - 1>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<[1, 2, 3].last()>",
            "dst": "<last:fn>",
            "type": "CALLS"
          },
          {
            "src": "<[1, 2, 3].last()>",
            "dst": "<[1, 2, 3]>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::regex-lookbehind",
      "category": "builtins",
      "code": "const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<posLookbehind>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<=\\$)\\d+/>",
          "metadata": {
            "value": "/(?<=\\$)\\d+/",
            "literalType": "regex",
            "flags": "",
            "hasLookbehind": true,
            "lookbehindType": "positive"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<negLookbehind>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</(?<!\\$)\\d+/>",
          "metadata": {
            "value": "/(?<!\\$)\\d+/",
            "literalType": "regex",
            "flags": "",
            "hasLookbehind": true,
            "lookbehindType": "negative"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<posLookbehind>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<negLookbehind>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<posLookbehind>",
            "dst": "</(?<=\\$)\\d+/>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<negLookbehind>",
            "dst": "</(?<!\\$)\\d+/>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "prototypes::proto-inheritance-chain",
      "category": "prototypes",
      "code": "function Employee(name, age, role) {\n  Person.call(this, name, age);\n  this.role = role;\n}\n\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\nEmployee.prototype.describe = function () {\n  return `${this.greet()}, I'm a ${this.role}`;\n};\n\n// --- Object.create ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<Employee>",
          "metadata": {
            "constructorFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>"
        },
        {
          "type": "PARAMETER",
          "id": "<age>"
        },
        {
          "type": "PARAMETER",
          "id": "<role>"
        },
        {
          "type": "CALL",
          "id": "<Person.call(this, name, age)>",
          "metadata": {
            "callee": "Person.call"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.role>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Employee.prototype>",
          "metadata": {
            "objectName": "Employee"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.create(Person.prototype)>",
          "metadata": {
            "callee": "Object.create"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Person.prototype>",
          "metadata": {
            "objectName": "Person"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Employee.prototype.constructor>",
          "metadata": {
            "objectName": "Employee.prototype"
          }
        },
        {
          "type": "METHOD",
          "id": "<Employee.prototype.describe>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<this.greet()>",
          "metadata": {
            "callee": "this.greet"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Employee>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<Employee>",
            "dst": "<age>",
            "type": "CONTAINS"
          },
          {
            "src": "<Employee>",
            "dst": "<role>",
            "type": "CONTAINS"
          },
          {
            "src": "<Employee>",
            "dst": "<Person.call(this, name, age)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Person.call(this, name, age)>",
            "dst": "<name>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Person.call(this, name, age)>",
            "dst": "<age>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.create(Person.prototype)>",
            "dst": "<Person.prototype>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Employee.prototype>",
            "dst": "<Employee.prototype.describe>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<Employee.prototype.describe>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<this.role>",
            "dst": "<role>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Employee>",
            "dst": "<this.role>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Employee.prototype>",
            "dst": "<Object.create(Person.prototype)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Employee.prototype.constructor>",
            "dst": "<Employee>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Employee.prototype>",
            "dst": "<Person.prototype>",
            "type": "EXTENDS"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.greet()>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.role>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.greet()>",
            "dst": "<this>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-symbol-hasinstance",
      "category": "prototypes",
      "code": "class EvenNumber {\n  static [Symbol.hasInstance](instance) {\n    return typeof instance === 'number' && instance % 2 === 0;\n  }\n}\n\n// --- Monkey-patching ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<EvenNumber>"
        },
        {
          "type": "METHOD",
          "id": "<EvenNumber[Symbol.hasInstance]>",
          "metadata": {
            "kind": "static",
            "computed": true,
            "symbol": "Symbol.hasInstance"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<instance>"
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof instance === 'number' && instance % 2 === 0>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'number'>",
          "metadata": {
            "value": "number",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<EvenNumber>",
            "dst": "<EvenNumber[Symbol.hasInstance]>",
            "type": "CONTAINS"
          },
          {
            "src": "<EvenNumber[Symbol.hasInstance]>",
            "dst": "<instance>",
            "type": "CONTAINS"
          },
          {
            "src": "<EvenNumber[Symbol.hasInstance]>",
            "dst": "<typeof instance === 'number' && instance % 2 === 0>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<typeof instance === 'number' && instance % 2 === 0>",
            "dst": "<instance>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof instance === 'number' && instance % 2 === 0>",
            "dst": "<'number'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof instance === 'number' && instance % 2 === 0>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof instance === 'number' && instance % 2 === 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-define-getter-setter",
      "category": "prototypes",
      "code": "function withComputedProp(obj) {\n  let _internal = 0;\n  Object.defineProperty(obj, 'computed', {\n    get() { return _internal * 2; },\n    set(v) { _internal = v; },\n    enumerable: true,\n    configurable: true,\n  });\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<withComputedProp>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<_internal>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.defineProperty>",
          "metadata": {
            "callee": "Object.defineProperty"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'computed'>",
          "metadata": {
            "value": "computed",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<computed-descriptor>"
        },
        {
          "type": "GETTER",
          "id": "<computed-getter>"
        },
        {
          "type": "SETTER",
          "id": "<computed-setter>"
        },
        {
          "type": "PARAMETER",
          "id": "<v>"
        },
        {
          "type": "EXPRESSION",
          "id": "<_internal * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-enumerable>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-configurable>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<withComputedProp>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<withComputedProp>",
            "dst": "<_internal>",
            "type": "CONTAINS"
          },
          {
            "src": "<withComputedProp>",
            "dst": "<Object.defineProperty>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.defineProperty>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperty>",
            "dst": "<'computed'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperty>",
            "dst": "<computed-descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<computed-descriptor>",
            "dst": "<computed-getter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<computed-descriptor>",
            "dst": "<computed-setter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<computed-descriptor>",
            "dst": "<true-enumerable>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<computed-descriptor>",
            "dst": "<true-configurable>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<computed-getter>",
            "dst": "<_internal * 2>",
            "type": "RETURNS"
          },
          {
            "src": "<computed-setter>",
            "dst": "<v>",
            "type": "CONTAINS"
          },
          {
            "src": "<withComputedProp>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<_internal>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<computed-setter>",
            "dst": "<_internal>",
            "type": "WRITES_TO"
          },
          {
            "src": "<_internal>",
            "dst": "<v>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<_internal * 2>",
            "dst": "<_internal>",
            "type": "READS_FROM"
          },
          {
            "src": "<_internal * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-chain-inspection",
      "category": "prototypes",
      "code": "function inspectPrototype(obj) {\n  const proto = Object.getPrototypeOf(obj);\n  const hasOwn = obj.hasOwnProperty('name');\n  const hasOwn2 = Object.hasOwn(obj, 'name');\n  const inChain = 'toString' in obj;\n  return { proto, hasOwn, hasOwn2, inChain };\n}\n\n// --- Object.setPrototypeOf ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<inspectPrototype>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<proto>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.getPrototypeOf(obj)>",
          "metadata": {
            "callee": "Object.getPrototypeOf"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.getPrototypeOf>",
          "metadata": {
            "objectName": "Object"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasOwn>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<obj.hasOwnProperty('name')>",
          "metadata": {
            "callee": "hasOwnProperty"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj.hasOwnProperty>",
          "metadata": {
            "objectName": "obj"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasOwn2>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.hasOwn(obj, 'name')>",
          "metadata": {
            "callee": "Object.hasOwn"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Object.hasOwn>",
          "metadata": {
            "objectName": "Object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'2>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<inChain>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'toString' in obj>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'toString'>",
          "metadata": {
            "value": "toString",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ proto, hasOwn, hasOwn2, inChain }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<inspectPrototype>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<inspectPrototype>",
            "dst": "<proto>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.getPrototypeOf(obj)>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<inspectPrototype>",
            "dst": "<hasOwn>",
            "type": "CONTAINS"
          },
          {
            "src": "<obj.hasOwnProperty('name')>",
            "dst": "<'name'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<inspectPrototype>",
            "dst": "<hasOwn2>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.hasOwn(obj, 'name')>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.hasOwn(obj, 'name')>",
            "dst": "<'name'2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<inspectPrototype>",
            "dst": "<inChain>",
            "type": "CONTAINS"
          },
          {
            "src": "<inspectPrototype>",
            "dst": "<{ proto, hasOwn, hasOwn2, inChain }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<proto>",
            "dst": "<Object.getPrototypeOf(obj)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasOwn>",
            "dst": "<obj.hasOwnProperty('name')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasOwn2>",
            "dst": "<Object.hasOwn(obj, 'name')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<inChain>",
            "dst": "<'toString' in obj>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Object.getPrototypeOf(obj)>",
            "dst": "<Object.getPrototypeOf>",
            "type": "CALLS"
          },
          {
            "src": "<obj.hasOwnProperty('name')>",
            "dst": "<obj.hasOwnProperty>",
            "type": "CALLS"
          },
          {
            "src": "<Object.hasOwn(obj, 'name')>",
            "dst": "<Object.hasOwn>",
            "type": "CALLS"
          },
          {
            "src": "<'toString' in obj>",
            "dst": "<'toString'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'toString' in obj>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ proto, hasOwn, hasOwn2, inChain }>",
            "dst": "<proto>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ proto, hasOwn, hasOwn2, inChain }>",
            "dst": "<hasOwn>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ proto, hasOwn, hasOwn2, inChain }>",
            "dst": "<hasOwn2>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ proto, hasOwn, hasOwn2, inChain }>",
            "dst": "<inChain>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::monkey-patch-third-party",
      "category": "prototypes",
      "code": "function patchRouter(router) {\n  const originalGet = router.get;\n  router.get = function (path, handler) {\n    console.log(`GET ${path}`);\n    return originalGet.call(this, path, handler);\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<patchRouter>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<router>"
        },
        {
          "type": "VARIABLE",
          "id": "<originalGet>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<router.get>",
          "metadata": {
            "objectName": "router",
            "propertyName": "get"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<router.get:replacement>",
          "metadata": {
            "async": false,
            "generator": false,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<path>"
        },
        {
          "type": "PARAMETER",
          "id": "<handler>"
        },
        {
          "type": "CALL",
          "id": "<console.log>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'GET '>",
          "metadata": {
            "value": "GET ",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`GET ${path}`>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<originalGet.call>",
          "metadata": {
            "callee": "originalGet.call"
          }
        },
        {
          "type": "LITERAL",
          "id": "<this>",
          "metadata": {
            "value": "this",
            "literalType": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<patchRouter>",
            "dst": "<router>",
            "type": "CONTAINS"
          },
          {
            "src": "<patchRouter>",
            "dst": "<originalGet>",
            "type": "DECLARES"
          },
          {
            "src": "<router.get:replacement>",
            "dst": "<path>",
            "type": "CONTAINS"
          },
          {
            "src": "<router.get:replacement>",
            "dst": "<handler>",
            "type": "CONTAINS"
          },
          {
            "src": "<router.get:replacement>",
            "dst": "<console.log>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log>",
            "dst": "<`GET ${path}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<router.get:replacement>",
            "dst": "<originalGet.call>",
            "type": "RETURNS"
          },
          {
            "src": "<originalGet.call>",
            "dst": "<this>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<originalGet.call>",
            "dst": "<path>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<originalGet.call>",
            "dst": "<handler>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<originalGet>",
            "dst": "<router.get>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<router.get>",
            "dst": "<router.get:replacement>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<patchRouter>",
            "dst": "<router>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<router.get>",
            "dst": "<router>",
            "type": "READS_FROM"
          },
          {
            "src": "<`GET ${path}`>",
            "dst": "<path>",
            "type": "READS_FROM"
          },
          {
            "src": "<originalGet.call>",
            "dst": "<originalGet>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::super-in-object-literal",
      "category": "prototypes",
      "code": "const parentObj = {\n  greet() { return 'hello from parent'; },\n};\n\nconst childObj = {\n  __proto__: parentObj,\n  greet() {\n    return super.greet() + ' and child';\n  },\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<parentObj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<parentObj:obj>"
        },
        {
          "type": "METHOD",
          "id": "<parentObj.greet>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hello from parent'>",
          "metadata": {
            "value": "hello from parent",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<childObj>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<childObj:obj>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<__proto__>",
          "metadata": {
            "propertyName": "__proto__"
          }
        },
        {
          "type": "METHOD",
          "id": "<childObj.greet>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "CALL",
          "id": "<super.greet()>",
          "metadata": {
            "methodName": "greet"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<super.greet() + ' and child'>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "LITERAL",
          "id": "<' and child'>",
          "metadata": {
            "value": " and child",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<parentObj:obj>",
            "dst": "<parentObj.greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<parentObj.greet>",
            "dst": "<'hello from parent'>",
            "type": "RETURNS"
          },
          {
            "src": "<childObj:obj>",
            "dst": "<__proto__>",
            "type": "CONTAINS"
          },
          {
            "src": "<childObj:obj>",
            "dst": "<childObj.greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<childObj.greet>",
            "dst": "<super.greet() + ' and child'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<parentObj>",
            "dst": "<parentObj:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<childObj>",
            "dst": "<childObj:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<__proto__>",
            "dst": "<parentObj>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<childObj:obj>",
            "dst": "<parentObj:obj>",
            "type": "EXTENDS"
          },
          {
            "src": "<super.greet()>",
            "dst": "<parentObj.greet>",
            "type": "CALLS"
          },
          {
            "src": "<super.greet() + ' and child'>",
            "dst": "<super.greet()>",
            "type": "READS_FROM"
          },
          {
            "src": "<super.greet() + ' and child'>",
            "dst": "<' and child'>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::monkey-patch-global",
      "category": "prototypes",
      "code": "const originalFetch = globalThis.fetch;\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n  apply(target, thisArg, args) {\n    console.log('intercepted:', args[0]);\n    return Reflect.apply(target, thisArg, args);\n  },\n});",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<originalFetch>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<globalThis.fetch>",
          "metadata": {
            "objectName": "globalThis",
            "propertyName": "fetch"
          }
        },
        {
          "type": "CALL",
          "id": "<fetch-proxy>",
          "metadata": {
            "callee": "Proxy",
            "constructor": true
          }
        },
        {
          "type": "METHOD",
          "id": "<apply-handler>",
          "metadata": {
            "kind": "proxy-handler",
            "trap": "apply"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<target>"
        },
        {
          "type": "PARAMETER",
          "id": "<thisArg>"
        },
        {
          "type": "PARAMETER",
          "id": "<args>"
        },
        {
          "type": "CALL",
          "id": "<console.log>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<args[0]>",
          "metadata": {
            "objectName": "args",
            "propertyName": "0"
          }
        },
        {
          "type": "CALL",
          "id": "<Reflect.apply>",
          "metadata": {
            "callee": "Reflect.apply"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<fetch-proxy>",
            "dst": "<globalThis.fetch>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fetch-proxy>",
            "dst": "<apply-handler>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<apply-handler>",
            "dst": "<target>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<apply-handler>",
            "dst": "<thisArg>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<apply-handler>",
            "dst": "<args>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<apply-handler>",
            "dst": "<console.log>",
            "type": "CONTAINS"
          },
          {
            "src": "<apply-handler>",
            "dst": "<Reflect.apply>",
            "type": "RETURNS"
          },
          {
            "src": "<console.log>",
            "dst": "<args[0]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.apply>",
            "dst": "<target>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.apply>",
            "dst": "<thisArg>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Reflect.apply>",
            "dst": "<args>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<originalFetch>",
            "dst": "<globalThis.fetch>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<globalThis.fetch>",
            "dst": "<fetch-proxy>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "runtime-apis::runtime-message-channel",
      "category": "runtime-apis",
      "code": "function messageChannelPattern() {\n  const { port1, port2 } = new MessageChannel();\n  port1.onmessage = (e) => console.log(e.data);\n  port2.postMessage('hello');\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<messageChannelPattern>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<port1>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<port2>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "CALL",
          "id": "<new MessageChannel()>",
          "metadata": {
            "callee": "MessageChannel",
            "constructor": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<port1.onmessage>",
          "metadata": {
            "objectName": "port1",
            "property": "onmessage"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<onmessage-handler>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CALL",
          "id": "<console.log(e.data)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<e.data>",
          "metadata": {
            "objectName": "e",
            "property": "data"
          }
        },
        {
          "type": "CALL",
          "id": "<port2.postMessage('hello')>",
          "metadata": {
            "callee": "port2.postMessage"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hello'>",
          "metadata": {
            "value": "hello",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<messageChannelPattern>",
            "dst": "<port1>",
            "type": "CONTAINS"
          },
          {
            "src": "<messageChannelPattern>",
            "dst": "<port2>",
            "type": "CONTAINS"
          },
          {
            "src": "<onmessage-handler>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<onmessage-handler>",
            "dst": "<console.log(e.data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(e.data)>",
            "dst": "<e.data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<messageChannelPattern>",
            "dst": "<port2.postMessage('hello')>",
            "type": "CONTAINS"
          },
          {
            "src": "<port2.postMessage('hello')>",
            "dst": "<'hello'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<port1>",
            "dst": "<new MessageChannel()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<port2>",
            "dst": "<new MessageChannel()>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<port1.onmessage>",
            "dst": "<onmessage-handler>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<new MessageChannel()>",
            "dst": "<MessageChannel>",
            "type": "CALLS"
          },
          {
            "src": "<console.log(e.data)>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<e.data>",
            "dst": "<e>",
            "type": "READS_FROM"
          },
          {
            "src": "<port2.postMessage('hello')>",
            "dst": "<port2.postMessage>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-atomics-wait-notify",
      "category": "runtime-apis",
      "code": "function atomicsSynchronization(view) {\n  // Atomics.wait(view, 0, 0);     // blocks thread (worker only)\n  Atomics.notify(view, 0, 1);      // wake one waiting thread\n  Atomics.waitAsync(view, 0, 0);   // non-blocking, returns Promise\n}\n\n// --- Worker Communication (Plugin: workers) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<atomicsSynchronization>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<view>"
        },
        {
          "type": "CALL",
          "id": "<Atomics.notify(view, 0, 1)>",
          "metadata": {
            "callee": "Atomics.notify"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Atomics.notify>",
          "metadata": {
            "objectName": "Atomics",
            "propertyName": "notify"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<Atomics.waitAsync(view, 0, 0)>",
          "metadata": {
            "callee": "Atomics.waitAsync"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Atomics.waitAsync>",
          "metadata": {
            "objectName": "Atomics",
            "propertyName": "waitAsync"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0_2>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0_3>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<atomicsSynchronization>",
            "dst": "<view>",
            "type": "HAS_BODY"
          },
          {
            "src": "<atomicsSynchronization>",
            "dst": "<Atomics.notify(view, 0, 1)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<atomicsSynchronization>",
            "dst": "<Atomics.waitAsync(view, 0, 0)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<Atomics.notify(view, 0, 1)>",
            "dst": "<view>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Atomics.notify(view, 0, 1)>",
            "dst": "<0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Atomics.notify(view, 0, 1)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Atomics.waitAsync(view, 0, 0)>",
            "dst": "<view>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Atomics.waitAsync(view, 0, 0)>",
            "dst": "<0_2>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Atomics.waitAsync(view, 0, 0)>",
            "dst": "<0_3>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Atomics.notify(view, 0, 1)>",
            "dst": "<Atomics.notify>",
            "type": "CALLS"
          },
          {
            "src": "<Atomics.waitAsync(view, 0, 0)>",
            "dst": "<Atomics.waitAsync>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-transfer-ownership",
      "category": "runtime-apis",
      "code": "function transferOwnership(worker) {\n  const buffer = new ArrayBuffer(1024);\n  worker.postMessage(buffer, [buffer]); // buffer neutered in sender\n}\n\n// --- import.meta Extensions (Plugin: node-modules) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<transferOwnership>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<worker>"
        },
        {
          "type": "VARIABLE",
          "id": "<buffer>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new ArrayBuffer(1024)>",
          "metadata": {
            "callee": "ArrayBuffer",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1024>",
          "metadata": {
            "value": 1024,
            "literalType": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<worker.postMessage(buffer, [buffer])>",
          "metadata": {
            "callee": "postMessage"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<worker.postMessage>",
          "metadata": {
            "objectName": "worker",
            "propertyName": "postMessage"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[buffer]>",
          "metadata": {
            "type": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<transferOwnership>",
            "dst": "<worker>",
            "type": "HAS_BODY"
          },
          {
            "src": "<transferOwnership>",
            "dst": "<buffer>",
            "type": "HAS_BODY"
          },
          {
            "src": "<new ArrayBuffer(1024)>",
            "dst": "<1024>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<transferOwnership>",
            "dst": "<worker.postMessage(buffer, [buffer])>",
            "type": "HAS_BODY"
          },
          {
            "src": "<worker.postMessage(buffer, [buffer])>",
            "dst": "<buffer>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<worker.postMessage(buffer, [buffer])>",
            "dst": "<[buffer]>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<[buffer]>",
            "dst": "<buffer>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [
          {
            "src": "<buffer>",
            "dst": "<new ArrayBuffer(1024)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<worker.postMessage(buffer, [buffer])>",
            "dst": "<worker.postMessage>",
            "type": "CALLS"
          },
          {
            "src": "<worker.postMessage>",
            "dst": "<worker>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::proto-define-properties",
      "category": "prototypes",
      "code": "function defineMultiple(obj) {\n  Object.defineProperties(obj, {\n    x: { value: 10, writable: true, enumerable: true },\n    y: { value: 20, writable: true, enumerable: true },\n    sum: {\n      get() { return this.x + this.y; },\n      enumerable: true,\n    },\n  });\n  return obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<defineMultiple>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "CALL",
          "id": "<Object.defineProperties>",
          "metadata": {
            "callee": "Object.defineProperties"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x-descriptor>",
          "metadata": {
            "propertyName": "x"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-writable-x>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-enumerable-x>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<y-descriptor>",
          "metadata": {
            "propertyName": "y"
          }
        },
        {
          "type": "LITERAL",
          "id": "<20>",
          "metadata": {
            "value": 20,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-writable-y>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-enumerable-y>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<sum-descriptor>",
          "metadata": {
            "propertyName": "sum"
          }
        },
        {
          "type": "GETTER",
          "id": "<sum-getter>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.x + this.y>",
          "metadata": {
            "operator": "+"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.x>",
          "metadata": {
            "objectName": "this",
            "propertyName": "x"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.y>",
          "metadata": {
            "objectName": "this",
            "propertyName": "y"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true-enumerable-sum>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<defineMultiple>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<defineMultiple>",
            "dst": "<Object.defineProperties>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.defineProperties>",
            "dst": "<obj>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperties>",
            "dst": "<x-descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperties>",
            "dst": "<y-descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.defineProperties>",
            "dst": "<sum-descriptor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<x-descriptor>",
            "dst": "<10>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<x-descriptor>",
            "dst": "<true-writable-x>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<x-descriptor>",
            "dst": "<true-enumerable-x>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<y-descriptor>",
            "dst": "<20>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<y-descriptor>",
            "dst": "<true-writable-y>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<y-descriptor>",
            "dst": "<true-enumerable-y>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<sum-descriptor>",
            "dst": "<sum-getter>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<sum-descriptor>",
            "dst": "<true-enumerable-sum>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<sum-getter>",
            "dst": "<this.x + this.y>",
            "type": "RETURNS"
          },
          {
            "src": "<defineMultiple>",
            "dst": "<obj>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<this.x + this.y>",
            "dst": "<this.x>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.x + this.y>",
            "dst": "<this.y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "prototypes::method-vs-function-property-super",
      "category": "prototypes",
      "code": "const superParent = {\n  greet() { return 'parent'; },\n};\n\nconst superChild = {\n  __proto__: superParent,\n\n  // Method shorthand  HAS [[HomeObject]], super works\n  shorthand() {\n    return super.greet(); // 'parent' \n  },\n\n  // Function property  NO [[HomeObject]], super is SyntaxError\n  funcProp: function() {\n    // super.greet(); // Would be SyntaxError: 'super' keyword unexpected here\n    return 'no super access';\n  },\n\n  // Arrow property  NO own [[HomeObject]], inherits from defining scope\n  arrowProp: () => {\n    // super.greet(); // Would use enclosing scope's super, not this object's\n    return 'arrow has no own super';\n  },\n};",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<superParent>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<superParent:obj>"
        },
        {
          "type": "METHOD",
          "id": "<superParent.greet>",
          "metadata": {
            "kind": "method",
            "hasHomeObject": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'parent'>",
          "metadata": {
            "value": "parent",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<superChild>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<superChild:obj>"
        },
        {
          "type": "PROPERTY",
          "id": "<__proto__:superParent>"
        },
        {
          "type": "METHOD",
          "id": "<superChild.shorthand>",
          "metadata": {
            "kind": "method",
            "hasHomeObject": true
          }
        },
        {
          "type": "CALL",
          "id": "<super.greet()>"
        },
        {
          "type": "PROPERTY",
          "id": "<superChild.funcProp>"
        },
        {
          "type": "FUNCTION",
          "id": "<superChild.funcProp:fn>",
          "metadata": {
            "hasHomeObject": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'no super access'>",
          "metadata": {
            "value": "no super access",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<superChild.arrowProp>"
        },
        {
          "type": "FUNCTION",
          "id": "<superChild.arrowProp:fn>",
          "metadata": {
            "arrowFunction": true,
            "hasHomeObject": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<'arrow has no own super'>",
          "metadata": {
            "value": "arrow has no own super",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<superParent:obj>",
            "dst": "<superParent.greet>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<superParent.greet>",
            "dst": "<'parent'>",
            "type": "RETURNS"
          },
          {
            "src": "<superChild:obj>",
            "dst": "<__proto__:superParent>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<superChild:obj>",
            "dst": "<superChild.shorthand>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<superChild.shorthand>",
            "dst": "<super.greet()>",
            "type": "CONTAINS"
          },
          {
            "src": "<superChild.shorthand>",
            "dst": "<super.greet()>",
            "type": "RETURNS"
          },
          {
            "src": "<superChild:obj>",
            "dst": "<superChild.funcProp>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<superChild.funcProp:fn>",
            "dst": "<'no super access'>",
            "type": "RETURNS"
          },
          {
            "src": "<superChild:obj>",
            "dst": "<superChild.arrowProp>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<superChild.arrowProp:fn>",
            "dst": "<'arrow has no own super'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<superParent>",
            "dst": "<superParent:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<superChild>",
            "dst": "<superChild:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<__proto__:superParent>",
            "dst": "<superParent:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<superChild.funcProp>",
            "dst": "<superChild.funcProp:fn>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<superChild.arrowProp>",
            "dst": "<superChild.arrowProp:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<super.greet()>",
            "dst": "<superParent.greet>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::regex-unicode-props",
      "category": "builtins",
      "code": "const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<emoji>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\p{Emoji}/u>",
          "metadata": {
            "value": "/\\p{Emoji}/u",
            "literalType": "regex",
            "flags": [
              "u"
            ],
            "unicodeProperty": "Emoji"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<greek>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\p{Script=Greek}/u>",
          "metadata": {
            "value": "/\\p{Script=Greek}/u",
            "literalType": "regex",
            "flags": [
              "u"
            ],
            "unicodeProperty": "Script=Greek"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<letter>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "</\\p{Letter}/u>",
          "metadata": {
            "value": "/\\p{Letter}/u",
            "literalType": "regex",
            "flags": [
              "u"
            ],
            "unicodeProperty": "Letter"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<MODULE>",
            "dst": "<emoji>",
            "type": "DECLARES"
          },
          {
            "src": "<MODULE>",
            "dst": "<greek>",
            "type": "DECLARES"
          },
          {
            "src": "<MODULE>",
            "dst": "<letter>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<emoji>",
            "dst": "</\\p{Emoji}/u>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<greek>",
            "dst": "</\\p{Script=Greek}/u>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<letter>",
            "dst": "</\\p{Letter}/u>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "prototypes::export-named-list",
      "category": "prototypes",
      "code": "export {\n  Person,\n  Employee,\n  baseProto,\n  derived,\n  nullProto,\n  inspectPrototype,\n  reparent,\n  Serializable,\n  EventEmitterMixin,\n  applyMixins,\n  Widget,\n  createReadonly,\n  withComputedProp,\n  defineMultiple,\n  getDescriptor,\n  getAllDescriptors,\n  EvenNumber,\n  patchRouter,\n  originalFetch,\n  parentObj,\n  childObj,\n  superParent,\n  superChild,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Person>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Employee>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<baseProto>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<derived>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<nullProto>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<inspectPrototype>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<reparent>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Serializable>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<EventEmitterMixin>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<applyMixins>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Widget>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<createReadonly>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<withComputedProp>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<defineMultiple>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getDescriptor>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<getAllDescriptors>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<EvenNumber>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<patchRouter>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<originalFetch>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<parentObj>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<childObj>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<superParent>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<superChild>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<Person>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Employee>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<baseProto>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<derived>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<nullProto>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<inspectPrototype>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<reparent>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Serializable>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<EventEmitterMixin>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<applyMixins>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<Widget>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<createReadonly>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<withComputedProp>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<defineMultiple>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<getDescriptor>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<getAllDescriptors>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<EvenNumber>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<patchRouter>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<originalFetch>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<parentObj>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<childObj>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<superParent>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<superChild>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "runtime-apis::runtime-broadcast-channel",
      "category": "runtime-apis",
      "code": "function broadcastChannelPattern() {\n  const bc = new BroadcastChannel('updates');\n  bc.postMessage({ type: 'refresh' });\n  bc.onmessage = (e) => console.log(e.data);\n  bc.close();\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<broadcastChannelPattern>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<bc>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new BroadcastChannel('updates')>",
          "metadata": {
            "callee": "BroadcastChannel",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'updates'>",
          "metadata": {
            "value": "updates",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<bc.postMessage({ type: 'refresh' })>",
          "metadata": {
            "callee": "postMessage"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ type: 'refresh' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<bc.onmessage>",
          "metadata": {
            "objectName": "bc",
            "propertyName": "onmessage"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<(e) => console.log(e.data)>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CALL",
          "id": "<console.log(e.data)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<e.data>",
          "metadata": {
            "objectName": "e",
            "propertyName": "data"
          }
        },
        {
          "type": "CALL",
          "id": "<bc.close()>",
          "metadata": {
            "callee": "close"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<broadcastChannelPattern>",
            "dst": "<bc>",
            "type": "CONTAINS"
          },
          {
            "src": "<new BroadcastChannel('updates')>",
            "dst": "<'updates'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<bc.postMessage({ type: 'refresh' })>",
            "dst": "<{ type: 'refresh' }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<(e) => console.log(e.data)>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<(e) => console.log(e.data)>",
            "dst": "<console.log(e.data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(e.data)>",
            "dst": "<e.data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<broadcastChannelPattern>",
            "dst": "<bc.postMessage({ type: 'refresh' })>",
            "type": "CONTAINS"
          },
          {
            "src": "<broadcastChannelPattern>",
            "dst": "<bc.onmessage>",
            "type": "CONTAINS"
          },
          {
            "src": "<broadcastChannelPattern>",
            "dst": "<bc.close()>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<bc>",
            "dst": "<new BroadcastChannel('updates')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<bc.onmessage>",
            "dst": "<(e) => console.log(e.data)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<bc.postMessage({ type: 'refresh' })>",
            "dst": "<bc>",
            "type": "CALLS_ON"
          },
          {
            "src": "<e.data>",
            "dst": "<e>",
            "type": "READS_FROM"
          },
          {
            "src": "<bc.close()>",
            "dst": "<bc>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::export-named-list",
      "category": "runtime-apis",
      "code": "export {\n  sharedMemory,\n  atomicsSynchronization,\n  workerCommunication,\n  messageChannelPattern,\n  broadcastChannelPattern,\n  transferOwnership,\n  importMetaExtensions,\n  deferredPromise,\n};",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-named-list>",
          "metadata": {
            "exportType": "named"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<sharedMemory>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<atomicsSynchronization>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<workerCommunication>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<messageChannelPattern>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<broadcastChannelPattern>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<transferOwnership>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<importMetaExtensions>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<deferredPromise>",
          "metadata": {
            "exported": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [],
        "postFile": [
          {
            "src": "<export-named-list>",
            "dst": "<sharedMemory>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<atomicsSynchronization>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<workerCommunication>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<messageChannelPattern>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<broadcastChannelPattern>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<transferOwnership>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<importMetaExtensions>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-named-list>",
            "dst": "<deferredPromise>",
            "type": "EXPORTS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "statements::if-else",
      "category": "statements",
      "code": "function ifElseStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  } else {\n    return 'non-positive';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<ifElseStatement>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "BRANCH",
          "id": "<if-else>",
          "metadata": {
            "branchType": "if-else"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 0>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'positive'>",
          "metadata": {
            "value": "positive",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'non-positive'>",
          "metadata": {
            "value": "non-positive",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ifElseStatement>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<ifElseStatement>",
            "dst": "<if-else>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-else>",
            "dst": "<x > 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-else>",
            "dst": "<'positive'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ifElseStatement>",
            "dst": "<'positive'>",
            "type": "RETURNS"
          },
          {
            "src": "<ifElseStatement>",
            "dst": "<'non-positive'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<if-else>",
            "dst": "<'non-positive'>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<x > 0>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-import-meta-resolve",
      "category": "runtime-apis",
      "code": "function importMetaExtensions() {\n  const depPath = import.meta.resolve('lodash');\n  const localPath = import.meta.resolve('./utils.js');\n  // Node.js 21+:\n  // const dir = import.meta.dirname;   // replaces __dirname\n  // const file = import.meta.filename; // replaces __filename\n  return { depPath, localPath };\n}\n\n// --- Global Error Sinks (Plugin: error-flow) ---\n// These create implicit edges from ANY uncaught throw/reject to handler.",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<importMetaExtensions>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<depPath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import.meta.resolve('lodash')>",
          "metadata": {
            "callee": "import.meta.resolve"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<import.meta.resolve>",
          "metadata": {
            "objectName": "import.meta",
            "propertyName": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'lodash'>",
          "metadata": {
            "value": "lodash",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<localPath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<import.meta.resolve('./utils.js')>",
          "metadata": {
            "callee": "import.meta.resolve"
          }
        },
        {
          "type": "META_PROPERTY",
          "id": "<import.meta.resolve2>",
          "metadata": {
            "objectName": "import.meta",
            "propertyName": "resolve"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./utils.js'>",
          "metadata": {
            "value": "./utils.js",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ depPath, localPath }>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<importMetaExtensions>",
            "dst": "<depPath>",
            "type": "CONTAINS"
          },
          {
            "src": "<importMetaExtensions>",
            "dst": "<localPath>",
            "type": "CONTAINS"
          },
          {
            "src": "<import.meta.resolve('lodash')>",
            "dst": "<'lodash'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<import.meta.resolve('./utils.js')>",
            "dst": "<'./utils.js'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<importMetaExtensions>",
            "dst": "<{ depPath, localPath }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<depPath>",
            "dst": "<import.meta.resolve('lodash')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<localPath>",
            "dst": "<import.meta.resolve('./utils.js')>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import.meta.resolve('lodash')>",
            "dst": "<import.meta.resolve>",
            "type": "CALLS"
          },
          {
            "src": "<import.meta.resolve('./utils.js')>",
            "dst": "<import.meta.resolve2>",
            "type": "CALLS"
          },
          {
            "src": "<{ depPath, localPath }>",
            "dst": "<depPath>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ depPath, localPath }>",
            "dst": "<localPath>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "builtins::string-raw-template",
      "category": "builtins",
      "code": "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file'  no escape processing",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<windowsPath>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<String.raw`C:\\Users\\name\\file`>",
          "metadata": {
            "callee": "String.raw",
            "callType": "tagged-template"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<String.raw>",
          "metadata": {
            "objectName": "String",
            "propertyName": "raw"
          }
        },
        {
          "type": "LITERAL",
          "id": "<String>",
          "metadata": {
            "value": "String",
            "literalType": "identifier",
            "builtinType": "constructor"
          }
        },
        {
          "type": "LITERAL",
          "id": "<template-literal>",
          "metadata": {
            "value": "C:\\Users\\name\\file",
            "literalType": "template",
            "raw": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<windowsPath>",
            "type": "DECLARES"
          },
          {
            "src": "<String.raw`C:\\Users\\name\\file`>",
            "dst": "<template-literal>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<windowsPath>",
            "dst": "<String.raw`C:\\Users\\name\\file`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<String.raw`C:\\Users\\name\\file`>",
            "dst": "<String.raw>",
            "type": "CALLS"
          },
          {
            "src": "<String.raw>",
            "dst": "<String>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::if-basic",
      "category": "statements",
      "code": "function ifStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  }\n  return 'non-positive';\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<ifStatement>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "BRANCH",
          "id": "<if-branch>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 0>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'positive'>",
          "metadata": {
            "value": "positive",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'non-positive'>",
          "metadata": {
            "value": "non-positive",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ifStatement>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<ifStatement>",
            "dst": "<if-branch>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-branch>",
            "dst": "<x > 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-branch>",
            "dst": "<'positive'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ifStatement>",
            "dst": "<'positive'>",
            "type": "RETURNS"
          },
          {
            "src": "<ifStatement>",
            "dst": "<'non-positive'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<x > 0>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-promise-try",
      "category": "runtime-apis",
      "code": "// const result = await Promise.try(() => {\n//   if (cached) return cachedValue;    // sync return  wrapped in Promise\n//   return fetchFromNetwork();          // async return\n// });",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.try(...)>",
          "metadata": {
            "callee": "Promise.try",
            "async": true
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Promise.try:callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-cached>"
        },
        {
          "type": "VARIABLE",
          "id": "<cached>"
        },
        {
          "type": "VARIABLE",
          "id": "<cachedValue>"
        },
        {
          "type": "CALL",
          "id": "<fetchFromNetwork()>",
          "metadata": {
            "callee": "fetchFromNetwork",
            "async": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Promise.try(...)>",
            "dst": "<Promise.try:callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Promise.try:callback>",
            "dst": "<if-cached>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-cached>",
            "dst": "<cached>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-cached>",
            "dst": "<cachedValue>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<Promise.try(...)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<if-cached>",
            "dst": "<fetchFromNetwork()>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<Promise.try:callback>",
            "dst": "<cached>",
            "type": "READS_FROM"
          },
          {
            "src": "<Promise.try:callback>",
            "dst": "<cachedValue>",
            "type": "READS_FROM"
          },
          {
            "src": "<fetchFromNetwork()>",
            "dst": "fetchFromNetwork",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-global-error-handlers",
      "category": "runtime-apis",
      "code": "// Node.js:\n// process.on('unhandledRejection', (reason, promise) => { ... });\n// process.on('uncaughtException', (error) => { process.exit(1); });\n//\n// Browser:\n// window.addEventListener('unhandledrejection', (event) => { ... });\n// window.addEventListener('error', (event) => { ... });\n\n// --- ES2025+ API Methods (Plugin: es-builtins) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<process.unhandledRejection>",
          "metadata": {
            "runtime": "node",
            "eventType": "unhandledRejection"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<reason>"
        },
        {
          "type": "PARAMETER",
          "id": "<promise>"
        },
        {
          "type": "FUNCTION",
          "id": "<process.uncaughtException>",
          "metadata": {
            "runtime": "node",
            "eventType": "uncaughtException"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<error>"
        },
        {
          "type": "CALL",
          "id": "<process.exit(1)>",
          "metadata": {
            "callee": "process.exit"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<window.unhandledrejection>",
          "metadata": {
            "runtime": "browser",
            "eventType": "unhandledrejection"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<event1>",
          "metadata": {
            "parameterName": "event"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<window.error>",
          "metadata": {
            "runtime": "browser",
            "eventType": "error"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<event2>",
          "metadata": {
            "parameterName": "event"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<process>",
          "metadata": {
            "runtime": "node"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<window>",
          "metadata": {
            "runtime": "browser"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<process>",
            "dst": "<process.unhandledRejection>",
            "type": "LISTENS_TO"
          },
          {
            "src": "<process.unhandledRejection>",
            "dst": "<reason>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<process.unhandledRejection>",
            "dst": "<promise>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<process>",
            "dst": "<process.uncaughtException>",
            "type": "LISTENS_TO"
          },
          {
            "src": "<process.uncaughtException>",
            "dst": "<error>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<process.uncaughtException>",
            "dst": "<process.exit(1)>",
            "type": "CONTAINS"
          },
          {
            "src": "<process.exit(1)>",
            "dst": "<1>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<window>",
            "dst": "<window.unhandledrejection>",
            "type": "LISTENS_TO"
          },
          {
            "src": "<window.unhandledrejection>",
            "dst": "<event1>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<window>",
            "dst": "<window.error>",
            "type": "LISTENS_TO"
          },
          {
            "src": "<window.error>",
            "dst": "<event2>",
            "type": "RECEIVES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "statements::for-in",
      "category": "statements",
      "code": "function forIn(obj) {\n  const keys = [];\n  for (const key in obj) {\n    keys.push(key);\n  }\n  return keys;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forIn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<keys>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-in>",
          "metadata": {
            "loopType": "for-in"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<keys.push(key)>",
          "metadata": {
            "callee": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forIn>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<forIn>",
            "dst": "<keys>",
            "type": "CONTAINS"
          },
          {
            "src": "<forIn>",
            "dst": "<for-in>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-in>",
            "dst": "<obj>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-in>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<forIn>",
            "dst": "<keys.push(key)>",
            "type": "CONTAINS"
          },
          {
            "src": "<keys.push(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forIn>",
            "dst": "<keys>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<keys>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<keys.push(key)>",
            "dst": "<keys>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-worker-postmessage",
      "category": "runtime-apis",
      "code": "function workerCommunication() {\n  const worker = new Worker('./task.js');\n  worker.postMessage({ type: 'start', payload: 'data' });\n  worker.onmessage = (e) => console.log(e.data);\n  worker.onerror = (err) => console.error(err);\n  worker.terminate();\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<workerCommunication>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<worker>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<new Worker('./task.js')>",
          "metadata": {
            "callee": "Worker",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'./task.js'>",
          "metadata": {
            "value": "./task.js",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<worker.postMessage>",
          "metadata": {
            "callee": "postMessage",
            "method": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ type: 'start', payload: 'data' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<worker.onmessage>",
          "metadata": {
            "objectName": "worker",
            "propertyName": "onmessage"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<onmessage-handler>",
          "metadata": {
            "arrowFunction": true,
            "eventHandler": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CALL",
          "id": "<console.log(e.data)>",
          "metadata": {
            "callee": "console.log",
            "method": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<e.data>",
          "metadata": {
            "objectName": "e",
            "propertyName": "data"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<worker.onerror>",
          "metadata": {
            "objectName": "worker",
            "propertyName": "onerror"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<onerror-handler>",
          "metadata": {
            "arrowFunction": true,
            "eventHandler": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<err>"
        },
        {
          "type": "CALL",
          "id": "<console.error(err)>",
          "metadata": {
            "callee": "console.error",
            "method": true
          }
        },
        {
          "type": "CALL",
          "id": "<worker.terminate>",
          "metadata": {
            "callee": "terminate",
            "method": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<workerCommunication>",
            "dst": "<worker>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Worker('./task.js')>",
            "dst": "<'./task.js'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<workerCommunication>",
            "dst": "<worker.postMessage>",
            "type": "CONTAINS"
          },
          {
            "src": "<worker.postMessage>",
            "dst": "<{ type: 'start', payload: 'data' }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<onmessage-handler>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<onmessage-handler>",
            "dst": "<console.log(e.data)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(e.data)>",
            "dst": "<e.data>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<onerror-handler>",
            "dst": "<err>",
            "type": "CONTAINS"
          },
          {
            "src": "<onerror-handler>",
            "dst": "<console.error(err)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.error(err)>",
            "dst": "<err>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<workerCommunication>",
            "dst": "<worker.terminate>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<worker>",
            "dst": "<new Worker('./task.js')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<worker.onmessage>",
            "dst": "<onmessage-handler>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<worker.onerror>",
            "dst": "<onerror-handler>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<e.data>",
            "dst": "<e>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::do-while",
      "category": "statements",
      "code": "function doWhileLoop() {\n  let attempts = 0;\n  do {\n    attempts++;\n  } while (attempts < 3);\n  return attempts;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<doWhileLoop>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<attempts>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<do-while>",
          "metadata": {
            "loopType": "do-while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<attempts++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<attempts < 3>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<doWhileLoop>",
            "dst": "<attempts>",
            "type": "CONTAINS"
          },
          {
            "src": "<doWhileLoop>",
            "dst": "<do-while>",
            "type": "CONTAINS"
          },
          {
            "src": "<do-while>",
            "dst": "<attempts++>",
            "type": "HAS_BODY"
          },
          {
            "src": "<do-while>",
            "dst": "<attempts < 3>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<doWhileLoop>",
            "dst": "<attempts>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<attempts>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<attempts++>",
            "dst": "<attempts>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<attempts < 3>",
            "dst": "<attempts>",
            "type": "READS_FROM"
          },
          {
            "src": "<attempts < 3>",
            "dst": "<3>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::while",
      "category": "statements",
      "code": "function whileLoop() {\n  let count = 0;\n  while (count < 5) {\n    count++;\n  }\n  return count;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<whileLoop>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<count>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<while>",
          "metadata": {
            "loopType": "while"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<count < 5>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<count++>",
          "metadata": {
            "operator": "++"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<whileLoop>",
            "dst": "<count>",
            "type": "DECLARES"
          },
          {
            "src": "<whileLoop>",
            "dst": "<while>",
            "type": "CONTAINS"
          },
          {
            "src": "<while>",
            "dst": "<count < 5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<while>",
            "dst": "<count++>",
            "type": "HAS_BODY"
          },
          {
            "src": "<whileLoop>",
            "dst": "<count>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<count>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<count++>",
            "dst": "<count>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<count < 5>",
            "dst": "<count>",
            "type": "READS_FROM"
          },
          {
            "src": "<count < 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::for-classic",
      "category": "statements",
      "code": "function classicFor() {\n  const results = [];\n  for (let i = 0; i < 10; i++) {\n    results.push(i);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<classicFor>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-classic>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 10>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<10>",
          "metadata": {
            "value": 10,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(i)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<results.push>",
          "metadata": {
            "objectName": "results",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<classicFor>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<classicFor>",
            "dst": "<for-classic>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-classic>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-classic>",
            "dst": "<i < 10>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-classic>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-classic>",
            "dst": "<results.push(i)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<results.push(i)>",
            "dst": "<i>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<classicFor>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i < 10>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 10>",
            "dst": "<10>",
            "type": "READS_FROM"
          },
          {
            "src": "<results.push(i)>",
            "dst": "<results.push>",
            "type": "CALLS"
          },
          {
            "src": "<results.push>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::switch-break",
      "category": "statements",
      "code": "function switchWithBreak(action) {\n  let result;\n  switch (action) {\n    case 'start':\n      result = 'starting';\n      break;\n    case 'stop':\n      result = 'stopping';\n      break;\n    default:\n      result = 'unknown';\n  }\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<switchWithBreak>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<action>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "BRANCH",
          "id": "<switch>",
          "metadata": {
            "branchType": "switch"
          }
        },
        {
          "type": "CASE",
          "id": "<case-start>",
          "metadata": {
            "value": "start"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'start'>",
          "metadata": {
            "value": "start",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'starting'>",
          "metadata": {
            "value": "starting",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<case-stop>",
          "metadata": {
            "value": "stop"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'stop'>",
          "metadata": {
            "value": "stop",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'stopping'>",
          "metadata": {
            "value": "stopping",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<default-case>",
          "metadata": {
            "isDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'unknown'>",
          "metadata": {
            "value": "unknown",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<switchWithBreak>",
            "dst": "<action>",
            "type": "CONTAINS"
          },
          {
            "src": "<switchWithBreak>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<switchWithBreak>",
            "dst": "<switch>",
            "type": "CONTAINS"
          },
          {
            "src": "<switch>",
            "dst": "<action>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<switch>",
            "dst": "<case-start>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch>",
            "dst": "<case-stop>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch>",
            "dst": "<default-case>",
            "type": "HAS_DEFAULT"
          },
          {
            "src": "<case-start>",
            "dst": "<'start'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-stop>",
            "dst": "<'stop'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<switchWithBreak>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<case-start>",
            "dst": "<result>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result>",
            "dst": "<'starting'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<case-stop>",
            "dst": "<result>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result>",
            "dst": "<'stopping'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<default-case>",
            "dst": "<result>",
            "type": "WRITES_TO"
          },
          {
            "src": "<result>",
            "dst": "<'unknown'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "statements::for-of",
      "category": "statements",
      "code": "function forOf(iterable) {\n  const values = [];\n  for (const item of iterable) {\n    values.push(item);\n  }\n  return values;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forOf>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<iterable>"
        },
        {
          "type": "VARIABLE",
          "id": "<values>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<values.push(item)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<values.push>",
          "metadata": {
            "objectName": "values",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forOf>",
            "dst": "<iterable>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOf>",
            "dst": "<values>",
            "type": "DECLARES"
          },
          {
            "src": "<forOf>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<iterable>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<values.push(item)>",
            "type": "CONTAINS"
          },
          {
            "src": "<values.push(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forOf>",
            "dst": "<values>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<values>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<values.push(item)>",
            "dst": "<values.push>",
            "type": "CALLS"
          },
          {
            "src": "<values.push>",
            "dst": "<values>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::if-else-if-chain",
      "category": "statements",
      "code": "function ifElseIfChain(x) {\n  if (x > 0) {\n    return 'positive';\n  } else if (x < 0) {\n    return 'negative';\n  } else {\n    return 'zero';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<ifElseIfChain>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "BRANCH",
          "id": "<if-x>0>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 0>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-first>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'positive'>",
          "metadata": {
            "value": "positive",
            "literalType": "string"
          }
        },
        {
          "type": "BRANCH",
          "id": "<else-if-x<0>",
          "metadata": {
            "branchType": "else-if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x < 0>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-second>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'negative'>",
          "metadata": {
            "value": "negative",
            "literalType": "string"
          }
        },
        {
          "type": "BRANCH",
          "id": "<else>",
          "metadata": {
            "branchType": "else"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'zero'>",
          "metadata": {
            "value": "zero",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<ifElseIfChain>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<ifElseIfChain>",
            "dst": "<if-x>0>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-x>0>",
            "dst": "<x > 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-x>0>",
            "dst": "<'positive'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ifElseIfChain>",
            "dst": "<'positive'>",
            "type": "RETURNS"
          },
          {
            "src": "<else-if-x<0>",
            "dst": "<x < 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<else-if-x<0>",
            "dst": "<'negative'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ifElseIfChain>",
            "dst": "<'negative'>",
            "type": "RETURNS"
          },
          {
            "src": "<else>",
            "dst": "<'zero'>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<ifElseIfChain>",
            "dst": "<'zero'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<if-x>0>",
            "dst": "<else-if-x<0>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<else-if-x<0>",
            "dst": "<else>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<x > 0>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 0>",
            "dst": "<0-first>",
            "type": "READS_FROM"
          },
          {
            "src": "<x < 0>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x < 0>",
            "dst": "<0-second>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "runtime-apis::runtime-promise-withresolvers-deferred",
      "category": "runtime-apis",
      "code": "function deferredPromise() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  // resolve/reject passed to different scopes as callbacks\n  setTimeout(() => reject(new Error('timeout')), 5000);\n  return { promise, resolve, reject };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<deferredPromise>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "CALL",
          "id": "<Promise.withResolvers()>",
          "metadata": {
            "callee": "Promise.withResolvers"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<promise>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resolve>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<reject>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "CALL",
          "id": "<setTimeout(...)>",
          "metadata": {
            "callee": "setTimeout"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<timeout-callback>",
          "metadata": {
            "arrowFunction": true,
            "anonymous": true
          }
        },
        {
          "type": "CALL",
          "id": "<reject(new Error('timeout'))>",
          "metadata": {
            "callee": "reject"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('timeout')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'timeout'>",
          "metadata": {
            "value": "timeout",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5000>",
          "metadata": {
            "value": 5000,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<deferredPromise>",
            "dst": "<Promise.withResolvers()>",
            "type": "CONTAINS"
          },
          {
            "src": "<deferredPromise>",
            "dst": "<setTimeout(...)>",
            "type": "CONTAINS"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "<timeout-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<setTimeout(...)>",
            "dst": "<5000>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<timeout-callback>",
            "dst": "<reject(new Error('timeout'))>",
            "type": "CONTAINS"
          },
          {
            "src": "<reject(new Error('timeout'))>",
            "dst": "<new Error('timeout')>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('timeout')>",
            "dst": "<'timeout'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<deferredPromise>",
            "dst": "<return-object>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<timeout-callback>",
            "dst": "<reject>",
            "type": "CAPTURES"
          }
        ],
        "postProject": [
          {
            "src": "<Promise.withResolvers()>",
            "dst": "<promise>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<Promise.withResolvers()>",
            "dst": "<resolve>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<Promise.withResolvers()>",
            "dst": "<reject>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<return-object>",
            "dst": "<promise>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<resolve>",
            "type": "READS_FROM"
          },
          {
            "src": "<return-object>",
            "dst": "<reject>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::for-of-destructuring",
      "category": "statements",
      "code": "function forOfDestructuring(entries) {\n  const result = {};\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forOfDestructuring>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<entries>"
        },
        {
          "type": "VARIABLE",
          "id": "<result>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": {},
            "literalType": "object"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<result[key]>",
          "metadata": {
            "objectName": "result",
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<result[key] = value>",
          "metadata": {
            "operator": "="
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forOfDestructuring>",
            "dst": "<entries>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructuring>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructuring>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<entries>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<result[key] = value>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructuring>",
            "dst": "<result>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<result>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<result[key] = value>",
            "dst": "<result[key]>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<result[key] = value>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<result[key]>",
            "dst": "<result>",
            "type": "READS_FROM"
          },
          {
            "src": "<result[key]>",
            "dst": "<key>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::try-finally",
      "category": "statements",
      "code": "function tryFinally() {\n  try {\n    doSomething();\n  } finally {\n    alwaysRun();\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tryFinally>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "CALL",
          "id": "<doSomething()>",
          "metadata": {
            "callee": "doSomething"
          }
        },
        {
          "type": "CALL",
          "id": "<alwaysRun()>",
          "metadata": {
            "callee": "alwaysRun"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<tryFinally>",
            "type": "DECLARES"
          },
          {
            "src": "<tryFinally>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<tryFinally>",
            "dst": "<finally-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<doSomething()>",
            "type": "HAS_BODY"
          },
          {
            "src": "<finally-block>",
            "dst": "<alwaysRun()>",
            "type": "HAS_BODY"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<try-block>",
            "dst": "<finally-block>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<doSomething()>",
            "dst": "<doSomething>",
            "type": "CALLS"
          },
          {
            "src": "<alwaysRun()>",
            "dst": "<alwaysRun>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "statements::debugger",
      "category": "statements",
      "code": "function debuggerStatement() {\n  debugger;\n  return 'after debugger';\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<debuggerStatement>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "SIDE_EFFECT",
          "id": "<debugger>",
          "metadata": {
            "effectType": "debugger"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'after debugger'>",
          "metadata": {
            "value": "after debugger",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<debuggerStatement>",
            "type": "DECLARES"
          },
          {
            "src": "<debuggerStatement>",
            "dst": "<debugger>",
            "type": "CONTAINS"
          },
          {
            "src": "<debuggerStatement>",
            "dst": "<'after debugger'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "statements::switch-return-fallthrough",
      "category": "statements",
      "code": "function switchWithReturn(action) {\n  switch (action) {\n    case 'start':\n      return 'starting';\n    case 'stop':\n      return 'stopping';\n    case 'pause':\n    case 'suspend':\n      return 'pausing';\n    default:\n      return 'unknown';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<switchWithReturn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<action>"
        },
        {
          "type": "BRANCH",
          "id": "<switch>",
          "metadata": {
            "branchType": "switch"
          }
        },
        {
          "type": "CASE",
          "id": "<case-start>",
          "metadata": {
            "value": "start"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'start'>",
          "metadata": {
            "value": "start",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'starting'>",
          "metadata": {
            "value": "starting",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<case-stop>",
          "metadata": {
            "value": "stop"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'stop'>",
          "metadata": {
            "value": "stop",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'stopping'>",
          "metadata": {
            "value": "stopping",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<case-pause>",
          "metadata": {
            "value": "pause"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'pause'>",
          "metadata": {
            "value": "pause",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<case-suspend>",
          "metadata": {
            "value": "suspend"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'suspend'>",
          "metadata": {
            "value": "suspend",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'pausing'>",
          "metadata": {
            "value": "pausing",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<default>",
          "metadata": {
            "isDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'unknown'>",
          "metadata": {
            "value": "unknown",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<switchWithReturn>",
            "dst": "<action>",
            "type": "CONTAINS"
          },
          {
            "src": "<switchWithReturn>",
            "dst": "<switch>",
            "type": "CONTAINS"
          },
          {
            "src": "<switch>",
            "dst": "<action>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<switch>",
            "dst": "<case-start>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch>",
            "dst": "<case-stop>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch>",
            "dst": "<case-pause>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch>",
            "dst": "<case-suspend>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch>",
            "dst": "<default>",
            "type": "HAS_DEFAULT"
          },
          {
            "src": "<case-start>",
            "dst": "<'start'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-start>",
            "dst": "<'starting'>",
            "type": "RETURNS"
          },
          {
            "src": "<case-stop>",
            "dst": "<'stop'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-stop>",
            "dst": "<'stopping'>",
            "type": "RETURNS"
          },
          {
            "src": "<case-pause>",
            "dst": "<'pause'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-suspend>",
            "dst": "<'suspend'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-suspend>",
            "dst": "<'pausing'>",
            "type": "RETURNS"
          },
          {
            "src": "<default>",
            "dst": "<'unknown'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<case-pause>",
            "dst": "<case-suspend>",
            "type": "FLOWS_INTO"
          }
        ]
      }
    },
    {
      "constructId": "statements::labeled-function",
      "category": "statements",
      "code": "myLabel: function labeledFn() { return 1; }",
      "expectedNodes": [
        {
          "type": "LABEL",
          "id": "<myLabel>",
          "metadata": {
            "labelType": "statement"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<labeledFn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<myLabel>",
            "type": "CONTAINS"
          },
          {
            "src": "<myLabel>",
            "dst": "<labeledFn>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<labeledFn>",
            "type": "DECLARES"
          },
          {
            "src": "<labeledFn>",
            "dst": "<1>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "statements::try-catch",
      "category": "statements",
      "code": "function tryCatch() {\n  try {\n    JSON.parse('invalid');\n  } catch (error) {\n    console.error(error.message);\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tryCatch>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<error>",
          "metadata": {
            "catchParameter": true
          }
        },
        {
          "type": "CALL",
          "id": "<JSON.parse('invalid')>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'invalid'>",
          "metadata": {
            "value": "invalid",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<console.error(error.message)>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<error.message>",
          "metadata": {
            "property": "message"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<JSON.parse>",
          "metadata": {
            "source": "global"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<console.error>",
          "metadata": {
            "source": "global"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tryCatch>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<tryCatch>",
            "dst": "<catch-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<catch-block>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<JSON.parse('invalid')>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSON.parse('invalid')>",
            "dst": "<'invalid'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<console.error(error.message)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.error(error.message)>",
            "dst": "<error.message>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<JSON.parse('invalid')>",
            "dst": "<catch-block>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<JSON.parse('invalid')>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<console.error(error.message)>",
            "dst": "<console.error>",
            "type": "CALLS"
          },
          {
            "src": "<error.message>",
            "dst": "<error>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::finally-return-override",
      "category": "statements",
      "code": "function finallyReturnOverride() {\n  try {\n    return 1;\n  } finally {\n    return 2; // swallows try return  returns 2\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<finallyReturnOverride>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally>"
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<finallyReturnOverride>",
            "dst": "<try>",
            "type": "CONTAINS"
          },
          {
            "src": "<finallyReturnOverride>",
            "dst": "<finally>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try>",
            "dst": "<1>",
            "type": "RETURNS"
          },
          {
            "src": "<finally>",
            "dst": "<2>",
            "type": "RETURNS"
          },
          {
            "src": "<finallyReturnOverride>",
            "dst": "<2>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "statements::catch-no-binding",
      "category": "statements",
      "code": "function catchWithoutBinding() {\n  try {\n    JSON.parse('{}');\n  } catch {\n    console.error('parse failed');\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<catchWithoutBinding>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>",
          "metadata": {
            "hasBinding": false
          }
        },
        {
          "type": "CALL",
          "id": "<JSON.parse('{}')>",
          "metadata": {
            "callee": "JSON.parse"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<JSON.parse>",
          "metadata": {
            "objectName": "JSON",
            "propertyName": "parse"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'{}'>",
          "metadata": {
            "value": "{}",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<console.error('parse failed')>",
          "metadata": {
            "callee": "console.error"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.error>",
          "metadata": {
            "objectName": "console",
            "propertyName": "error"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'parse failed'>",
          "metadata": {
            "value": "parse failed",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<catchWithoutBinding>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<catchWithoutBinding>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<try-block>",
            "dst": "<JSON.parse('{}')>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSON.parse('{}')>",
            "dst": "<'{}'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<console.error('parse failed')>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.error('parse failed')>",
            "dst": "<'parse failed'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<JSON.parse('{}')>",
            "dst": "<JSON.parse>",
            "type": "CALLS"
          },
          {
            "src": "<console.error('parse failed')>",
            "dst": "<console.error>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "statements::labeled-block",
      "category": "statements",
      "code": "function labeledBlock() {\n  block: {\n    if (true) break block;\n    unreachable();\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<labeledBlock>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LABEL",
          "id": "<block>",
          "metadata": {
            "labelName": "block"
          }
        },
        {
          "type": "SCOPE",
          "id": "<block-scope>",
          "metadata": {
            "scopeType": "block"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-true>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "CALL",
          "id": "<unreachable()>",
          "metadata": {
            "callee": "unreachable"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<labeledBlock>",
            "dst": "<block>",
            "type": "CONTAINS"
          },
          {
            "src": "<block>",
            "dst": "<block-scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<block-scope>",
            "dst": "<if-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<block-scope>",
            "dst": "<unreachable()>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<unreachable()>",
            "dst": "<unreachable>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "statements::try-catch-finally",
      "category": "statements",
      "code": "function tryCatchFinally() {\n  let resource;\n  try {\n    resource = openResource();\n  } catch (error) {\n    handleError(error);\n  } finally {\n    cleanup(resource);\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tryCatchFinally>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<resource>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CALL",
          "id": "<openResource()>",
          "metadata": {
            "callee": "openResource"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<error>"
        },
        {
          "type": "CALL",
          "id": "<handleError(error)>",
          "metadata": {
            "callee": "handleError"
          }
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "CALL",
          "id": "<cleanup(resource)>",
          "metadata": {
            "callee": "cleanup"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tryCatchFinally>",
            "dst": "<resource>",
            "type": "CONTAINS"
          },
          {
            "src": "<tryCatchFinally>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<tryCatchFinally>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<tryCatchFinally>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<try-block>",
            "dst": "<openResource()>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<handleError(error)>",
            "type": "CONTAINS"
          },
          {
            "src": "<handleError(error)>",
            "dst": "<error>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<finally-block>",
            "dst": "<cleanup(resource)>",
            "type": "CONTAINS"
          },
          {
            "src": "<cleanup(resource)>",
            "dst": "<resource>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<resource>",
            "dst": "<openResource()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "statements::empty-statement",
      "category": "statements",
      "code": "function emptyStatements() {\n  ;\n  for (let i = 0; i < 0; i++);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<emptyStatements>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-init>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 0>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-condition>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<emptyStatements>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "DECLARES"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          }
        ],
        "postFile": [
          {
            "src": "<i>",
            "dst": "<0-init>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i < 0>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 0>",
            "dst": "<0-condition>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::try-nested",
      "category": "statements",
      "code": "function nestedTryCatch() {\n  try {\n    try {\n      riskyOperation();\n    } catch (innerError) {\n      fallback(innerError);\n    }\n  } catch (outerError) {\n    lastResort(outerError);\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<nestedTryCatch>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<outer-try>",
          "metadata": {
            "level": "outer"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<outer-catch>",
          "metadata": {
            "level": "outer"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<outerError>"
        },
        {
          "type": "TRY_BLOCK",
          "id": "<inner-try>",
          "metadata": {
            "level": "inner"
          }
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<inner-catch>",
          "metadata": {
            "level": "inner"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<innerError>"
        },
        {
          "type": "CALL",
          "id": "<riskyOperation()>",
          "metadata": {
            "callee": "riskyOperation"
          }
        },
        {
          "type": "CALL",
          "id": "<fallback(innerError)>",
          "metadata": {
            "callee": "fallback"
          }
        },
        {
          "type": "CALL",
          "id": "<lastResort(outerError)>",
          "metadata": {
            "callee": "lastResort"
          }
        },
        {
          "type": "EXTERNAL",
          "id": "<riskyOperation>"
        },
        {
          "type": "EXTERNAL",
          "id": "<fallback>"
        },
        {
          "type": "EXTERNAL",
          "id": "<lastResort>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<nestedTryCatch>",
            "dst": "<outer-try>",
            "type": "HAS_BODY"
          },
          {
            "src": "<outer-try>",
            "dst": "<outer-catch>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<outer-catch>",
            "dst": "<outerError>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<outer-try>",
            "dst": "<inner-try>",
            "type": "CONTAINS"
          },
          {
            "src": "<inner-try>",
            "dst": "<inner-catch>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<inner-catch>",
            "dst": "<innerError>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<inner-try>",
            "dst": "<riskyOperation()>",
            "type": "CONTAINS"
          },
          {
            "src": "<inner-catch>",
            "dst": "<fallback(innerError)>",
            "type": "CONTAINS"
          },
          {
            "src": "<outer-catch>",
            "dst": "<lastResort(outerError)>",
            "type": "CONTAINS"
          },
          {
            "src": "<fallback(innerError)>",
            "dst": "<innerError>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<lastResort(outerError)>",
            "dst": "<outerError>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<riskyOperation()>",
            "dst": "<inner-catch>",
            "type": "CATCHES_FROM"
          },
          {
            "src": "<fallback(innerError)>",
            "dst": "<outer-catch>",
            "type": "CATCHES_FROM"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<riskyOperation()>",
            "dst": "<riskyOperation>",
            "type": "CALLS"
          },
          {
            "src": "<fallback(innerError)>",
            "dst": "<fallback>",
            "type": "CALLS"
          },
          {
            "src": "<lastResort(outerError)>",
            "dst": "<lastResort>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::array-from-mapfn",
      "category": "builtins",
      "code": "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<arrayFromMapFn>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<indices>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<Array.from({ length: 5 }, (_, i) => i)>",
          "metadata": {
            "callee": "Array.from"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ length: 5 }>",
          "metadata": {
            "value": "{ length: 5 }",
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<(_, i) => i>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<_>"
        },
        {
          "type": "PARAMETER",
          "id": "<i>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<arrayFromMapFn>",
            "dst": "<indices>",
            "type": "CONTAINS"
          },
          {
            "src": "<Array.from({ length: 5 }, (_, i) => i)>",
            "dst": "<{ length: 5 }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Array.from({ length: 5 }, (_, i) => i)>",
            "dst": "<(_, i) => i>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<(_, i) => i>",
            "dst": "<_>",
            "type": "CONTAINS"
          },
          {
            "src": "<(_, i) => i>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<(_, i) => i>",
            "dst": "<i>",
            "type": "RETURNS"
          },
          {
            "src": "<arrayFromMapFn>",
            "dst": "<indices>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<indices>",
            "dst": "<Array.from({ length: 5 }, (_, i) => i)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Array.from({ length: 5 }, (_, i) => i)>",
            "dst": "<Array.from>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "statements::finally-throw-override",
      "category": "statements",
      "code": "function finallyThrowOverride() {\n  try {\n    throw new Error('original');\n  } catch (e) {\n    throw new Error('from catch');\n  } finally {\n    throw new Error('from finally'); // swallows catch throw\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<finallyThrowOverride>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "FINALLY_BLOCK",
          "id": "<finally-block>"
        },
        {
          "type": "PARAMETER",
          "id": "<e>"
        },
        {
          "type": "CALL",
          "id": "<new Error('original')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'original'>",
          "metadata": {
            "value": "original",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('from catch')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'from catch'>",
          "metadata": {
            "value": "from catch",
            "literalType": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('from finally')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'from finally'>",
          "metadata": {
            "value": "from finally",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<finallyThrowOverride>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<finallyThrowOverride>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<finallyThrowOverride>",
            "dst": "<finally-block>",
            "type": "HAS_FINALLY"
          },
          {
            "src": "<catch-block>",
            "dst": "<e>",
            "type": "CONTAINS"
          },
          {
            "src": "<new Error('original')>",
            "dst": "<'original'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('from catch')>",
            "dst": "<'from catch'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<new Error('from finally')>",
            "dst": "<'from finally'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<catch-block>",
            "dst": "<new Error('original')>",
            "type": "CATCHES_FROM"
          }
        ],
        "postFile": [
          {
            "src": "<try-block>",
            "dst": "<new Error('original')>",
            "type": "THROWS"
          },
          {
            "src": "<catch-block>",
            "dst": "<new Error('from catch')>",
            "type": "THROWS"
          },
          {
            "src": "<finally-block>",
            "dst": "<new Error('from finally')>",
            "type": "THROWS"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "statements::tdz-switch-fallthrough",
      "category": "statements",
      "code": "function tdzSwitch(x) {\n  switch (x) {\n    case 1:\n      let y = 1; // y scoped to ENTIRE switch block\n      break;\n    case 2:\n      // console.log(y); // ReferenceError  TDZ\n      break;\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<tdzSwitch>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "BRANCH",
          "id": "<switch>",
          "metadata": {
            "branchType": "switch"
          }
        },
        {
          "type": "SCOPE",
          "id": "<switch-block-scope>",
          "metadata": {
            "scopeType": "block"
          }
        },
        {
          "type": "CASE",
          "id": "<case-1>",
          "metadata": {
            "value": 1
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<y>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1-init>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "CASE",
          "id": "<case-2>",
          "metadata": {
            "value": 2
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<tdzSwitch>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<tdzSwitch>",
            "dst": "<switch>",
            "type": "CONTAINS"
          },
          {
            "src": "<switch>",
            "dst": "<x>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<switch>",
            "dst": "<switch-block-scope>",
            "type": "HAS_SCOPE"
          },
          {
            "src": "<switch-block-scope>",
            "dst": "<y>",
            "type": "DECLARES"
          },
          {
            "src": "<switch>",
            "dst": "<case-1>",
            "type": "HAS_CASE"
          },
          {
            "src": "<case-1>",
            "dst": "<1>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-1>",
            "dst": "<y>",
            "type": "CONTAINS"
          },
          {
            "src": "<switch>",
            "dst": "<case-2>",
            "type": "HAS_CASE"
          },
          {
            "src": "<case-2>",
            "dst": "<2>",
            "type": "HAS_CONDITION"
          }
        ],
        "postFile": [
          {
            "src": "<y>",
            "dst": "<1-init>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "statements::for-of-no-declaration",
      "category": "statements",
      "code": "function forOfNoDeclaration(items) {\n  let item;\n  for (item of items) {           // REASSIGNS existing var, not declaration\n    console.log(item);\n  }\n  return item; // last item  outer var mutated\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forOfNoDeclaration>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>"
        },
        {
          "type": "VARIABLE",
          "id": "<item>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(item)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forOfNoDeclaration>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfNoDeclaration>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfNoDeclaration>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<items>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<console.log(item)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(item)>",
            "dst": "<item>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forOfNoDeclaration>",
            "dst": "<item>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<for-of>",
            "dst": "<item>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(item)>",
            "dst": "<console.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "statements::destructure-catch-clause",
      "category": "statements",
      "code": "function destructureCatchClause() {\n  try {\n    throw { code: 'ENOENT', message: 'not found' };\n  } catch ({ code, message }) {\n    return { code, message };\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureCatchClause>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "LITERAL",
          "id": "<{ code: 'ENOENT', message: 'not found' }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'ENOENT'>",
          "metadata": {
            "value": "ENOENT",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'not found'>",
          "metadata": {
            "value": "not found",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<code>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<message>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ code, message }>",
          "metadata": {
            "literalType": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureCatchClause>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureCatchClause>",
            "dst": "<catch-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<{ code: 'ENOENT', message: 'not found' }>",
            "dst": "<'ENOENT'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ code: 'ENOENT', message: 'not found' }>",
            "dst": "<'not found'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<catch-block>",
            "dst": "<code>",
            "type": "DECLARES"
          },
          {
            "src": "<catch-block>",
            "dst": "<message>",
            "type": "DECLARES"
          },
          {
            "src": "<destructureCatchClause>",
            "dst": "<{ code, message }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<try-block>",
            "dst": "<{ code: 'ENOENT', message: 'not found' }>",
            "type": "THROWS"
          },
          {
            "src": "<code>",
            "dst": "<{ code: 'ENOENT', message: 'not found' }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<message>",
            "dst": "<{ code: 'ENOENT', message: 'not found' }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ code, message }>",
            "dst": "<code>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ code, message }>",
            "dst": "<message>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::throw",
      "category": "statements",
      "code": "function throwError(type) {\n  if (type === 'error') {\n    throw new Error('Something went wrong');\n  }\n  if (type === 'custom') {\n    throw { code: 'CUSTOM', message: 'Custom error' };\n  }\n  if (type === 'string') {\n    throw 'simple string error';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<throwError>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<type>"
        },
        {
          "type": "BRANCH",
          "id": "<if-error>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<type === 'error'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'error'>",
          "metadata": {
            "value": "error",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw-error>",
          "metadata": {
            "throwType": "constructor"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('Something went wrong')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Something went wrong'>",
          "metadata": {
            "value": "Something went wrong",
            "literalType": "string"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-custom>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<type === 'custom'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'custom'>",
          "metadata": {
            "value": "custom",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw-custom>",
          "metadata": {
            "throwType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<custom-object>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'CUSTOM'>",
          "metadata": {
            "value": "CUSTOM",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Custom error'>",
          "metadata": {
            "value": "Custom error",
            "literalType": "string"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-string>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<type === 'string'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<'string'>",
          "metadata": {
            "value": "string",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw-string>",
          "metadata": {
            "throwType": "literal"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'simple string error'>",
          "metadata": {
            "value": "simple string error",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<throwError>",
            "dst": "<type>",
            "type": "CONTAINS"
          },
          {
            "src": "<throwError>",
            "dst": "<if-error>",
            "type": "CONTAINS"
          },
          {
            "src": "<throwError>",
            "dst": "<if-custom>",
            "type": "CONTAINS"
          },
          {
            "src": "<throwError>",
            "dst": "<if-string>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-error>",
            "dst": "<type === 'error'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-error>",
            "dst": "<throw-error>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<new Error('Something went wrong')>",
            "dst": "<'Something went wrong'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<if-custom>",
            "dst": "<type === 'custom'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-custom>",
            "dst": "<throw-custom>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<custom-object>",
            "dst": "<'CUSTOM'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<custom-object>",
            "dst": "<'Custom error'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<if-string>",
            "dst": "<type === 'string'>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-string>",
            "dst": "<throw-string>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<throw-error>",
            "dst": "<new Error('Something went wrong')>",
            "type": "THROWS"
          },
          {
            "src": "<throw-custom>",
            "dst": "<custom-object>",
            "type": "THROWS"
          },
          {
            "src": "<throw-string>",
            "dst": "<'simple string error'>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<type === 'error'>",
            "dst": "<type>",
            "type": "READS_FROM"
          },
          {
            "src": "<type === 'error'>",
            "dst": "<'error'>",
            "type": "READS_FROM"
          },
          {
            "src": "<type === 'custom'>",
            "dst": "<type>",
            "type": "READS_FROM"
          },
          {
            "src": "<type === 'custom'>",
            "dst": "<'custom'>",
            "type": "READS_FROM"
          },
          {
            "src": "<type === 'string'>",
            "dst": "<type>",
            "type": "READS_FROM"
          },
          {
            "src": "<type === 'string'>",
            "dst": "<'string'>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::labeled-continue",
      "category": "statements",
      "code": "function labeledContinue() {\n  const results = [];\n  loop: for (let i = 0; i < 5; i++) {\n    if (i === 3) continue loop;\n    results.push(i);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<labeledContinue>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LABEL",
          "id": "<loop>",
          "metadata": {
            "labelName": "loop"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-loop>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 5>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-i===3>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i === 3>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<continue-loop>",
          "metadata": {
            "statementType": "continue",
            "targetLabel": "loop"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(i)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<results.push>",
          "metadata": {
            "objectName": "results",
            "propertyName": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<labeledContinue>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<labeledContinue>",
            "dst": "<loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<labeledContinue>",
            "dst": "<for-loop>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-loop>",
            "dst": "<i < 5>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-loop>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-loop>",
            "dst": "<if-i===3>",
            "type": "HAS_BODY"
          },
          {
            "src": "<if-i===3>",
            "dst": "<i === 3>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-i===3>",
            "dst": "<continue-loop>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<for-loop>",
            "dst": "<results.push(i)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<results.push(i)>",
            "dst": "<i>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<labeledContinue>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<i < 5>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 5>",
            "dst": "<5>",
            "type": "READS_FROM"
          },
          {
            "src": "<i === 3>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i === 3>",
            "dst": "<3>",
            "type": "READS_FROM"
          },
          {
            "src": "<continue-loop>",
            "dst": "<loop>",
            "type": "FLOWS_INTO"
          },
          {
            "src": "<results.push(i)>",
            "dst": "<results.push>",
            "type": "CALLS"
          },
          {
            "src": "<results.push>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::for-in-no-declaration",
      "category": "statements",
      "code": "function forInNoDeclaration(obj) {\n  let key;\n  for (key in obj) {              // REASSIGNS existing var\n    console.log(key);\n  }\n  return key; // last key  outer var mutated\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forInNoDeclaration>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>"
        },
        {
          "type": "VARIABLE",
          "id": "<key>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-in>",
          "metadata": {
            "loopType": "for-in"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(key)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forInNoDeclaration>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<forInNoDeclaration>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<forInNoDeclaration>",
            "dst": "<for-in>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-in>",
            "dst": "<obj>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-in>",
            "dst": "<console.log(key)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<console.log(key)>",
            "dst": "<key>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forInNoDeclaration>",
            "dst": "<key>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<for-in>",
            "dst": "<key>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(key)>",
            "dst": "<console.log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "builtins::sparse-array",
      "category": "builtins",
      "code": "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false  hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sparseArrayOps>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<sparse>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<sparse-array>",
          "metadata": {
            "value": "[1, , 3, , 5]",
            "literalType": "array",
            "sparse": true,
            "holes": [
              1,
              3
            ]
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<5>",
          "metadata": {
            "value": 5,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<length>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<sparse.length>",
          "metadata": {
            "property": "length"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hasIndex1>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<1 in sparse>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1-key>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<mapped>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<sparse.map(x => x * 2)>",
          "metadata": {
            "method": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<map-callback>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<return-object>",
          "metadata": {
            "type": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<sparseArrayOps>",
            "dst": "<sparse>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<length>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<hasIndex1>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<mapped>",
            "type": "CONTAINS"
          },
          {
            "src": "<sparse-array>",
            "dst": "<1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<sparse-array>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<sparse-array>",
            "dst": "<5>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<sparse.map(x => x * 2)>",
            "dst": "<map-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<map-callback>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<map-callback>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          },
          {
            "src": "<sparseArrayOps>",
            "dst": "<return-object>",
            "type": "RETURNS"
          },
          {
            "src": "<return-object>",
            "dst": "<length>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<hasIndex1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<return-object>",
            "dst": "<mapped>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<sparse>",
            "dst": "<sparse-array>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<length>",
            "dst": "<sparse.length>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hasIndex1>",
            "dst": "<1 in sparse>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<mapped>",
            "dst": "<sparse.map(x => x * 2)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<sparse.length>",
            "dst": "<sparse>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 in sparse>",
            "dst": "<1-key>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 in sparse>",
            "dst": "<sparse>",
            "type": "READS_FROM"
          },
          {
            "src": "<sparse.map(x => x * 2)>",
            "dst": "<sparse>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::switch-true-pattern",
      "category": "statements",
      "code": "function switchTruePattern(x) {\n  switch (true) {\n    case x > 100: return 'high';\n    case x > 50:  return 'medium';\n    case x > 0:   return 'low';\n    default:       return 'none';\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<switchTruePattern>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>"
        },
        {
          "type": "BRANCH",
          "id": "<switch-true>",
          "metadata": {
            "branchType": "switch"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "CASE",
          "id": "<case-x>100>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 100>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<100>",
          "metadata": {
            "value": 100,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'high'>",
          "metadata": {
            "value": "high",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<case-x>50>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 50>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<50>",
          "metadata": {
            "value": 50,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'medium'>",
          "metadata": {
            "value": "medium",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<case-x>0>"
        },
        {
          "type": "EXPRESSION",
          "id": "<x > 0>",
          "metadata": {
            "operator": ">"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'low'>",
          "metadata": {
            "value": "low",
            "literalType": "string"
          }
        },
        {
          "type": "CASE",
          "id": "<default-case>",
          "metadata": {
            "isDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'none'>",
          "metadata": {
            "value": "none",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<switchTruePattern>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<switchTruePattern>",
            "dst": "<switch-true>",
            "type": "CONTAINS"
          },
          {
            "src": "<switch-true>",
            "dst": "<true>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<switch-true>",
            "dst": "<case-x>100>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch-true>",
            "dst": "<case-x>50>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch-true>",
            "dst": "<case-x>0>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch-true>",
            "dst": "<default-case>",
            "type": "HAS_DEFAULT"
          },
          {
            "src": "<case-x>100>",
            "dst": "<x > 100>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-x>100>",
            "dst": "<'high'>",
            "type": "RETURNS"
          },
          {
            "src": "<case-x>50>",
            "dst": "<x > 50>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-x>50>",
            "dst": "<'medium'>",
            "type": "RETURNS"
          },
          {
            "src": "<case-x>0>",
            "dst": "<x > 0>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<case-x>0>",
            "dst": "<'low'>",
            "type": "RETURNS"
          },
          {
            "src": "<default-case>",
            "dst": "<'none'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<x > 100>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 100>",
            "dst": "<100>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 50>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 50>",
            "dst": "<50>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 0>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x > 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::for-of-destructure-assign",
      "category": "statements",
      "code": "function forOfDestructureAssign(pairs) {\n  let a, b;\n  for ([a, b] of pairs) {        // destructuring assignment in for-of head\n    console.log(a, b);\n  }\n  return { a, b }; // last pair values\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forOfDestructureAssign>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<pairs>"
        },
        {
          "type": "VARIABLE",
          "id": "<a>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<b>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[a, b]>",
          "metadata": {
            "type": "array-pattern"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(a, b)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<console.log>",
          "metadata": {
            "objectName": "console",
            "propertyName": "log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ a, b }>",
          "metadata": {
            "type": "object",
            "shorthandProperties": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forOfDestructureAssign>",
            "dst": "<pairs>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructureAssign>",
            "dst": "<a>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructureAssign>",
            "dst": "<b>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructureAssign>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<pairs>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<console.log(a, b)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(a, b)>",
            "dst": "<a>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<console.log(a, b)>",
            "dst": "<b>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forOfDestructureAssign>",
            "dst": "<{ a, b }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<[a, b]>",
            "dst": "<a>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<[a, b]>",
            "dst": "<b>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<console.log(a, b)>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<{ a, b }>",
            "dst": "<a>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ a, b }>",
            "dst": "<b>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::interface-basic",
      "category": "ts-specific",
      "code": "interface User {\n  name: string;\n  age: number;\n  email?: string;\n  readonly id: number;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<User>"
        },
        {
          "type": "PROPERTY",
          "id": "<User.name>",
          "metadata": {
            "type": "string",
            "optional": false,
            "readonly": false
          }
        },
        {
          "type": "PROPERTY",
          "id": "<User.age>",
          "metadata": {
            "type": "number",
            "optional": false,
            "readonly": false
          }
        },
        {
          "type": "PROPERTY",
          "id": "<User.email>",
          "metadata": {
            "type": "string",
            "optional": true,
            "readonly": false
          }
        },
        {
          "type": "PROPERTY",
          "id": "<User.id>",
          "metadata": {
            "type": "number",
            "optional": false,
            "readonly": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<User>",
            "type": "DECLARES"
          },
          {
            "src": "<User>",
            "dst": "<User.name>",
            "type": "CONTAINS"
          },
          {
            "src": "<User>",
            "dst": "<User.age>",
            "type": "CONTAINS"
          },
          {
            "src": "<User>",
            "dst": "<User.email>",
            "type": "CONTAINS"
          },
          {
            "src": "<User>",
            "dst": "<User.id>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "statements::for-of-destructuring-object",
      "category": "statements",
      "code": "function forOfDestructuringObject() {\n  const points = [{ x: 1, y: 2 }, { x: 3, y: 4 }];\n  const results = [];\n  for (const { x, y } of points) {\n    results.push(x + y);\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forOfDestructuringObject>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<points>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ x: 1, y: 2 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ x: 3, y: 4 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<4>",
          "metadata": {
            "value": 4,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-of>",
          "metadata": {
            "loopType": "for-of"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<x>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<y>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(x + y)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x + y>",
          "metadata": {
            "operator": "+"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forOfDestructuringObject>",
            "dst": "<points>",
            "type": "CONTAINS"
          },
          {
            "src": "<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>",
            "dst": "<{ x: 1, y: 2 }>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>",
            "dst": "<{ x: 3, y: 4 }>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<{ x: 1, y: 2 }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ x: 1, y: 2 }>",
            "dst": "<2>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ x: 3, y: 4 }>",
            "dst": "<3>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ x: 3, y: 4 }>",
            "dst": "<4>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<forOfDestructuringObject>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<forOfDestructuringObject>",
            "dst": "<for-of>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<points>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-of>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<y>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-of>",
            "dst": "<results.push(x + y)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<results.push(x + y)>",
            "dst": "<x + y>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forOfDestructuringObject>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<points>",
            "dst": "<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(x + y)>",
            "dst": "<results>",
            "type": "CALLS_ON"
          },
          {
            "src": "<x + y>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x + y>",
            "dst": "<y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::for-in-destructuring",
      "category": "statements",
      "code": "function forInDestructuring() {\n  const results = [];\n  for (const { length } in { abc: 1, de: 2, f: 3 }) {\n    results.push(length); // 3, 2, 1  destructures the string KEY, not value\n  }\n  return results;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forInDestructuring>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<results>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": [],
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-in>",
          "metadata": {
            "loopType": "for-in"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<length>",
          "metadata": {
            "kind": "const",
            "destructured": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ abc: 1, de: 2, f: 3 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "CALL",
          "id": "<results.push(length)>",
          "metadata": {
            "callee": "push"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<results.push>",
          "metadata": {
            "property": "push"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<forInDestructuring>",
            "dst": "<results>",
            "type": "CONTAINS"
          },
          {
            "src": "<forInDestructuring>",
            "dst": "<for-in>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-in>",
            "dst": "<{ abc: 1, de: 2, f: 3 }>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-in>",
            "dst": "<length>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-in>",
            "dst": "<results.push(length)>",
            "type": "HAS_BODY"
          },
          {
            "src": "<results.push(length)>",
            "dst": "<length>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<forInDestructuring>",
            "dst": "<results>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<results>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<results.push(length)>",
            "dst": "<results.push>",
            "type": "CALLS"
          },
          {
            "src": "<results.push>",
            "dst": "<results>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-typed-function",
      "category": "ts-specific",
      "code": "function typedFunction(name: string, age: number): string {\n  return `${name} is ${age}`;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<typedFunction>",
          "metadata": {
            "async": false,
            "generator": false,
            "typed": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<age>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string:return>",
          "metadata": {
            "typeName": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<`${name} is ${age}`>"
        },
        {
          "type": "EXPRESSION",
          "id": "<${name}>"
        },
        {
          "type": "EXPRESSION",
          "id": "<${age}>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<typedFunction>",
            "type": "DECLARES"
          },
          {
            "src": "<typedFunction>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<typedFunction>",
            "dst": "<age>",
            "type": "CONTAINS"
          },
          {
            "src": "<typedFunction>",
            "dst": "<string:return>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<typedFunction>",
            "dst": "<`${name} is ${age}`>",
            "type": "RETURNS"
          },
          {
            "src": "<`${name} is ${age}`>",
            "dst": "<${name}>",
            "type": "CONTAINS"
          },
          {
            "src": "<`${name} is ${age}`>",
            "dst": "<${age}>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<name>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<age>",
            "dst": "<number>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<${name}>",
            "dst": "<name>",
            "type": "READS_FROM"
          },
          {
            "src": "<${age}>",
            "dst": "<age>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::interface-method",
      "category": "ts-specific",
      "code": "interface Printable {\n  print(): void;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<Printable>",
          "metadata": {
            "kind": "interface"
          }
        },
        {
          "type": "METHOD",
          "id": "<Printable.print>",
          "metadata": {
            "kind": "interface-method",
            "returnType": "void"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Printable>",
            "type": "DECLARES"
          },
          {
            "src": "<Printable>",
            "dst": "<Printable.print>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "statements::destructure-catch-nested",
      "category": "statements",
      "code": "function destructureCatchNested() {\n  try {\n    throw { errors: [{ code: 'E1', path: '/api' }], status: 500 };\n  } catch ({ errors: [{ code, path }], status }) {\n    return { code, path, status };\n  }\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<destructureCatchNested>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "TRY_BLOCK",
          "id": "<try-block>"
        },
        {
          "type": "CATCH_BLOCK",
          "id": "<catch-block>"
        },
        {
          "type": "LITERAL",
          "id": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'E1'>",
          "metadata": {
            "value": "E1",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/api'>",
          "metadata": {
            "value": "/api",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<500>",
          "metadata": {
            "value": 500,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<code>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<path>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<status>",
          "metadata": {
            "destructured": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ code, path, status }>",
          "metadata": {
            "objectLiteral": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<destructureCatchNested>",
            "dst": "<try-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<destructureCatchNested>",
            "dst": "<catch-block>",
            "type": "CONTAINS"
          },
          {
            "src": "<try-block>",
            "dst": "<catch-block>",
            "type": "HAS_CATCH"
          },
          {
            "src": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "dst": "<'E1'>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "dst": "<'/api'>",
            "type": "CONTAINS"
          },
          {
            "src": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "dst": "<500>",
            "type": "CONTAINS"
          },
          {
            "src": "<catch-block>",
            "dst": "<code>",
            "type": "DECLARES"
          },
          {
            "src": "<catch-block>",
            "dst": "<path>",
            "type": "DECLARES"
          },
          {
            "src": "<catch-block>",
            "dst": "<status>",
            "type": "DECLARES"
          },
          {
            "src": "<destructureCatchNested>",
            "dst": "<{ code, path, status }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<try-block>",
            "dst": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "type": "THROWS"
          },
          {
            "src": "<code>",
            "dst": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<path>",
            "dst": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<status>",
            "dst": "<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{ code, path, status }>",
            "dst": "<code>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ code, path, status }>",
            "dst": "<path>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ code, path, status }>",
            "dst": "<status>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::interface-extends",
      "category": "ts-specific",
      "code": "interface Admin extends User, Printable {\n  role: string;\n  permissions: string[];\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<Admin>",
          "metadata": {
            "language": "typescript"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Admin.role>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Admin.permissions>",
          "metadata": {
            "type": "string[]"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Admin>",
            "type": "DECLARES"
          },
          {
            "src": "<Admin>",
            "dst": "<Admin.role>",
            "type": "CONTAINS"
          },
          {
            "src": "<Admin>",
            "dst": "<Admin.permissions>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Admin>",
            "dst": "<User>",
            "type": "EXTENDS"
          },
          {
            "src": "<Admin>",
            "dst": "<Printable>",
            "type": "EXTENDS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::interface-index-signature",
      "category": "ts-specific",
      "code": "interface StringMap {\n  [key: string]: string;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<StringMap>"
        },
        {
          "type": "PROPERTY",
          "id": "<StringMap[key: string]>",
          "metadata": {
            "keyType": "string",
            "valueType": "string",
            "isIndexSignature": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>",
          "metadata": {
            "type": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<StringMap>",
            "type": "DECLARES"
          },
          {
            "src": "<StringMap>",
            "dst": "<StringMap[key: string]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<StringMap[key: string]>",
            "dst": "<key>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::type-alias-union",
      "category": "ts-specific",
      "code": "type ID = string | number;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ID>",
          "metadata": {
            "kind": "union"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "primitive": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ID>",
            "type": "DECLARES"
          },
          {
            "src": "<ID>",
            "dst": "<string>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<ID>",
            "dst": "<number>",
            "type": "UNION_MEMBER"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-typed-arrow",
      "category": "ts-specific",
      "code": "const typedArrow = (x: number): number => x * 2;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<typedArrow>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<typedArrow:fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x>",
          "metadata": {
            "typeAnnotation": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:param>",
          "metadata": {
            "typeName": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:return>",
          "metadata": {
            "typeName": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<x * 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<typedArrow>",
            "type": "DECLARES"
          },
          {
            "src": "<typedArrow:fn>",
            "dst": "<x>",
            "type": "CONTAINS"
          },
          {
            "src": "<typedArrow:fn>",
            "dst": "<number:return>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<typedArrow:fn>",
            "dst": "<x * 2>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<typedArrow>",
            "dst": "<typedArrow:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<x>",
            "dst": "<number:param>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<x * 2>",
            "dst": "<x>",
            "type": "READS_FROM"
          },
          {
            "src": "<x * 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::interface-construct-signature",
      "category": "ts-specific",
      "code": "interface Constructor {\n  new (name: string): User;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<Constructor>",
          "metadata": {
            "kind": "interface"
          }
        },
        {
          "type": "METHOD",
          "id": "<Constructor.new>",
          "metadata": {
            "kind": "construct",
            "isConstructSignature": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<User>",
          "metadata": {
            "primitive": false
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Constructor>",
            "dst": "<Constructor.new>",
            "type": "CONTAINS"
          },
          {
            "src": "<Constructor.new>",
            "dst": "<name>",
            "type": "RECEIVES_ARGUMENT"
          },
          {
            "src": "<Constructor.new>",
            "dst": "<User>",
            "type": "RETURNS_TYPE"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<name>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::interface-call-signature",
      "category": "ts-specific",
      "code": "interface Logger {\n  (message: string): void;\n  level: string;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<Logger>",
          "metadata": {
            "callable": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Logger:call>",
          "metadata": {
            "returnType": "void",
            "isCallSignature": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<message>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Logger.level>",
          "metadata": {
            "type": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Logger>",
            "type": "DECLARES"
          },
          {
            "src": "<Logger>",
            "dst": "<Logger:call>",
            "type": "CONTAINS"
          },
          {
            "src": "<Logger>",
            "dst": "<Logger.level>",
            "type": "CONTAINS"
          },
          {
            "src": "<Logger:call>",
            "dst": "<message>",
            "type": "RECEIVES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::type-alias-tuple",
      "category": "ts-specific",
      "code": "type Pair<A, B> = [A, B];",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Pair>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<A>"
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<B>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<[A, B]>",
          "metadata": {
            "tupleLength": 2,
            "isTuple": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Pair>",
            "type": "DECLARES"
          },
          {
            "src": "<Pair>",
            "dst": "<A>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Pair>",
            "dst": "<B>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<[A, B]>",
            "dst": "<A>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[A, B]>",
            "dst": "<B>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Pair>",
            "dst": "<[A, B]>",
            "type": "ALIASES"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::enum-numeric",
      "category": "ts-specific",
      "code": "enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<Direction>",
          "metadata": {
            "numeric": true
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Direction.Up>",
          "metadata": {
            "value": 0
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Direction.Down>",
          "metadata": {
            "value": 1
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Direction.Left>",
          "metadata": {
            "value": 2
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Direction.Right>",
          "metadata": {
            "value": 3
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Direction>",
            "type": "DECLARES"
          },
          {
            "src": "<Direction>",
            "dst": "<Direction.Up>",
            "type": "CONTAINS"
          },
          {
            "src": "<Direction>",
            "dst": "<Direction.Down>",
            "type": "CONTAINS"
          },
          {
            "src": "<Direction>",
            "dst": "<Direction.Left>",
            "type": "CONTAINS"
          },
          {
            "src": "<Direction>",
            "dst": "<Direction.Right>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::enum-heterogeneous",
      "category": "ts-specific",
      "code": "enum Mixed {\n  No = 0,\n  Yes = 'YES',\n}",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<Mixed>",
          "metadata": {
            "heterogeneous": true
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Mixed.No>",
          "metadata": {
            "key": "No"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Mixed.Yes>",
          "metadata": {
            "key": "Yes"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'YES'>",
          "metadata": {
            "value": "YES",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Mixed>",
            "type": "DECLARES"
          },
          {
            "src": "<Mixed>",
            "dst": "<Mixed.No>",
            "type": "CONTAINS"
          },
          {
            "src": "<Mixed>",
            "dst": "<Mixed.Yes>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Mixed.No>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Mixed.Yes>",
            "dst": "<'YES'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::type-alias-generic",
      "category": "ts-specific",
      "code": "type Nullable<T> = T | null;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Nullable>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T:ref>",
          "metadata": {
            "referencesTypeParam": true
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<null>",
          "metadata": {
            "value": "null",
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<Nullable>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Nullable>",
            "dst": "<T:ref>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<Nullable>",
            "dst": "<null>",
            "type": "UNION_MEMBER"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<T:ref>",
            "dst": "<T>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::type-alias-function",
      "category": "ts-specific",
      "code": "type Callback = (error: Error | null, result?: unknown) => void;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Callback>",
          "metadata": {
            "kind": "function"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<error>",
          "metadata": {
            "type": "Error | null"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<result>",
          "metadata": {
            "type": "unknown",
            "optional": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Error | null>",
          "metadata": {
            "kind": "union"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Error>",
          "metadata": {
            "kind": "reference"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<null>",
          "metadata": {
            "kind": "literal"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<unknown>",
          "metadata": {
            "kind": "primitive"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<void>",
          "metadata": {
            "kind": "primitive"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Callback>",
            "type": "DECLARES"
          },
          {
            "src": "<Callback>",
            "dst": "<error>",
            "type": "CONTAINS"
          },
          {
            "src": "<Callback>",
            "dst": "<result>",
            "type": "CONTAINS"
          },
          {
            "src": "<Callback>",
            "dst": "<void>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Error | null>",
            "dst": "<Error>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<Error | null>",
            "dst": "<null>",
            "type": "UNION_MEMBER"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<error>",
            "dst": "<Error | null>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<result>",
            "dst": "<unknown>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "statements::for-comma-update",
      "category": "statements",
      "code": "function forCommaUpdate() {\n  const arr = [1, 2, 3, 4, 5];\n\n  // Two-pointer technique  comma in both init and update\n  for (let lo = 0, hi = arr.length - 1; lo < hi; lo++, hi--) {\n    [arr[lo], arr[hi]] = [arr[hi], arr[lo]]; // swap\n  }\n\n  // Side effect in update clause\n  let processed = 0;\n  for (let i = 0; i < 3; i++, processed++) {\n    // comma separates two update expressions\n  }\n\n  return { arr, processed };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<forCommaUpdate>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "VARIABLE",
          "id": "<arr>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[1, 2, 3, 4, 5]>",
          "metadata": {
            "literalType": "array"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-two-pointer>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<lo>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<hi>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<arr.length - 1>",
          "metadata": {
            "operator": "-"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<lo < hi>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<lo++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<hi-->",
          "metadata": {
            "operator": "--"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>",
          "metadata": {
            "operator": "="
          }
        },
        {
          "type": "VARIABLE",
          "id": "<processed>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-2>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-side-effect>",
          "metadata": {
            "loopType": "for"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<i>",
          "metadata": {
            "kind": "let"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0-3>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i < 3>",
          "metadata": {
            "operator": "<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<i++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<processed++>",
          "metadata": {
            "operator": "++"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ arr, processed }>",
          "metadata": {
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<forCommaUpdate>",
            "type": "DECLARES"
          },
          {
            "src": "<forCommaUpdate>",
            "dst": "<arr>",
            "type": "CONTAINS"
          },
          {
            "src": "<forCommaUpdate>",
            "dst": "<for-two-pointer>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-two-pointer>",
            "dst": "<lo>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-two-pointer>",
            "dst": "<hi>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-two-pointer>",
            "dst": "<lo < hi>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-two-pointer>",
            "dst": "<lo++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-two-pointer>",
            "dst": "<hi-->",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-two-pointer>",
            "dst": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>",
            "type": "HAS_BODY"
          },
          {
            "src": "<forCommaUpdate>",
            "dst": "<processed>",
            "type": "CONTAINS"
          },
          {
            "src": "<forCommaUpdate>",
            "dst": "<for-side-effect>",
            "type": "CONTAINS"
          },
          {
            "src": "<for-side-effect>",
            "dst": "<i>",
            "type": "HAS_INIT"
          },
          {
            "src": "<for-side-effect>",
            "dst": "<i < 3>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<for-side-effect>",
            "dst": "<i++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<for-side-effect>",
            "dst": "<processed++>",
            "type": "HAS_UPDATE"
          },
          {
            "src": "<forCommaUpdate>",
            "dst": "<{ arr, processed }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<arr>",
            "dst": "<[1, 2, 3, 4, 5]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<lo>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<hi>",
            "dst": "<arr.length - 1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<lo++>",
            "dst": "<lo>",
            "type": "MODIFIES"
          },
          {
            "src": "<hi-->",
            "dst": "<hi>",
            "type": "MODIFIES"
          },
          {
            "src": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>",
            "dst": "<arr>",
            "type": "MODIFIES"
          },
          {
            "src": "<processed>",
            "dst": "<0-2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i>",
            "dst": "<0-3>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<i++>",
            "dst": "<i>",
            "type": "MODIFIES"
          },
          {
            "src": "<processed++>",
            "dst": "<processed>",
            "type": "MODIFIES"
          }
        ],
        "postProject": [
          {
            "src": "<arr.length - 1>",
            "dst": "<arr>",
            "type": "READS_FROM"
          },
          {
            "src": "<lo < hi>",
            "dst": "<lo>",
            "type": "READS_FROM"
          },
          {
            "src": "<lo < hi>",
            "dst": "<hi>",
            "type": "READS_FROM"
          },
          {
            "src": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>",
            "dst": "<lo>",
            "type": "READS_FROM"
          },
          {
            "src": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>",
            "dst": "<hi>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 3>",
            "dst": "<i>",
            "type": "READS_FROM"
          },
          {
            "src": "<i < 3>",
            "dst": "<3>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ arr, processed }>",
            "dst": "<arr>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ arr, processed }>",
            "dst": "<processed>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "statements::in-operator-type-guard",
      "category": "statements",
      "code": "function inOperatorTypeGuard(input) {\n  // 'prop' in obj as conditional guard  narrows type inside branch\n  if ('name' in input) {\n    return input.name.toUpperCase(); // safe  guarded by 'in' check\n  }\n\n  // Compound in-check  multiple property guards\n  if ('items' in input && 'count' in input) {\n    return input.items.slice(0, input.count);\n  }\n\n  // Negated in-check\n  if (!('error' in input)) {\n    return input;\n  }\n\n  return null;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<inOperatorTypeGuard>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input>"
        },
        {
          "type": "BRANCH",
          "id": "<if-name-in-input>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'name' in input>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<input.name>"
        },
        {
          "type": "CALL",
          "id": "<input.name.toUpperCase()>",
          "metadata": {
            "callee": "toUpperCase"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-items-and-count>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'items' in input && 'count' in input>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'items' in input>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'items'>",
          "metadata": {
            "value": "items",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'count' in input>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'count'>",
          "metadata": {
            "value": "count",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<input.items>"
        },
        {
          "type": "CALL",
          "id": "<input.items.slice(0, input.count)>",
          "metadata": {
            "callee": "slice"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<input.count>"
        },
        {
          "type": "BRANCH",
          "id": "<if-not-error>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<!('error' in input)>",
          "metadata": {
            "operator": "!"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'error' in input>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'error'>",
          "metadata": {
            "value": "error",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<inOperatorTypeGuard>",
            "type": "DECLARES"
          },
          {
            "src": "<inOperatorTypeGuard>",
            "dst": "<input>",
            "type": "CONTAINS"
          },
          {
            "src": "<inOperatorTypeGuard>",
            "dst": "<if-name-in-input>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-name-in-input>",
            "dst": "<'name' in input>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-name-in-input>",
            "dst": "<input.name.toUpperCase()>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<inOperatorTypeGuard>",
            "dst": "<if-items-and-count>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-items-and-count>",
            "dst": "<'items' in input && 'count' in input>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-items-and-count>",
            "dst": "<input.items.slice(0, input.count)>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<input.items.slice(0, input.count)>",
            "dst": "<0>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<input.items.slice(0, input.count)>",
            "dst": "<input.count>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<inOperatorTypeGuard>",
            "dst": "<if-not-error>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-not-error>",
            "dst": "<!('error' in input)>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-not-error>",
            "dst": "<input>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<inOperatorTypeGuard>",
            "dst": "<null>",
            "type": "RETURNS"
          },
          {
            "src": "<if-name-in-input>",
            "dst": "<input.name.toUpperCase()>",
            "type": "RETURNS"
          },
          {
            "src": "<if-items-and-count>",
            "dst": "<input.items.slice(0, input.count)>",
            "type": "RETURNS"
          },
          {
            "src": "<if-not-error>",
            "dst": "<input>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<'name' in input>",
            "dst": "<'name'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'name' in input>",
            "dst": "<input>",
            "type": "READS_FROM"
          },
          {
            "src": "<input.name.toUpperCase()>",
            "dst": "<input.name>",
            "type": "CALLS"
          },
          {
            "src": "<input.name>",
            "dst": "<input>",
            "type": "READS_FROM"
          },
          {
            "src": "<'items' in input && 'count' in input>",
            "dst": "<'items' in input>",
            "type": "READS_FROM"
          },
          {
            "src": "<'items' in input && 'count' in input>",
            "dst": "<'count' in input>",
            "type": "READS_FROM"
          },
          {
            "src": "<'items' in input>",
            "dst": "<'items'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'items' in input>",
            "dst": "<input>",
            "type": "READS_FROM"
          },
          {
            "src": "<'count' in input>",
            "dst": "<'count'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'count' in input>",
            "dst": "<input>",
            "type": "READS_FROM"
          },
          {
            "src": "<input.items.slice(0, input.count)>",
            "dst": "<input.items>",
            "type": "CALLS"
          },
          {
            "src": "<input.items>",
            "dst": "<input>",
            "type": "READS_FROM"
          },
          {
            "src": "<input.count>",
            "dst": "<input>",
            "type": "READS_FROM"
          },
          {
            "src": "<!('error' in input)>",
            "dst": "<'error' in input>",
            "type": "READS_FROM"
          },
          {
            "src": "<'error' in input>",
            "dst": "<'error'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'error' in input>",
            "dst": "<input>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::enum-const",
      "category": "ts-specific",
      "code": "const enum Flags {\n  Read = 1,\n  Write = 2,\n  Execute = 4,\n}",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<Flags>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Flags.Read>",
          "metadata": {
            "name": "Read"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Flags.Write>",
          "metadata": {
            "name": "Write"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Flags.Execute>",
          "metadata": {
            "name": "Execute"
          }
        },
        {
          "type": "LITERAL",
          "id": "<4>",
          "metadata": {
            "value": 4,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Flags>",
            "type": "DECLARES"
          },
          {
            "src": "<Flags>",
            "dst": "<Flags.Read>",
            "type": "CONTAINS"
          },
          {
            "src": "<Flags>",
            "dst": "<Flags.Write>",
            "type": "CONTAINS"
          },
          {
            "src": "<Flags>",
            "dst": "<Flags.Execute>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Flags.Read>",
            "dst": "<1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Flags.Write>",
            "dst": "<2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Flags.Execute>",
            "dst": "<4>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::enum-string",
      "category": "ts-specific",
      "code": "enum Status {\n  Active = 'ACTIVE',\n  Inactive = 'INACTIVE',\n  Pending = 'PENDING',\n}",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<Status>",
          "metadata": {
            "enumType": "string"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Status.Active>",
          "metadata": {
            "key": "Active"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'ACTIVE'>",
          "metadata": {
            "value": "ACTIVE",
            "literalType": "string"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Status.Inactive>",
          "metadata": {
            "key": "Inactive"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'INACTIVE'>",
          "metadata": {
            "value": "INACTIVE",
            "literalType": "string"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Status.Pending>",
          "metadata": {
            "key": "Pending"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'PENDING'>",
          "metadata": {
            "value": "PENDING",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Status>",
            "type": "DECLARES"
          },
          {
            "src": "<Status>",
            "dst": "<Status.Active>",
            "type": "CONTAINS"
          },
          {
            "src": "<Status>",
            "dst": "<Status.Inactive>",
            "type": "CONTAINS"
          },
          {
            "src": "<Status>",
            "dst": "<Status.Pending>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Status.Active>",
            "dst": "<'ACTIVE'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Status.Inactive>",
            "dst": "<'INACTIVE'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Status.Pending>",
            "dst": "<'PENDING'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::generic-function",
      "category": "ts-specific",
      "code": "function identity<T>(value: T): T {\n  return value;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<identity>",
          "metadata": {
            "async": false,
            "generator": false,
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": null
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T:param>",
          "metadata": {
            "typeReference": "T",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T:return>",
          "metadata": {
            "typeReference": "T",
            "originalType": "TYPE_ANNOTATION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<identity>",
            "type": "DECLARES"
          },
          {
            "src": "<identity>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<identity>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<identity>",
            "dst": "<T:return>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<identity>",
            "dst": "<value>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<value>",
            "dst": "<T:param>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<T:param>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<T:return>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::generic-function-multi",
      "category": "ts-specific",
      "code": "function merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<merge>",
          "metadata": {
            "async": false,
            "generator": false,
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": null
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<U>",
          "metadata": {
            "constraint": null
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj1>",
          "metadata": {
            "typeAnnotation": "T"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj2>",
          "metadata": {
            "typeAnnotation": "U"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T & U>",
          "metadata": {
            "kind": "intersection",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ ...obj1, ...obj2 }>",
          "metadata": {
            "kind": "object-spread"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<merge>",
            "type": "DECLARES"
          },
          {
            "src": "<merge>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<merge>",
            "dst": "<U>",
            "type": "CONTAINS"
          },
          {
            "src": "<merge>",
            "dst": "<obj1>",
            "type": "CONTAINS"
          },
          {
            "src": "<merge>",
            "dst": "<obj2>",
            "type": "CONTAINS"
          },
          {
            "src": "<merge>",
            "dst": "<T & U>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<T & U>",
            "dst": "<T>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<T & U>",
            "dst": "<U>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<merge>",
            "dst": "<{ ...obj1, ...obj2 }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ ...obj1, ...obj2 }>",
            "dst": "<obj1>",
            "type": "SPREADS_FROM",
            "metadata": {
              "originalType": "SPREADS"
            }
          },
          {
            "src": "<{ ...obj1, ...obj2 }>",
            "dst": "<obj2>",
            "type": "SPREADS_FROM",
            "metadata": {
              "originalType": "SPREADS"
            }
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<obj1>",
            "dst": "<T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<obj2>",
            "dst": "<U>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::generic-constraint",
      "category": "ts-specific",
      "code": "function getLength<T extends { length: number }>(item: T): number {\n  return item.length;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getLength>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "hasConstraint": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<{ length: number }>",
          "metadata": {
            "constraintType": "object",
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>",
          "metadata": {
            "typeAnnotation": "T"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T:param>",
          "metadata": {
            "type": "T",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:return>",
          "metadata": {
            "type": "number",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<item.length>",
          "metadata": {
            "property": "length"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<getLength>",
            "type": "DECLARES"
          },
          {
            "src": "<getLength>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<T>",
            "dst": "<{ length: number }>",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<getLength>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<getLength>",
            "dst": "<number:return>",
            "type": "RETURNS_TYPE",
            "metadata": {
              "originalType": "HAS_RETURN_TYPE"
            }
          },
          {
            "src": "<getLength>",
            "dst": "<item.length>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<item>",
            "dst": "<T:param>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<item.length>",
            "dst": "<item>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::generic-default",
      "category": "ts-specific",
      "code": "function createArray<T = string>(length: number, fill: T): T[] {\n  return Array(length).fill(fill);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createArray>",
          "metadata": {
            "async": false,
            "generator": false,
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "hasDefault": true,
            "defaultType": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<length>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<fill>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "CALL",
          "id": "<Array(length)>",
          "metadata": {
            "callee": "Array"
          }
        },
        {
          "type": "CALL",
          "id": "<Array(length).fill(fill)>",
          "metadata": {
            "callee": "fill"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<createArray>",
            "type": "DECLARES"
          },
          {
            "src": "<createArray>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<createArray>",
            "dst": "<length>",
            "type": "CONTAINS"
          },
          {
            "src": "<createArray>",
            "dst": "<fill>",
            "type": "CONTAINS"
          },
          {
            "src": "<createArray>",
            "dst": "<Array(length).fill(fill)>",
            "type": "RETURNS"
          },
          {
            "src": "<Array(length)>",
            "dst": "<length>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Array(length).fill(fill)>",
            "dst": "<fill>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<fill>",
            "dst": "<T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<Array(length)>",
            "dst": "<Array>",
            "type": "CALLS"
          },
          {
            "src": "<Array(length).fill(fill)>",
            "dst": "<Array(length)>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::generic-interface",
      "category": "ts-specific",
      "code": "interface Repository<T> {\n  find(id: string): Promise<T>;\n  save(item: T): Promise<void>;\n  delete(id: string): Promise<boolean>;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<Repository>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "METHOD",
          "id": "<Repository.find>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Promise<T>>",
          "metadata": {
            "generic": true,
            "baseType": "Promise",
            "originalType": "TYPE"
          }
        },
        {
          "type": "METHOD",
          "id": "<Repository.save>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Promise<void>>",
          "metadata": {
            "generic": true,
            "baseType": "Promise",
            "originalType": "TYPE"
          }
        },
        {
          "type": "METHOD",
          "id": "<Repository.delete>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id2>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Promise<boolean>>",
          "metadata": {
            "generic": true,
            "baseType": "Promise",
            "originalType": "TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Repository>",
            "type": "DECLARES"
          },
          {
            "src": "<Repository>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Repository>",
            "dst": "<Repository.find>",
            "type": "CONTAINS"
          },
          {
            "src": "<Repository>",
            "dst": "<Repository.save>",
            "type": "CONTAINS"
          },
          {
            "src": "<Repository>",
            "dst": "<Repository.delete>",
            "type": "CONTAINS"
          },
          {
            "src": "<Repository.find>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<Repository.find>",
            "dst": "<Promise<T>>",
            "type": "RETURNS"
          },
          {
            "src": "<Promise<T>>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER",
            "metadata": {
              "originalType": "PARAMETERIZED_BY"
            }
          },
          {
            "src": "<Repository.save>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<Repository.save>",
            "dst": "<Promise<void>>",
            "type": "RETURNS"
          },
          {
            "src": "<Repository.delete>",
            "dst": "<id2>",
            "type": "CONTAINS"
          },
          {
            "src": "<Repository.delete>",
            "dst": "<Promise<boolean>>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<item>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::satisfies",
      "category": "ts-specific",
      "code": "const theme = {\n  primary: '#007bff',\n  secondary: '#6c757d',\n} satisfies Record<string, string>;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<theme>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{primary: '#007bff', secondary: '#6c757d'}>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'#007bff'>",
          "metadata": {
            "value": "#007bff",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'#6c757d'>",
          "metadata": {
            "value": "#6c757d",
            "literalType": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, string>>",
          "metadata": {
            "constraintType": "satisfies",
            "originalType": "TYPE_CONSTRAINT"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<theme>",
            "type": "DECLARES"
          },
          {
            "src": "<{primary: '#007bff', secondary: '#6c757d'}>",
            "dst": "<'#007bff'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{primary: '#007bff', secondary: '#6c757d'}>",
            "dst": "<'#6c757d'>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<theme>",
            "dst": "<{primary: '#007bff', secondary: '#6c757d'}>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<{primary: '#007bff', secondary: '#6c757d'}>",
            "dst": "<Record<string, string>>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "SATISFIES_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::type-assertion-as",
      "category": "ts-specific",
      "code": "function typeAssertions(value: unknown) {\n  const asString = value as string;\n  const angleBracket = <number>value;\n  return { asString, angleBracket };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<typeAssertions>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "typeAnnotation": "unknown"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<asString>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<value as string>",
          "metadata": {
            "assertionType": "as",
            "targetType": "string",
            "originalType": "TYPE_ASSERTION"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<angleBracket>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<<number>value>",
          "metadata": {
            "assertionType": "angle-bracket",
            "targetType": "number",
            "originalType": "TYPE_ASSERTION"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<{ asString, angleBracket }>",
          "metadata": {
            "expressionType": "object-literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<typeAssertions>",
            "type": "DECLARES"
          },
          {
            "src": "<typeAssertions>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<typeAssertions>",
            "dst": "<asString>",
            "type": "DECLARES"
          },
          {
            "src": "<typeAssertions>",
            "dst": "<angleBracket>",
            "type": "DECLARES"
          },
          {
            "src": "<typeAssertions>",
            "dst": "<{ asString, angleBracket }>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<asString>",
            "dst": "<value as string>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<angleBracket>",
            "dst": "<<number>value>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<value as string>",
            "dst": "<value>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_TYPE_OF"
            }
          },
          {
            "src": "<<number>value>",
            "dst": "<value>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_TYPE_OF"
            }
          },
          {
            "src": "<{ asString, angleBracket }>",
            "dst": "<asString>",
            "type": "READS_FROM"
          },
          {
            "src": "<{ asString, angleBracket }>",
            "dst": "<angleBracket>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::non-null-assertion",
      "category": "ts-specific",
      "code": "function nonNullAssertion(map: Map<string, string>) {\n  const value = map.get('key')!;\n  return value.toUpperCase();\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<nonNullAssertion>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<map>",
          "metadata": {
            "tsType": "Map<string, string>"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<value>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<map.get('key')>",
          "metadata": {
            "callee": "get"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'key'>",
          "metadata": {
            "value": "key",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<map.get('key')!>",
          "metadata": {
            "operator": "!",
            "originalType": "TS_NON_NULL_ASSERTION"
          }
        },
        {
          "type": "CALL",
          "id": "<value.toUpperCase()>",
          "metadata": {
            "callee": "toUpperCase"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<nonNullAssertion>",
            "type": "DECLARES"
          },
          {
            "src": "<nonNullAssertion>",
            "dst": "<map>",
            "type": "CONTAINS"
          },
          {
            "src": "<nonNullAssertion>",
            "dst": "<value>",
            "type": "DECLARES"
          },
          {
            "src": "<map.get('key')>",
            "dst": "<'key'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<nonNullAssertion>",
            "dst": "<value.toUpperCase()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<value>",
            "dst": "<map.get('key')!>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<map.get('key')>",
            "dst": "<map>",
            "type": "CALLS"
          },
          {
            "src": "<map.get('key')!>",
            "dst": "<map.get('key')>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_NON_NULL"
            }
          },
          {
            "src": "<value.toUpperCase()>",
            "dst": "<value>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::access-modifiers",
      "category": "ts-specific",
      "code": "class Service {\n  public name: string;\n  protected config: Record<string, unknown>;\n  private secret: string;\n\n  constructor(name: string, secret: string) {\n    this.name = name;\n    this.config = {};\n    this.secret = secret;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Service>"
        },
        {
          "type": "PROPERTY",
          "id": "<Service.name>",
          "metadata": {
            "accessModifier": "public",
            "type": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Service.config>",
          "metadata": {
            "accessModifier": "protected",
            "type": "Record<string, unknown>"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Service.secret>",
          "metadata": {
            "accessModifier": "private",
            "type": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<Service.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<secret>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.config>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.secret>"
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Service>",
            "type": "DECLARES"
          },
          {
            "src": "<Service>",
            "dst": "<Service.name>",
            "type": "CONTAINS"
          },
          {
            "src": "<Service>",
            "dst": "<Service.config>",
            "type": "CONTAINS"
          },
          {
            "src": "<Service>",
            "dst": "<Service.secret>",
            "type": "CONTAINS"
          },
          {
            "src": "<Service>",
            "dst": "<Service.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Service.constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<Service.constructor>",
            "dst": "<secret>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Service.constructor>",
            "dst": "<this.name>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Service.constructor>",
            "dst": "<this.config>",
            "type": "WRITES_TO"
          },
          {
            "src": "<Service.constructor>",
            "dst": "<this.secret>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.config>",
            "dst": "<{}>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.secret>",
            "dst": "<secret>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::generic-class",
      "category": "ts-specific",
      "code": "class Container<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n\n  map<U>(fn: (value: T) => U): Container<U> {\n    return new Container(fn(this.value));\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Container>",
          "metadata": {
            "generic": true,
            "typeParameters": [
              "T"
            ]
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "scope": "class"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Container.value>",
          "metadata": {
            "visibility": "private",
            "type": "T"
          }
        },
        {
          "type": "METHOD",
          "id": "<Container.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<constructor.value>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.value>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<Container.getValue>",
          "metadata": {
            "kind": "method",
            "returnType": "T"
          }
        },
        {
          "type": "METHOD",
          "id": "<Container.map>",
          "metadata": {
            "kind": "method",
            "generic": true,
            "typeParameters": [
              "U"
            ],
            "returnType": "Container<U>"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<U>",
          "metadata": {
            "scope": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<map.fn>",
          "metadata": {
            "type": "(value: T) => U"
          }
        },
        {
          "type": "CALL",
          "id": "<new Container(fn(this.value))>",
          "metadata": {
            "constructor": true
          }
        },
        {
          "type": "CALL",
          "id": "<fn(this.value)>",
          "metadata": {
            "callee": "fn"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Container>",
            "type": "DECLARES"
          },
          {
            "src": "<Container>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Container>",
            "dst": "<Container.value>",
            "type": "CONTAINS"
          },
          {
            "src": "<Container>",
            "dst": "<Container.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Container>",
            "dst": "<Container.getValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<Container>",
            "dst": "<Container.map>",
            "type": "CONTAINS"
          },
          {
            "src": "<Container.constructor>",
            "dst": "<constructor.value>",
            "type": "CONTAINS"
          },
          {
            "src": "<Container.getValue>",
            "dst": "<T>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Container.getValue>",
            "dst": "<this.value>",
            "type": "RETURNS"
          },
          {
            "src": "<Container.map>",
            "dst": "<U>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Container.map>",
            "dst": "<map.fn>",
            "type": "CONTAINS"
          },
          {
            "src": "<map.fn>",
            "dst": "<U>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Container.map>",
            "dst": "<Container>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Container.map>",
            "dst": "<U>",
            "type": "RETURNS_TYPE",
            "metadata": {
              "originalType": "RETURNS_GENERIC_TYPE"
            }
          },
          {
            "src": "<Container.map>",
            "dst": "<new Container(fn(this.value))>",
            "type": "RETURNS"
          },
          {
            "src": "<new Container(fn(this.value))>",
            "dst": "<fn(this.value)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<fn(this.value)>",
            "dst": "<this.value>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<this.value>",
            "dst": "<constructor.value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Container.constructor>",
            "dst": "<this.value>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<Container.value>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          },
          {
            "src": "<constructor.value>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          },
          {
            "src": "<Container.getValue>",
            "dst": "<this.value>",
            "type": "READS_FROM"
          },
          {
            "src": "<map.fn>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "PARAMETER_TYPED_AS"
            }
          },
          {
            "src": "<new Container(fn(this.value))>",
            "dst": "<Container>",
            "type": "CALLS",
            "metadata": {
              "originalType": "INSTANTIATES"
            }
          },
          {
            "src": "<fn(this.value)>",
            "dst": "<map.fn>",
            "type": "CALLS"
          },
          {
            "src": "<fn(this.value)>",
            "dst": "<this.value>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::decorator-class",
      "category": "ts-specific",
      "code": "function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<sealed>",
          "metadata": {
            "decorator": true,
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<constructor>",
          "metadata": {
            "type": "Function"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.seal(constructor)>",
          "metadata": {
            "callee": "Object.seal"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<constructor.prototype>",
          "metadata": {
            "objectName": "constructor",
            "propertyName": "prototype"
          }
        },
        {
          "type": "CALL",
          "id": "<Object.seal(constructor.prototype)>",
          "metadata": {
            "callee": "Object.seal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<sealed>",
            "type": "DECLARES"
          },
          {
            "src": "<sealed>",
            "dst": "<constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<sealed>",
            "dst": "<Object.seal(constructor)>",
            "type": "CONTAINS"
          },
          {
            "src": "<sealed>",
            "dst": "<Object.seal(constructor.prototype)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Object.seal(constructor)>",
            "dst": "<constructor>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<Object.seal(constructor.prototype)>",
            "dst": "<constructor.prototype>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Object.seal(constructor)>",
            "dst": "<Object.seal>",
            "type": "CALLS"
          },
          {
            "src": "<Object.seal(constructor.prototype)>",
            "dst": "<Object.seal>",
            "type": "CALLS"
          },
          {
            "src": "<constructor.prototype>",
            "dst": "<constructor>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::as-const",
      "category": "ts-specific",
      "code": "const config = {\n  api: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n} as const;\n\nconst directions = ['up', 'down', 'left', 'right'] as const;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<config>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<config:object>",
          "metadata": {
            "readonly": true,
            "originalType": "OBJECT"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<config:object.api>",
          "metadata": {
            "key": "api",
            "readonly": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'https://api.example.com'>",
          "metadata": {
            "value": "https://api.example.com",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<config:object.timeout>",
          "metadata": {
            "key": "timeout",
            "readonly": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<5000>",
          "metadata": {
            "value": 5000,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<config:object.retries>",
          "metadata": {
            "key": "retries",
            "readonly": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<config:as-const>",
          "metadata": {
            "assertionType": "const",
            "originalType": "TYPE_ASSERTION"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<directions>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<directions:array>",
          "metadata": {
            "readonly": true,
            "originalType": "ARRAY"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'up'>",
          "metadata": {
            "value": "up",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'down'>",
          "metadata": {
            "value": "down",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'left'>",
          "metadata": {
            "value": "left",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'right'>",
          "metadata": {
            "value": "right",
            "literalType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<directions:as-const>",
          "metadata": {
            "assertionType": "const",
            "originalType": "TYPE_ASSERTION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<config>",
            "type": "DECLARES"
          },
          {
            "src": "<config:object>",
            "dst": "<config:object.api>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<config:object>",
            "dst": "<config:object.timeout>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<config:object>",
            "dst": "<config:object.retries>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<module>",
            "dst": "<directions>",
            "type": "DECLARES"
          },
          {
            "src": "<directions:array>",
            "dst": "<'up'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<directions:array>",
            "dst": "<'down'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<directions:array>",
            "dst": "<'left'>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<directions:array>",
            "dst": "<'right'>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [
          {
            "src": "<config>",
            "dst": "<config:as-const>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config:object.api>",
            "dst": "<'https://api.example.com'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config:object.timeout>",
            "dst": "<5000>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<config:object.retries>",
            "dst": "<3>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<directions>",
            "dst": "<directions:as-const>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<config:as-const>",
            "dst": "<config:object>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_TYPE"
            }
          },
          {
            "src": "<directions:as-const>",
            "dst": "<directions:array>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::decorator-usage",
      "category": "ts-specific",
      "code": "@sealed\nclass DecoratedClass {\n  @log\n  method() {\n    return 42;\n  }\n}",
      "expectedNodes": [
        {
          "type": "DECORATOR",
          "id": "<@sealed>",
          "metadata": {
            "name": "sealed"
          }
        },
        {
          "type": "CLASS",
          "id": "<DecoratedClass>"
        },
        {
          "type": "DECORATOR",
          "id": "<@log>",
          "metadata": {
            "name": "log"
          }
        },
        {
          "type": "METHOD",
          "id": "<DecoratedClass.method>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<42>",
          "metadata": {
            "value": 42,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<DecoratedClass>",
            "type": "DECLARES"
          },
          {
            "src": "<@sealed>",
            "dst": "<DecoratedClass>",
            "type": "DECORATED_BY",
            "metadata": {
              "originalType": "DECORATES"
            }
          },
          {
            "src": "<DecoratedClass>",
            "dst": "<DecoratedClass.method>",
            "type": "CONTAINS"
          },
          {
            "src": "<@log>",
            "dst": "<DecoratedClass.method>",
            "type": "DECORATED_BY",
            "metadata": {
              "originalType": "DECORATES"
            }
          },
          {
            "src": "<DecoratedClass.method>",
            "dst": "<42>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<@sealed>",
            "dst": "<sealed>",
            "type": "CALLS"
          },
          {
            "src": "<@log>",
            "dst": "<log>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::parameter-properties",
      "category": "ts-specific",
      "code": "class ServiceWithParamProps {\n  constructor(\n    public name: string,\n    protected config: Record<string, unknown>,\n    private secret: string,\n    readonly id: number,\n  ) {}\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ServiceWithParamProps>"
        },
        {
          "type": "METHOD",
          "id": "<ServiceWithParamProps.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>",
          "metadata": {
            "visibility": "public",
            "type": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<config>",
          "metadata": {
            "visibility": "protected",
            "type": "Record<string, unknown>"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<secret>",
          "metadata": {
            "visibility": "private",
            "type": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id>",
          "metadata": {
            "readonly": true,
            "type": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ServiceWithParamProps.name>",
          "metadata": {
            "visibility": "public",
            "type": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ServiceWithParamProps.config>",
          "metadata": {
            "visibility": "protected",
            "type": "Record<string, unknown>"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ServiceWithParamProps.secret>",
          "metadata": {
            "visibility": "private",
            "type": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<ServiceWithParamProps.id>",
          "metadata": {
            "readonly": true,
            "type": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ServiceWithParamProps>",
            "type": "DECLARES"
          },
          {
            "src": "<ServiceWithParamProps>",
            "dst": "<ServiceWithParamProps.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps.constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps.constructor>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps.constructor>",
            "dst": "<secret>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps.constructor>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps>",
            "dst": "<ServiceWithParamProps.name>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps>",
            "dst": "<ServiceWithParamProps.config>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps>",
            "dst": "<ServiceWithParamProps.secret>",
            "type": "CONTAINS"
          },
          {
            "src": "<ServiceWithParamProps>",
            "dst": "<ServiceWithParamProps.id>",
            "type": "CONTAINS"
          },
          {
            "src": "<name>",
            "dst": "<ServiceWithParamProps.name>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "CREATES_PROPERTY"
            }
          },
          {
            "src": "<config>",
            "dst": "<ServiceWithParamProps.config>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "CREATES_PROPERTY"
            }
          },
          {
            "src": "<secret>",
            "dst": "<ServiceWithParamProps.secret>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "CREATES_PROPERTY"
            }
          },
          {
            "src": "<id>",
            "dst": "<ServiceWithParamProps.id>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "CREATES_PROPERTY"
            }
          }
        ],
        "postFile": [
          {
            "src": "<ServiceWithParamProps.name>",
            "dst": "<name>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ServiceWithParamProps.config>",
            "dst": "<config>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ServiceWithParamProps.secret>",
            "dst": "<secret>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ServiceWithParamProps.id>",
            "dst": "<id>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::conditional-type",
      "category": "ts-specific",
      "code": "type IsString<T> = T extends string ? true : false;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<IsString>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends string ? true : false>",
          "metadata": {
            "checkType": "T",
            "extendsType": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<IsString>",
            "type": "DECLARES"
          },
          {
            "src": "<IsString>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends string ? true : false>",
            "dst": "<T>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "CHECKS_TYPE"
            }
          },
          {
            "src": "<T extends string ? true : false>",
            "dst": "<true>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<IsString>",
            "dst": "<T extends string ? true : false>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<T extends string ? true : false>",
            "dst": "<false>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<T extends string ? true : false>",
            "dst": "<string>",
            "type": "EXTENDS",
            "metadata": {
              "originalType": "EXTENDS_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::decorator-method",
      "category": "ts-specific",
      "code": "function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey}`);\n    return original.apply(this, args);\n  };\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<log>",
          "metadata": {
            "decorator": true,
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<target>",
          "metadata": {
            "type": "any"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<propertyKey>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<descriptor>",
          "metadata": {
            "type": "PropertyDescriptor"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<original>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<descriptor.value>",
          "metadata": {
            "objectName": "descriptor"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<wrapper:fn>",
          "metadata": {
            "arrowFunction": false,
            "anonymous": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<args>",
          "metadata": {
            "type": "any[]",
            "restParameter": true
          }
        },
        {
          "type": "CALL",
          "id": "<console.log>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<original.apply>",
          "metadata": {
            "callee": "original.apply"
          }
        },
        {
          "type": "LITERAL",
          "id": "<this>",
          "metadata": {
            "value": "this",
            "literalType": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<log>",
            "type": "DECLARES"
          },
          {
            "src": "<log>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<log>",
            "dst": "<propertyKey>",
            "type": "CONTAINS"
          },
          {
            "src": "<log>",
            "dst": "<descriptor>",
            "type": "CONTAINS"
          },
          {
            "src": "<log>",
            "dst": "<original>",
            "type": "DECLARES"
          },
          {
            "src": "<wrapper:fn>",
            "dst": "<args>",
            "type": "CONTAINS"
          },
          {
            "src": "<wrapper:fn>",
            "dst": "<console.log>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log>",
            "dst": "<template-literal>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<wrapper:fn>",
            "dst": "<original.apply>",
            "type": "RETURNS"
          },
          {
            "src": "<original.apply>",
            "dst": "<this>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<original.apply>",
            "dst": "<args>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<original>",
            "dst": "<descriptor.value>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<descriptor.value>",
            "dst": "<wrapper:fn>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<descriptor.value>",
            "dst": "<descriptor>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<propertyKey>",
            "type": "READS_FROM"
          },
          {
            "src": "<original.apply>",
            "dst": "<original>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::conditional-type-infer",
      "category": "ts-specific",
      "code": "type UnpackPromise<T> = T extends Promise<infer U> ? U : T;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<UnpackPromise>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends Promise<infer U> ? U : T>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T extends Promise<infer U>>",
          "metadata": {
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Promise<infer U>>",
          "metadata": {
            "originalType": "GENERIC_TYPE"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<infer U>",
          "metadata": {
            "originalType": "INFERRED_TYPE"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<U>",
          "metadata": {
            "inferred": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<U:true-branch>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T:false-branch>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<UnpackPromise>",
            "type": "DECLARES"
          },
          {
            "src": "<UnpackPromise>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends Promise<infer U> ? U : T>",
            "dst": "<T extends Promise<infer U>>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<T extends Promise<infer U>>",
            "dst": "<T>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "CHECKS_TYPE"
            }
          },
          {
            "src": "<infer U>",
            "dst": "<U>",
            "type": "INFERS"
          },
          {
            "src": "<T extends Promise<infer U> ? U : T>",
            "dst": "<U:true-branch>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<UnpackPromise>",
            "dst": "<T extends Promise<infer U> ? U : T>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<T extends Promise<infer U> ? U : T>",
            "dst": "<T:false-branch>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<T extends Promise<infer U>>",
            "dst": "<Promise<infer U>>",
            "type": "EXTENDS",
            "metadata": {
              "originalType": "EXTENDS_TYPE"
            }
          },
          {
            "src": "<Promise<infer U>>",
            "dst": "<infer U>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "HAS_TYPE_ARGUMENT"
            }
          },
          {
            "src": "<U:true-branch>",
            "dst": "<U>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "REFERENCES"
            }
          },
          {
            "src": "<T:false-branch>",
            "dst": "<T>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "REFERENCES"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::conditional-type-exclude",
      "category": "ts-specific",
      "code": "type StrictNonNull<T> = T extends null | undefined ? never : T;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<StrictNonNull>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": null
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends null | undefined ? never : T>",
          "metadata": {
            "condition": "T extends null | undefined"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<null | undefined>",
          "metadata": {
            "members": [
              "null",
              "undefined"
            ],
            "originalType": "TYPE_UNION"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<null>",
          "metadata": {
            "value": "null",
            "originalType": "TYPE_LITERAL"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<undefined>",
          "metadata": {
            "value": "undefined",
            "originalType": "TYPE_LITERAL"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never>",
          "metadata": {
            "value": "never",
            "originalType": "TYPE_LITERAL"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<StrictNonNull>",
            "type": "DECLARES"
          },
          {
            "src": "<StrictNonNull>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends null | undefined ? never : T>",
            "dst": "<T>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "CHECKS_TYPE"
            }
          },
          {
            "src": "<T extends null | undefined ? never : T>",
            "dst": "<null | undefined>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "EXTENDS_CHECK"
            }
          },
          {
            "src": "<null | undefined>",
            "dst": "<null>",
            "type": "CONTAINS"
          },
          {
            "src": "<null | undefined>",
            "dst": "<undefined>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends null | undefined ? never : T>",
            "dst": "<never>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<StrictNonNull>",
            "dst": "<T extends null | undefined ? never : T>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<T extends null | undefined ? never : T>",
            "dst": "<T>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::mapped-type-readonly",
      "category": "ts-specific",
      "code": "type ReadonlyAll<T> = { readonly [K in keyof T]: T[K] };",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ReadonlyAll>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ReadonlyAll:mapped>",
          "metadata": {
            "readonly": true,
            "originalType": "MAPPED_TYPE"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K>",
          "metadata": {
            "mappedTypeKey": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<keyof T>",
          "metadata": {
            "originalType": "KEYOF_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T[K]>",
          "metadata": {
            "originalType": "INDEXED_ACCESS_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ReadonlyAll>",
            "type": "DECLARES"
          },
          {
            "src": "<ReadonlyAll>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<ReadonlyAll:mapped>",
            "dst": "<K>",
            "type": "CONTAINS"
          },
          {
            "src": "<K>",
            "dst": "<keyof T>",
            "type": "CONSTRAINED_BY"
          }
        ],
        "postFile": [
          {
            "src": "<ReadonlyAll>",
            "dst": "<ReadonlyAll:mapped>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<keyof T>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<ReadonlyAll:mapped>",
            "dst": "<T[K]>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_TO"
            }
          },
          {
            "src": "<T[K]>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<T[K]>",
            "dst": "<K>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "INDEXED_BY"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::abstract-class",
      "category": "ts-specific",
      "code": "abstract class Shape {\n  abstract area(): number;\n  abstract perimeter(): number;\n\n  describe(): string {\n    return `Area: ${this.area()}, Perimeter: ${this.perimeter()}`;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(private radius: number) {\n    super();\n  }\n\n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n\n  perimeter(): number {\n    return 2 * Math.PI * this.radius;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Shape>",
          "metadata": {
            "abstract": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Shape.area>",
          "metadata": {
            "abstract": true,
            "returnType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Shape.perimeter>",
          "metadata": {
            "abstract": true,
            "returnType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Shape.describe>",
          "metadata": {
            "returnType": "string"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<template-literal>",
          "metadata": {
            "type": "template-literal"
          }
        },
        {
          "type": "CALL",
          "id": "<this.area()>",
          "metadata": {
            "callee": "area"
          }
        },
        {
          "type": "CALL",
          "id": "<this.perimeter()>",
          "metadata": {
            "callee": "perimeter"
          }
        },
        {
          "type": "CLASS",
          "id": "<Circle>"
        },
        {
          "type": "METHOD",
          "id": "<Circle.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<radius>",
          "metadata": {
            "visibility": "private",
            "type": "number"
          }
        },
        {
          "type": "CALL",
          "id": "<super()>",
          "metadata": {
            "callee": "super"
          }
        },
        {
          "type": "METHOD",
          "id": "<Circle.area>",
          "metadata": {
            "returnType": "number",
            "implements": "Shape.area"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Math.PI * this.radius ** 2>",
          "metadata": {
            "operator": "**"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Math.PI>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.radius>"
        },
        {
          "type": "METHOD",
          "id": "<Circle.perimeter>",
          "metadata": {
            "returnType": "number",
            "implements": "Shape.perimeter"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<2 * Math.PI * this.radius>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Shape>",
            "type": "DECLARES"
          },
          {
            "src": "<Shape>",
            "dst": "<Shape.area>",
            "type": "CONTAINS"
          },
          {
            "src": "<Shape>",
            "dst": "<Shape.perimeter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Shape>",
            "dst": "<Shape.describe>",
            "type": "CONTAINS"
          },
          {
            "src": "<Shape.describe>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.area()>",
            "type": "CONTAINS"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.perimeter()>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<Circle>",
            "type": "DECLARES"
          },
          {
            "src": "<Circle>",
            "dst": "<Circle.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Circle.constructor>",
            "dst": "<radius>",
            "type": "CONTAINS"
          },
          {
            "src": "<Circle.constructor>",
            "dst": "<super()>",
            "type": "CONTAINS"
          },
          {
            "src": "<Circle>",
            "dst": "<Circle.area>",
            "type": "CONTAINS"
          },
          {
            "src": "<Circle.area>",
            "dst": "<Math.PI * this.radius ** 2>",
            "type": "RETURNS"
          },
          {
            "src": "<Circle>",
            "dst": "<Circle.perimeter>",
            "type": "CONTAINS"
          },
          {
            "src": "<Circle.perimeter>",
            "dst": "<2 * Math.PI * this.radius>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<this.area()>",
            "dst": "<Shape.area>",
            "type": "CALLS"
          },
          {
            "src": "<this.perimeter()>",
            "dst": "<Shape.perimeter>",
            "type": "CALLS"
          },
          {
            "src": "<Circle>",
            "dst": "<Shape>",
            "type": "EXTENDS"
          },
          {
            "src": "<super()>",
            "dst": "<Shape>",
            "type": "CALLS"
          },
          {
            "src": "<Circle.area>",
            "dst": "<Shape.area>",
            "type": "IMPLEMENTS"
          },
          {
            "src": "<Math.PI * this.radius ** 2>",
            "dst": "<Math.PI>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.PI * this.radius ** 2>",
            "dst": "<this.radius>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.radius>",
            "dst": "<radius>",
            "type": "READS_FROM"
          },
          {
            "src": "<Circle.perimeter>",
            "dst": "<Shape.perimeter>",
            "type": "IMPLEMENTS"
          },
          {
            "src": "<2 * Math.PI * this.radius>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<2 * Math.PI * this.radius>",
            "dst": "<Math.PI>",
            "type": "READS_FROM"
          },
          {
            "src": "<2 * Math.PI * this.radius>",
            "dst": "<this.radius>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::mapped-type-mutable",
      "category": "ts-specific",
      "code": "type Mutable<T> = { -readonly [K in keyof T]: T[K] };",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Mutable>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Mutable:mapped>",
          "metadata": {
            "removeReadonly": true,
            "originalType": "MAPPED_TYPE"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K>",
          "metadata": {
            "mappingVariable": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<keyof T>",
          "metadata": {
            "originalType": "KEYOF_OPERATOR"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<T[K]>",
          "metadata": {
            "originalType": "INDEXED_ACCESS"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Mutable>",
            "type": "DECLARES"
          },
          {
            "src": "<Mutable>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<Mutable:mapped>",
            "dst": "<K>",
            "type": "CONTAINS"
          },
          {
            "src": "<K>",
            "dst": "<keyof T>",
            "type": "ITERATES_OVER"
          }
        ],
        "postFile": [
          {
            "src": "<Mutable>",
            "dst": "<Mutable:mapped>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<keyof T>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<Mutable:mapped>",
            "dst": "<T[K]>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_TO"
            }
          },
          {
            "src": "<T[K]>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<T[K]>",
            "dst": "<K>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::mapped-type-optional",
      "category": "ts-specific",
      "code": "type Optional<T> = { [K in keyof T]?: T[K] };",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Optional>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Optional:mapped>",
          "metadata": {
            "modifier": "optional",
            "originalType": "MAPPED_TYPE"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K>",
          "metadata": {
            "mappingVariable": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<keyof T>",
          "metadata": {
            "originalType": "KEYOF_OPERATOR"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<T[K]>",
          "metadata": {
            "originalType": "INDEX_ACCESS"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Optional>",
            "type": "DECLARES"
          },
          {
            "src": "<Optional>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<Optional:mapped>",
            "dst": "<K>",
            "type": "CONTAINS"
          },
          {
            "src": "<K>",
            "dst": "<keyof T>",
            "type": "ITERATES_OVER"
          }
        ],
        "postFile": [
          {
            "src": "<Optional>",
            "dst": "<Optional:mapped>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<keyof T>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<Optional:mapped>",
            "dst": "<T[K]>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_TO"
            }
          },
          {
            "src": "<T[K]>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<T[K]>",
            "dst": "<K>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "INDEXED_BY"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::template-literal-type",
      "category": "ts-specific",
      "code": "type EventName = 'click' | 'focus' | 'blur';\ntype OnEvent = `on${Capitalize<EventName>}`;\ntype CSSProperty = `${string}-${string}`;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<EventName>",
          "metadata": {
            "kind": "union"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'click'>",
          "metadata": {
            "value": "click",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'focus'>",
          "metadata": {
            "value": "focus",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'blur'>",
          "metadata": {
            "value": "blur",
            "literalType": "string"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<OnEvent>",
          "metadata": {
            "kind": "template-literal"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<`on${Capitalize<EventName>}`>",
          "metadata": {
            "prefix": "on",
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Capitalize<EventName>>",
          "metadata": {
            "utility": "Capitalize",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<CSSProperty>",
          "metadata": {
            "kind": "template-literal"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<`${string}-${string}`>",
          "metadata": {
            "separator": "-",
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": "string",
            "originalType": "PRIMITIVE_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<EventName>",
            "type": "DECLARES"
          },
          {
            "src": "<EventName>",
            "dst": "<'click'>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<EventName>",
            "dst": "<'focus'>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<EventName>",
            "dst": "<'blur'>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<module>",
            "dst": "<OnEvent>",
            "type": "DECLARES"
          },
          {
            "src": "<`on${Capitalize<EventName>}`>",
            "dst": "<Capitalize<EventName>>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "TEMPLATE_SUBSTITUTION"
            }
          },
          {
            "src": "<module>",
            "dst": "<CSSProperty>",
            "type": "DECLARES"
          },
          {
            "src": "<`${string}-${string}`>",
            "dst": "<string>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "TEMPLATE_SUBSTITUTION"
            }
          }
        ],
        "postFile": [
          {
            "src": "<OnEvent>",
            "dst": "<`on${Capitalize<EventName>}`>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<CSSProperty>",
            "dst": "<`${string}-${string}`>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Capitalize<EventName>>",
            "dst": "<EventName>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "TRANSFORMS"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::union-intersection",
      "category": "ts-specific",
      "code": "type StringOrNumber = string | number;\ntype ObjA = { a: string };\ntype ObjB = { b: number };\ntype Combined = ObjA & ObjB;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<StringOrNumber>",
          "metadata": {
            "kind": "union"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<string | number>",
          "metadata": {
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ObjA>",
          "metadata": {
            "kind": "object"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<{ a: string }>",
          "metadata": {
            "originalType": "OBJECT_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<a: string>",
          "metadata": {
            "propertyName": "a",
            "originalType": "PROPERTY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ObjB>",
          "metadata": {
            "kind": "object"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<{ b: number }>",
          "metadata": {
            "originalType": "OBJECT_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<b: number>",
          "metadata": {
            "propertyName": "b",
            "originalType": "PROPERTY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Combined>",
          "metadata": {
            "kind": "intersection"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<ObjA & ObjB>",
          "metadata": {
            "originalType": "INTERSECTION_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<StringOrNumber>",
            "type": "DECLARES"
          },
          {
            "src": "<string | number>",
            "dst": "<string>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<string | number>",
            "dst": "<number>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<module>",
            "dst": "<ObjA>",
            "type": "DECLARES"
          },
          {
            "src": "<{ a: string }>",
            "dst": "<a: string>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<ObjB>",
            "type": "DECLARES"
          },
          {
            "src": "<{ b: number }>",
            "dst": "<b: number>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<Combined>",
            "type": "DECLARES"
          },
          {
            "src": "<ObjA & ObjB>",
            "dst": "<ObjA>",
            "type": "INTERSECTS_WITH",
            "metadata": {
              "originalType": "INTERSECTION_MEMBER"
            }
          },
          {
            "src": "<ObjA & ObjB>",
            "dst": "<ObjB>",
            "type": "INTERSECTS_WITH",
            "metadata": {
              "originalType": "INTERSECTION_MEMBER"
            }
          }
        ],
        "postFile": [
          {
            "src": "<StringOrNumber>",
            "dst": "<string | number>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ObjA>",
            "dst": "<{ a: string }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ObjB>",
            "dst": "<{ b: number }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<Combined>",
            "dst": "<ObjA & ObjB>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<a: string>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<b: number>",
            "dst": "<number>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::type-guard-is",
      "category": "ts-specific",
      "code": "function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<isString>",
          "metadata": {
            "async": false,
            "generator": false,
            "typeGuard": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "typeAnnotation": "unknown"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<value is string>",
          "metadata": {
            "parameterName": "value",
            "predicateType": "string",
            "originalType": "TYPE_PREDICATE"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value === 'string'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof value>",
          "metadata": {
            "operator": "typeof"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'string'>",
          "metadata": {
            "value": "string",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<isString>",
            "type": "DECLARES"
          },
          {
            "src": "<isString>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<isString>",
            "dst": "<typeof value === 'string'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<isString>",
            "dst": "<value is string>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "HAS_TYPE_PREDICATE"
            }
          },
          {
            "src": "<typeof value === 'string'>",
            "dst": "<typeof value>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value === 'string'>",
            "dst": "<'string'>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof value>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<value is string>",
            "dst": "<value>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "NARROWS_TYPE_OF"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::discriminated-union",
      "category": "ts-specific",
      "code": "type Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: Error };",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Result>",
          "metadata": {
            "generic": true,
            "discriminated": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Result:union>",
          "metadata": {
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<success-case>",
          "metadata": {
            "discriminant": "success: true",
            "originalType": "OBJECT_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<success-case.success>",
          "metadata": {
            "required": true,
            "originalType": "PROPERTY_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<success-case.data>",
          "metadata": {
            "required": true,
            "originalType": "PROPERTY_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<error-case>",
          "metadata": {
            "discriminant": "success: false",
            "originalType": "OBJECT_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<error-case.success>",
          "metadata": {
            "required": true,
            "originalType": "PROPERTY_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<false>",
          "metadata": {
            "value": false,
            "literalType": "boolean"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<error-case.error>",
          "metadata": {
            "required": true,
            "originalType": "PROPERTY_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Error>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Result>",
            "type": "DECLARES"
          },
          {
            "src": "<Result>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Result:union>",
            "dst": "<success-case>",
            "type": "UNION_MEMBER",
            "metadata": {
              "originalType": "HAS_VARIANT"
            }
          },
          {
            "src": "<Result:union>",
            "dst": "<error-case>",
            "type": "UNION_MEMBER",
            "metadata": {
              "originalType": "HAS_VARIANT"
            }
          },
          {
            "src": "<success-case>",
            "dst": "<success-case.success>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<success-case>",
            "dst": "<success-case.data>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<error-case>",
            "dst": "<error-case.success>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<error-case>",
            "dst": "<error-case.error>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Result>",
            "dst": "<Result:union>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<success-case.success>",
            "dst": "<true>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<success-case.data>",
            "dst": "<T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<error-case.success>",
            "dst": "<false>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<error-case.error>",
            "dst": "<Error>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::keyof-typeof",
      "category": "ts-specific",
      "code": "type UserKeys = keyof User;\nconst sampleUser = { name: 'Alice', age: 30 };\ntype InferredUser = typeof sampleUser;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<UserKeys>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<keyof User>",
          "metadata": {
            "operator": "keyof",
            "originalType": "TYPE_OPERATOR"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<User>"
        },
        {
          "type": "VARIABLE",
          "id": "<sampleUser>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ name: 'Alice', age: 30 }>",
          "metadata": {
            "originalType": "OBJECT_LITERAL"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Alice'>",
          "metadata": {
            "value": "Alice",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<30>",
          "metadata": {
            "value": 30,
            "literalType": "number"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<InferredUser>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<typeof sampleUser>",
          "metadata": {
            "operator": "typeof",
            "originalType": "TYPE_OPERATOR"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<UserKeys>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<sampleUser>",
            "type": "DECLARES"
          },
          {
            "src": "<{ name: 'Alice', age: 30 }>",
            "dst": "<'Alice'>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ name: 'Alice', age: 30 }>",
            "dst": "<30>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<module>",
            "dst": "<InferredUser>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<UserKeys>",
            "dst": "<keyof User>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<sampleUser>",
            "dst": "<{ name: 'Alice', age: 30 }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<InferredUser>",
            "dst": "<typeof sampleUser>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<keyof User>",
            "dst": "<User>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "OPERATES_ON"
            }
          },
          {
            "src": "<typeof sampleUser>",
            "dst": "<sampleUser>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "OPERATES_ON"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::index-access-type",
      "category": "ts-specific",
      "code": "type UserName = User['name'];\ntype UserNameOrAge = User['name' | 'age'];",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<UserName>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<User['name']>",
          "metadata": {
            "objectType": "User",
            "indexType": "name",
            "originalType": "INDEX_ACCESS_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<UserNameOrAge>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<User['name' | 'age']>",
          "metadata": {
            "objectType": "User",
            "originalType": "INDEX_ACCESS_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<'name' | 'age'>",
          "metadata": {
            "unionMembers": [
              "name",
              "age"
            ],
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'age'>",
          "metadata": {
            "value": "age",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<UserName>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<UserNameOrAge>",
            "type": "DECLARES"
          },
          {
            "src": "<'name' | 'age'>",
            "dst": "<'name'>",
            "type": "CONTAINS"
          },
          {
            "src": "<'name' | 'age'>",
            "dst": "<'age'>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<UserName>",
            "dst": "<User['name']>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<UserNameOrAge>",
            "dst": "<User['name' | 'age']>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<User['name']>",
            "dst": "<User>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "INDEXES_INTO"
            }
          },
          {
            "src": "<User['name']>",
            "dst": "<'name'>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "INDEXED_BY"
            }
          },
          {
            "src": "<User['name' | 'age']>",
            "dst": "<User>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "INDEXES_INTO"
            }
          },
          {
            "src": "<User['name' | 'age']>",
            "dst": "<'name' | 'age'>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "INDEXED_BY"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::namespace",
      "category": "ts-specific",
      "code": "namespace Validation {\n  export interface Schema {\n    validate(data: unknown): boolean;\n  }\n\n  export function createSchema(): Schema {\n    return { validate: () => true };\n  }\n}",
      "expectedNodes": [
        {
          "type": "NAMESPACE",
          "id": "<Validation>",
          "metadata": {
            "exported": false
          }
        },
        {
          "type": "INTERFACE",
          "id": "<Validation.Schema>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Validation.Schema.validate>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>",
          "metadata": {
            "type": "unknown"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Validation.createSchema>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{ validate: () => true }>",
          "metadata": {
            "literalType": "object"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<() => true>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Validation>",
            "type": "DECLARES"
          },
          {
            "src": "<Validation>",
            "dst": "<Validation.Schema>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validation>",
            "dst": "<Validation.createSchema>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validation.Schema>",
            "dst": "<Validation.Schema.validate>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validation.Schema.validate>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<Validation.createSchema>",
            "dst": "<{ validate: () => true }>",
            "type": "RETURNS"
          },
          {
            "src": "<{ validate: () => true }>",
            "dst": "<() => true>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<() => true>",
            "dst": "<true>",
            "type": "RETURNS"
          },
          {
            "src": "<Validation.createSchema>",
            "dst": "<Validation.Schema>",
            "type": "RETURNS_TYPE"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-import-type",
      "category": "ts-specific",
      "code": "// import type { User } from './types';\n// import { type Role, Permission } from './auth';\n// (commented out  no actual modules to import from, but syntax is valid)\ntype ImportedType = User;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ImportedType>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<User>",
          "metadata": {
            "referencedType": "User"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ImportedType>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<ImportedType>",
            "dst": "<User>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::type-guard-assertion",
      "category": "ts-specific",
      "code": "function hasName(obj: unknown): obj is { name: string } {\n  return typeof obj === 'object' && obj !== null && 'name' in obj;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<hasName>",
          "metadata": {
            "typeGuard": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>",
          "metadata": {
            "type": "unknown"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<obj is { name: string }>",
          "metadata": {
            "predicateType": "type-guard",
            "originalType": "TYPE_PREDICATE"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<typeof obj === 'object'>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<obj !== null>",
          "metadata": {
            "operator": "!=="
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<'name' in obj>",
          "metadata": {
            "operator": "in"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<guard-conjunction>",
          "metadata": {
            "operator": "&&"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'object'>",
          "metadata": {
            "value": "object",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<null>",
          "metadata": {
            "value": null,
            "literalType": "null"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<hasName>",
            "type": "DECLARES"
          },
          {
            "src": "<hasName>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<hasName>",
            "dst": "<guard-conjunction>",
            "type": "RETURNS"
          },
          {
            "src": "<guard-conjunction>",
            "dst": "<typeof obj === 'object'>",
            "type": "CONTAINS"
          },
          {
            "src": "<guard-conjunction>",
            "dst": "<obj !== null>",
            "type": "CONTAINS"
          },
          {
            "src": "<guard-conjunction>",
            "dst": "<'name' in obj>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<hasName>",
            "dst": "<obj is { name: string }>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "HAS_TYPE_PREDICATE"
            }
          },
          {
            "src": "<typeof obj === 'object'>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<typeof obj === 'object'>",
            "dst": "<'object'>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj !== null>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj !== null>",
            "dst": "<null>",
            "type": "READS_FROM"
          },
          {
            "src": "<'name' in obj>",
            "dst": "<'name'>",
            "type": "READS_FROM"
          },
          {
            "src": "<'name' in obj>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj is { name: string }>",
            "dst": "<obj>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "NARROWS_TYPE_OF"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::function-overloads",
      "category": "ts-specific",
      "code": "function processInput(input: string): string;\nfunction processInput(input: number): number;\nfunction processInput(input: string | number): string | number {\n  return input;\n}",
      "expectedNodes": [
        {
          "type": "METHOD",
          "id": "<processInput:overload1>",
          "metadata": {
            "parameterTypes": [
              "string"
            ],
            "returnType": "string",
            "originalType": "FUNCTION_OVERLOAD"
          }
        },
        {
          "type": "METHOD",
          "id": "<processInput:overload2>",
          "metadata": {
            "parameterTypes": [
              "number"
            ],
            "returnType": "number",
            "originalType": "FUNCTION_OVERLOAD"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<processInput>",
          "metadata": {
            "implementation": true,
            "parameterTypes": [
              "string | number"
            ],
            "returnType": "string | number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input>",
          "metadata": {
            "type": "string | number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<processInput:overload1>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<processInput:overload2>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<processInput>",
            "type": "DECLARES"
          },
          {
            "src": "<processInput>",
            "dst": "<input>",
            "type": "CONTAINS"
          },
          {
            "src": "<processInput>",
            "dst": "<input>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<processInput>",
            "dst": "<processInput:overload1>",
            "type": "IMPLEMENTS_OVERLOAD"
          },
          {
            "src": "<processInput>",
            "dst": "<processInput:overload2>",
            "type": "IMPLEMENTS_OVERLOAD"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-export-type",
      "category": "ts-specific",
      "code": "export type { Admin };\n// export { type Status };  inline type export (already exported as value above)",
      "expectedNodes": [
        {
          "type": "EXPORT",
          "id": "<export-type-Admin>",
          "metadata": {
            "exportType": "type-only",
            "exportKind": "named"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Admin>",
          "metadata": {
            "kind": "type",
            "originalType": "TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<export-type-Admin>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-type-Admin>",
            "dst": "<Admin>",
            "type": "EXPORTS"
          },
          {
            "src": "<module>",
            "dst": "<Admin>",
            "type": "EXPORTS",
            "metadata": {
              "originalType": "EXPORTS_TYPE"
            }
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-declare-const",
      "category": "ts-specific",
      "code": "declare const __VERSION__: string;",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<__VERSION__>",
          "metadata": {
            "kind": "const",
            "declared": true,
            "tsType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<__VERSION__>",
            "type": "DECLARES"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::tuple-types",
      "category": "ts-specific",
      "code": "type Point2D = [number, number];\ntype Point3D = [number, number, number];\ntype NamedTuple = [name: string, age: number];\ntype RestTuple = [string, ...number[]];",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Point2D>",
          "metadata": {
            "kind": "tuple"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Point2D:tuple>",
          "metadata": {
            "elementCount": 2,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:0>",
          "metadata": {
            "typeName": "number",
            "position": 0
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:1>",
          "metadata": {
            "typeName": "number",
            "position": 1
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Point3D>",
          "metadata": {
            "kind": "tuple"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Point3D:tuple>",
          "metadata": {
            "elementCount": 3,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:0:3d>",
          "metadata": {
            "typeName": "number",
            "position": 0
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:1:3d>",
          "metadata": {
            "typeName": "number",
            "position": 1
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:2:3d>",
          "metadata": {
            "typeName": "number",
            "position": 2
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<NamedTuple>",
          "metadata": {
            "kind": "tuple",
            "hasNamedElements": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<NamedTuple:tuple>",
          "metadata": {
            "elementCount": 2,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<name>",
          "metadata": {
            "elementName": "name",
            "position": 0,
            "originalType": "TUPLE_ELEMENT"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string:named>",
          "metadata": {
            "typeName": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<age>",
          "metadata": {
            "elementName": "age",
            "position": 1,
            "originalType": "TUPLE_ELEMENT"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:named>",
          "metadata": {
            "typeName": "number"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<RestTuple>",
          "metadata": {
            "kind": "tuple",
            "hasRestElement": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<RestTuple:tuple>",
          "metadata": {
            "hasRestElement": true,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string:rest>",
          "metadata": {
            "typeName": "string",
            "position": 0
          }
        },
        {
          "type": "PARAMETER",
          "id": "<...number[]>",
          "metadata": {
            "position": 1,
            "originalType": "REST_ELEMENT"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number[]>",
          "metadata": {
            "elementType": "number",
            "originalType": "ARRAY_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number:array>",
          "metadata": {
            "typeName": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Point2D>",
            "type": "DECLARES"
          },
          {
            "src": "<Point2D>",
            "dst": "<Point2D:tuple>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "DEFINES_TYPE"
            }
          },
          {
            "src": "<Point2D:tuple>",
            "dst": "<number:0>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<Point2D:tuple>",
            "dst": "<number:1>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<module>",
            "dst": "<Point3D>",
            "type": "DECLARES"
          },
          {
            "src": "<Point3D>",
            "dst": "<Point3D:tuple>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "DEFINES_TYPE"
            }
          },
          {
            "src": "<Point3D:tuple>",
            "dst": "<number:0:3d>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<Point3D:tuple>",
            "dst": "<number:1:3d>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<Point3D:tuple>",
            "dst": "<number:2:3d>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<module>",
            "dst": "<NamedTuple>",
            "type": "DECLARES"
          },
          {
            "src": "<NamedTuple>",
            "dst": "<NamedTuple:tuple>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "DEFINES_TYPE"
            }
          },
          {
            "src": "<NamedTuple:tuple>",
            "dst": "<name>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<NamedTuple:tuple>",
            "dst": "<age>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<module>",
            "dst": "<RestTuple>",
            "type": "DECLARES"
          },
          {
            "src": "<RestTuple>",
            "dst": "<RestTuple:tuple>",
            "type": "DECLARES",
            "metadata": {
              "originalType": "DEFINES_TYPE"
            }
          },
          {
            "src": "<RestTuple:tuple>",
            "dst": "<string:rest>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<RestTuple:tuple>",
            "dst": "<...number[]>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "HAS_REST_ELEMENT"
            }
          },
          {
            "src": "<...number[]>",
            "dst": "<number[]>",
            "type": "SPREADS_FROM",
            "metadata": {
              "originalType": "SPREADS_TYPE"
            }
          },
          {
            "src": "<number[]>",
            "dst": "<number:array>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "HAS_ELEMENT_TYPE"
            }
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<name>",
            "dst": "<string:named>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<age>",
            "dst": "<number:named>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-declare-function",
      "category": "ts-specific",
      "code": "declare function require(id: string): any;",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<require>",
          "metadata": {
            "declared": true,
            "ambient": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<any>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<require>",
            "type": "DECLARES"
          },
          {
            "src": "<require>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<require>",
            "dst": "<any>",
            "type": "RETURNS_TYPE"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<id>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::class-implements",
      "category": "ts-specific",
      "code": "class UserImpl implements User, Printable {\n  constructor(\n    public name: string,\n    public age: number,\n    public readonly id: number,\n  ) {}\n\n  print(): void {\n    console.log(this.name);\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<UserImpl>"
        },
        {
          "type": "INTERFACE",
          "id": "<User>"
        },
        {
          "type": "INTERFACE",
          "id": "<Printable>"
        },
        {
          "type": "METHOD",
          "id": "<UserImpl.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<name>",
          "metadata": {
            "visibility": "public",
            "type": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<age>",
          "metadata": {
            "visibility": "public",
            "type": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id>",
          "metadata": {
            "visibility": "public",
            "readonly": true,
            "type": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<UserImpl.print>",
          "metadata": {
            "kind": "method",
            "returnType": "void"
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(this.name)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<UserImpl>",
            "type": "DECLARES"
          },
          {
            "src": "<UserImpl>",
            "dst": "<UserImpl.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<UserImpl>",
            "dst": "<UserImpl.print>",
            "type": "CONTAINS"
          },
          {
            "src": "<UserImpl.constructor>",
            "dst": "<name>",
            "type": "CONTAINS"
          },
          {
            "src": "<UserImpl.constructor>",
            "dst": "<age>",
            "type": "CONTAINS"
          },
          {
            "src": "<UserImpl.constructor>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<UserImpl.print>",
            "dst": "<console.log(this.name)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(this.name)>",
            "dst": "<this.name>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<UserImpl>",
            "dst": "<User>",
            "type": "IMPLEMENTS"
          },
          {
            "src": "<UserImpl>",
            "dst": "<Printable>",
            "type": "IMPLEMENTS"
          },
          {
            "src": "<console.log(this.name)>",
            "dst": "<console.log>",
            "type": "CALLS"
          },
          {
            "src": "<this.name>",
            "dst": "<name>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-declare-module",
      "category": "ts-specific",
      "code": "declare module '*.css' {\n  const content: Record<string, string>;\n  export default content;\n}",
      "expectedNodes": [
        {
          "type": "NAMESPACE",
          "id": "<declare-*.css>",
          "metadata": {
            "pattern": "*.css",
            "ambient": true,
            "originalType": "MODULE_DECLARATION"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<content>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, string>>",
          "metadata": {
            "typeExpression": "Record<string, string>",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "EXPORT",
          "id": "<default-export>",
          "metadata": {
            "exportType": "default"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<declare-*.css>",
            "type": "DECLARES"
          },
          {
            "src": "<declare-*.css>",
            "dst": "<content>",
            "type": "CONTAINS"
          },
          {
            "src": "<declare-*.css>",
            "dst": "<default-export>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<default-export>",
            "dst": "<content>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<content>",
            "dst": "<Record<string, string>>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-declare-namespace",
      "category": "ts-specific",
      "code": "declare namespace NodeJS {\n  interface ProcessEnv {\n    NODE_ENV: 'development' | 'production';\n  }\n}",
      "expectedNodes": [
        {
          "type": "NAMESPACE",
          "id": "<NodeJS>",
          "metadata": {
            "declared": true
          }
        },
        {
          "type": "INTERFACE",
          "id": "<ProcessEnv>",
          "metadata": {
            "declared": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<NODE_ENV>",
          "metadata": {
            "optional": false
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<'development' | 'production'>",
          "metadata": {
            "unionMembers": [
              "'development'",
              "'production'"
            ],
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'development'>",
          "metadata": {
            "value": "development",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<'production'>",
          "metadata": {
            "value": "production",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<NodeJS>",
            "type": "DECLARES"
          },
          {
            "src": "<NodeJS>",
            "dst": "<ProcessEnv>",
            "type": "CONTAINS"
          },
          {
            "src": "<ProcessEnv>",
            "dst": "<NODE_ENV>",
            "type": "CONTAINS"
          },
          {
            "src": "<'development' | 'production'>",
            "dst": "<'development'>",
            "type": "CONTAINS"
          },
          {
            "src": "<'development' | 'production'>",
            "dst": "<'production'>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<NODE_ENV>",
            "dst": "<'development' | 'production'>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-declare-global",
      "category": "ts-specific",
      "code": "declare global {\n  interface Window {\n    __APP_STATE__: unknown;\n  }\n}",
      "expectedNodes": [
        {
          "type": "EXPRESSION",
          "id": "<global-declaration>",
          "metadata": {
            "kind": "global",
            "ambient": true,
            "originalType": "DECLARATION"
          }
        },
        {
          "type": "INTERFACE",
          "id": "<Window>",
          "metadata": {
            "augmentation": true,
            "global": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<__APP_STATE__>",
          "metadata": {
            "type": "unknown"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<global-declaration>",
            "type": "CONTAINS"
          },
          {
            "src": "<global-declaration>",
            "dst": "<Window>",
            "type": "DECLARES"
          },
          {
            "src": "<Window>",
            "dst": "<__APP_STATE__>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-override",
      "category": "ts-specific",
      "code": "class BaseWithMethod {\n  greet() { return 'hello'; }\n}\nclass DerivedWithOverride extends BaseWithMethod {\n  override greet() { return 'hi'; }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<BaseWithMethod>"
        },
        {
          "type": "METHOD",
          "id": "<BaseWithMethod.greet>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hello'>",
          "metadata": {
            "value": "hello",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<DerivedWithOverride>"
        },
        {
          "type": "METHOD",
          "id": "<DerivedWithOverride.greet>",
          "metadata": {
            "kind": "method",
            "override": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'hi'>",
          "metadata": {
            "value": "hi",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<BaseWithMethod>",
            "type": "DECLARES"
          },
          {
            "src": "<BaseWithMethod>",
            "dst": "<BaseWithMethod.greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<BaseWithMethod.greet>",
            "dst": "<'hello'>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<DerivedWithOverride>",
            "type": "DECLARES"
          },
          {
            "src": "<DerivedWithOverride>",
            "dst": "<DerivedWithOverride.greet>",
            "type": "CONTAINS"
          },
          {
            "src": "<DerivedWithOverride.greet>",
            "dst": "<'hi'>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<DerivedWithOverride>",
            "dst": "<BaseWithMethod>",
            "type": "EXTENDS"
          },
          {
            "src": "<DerivedWithOverride.greet>",
            "dst": "<BaseWithMethod.greet>",
            "type": "OVERRIDES"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::utility-types",
      "category": "ts-specific",
      "code": "type PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype PickedUser = Pick<User, 'name' | 'age'>;\ntype OmittedUser = Omit<User, 'email'>;\ntype UserRecord = Record<string, User>;\ntype ExtractedType = Extract<string | number | boolean, string | boolean>;\ntype ExcludedType = Exclude<string | number | boolean, boolean>;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<PartialUser>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Partial<User>>",
          "metadata": {
            "utilityName": "Partial",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<RequiredUser>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Required<User>>",
          "metadata": {
            "utilityName": "Required",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<PickedUser>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Pick<User, 'name' | 'age'>>",
          "metadata": {
            "utilityName": "Pick",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'name'>",
          "metadata": {
            "value": "name",
            "literalType": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'age'>",
          "metadata": {
            "value": "age",
            "literalType": "string"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<OmittedUser>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Omit<User, 'email'>>",
          "metadata": {
            "utilityName": "Omit",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'email'>",
          "metadata": {
            "value": "email",
            "literalType": "string"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<UserRecord>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, User>>",
          "metadata": {
            "utilityName": "Record",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ExtractedType>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Extract<string | number | boolean, string | boolean>>",
          "metadata": {
            "utilityName": "Extract",
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<string | number | boolean>",
          "metadata": {
            "unionMembers": [
              "string",
              "number",
              "boolean"
            ],
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<string | boolean>",
          "metadata": {
            "unionMembers": [
              "string",
              "boolean"
            ],
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ExcludedType>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Exclude<string | number | boolean, boolean>>",
          "metadata": {
            "utilityName": "Exclude",
            "originalType": "UTILITY_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<PartialUser>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<RequiredUser>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<PickedUser>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<OmittedUser>",
            "type": "DECLARES"
          },
          {
            "src": "<Omit<User, 'email'>>",
            "dst": "<'email'>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "EXCLUDES_PROPERTY"
            }
          },
          {
            "src": "<module>",
            "dst": "<UserRecord>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<ExtractedType>",
            "type": "DECLARES"
          },
          {
            "src": "<Extract<string | number | boolean, string | boolean>>",
            "dst": "<string | boolean>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "MATCHES_AGAINST"
            }
          },
          {
            "src": "<module>",
            "dst": "<ExcludedType>",
            "type": "DECLARES"
          },
          {
            "src": "<Exclude<string | number | boolean, boolean>>",
            "dst": "<string | number | boolean>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "EXCLUDES_FROM"
            }
          }
        ],
        "postFile": [
          {
            "src": "<PartialUser>",
            "dst": "<Partial<User>>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<RequiredUser>",
            "dst": "<Required<User>>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<PickedUser>",
            "dst": "<Pick<User, 'name' | 'age'>>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<OmittedUser>",
            "dst": "<Omit<User, 'email'>>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<UserRecord>",
            "dst": "<Record<string, User>>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ExtractedType>",
            "dst": "<Extract<string | number | boolean, string | boolean>>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ExcludedType>",
            "dst": "<Exclude<string | number | boolean, boolean>>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Partial<User>>",
            "dst": "<User>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "TRANSFORMS"
            }
          },
          {
            "src": "<Required<User>>",
            "dst": "<User>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "TRANSFORMS"
            }
          },
          {
            "src": "<Pick<User, 'name' | 'age'>>",
            "dst": "<User>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "TRANSFORMS"
            }
          },
          {
            "src": "<Pick<User, 'name' | 'age'>>",
            "dst": "<'name'>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "SELECTS_PROPERTY"
            }
          },
          {
            "src": "<Pick<User, 'name' | 'age'>>",
            "dst": "<'age'>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "SELECTS_PROPERTY"
            }
          },
          {
            "src": "<Omit<User, 'email'>>",
            "dst": "<User>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "TRANSFORMS"
            }
          },
          {
            "src": "<Record<string, User>>",
            "dst": "<User>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_TO"
            }
          },
          {
            "src": "<Extract<string | number | boolean, string | boolean>>",
            "dst": "<string | number | boolean>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "EXTRACTS_FROM"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-module-augmentation",
      "category": "ts-specific",
      "code": "declare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}",
      "expectedNodes": [
        {
          "type": "NAMESPACE",
          "id": "<express-augmentation>",
          "metadata": {
            "targetModule": "express",
            "originalType": "MODULE_AUGMENTATION"
          }
        },
        {
          "type": "INTERFACE",
          "id": "<Request-augmentation>",
          "metadata": {
            "name": "Request",
            "isAugmentation": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<user>",
          "metadata": {
            "optional": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<user-type>",
          "metadata": {
            "kind": "object",
            "originalType": "TYPE"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<id>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<role>",
          "metadata": {
            "type": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<express-augmentation>",
            "type": "DECLARES"
          },
          {
            "src": "<express-augmentation>",
            "dst": "<Request-augmentation>",
            "type": "CONTAINS"
          },
          {
            "src": "<Request-augmentation>",
            "dst": "<user>",
            "type": "CONTAINS"
          },
          {
            "src": "<user-type>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<user-type>",
            "dst": "<role>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<user>",
            "dst": "<user-type>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<express-augmentation>",
            "dst": "express",
            "type": "MERGES_WITH",
            "metadata": {
              "originalType": "AUGMENTS"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-recursive-type",
      "category": "ts-specific",
      "code": "type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<JSONValue>",
          "metadata": {
            "recursive": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<JSONValue:union>",
          "metadata": {
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "originalType": "PRIMITIVE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "originalType": "PRIMITIVE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<boolean>",
          "metadata": {
            "originalType": "PRIMITIVE_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<null>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<JSONValue[]>",
          "metadata": {
            "originalType": "ARRAY_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<JSONValue:object>",
          "metadata": {
            "originalType": "OBJECT_TYPE"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<[key: string]: JSONValue>",
          "metadata": {
            "originalType": "INDEX_SIGNATURE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<JSONValue>",
            "type": "DECLARES"
          },
          {
            "src": "<JSONValue:union>",
            "dst": "<string>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSONValue:union>",
            "dst": "<number>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSONValue:union>",
            "dst": "<boolean>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSONValue:union>",
            "dst": "<null>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSONValue:union>",
            "dst": "<JSONValue[]>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSONValue:union>",
            "dst": "<JSONValue:object>",
            "type": "CONTAINS"
          },
          {
            "src": "<JSONValue[]>",
            "dst": "<JSONValue>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "ELEMENT_TYPE"
            }
          },
          {
            "src": "<JSONValue:object>",
            "dst": "<[key: string]: JSONValue>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<JSONValue>",
            "dst": "<JSONValue:union>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<[key: string]: JSONValue>",
            "dst": "<string>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "KEY_TYPE"
            }
          },
          {
            "src": "<[key: string]: JSONValue>",
            "dst": "<JSONValue>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "VALUE_TYPE"
            }
          },
          {
            "src": "<JSONValue>",
            "dst": "<JSONValue>",
            "type": "ALIASES",
            "metadata": {
              "originalType": "SELF_REFERENCES"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-const-type-param",
      "category": "ts-specific",
      "code": "function literal<const T>(value: T): T {\n  return value;\n}\nconst literalResult = literal({ x: 1, y: [2, 3] } as const);",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<literal>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": "const"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<literalResult>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "CALL",
          "id": "<literal({ x: 1, y: [2, 3] } as const)>"
        },
        {
          "type": "LITERAL",
          "id": "<{ x: 1, y: [2, 3] }>",
          "metadata": {
            "literalType": "object",
            "constAssertion": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[2, 3]>",
          "metadata": {
            "literalType": "array",
            "constAssertion": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<3>",
          "metadata": {
            "value": 3,
            "literalType": "number"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<literal>",
            "type": "DECLARES"
          },
          {
            "src": "<literal>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<literal>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<literal>",
            "dst": "<T>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<literal>",
            "dst": "<value>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<literalResult>",
            "type": "DECLARES"
          },
          {
            "src": "<literal({ x: 1, y: [2, 3] } as const)>",
            "dst": "<{ x: 1, y: [2, 3] }>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<{ x: 1, y: [2, 3] }>",
            "dst": "<1>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<{ x: 1, y: [2, 3] }>",
            "dst": "<[2, 3]>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<[2, 3]>",
            "dst": "<2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[2, 3]>",
            "dst": "<3>",
            "type": "HAS_ELEMENT"
          }
        ],
        "postFile": [
          {
            "src": "<literalResult>",
            "dst": "<literal({ x: 1, y: [2, 3] } as const)>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<value>",
            "dst": "<T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<literal({ x: 1, y: [2, 3] } as const)>",
            "dst": "<literal>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-variance-in-out",
      "category": "ts-specific",
      "code": "interface Producer<out T> {\n  produce(): T;\n}\ninterface Consumer<in T> {\n  consume(value: T): void;\n}\ninterface Transformer<in T, out U> {\n  transform(input: T): U;\n}",
      "expectedNodes": [
        {
          "type": "INTERFACE",
          "id": "<Producer>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<Producer.T>",
          "metadata": {
            "variance": "out",
            "covariant": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Producer.produce>",
          "metadata": {
            "returnType": "T"
          }
        },
        {
          "type": "INTERFACE",
          "id": "<Consumer>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<Consumer.T>",
          "metadata": {
            "variance": "in",
            "contravariant": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Consumer.consume>",
          "metadata": {
            "returnType": "void"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<Consumer.consume.value>",
          "metadata": {
            "paramType": "T"
          }
        },
        {
          "type": "INTERFACE",
          "id": "<Transformer>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<Transformer.T>",
          "metadata": {
            "variance": "in",
            "contravariant": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<Transformer.U>",
          "metadata": {
            "variance": "out",
            "covariant": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Transformer.transform>",
          "metadata": {
            "returnType": "U"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<Transformer.transform.input>",
          "metadata": {
            "paramType": "T"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Producer>",
            "type": "DECLARES"
          },
          {
            "src": "<Producer>",
            "dst": "<Producer.T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Producer>",
            "dst": "<Producer.produce>",
            "type": "CONTAINS"
          },
          {
            "src": "<Producer.produce>",
            "dst": "<Producer.T>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<module>",
            "dst": "<Consumer>",
            "type": "DECLARES"
          },
          {
            "src": "<Consumer>",
            "dst": "<Consumer.T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Consumer>",
            "dst": "<Consumer.consume>",
            "type": "CONTAINS"
          },
          {
            "src": "<Consumer.consume>",
            "dst": "<Consumer.consume.value>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<Transformer>",
            "type": "DECLARES"
          },
          {
            "src": "<Transformer>",
            "dst": "<Transformer.T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Transformer>",
            "dst": "<Transformer.U>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<Transformer>",
            "dst": "<Transformer.transform>",
            "type": "CONTAINS"
          },
          {
            "src": "<Transformer.transform>",
            "dst": "<Transformer.transform.input>",
            "type": "CONTAINS"
          },
          {
            "src": "<Transformer.transform>",
            "dst": "<Transformer.U>",
            "type": "RETURNS_TYPE"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Consumer.consume.value>",
            "dst": "<Consumer.T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<Transformer.transform.input>",
            "dst": "<Transformer.T>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-asserts-guard",
      "category": "ts-specific",
      "code": "function assertDefined<T>(val: T | undefined): asserts val is T {\n  if (val === undefined) throw new Error('undefined');\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<assertDefined>",
          "metadata": {
            "async": false,
            "generator": false,
            "typeGuard": true,
            "assertsGuard": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<val>",
          "metadata": {
            "name": "val"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T | undefined>",
          "metadata": {
            "kind": "union",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<asserts val is T>",
          "metadata": {
            "assertsType": "T",
            "assertsVariable": "val",
            "originalType": "TYPE_ASSERTION"
          }
        },
        {
          "type": "BRANCH",
          "id": "<if-undefined-check>",
          "metadata": {
            "branchType": "if"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<val === undefined>",
          "metadata": {
            "operator": "==="
          }
        },
        {
          "type": "LITERAL",
          "id": "<undefined>",
          "metadata": {
            "value": "undefined",
            "literalType": "undefined"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<throw-error>",
          "metadata": {
            "kind": "throw"
          }
        },
        {
          "type": "CALL",
          "id": "<new Error('undefined')>",
          "metadata": {
            "callee": "Error",
            "constructor": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'undefined'>",
          "metadata": {
            "value": "undefined",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<assertDefined>",
            "type": "DECLARES"
          },
          {
            "src": "<assertDefined>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<assertDefined>",
            "dst": "<val>",
            "type": "CONTAINS"
          },
          {
            "src": "<assertDefined>",
            "dst": "<asserts val is T>",
            "type": "RETURNS"
          },
          {
            "src": "<assertDefined>",
            "dst": "<if-undefined-check>",
            "type": "CONTAINS"
          },
          {
            "src": "<if-undefined-check>",
            "dst": "<val === undefined>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<if-undefined-check>",
            "dst": "<throw-error>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<new Error('undefined')>",
            "dst": "<'undefined'>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<throw-error>",
            "dst": "<new Error('undefined')>",
            "type": "THROWS"
          }
        ],
        "postProject": [
          {
            "src": "<val>",
            "dst": "<T | undefined>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<asserts val is T>",
            "dst": "<val>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_ABOUT"
            }
          },
          {
            "src": "<asserts val is T>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "NARROWS_TO"
            }
          },
          {
            "src": "<val === undefined>",
            "dst": "<val>",
            "type": "READS_FROM"
          },
          {
            "src": "<val === undefined>",
            "dst": "<undefined>",
            "type": "READS_FROM"
          },
          {
            "src": "<new Error('undefined')>",
            "dst": "<Error>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-recursive-type-tree",
      "category": "ts-specific",
      "code": "type TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<TreeNode>",
          "metadata": {
            "generic": true,
            "recursive": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": null
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<TreeNode:objectType>",
          "metadata": {
            "kind": "object",
            "originalType": "OBJECT_TYPE"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<value>",
          "metadata": {
            "required": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<children>",
          "metadata": {
            "required": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<TreeNode<T>[]>",
          "metadata": {
            "elementType": "TreeNode<T>",
            "originalType": "ARRAY_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<TreeNode<T>:ref>",
          "metadata": {
            "typeArgs": [
              "T"
            ]
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<TreeNode>",
            "type": "DECLARES"
          },
          {
            "src": "<TreeNode>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<TreeNode:objectType>",
            "dst": "<value>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<TreeNode:objectType>",
            "dst": "<children>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<TreeNode<T>[]>",
            "dst": "<TreeNode<T>:ref>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "HAS_ELEMENT_TYPE"
            }
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<TreeNode>",
            "dst": "<TreeNode:objectType>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<value>",
            "dst": "<T>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<children>",
            "dst": "<TreeNode<T>[]>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<TreeNode<T>:ref>",
            "dst": "<TreeNode>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<TreeNode<T>:ref>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "INSTANTIATED_WITH"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-import-assertions",
      "category": "ts-specific",
      "code": "// import data from './data.json' with { type: 'json' };\n// (commented out  import attributes syntax, requires runtime support)\ntype ImportedJSON = Record<string, unknown>;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ImportedJSON>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, unknown>>",
          "metadata": {
            "generic": true,
            "typeArgs": [
              "string",
              "unknown"
            ]
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ImportedJSON>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<ImportedJSON>",
            "dst": "<Record<string, unknown>>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-import-type-star",
      "category": "ts-specific",
      "code": "// import type * as AllTypes from './modules-helpers.js';\n// (commented out  no actual modules to import from, but syntax is valid)\ntype AllTypesPlaceholder = Record<string, unknown>;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<AllTypesPlaceholder>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, unknown>>",
          "metadata": {
            "utility": "Record",
            "keyType": "string",
            "valueType": "unknown",
            "originalType": "TYPE_EXPRESSION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<AllTypesPlaceholder>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<AllTypesPlaceholder>",
            "dst": "<Record<string, unknown>>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-noinfer",
      "category": "ts-specific",
      "code": "function createFSM<S extends string>(config: {\n  initial: NoInfer<S>;\n  states: Record<S, object>;\n}) {\n  return config;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createFSM>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<S>",
          "metadata": {
            "constraint": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<config>",
          "metadata": {
            "hasTypeAnnotation": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<config:type>",
          "metadata": {
            "kind": "object",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<initial>",
          "metadata": {
            "required": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<NoInfer<S>>",
          "metadata": {
            "utility": "NoInfer",
            "argument": "S",
            "originalType": "TYPE_UTILITY"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<states>",
          "metadata": {
            "required": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<S, object>>",
          "metadata": {
            "utility": "Record",
            "keyType": "S",
            "valueType": "object",
            "originalType": "TYPE_ANNOTATION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<createFSM>",
            "type": "DECLARES"
          },
          {
            "src": "<createFSM>",
            "dst": "<S>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<createFSM>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<config:type>",
            "dst": "<initial>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<config:type>",
            "dst": "<states>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<NoInfer<S>>",
            "dst": "<S>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "WRAPS_TYPE"
            }
          },
          {
            "src": "<createFSM>",
            "dst": "<config>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<S>",
            "dst": "string",
            "type": "EXTENDS"
          },
          {
            "src": "<config>",
            "dst": "<config:type>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<initial>",
            "dst": "<NoInfer<S>>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<states>",
            "dst": "<Record<S, object>>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<Record<S, object>>",
            "dst": "<S>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "USES_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-template-literal-infer",
      "category": "ts-specific",
      "code": "type ParseRoute<T extends string> =\n  T extends `/${infer Segment}/${infer Rest}`\n    ? [Segment, ...ParseRoute<`/${Rest}`>]\n    : T extends `/${infer Segment}`\n      ? [Segment]\n      : [];",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ParseRoute>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": "string"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<ParseRoute-conditional>",
          "metadata": {
            "nested": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<`/${infer Segment}/${infer Rest}`>",
          "metadata": {
            "pattern": "/${infer Segment}/${infer Rest}",
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<infer Segment>",
          "metadata": {
            "inferredName": "Segment"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<infer Rest>",
          "metadata": {
            "inferredName": "Rest"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[Segment, ...ParseRoute<`/${Rest}`>]>",
          "metadata": {
            "hasSpread": true,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<ParseRoute<`/${Rest}`>>",
          "metadata": {
            "recursive": true,
            "originalType": "RECURSIVE_TYPE_CALL"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<`/${Rest}`>",
          "metadata": {
            "pattern": "/${Rest}",
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<`/${infer Segment}`>",
          "metadata": {
            "pattern": "/${infer Segment}",
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<infer Segment-2>",
          "metadata": {
            "inferredName": "Segment"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[Segment]>",
          "metadata": {
            "hasSpread": false,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[]>",
          "metadata": {
            "empty": true,
            "originalType": "TUPLE_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ParseRoute>",
            "type": "DECLARES"
          },
          {
            "src": "<ParseRoute>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<ParseRoute-conditional>",
            "dst": "<T>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "CHECKS_TYPE"
            }
          },
          {
            "src": "<ParseRoute-conditional>",
            "dst": "<`/${infer Segment}/${infer Rest}`>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "EXTENDS_CHECK"
            }
          },
          {
            "src": "<`/${infer Segment}/${infer Rest}`>",
            "dst": "<infer Segment>",
            "type": "INFERS"
          },
          {
            "src": "<`/${infer Segment}/${infer Rest}`>",
            "dst": "<infer Rest>",
            "type": "INFERS"
          },
          {
            "src": "<ParseRoute-conditional>",
            "dst": "<[Segment, ...ParseRoute<`/${Rest}`>]>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<[Segment, ...ParseRoute<`/${Rest}`>]>",
            "dst": "<ParseRoute<`/${Rest}`>>",
            "type": "SPREADS_FROM",
            "metadata": {
              "originalType": "SPREADS"
            }
          },
          {
            "src": "<ParseRoute<`/${Rest}`>>",
            "dst": "<`/${Rest}`>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<ParseRoute-conditional>",
            "dst": "<`/${infer Segment}`>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "EXTENDS_CHECK"
            }
          },
          {
            "src": "<`/${infer Segment}`>",
            "dst": "<infer Segment-2>",
            "type": "INFERS"
          }
        ],
        "postFile": [
          {
            "src": "<ParseRoute>",
            "dst": "<ParseRoute-conditional>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ParseRoute-conditional>",
            "dst": "<[Segment]>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<ParseRoute-conditional>",
            "dst": "<[]>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<[Segment, ...ParseRoute<`/${Rest}`>]>",
            "dst": "<infer Segment>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "USES_INFERRED"
            }
          },
          {
            "src": "<ParseRoute<`/${Rest}`>>",
            "dst": "<ParseRoute>",
            "type": "CALLS"
          },
          {
            "src": "<`/${Rest}`>",
            "dst": "<infer Rest>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "USES_INFERRED"
            }
          },
          {
            "src": "<[Segment]>",
            "dst": "<infer Segment-2>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "USES_INFERRED"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-explicit-this-param",
      "category": "ts-specific",
      "code": "function onActivate(this: { name: string }, greeting: string): string {\n  return `${greeting}, ${this.name}`;\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<onActivate>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<this>",
          "metadata": {
            "kind": "this",
            "typeAnnotation": "{ name: string }"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<greeting>",
          "metadata": {
            "typeAnnotation": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<template-literal>",
          "metadata": {
            "literalType": "template",
            "parts": [
              "",
              ", ",
              ""
            ]
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.name>",
          "metadata": {
            "objectName": "this",
            "propertyName": "name"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<onActivate>",
            "type": "DECLARES"
          },
          {
            "src": "<onActivate>",
            "dst": "<this>",
            "type": "CONTAINS"
          },
          {
            "src": "<onActivate>",
            "dst": "<greeting>",
            "type": "CONTAINS"
          },
          {
            "src": "<onActivate>",
            "dst": "<template-literal>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<template-literal>",
            "dst": "<greeting>",
            "type": "READS_FROM"
          },
          {
            "src": "<template-literal>",
            "dst": "<this.name>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.name>",
            "dst": "<this>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-exhaustive-never",
      "category": "ts-specific",
      "code": "type ShapeUnion = { kind: 'circle'; radius: number } | { kind: 'square'; side: number };\n\nfunction shapeArea(shape: ShapeUnion): number {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n    default: {\n      const _exhaustive: never = shape;\n      throw new Error(`Unknown shape: ${_exhaustive}`);\n    }\n  }\n}",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ShapeUnion>",
          "metadata": {
            "kind": "union"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<circle-type>",
          "metadata": {
            "discriminant": "circle",
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<square-type>",
          "metadata": {
            "discriminant": "square",
            "originalType": "TYPE"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<shapeArea>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<shape>",
          "metadata": {
            "typeAnnotation": "ShapeUnion"
          }
        },
        {
          "type": "BRANCH",
          "id": "<switch-shape.kind>",
          "metadata": {
            "discriminant": "shape.kind",
            "originalType": "SWITCH"
          }
        },
        {
          "type": "CASE",
          "id": "<case-circle>",
          "metadata": {
            "value": "circle"
          }
        },
        {
          "type": "CASE",
          "id": "<case-square>",
          "metadata": {
            "value": "square"
          }
        },
        {
          "type": "CASE",
          "id": "<case-default>",
          "metadata": {
            "isDefault": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Math.PI * shape.radius ** 2>",
          "metadata": {
            "operator": "*"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<shape.side ** 2>",
          "metadata": {
            "operator": "**"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<_exhaustive>",
          "metadata": {
            "kind": "const",
            "typeAnnotation": "never"
          }
        },
        {
          "type": "CALL",
          "id": "<throw new Error>",
          "metadata": {
            "callee": "Error",
            "isThrow": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'Unknown shape: '>",
          "metadata": {
            "value": "Unknown shape: ",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ShapeUnion>",
            "type": "DECLARES"
          },
          {
            "src": "<ShapeUnion>",
            "dst": "<circle-type>",
            "type": "CONTAINS"
          },
          {
            "src": "<ShapeUnion>",
            "dst": "<square-type>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<shapeArea>",
            "type": "DECLARES"
          },
          {
            "src": "<shapeArea>",
            "dst": "<shape>",
            "type": "CONTAINS"
          },
          {
            "src": "<shapeArea>",
            "dst": "<switch-shape.kind>",
            "type": "CONTAINS"
          },
          {
            "src": "<switch-shape.kind>",
            "dst": "<case-circle>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch-shape.kind>",
            "dst": "<case-square>",
            "type": "HAS_CASE"
          },
          {
            "src": "<switch-shape.kind>",
            "dst": "<case-default>",
            "type": "HAS_DEFAULT"
          },
          {
            "src": "<case-circle>",
            "dst": "<Math.PI * shape.radius ** 2>",
            "type": "RETURNS"
          },
          {
            "src": "<case-square>",
            "dst": "<shape.side ** 2>",
            "type": "RETURNS"
          },
          {
            "src": "<case-default>",
            "dst": "<_exhaustive>",
            "type": "DECLARES"
          },
          {
            "src": "<case-default>",
            "dst": "<throw new Error>",
            "type": "CONTAINS"
          },
          {
            "src": "<throw new Error>",
            "dst": "<'Unknown shape: '>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<_exhaustive>",
            "dst": "<shape>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<shape>",
            "dst": "<ShapeUnion>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<switch-shape.kind>",
            "dst": "<shape>",
            "type": "READS_FROM"
          },
          {
            "src": "<Math.PI * shape.radius ** 2>",
            "dst": "<shape>",
            "type": "READS_FROM"
          },
          {
            "src": "<shape.side ** 2>",
            "dst": "<shape>",
            "type": "READS_FROM"
          },
          {
            "src": "<throw new Error>",
            "dst": "<_exhaustive>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-this-type",
      "category": "ts-specific",
      "code": "class Builder {\n  private builderValue = 0;\n\n  add(n: number): this {\n    this.builderValue += n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.builderValue *= n;\n    return this;\n  }\n}\n\nclass AdvancedBuilder extends Builder {\n  negate(): this {\n    return this;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Builder>"
        },
        {
          "type": "PROPERTY",
          "id": "<Builder.builderValue>",
          "metadata": {
            "visibility": "private",
            "hasInitializer": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Builder.add>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<n>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<this-return-type>",
          "metadata": {
            "type": "this",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.builderValue += n>",
          "metadata": {
            "operator": "+="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.builderValue>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "METHOD",
          "id": "<Builder.multiply>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<n2>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<this-return-type2>",
          "metadata": {
            "type": "this",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this.builderValue *= n>",
          "metadata": {
            "operator": "*="
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.builderValue2>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "CLASS",
          "id": "<AdvancedBuilder>"
        },
        {
          "type": "METHOD",
          "id": "<AdvancedBuilder.negate>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<this-return-type3>",
          "metadata": {
            "type": "this",
            "originalType": "TYPE_ANNOTATION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Builder>",
            "type": "DECLARES"
          },
          {
            "src": "<Builder>",
            "dst": "<Builder.builderValue>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder>",
            "dst": "<Builder.add>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder.add>",
            "dst": "<n>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder.add>",
            "dst": "<this-return-type>",
            "type": "RETURNS_TYPE",
            "metadata": {
              "originalType": "HAS_RETURN_TYPE"
            }
          },
          {
            "src": "<Builder.add>",
            "dst": "<this.builderValue += n>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder.add>",
            "dst": "<this>",
            "type": "RETURNS"
          },
          {
            "src": "<Builder>",
            "dst": "<Builder.multiply>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder.multiply>",
            "dst": "<n2>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder.multiply>",
            "dst": "<this-return-type2>",
            "type": "RETURNS_TYPE",
            "metadata": {
              "originalType": "HAS_RETURN_TYPE"
            }
          },
          {
            "src": "<Builder.multiply>",
            "dst": "<this.builderValue *= n>",
            "type": "CONTAINS"
          },
          {
            "src": "<Builder.multiply>",
            "dst": "<this>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<AdvancedBuilder>",
            "type": "DECLARES"
          },
          {
            "src": "<AdvancedBuilder>",
            "dst": "<AdvancedBuilder.negate>",
            "type": "CONTAINS"
          },
          {
            "src": "<AdvancedBuilder.negate>",
            "dst": "<this-return-type3>",
            "type": "RETURNS_TYPE",
            "metadata": {
              "originalType": "HAS_RETURN_TYPE"
            }
          },
          {
            "src": "<AdvancedBuilder.negate>",
            "dst": "<this>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<Builder.builderValue>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.builderValue += n>",
            "dst": "<this.builderValue>",
            "type": "WRITES_TO"
          },
          {
            "src": "<this.builderValue *= n>",
            "dst": "<this.builderValue2>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<this.builderValue += n>",
            "dst": "<n>",
            "type": "READS_FROM"
          },
          {
            "src": "<this.builderValue *= n>",
            "dst": "<n2>",
            "type": "READS_FROM"
          },
          {
            "src": "<AdvancedBuilder>",
            "dst": "<Builder>",
            "type": "EXTENDS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-branded-type",
      "category": "ts-specific",
      "code": "type UserId = string & { readonly __brand: unique symbol };\ntype OrderId = string & { readonly __brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction createOrderId(id: string): OrderId {\n  return id as OrderId;\n}",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<UserId>",
          "metadata": {
            "branded": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string & { readonly __brand: unique symbol }>",
          "metadata": {
            "operator": "&",
            "originalType": "TYPE_INTERSECTION"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "originalType": "TYPE_PRIMITIVE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<{ readonly __brand: unique symbol }>",
          "metadata": {
            "originalType": "TYPE_OBJECT"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<__brand>",
          "metadata": {
            "readonly": true,
            "originalType": "TYPE_PROPERTY"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<unique symbol>",
          "metadata": {
            "originalType": "TYPE_UNIQUE_SYMBOL"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<OrderId>",
          "metadata": {
            "branded": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string & { readonly __brand: unique symbol }#2>",
          "metadata": {
            "operator": "&",
            "originalType": "TYPE_INTERSECTION"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<{ readonly __brand: unique symbol }#2>",
          "metadata": {
            "originalType": "TYPE_OBJECT"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<__brand#2>",
          "metadata": {
            "readonly": true,
            "originalType": "TYPE_PROPERTY"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<unique symbol#2>",
          "metadata": {
            "originalType": "TYPE_UNIQUE_SYMBOL"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<createUserId>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id>",
          "metadata": {
            "hasTypeAnnotation": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<id as UserId>",
          "metadata": {
            "originalType": "TYPE_ASSERTION"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<createOrderId>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<id#2>",
          "metadata": {
            "hasTypeAnnotation": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<id as OrderId>",
          "metadata": {
            "originalType": "TYPE_ASSERTION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<UserId>",
            "type": "DECLARES"
          },
          {
            "src": "<string & { readonly __brand: unique symbol }>",
            "dst": "<string>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<string & { readonly __brand: unique symbol }>",
            "dst": "<{ readonly __brand: unique symbol }>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<{ readonly __brand: unique symbol }>",
            "dst": "<__brand>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<OrderId>",
            "type": "DECLARES"
          },
          {
            "src": "<string & { readonly __brand: unique symbol }#2>",
            "dst": "<string>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<string & { readonly __brand: unique symbol }#2>",
            "dst": "<{ readonly __brand: unique symbol }#2>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<{ readonly __brand: unique symbol }#2>",
            "dst": "<__brand#2>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<createUserId>",
            "type": "DECLARES"
          },
          {
            "src": "<createUserId>",
            "dst": "<id>",
            "type": "CONTAINS"
          },
          {
            "src": "<createUserId>",
            "dst": "<UserId>",
            "type": "RETURNS"
          },
          {
            "src": "<createUserId>",
            "dst": "<id as UserId>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<createOrderId>",
            "type": "DECLARES"
          },
          {
            "src": "<createOrderId>",
            "dst": "<id#2>",
            "type": "CONTAINS"
          },
          {
            "src": "<createOrderId>",
            "dst": "<OrderId>",
            "type": "RETURNS"
          },
          {
            "src": "<createOrderId>",
            "dst": "<id as OrderId>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<UserId>",
            "dst": "<string & { readonly __brand: unique symbol }>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<OrderId>",
            "dst": "<string & { readonly __brand: unique symbol }#2>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<__brand>",
            "dst": "<unique symbol>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<__brand#2>",
            "dst": "<unique symbol#2>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<id>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<id as UserId>",
            "dst": "<id>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_FROM"
            }
          },
          {
            "src": "<id as UserId>",
            "dst": "<UserId>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_TO"
            }
          },
          {
            "src": "<id#2>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<id as OrderId>",
            "dst": "<id#2>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_FROM"
            }
          },
          {
            "src": "<id as OrderId>",
            "dst": "<OrderId>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "ASSERTS_TO"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-abstract-construct",
      "category": "ts-specific",
      "code": "type AbstractConstructor<T> = abstract new (...args: any[]) => T;\n\nfunction withMixin<T extends AbstractConstructor<{}>>(Base: T) {\n  abstract class Mixed extends Base {\n    abstract doThing(): void;\n  }\n  return Mixed;\n}",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<AbstractConstructor>",
          "metadata": {
            "generic": true,
            "typeParameters": [
              "T"
            ]
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "scope": "AbstractConstructor"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<abstract new (...args: any[]) => T>",
          "metadata": {
            "abstract": true,
            "variadic": true,
            "originalType": "CONSTRUCTOR_TYPE"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<withMixin>",
          "metadata": {
            "generic": true,
            "typeParameters": [
              "T"
            ]
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T:withMixin>",
          "metadata": {
            "scope": "withMixin",
            "constraint": "AbstractConstructor<{}>"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<Base>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "CLASS",
          "id": "<Mixed>",
          "metadata": {
            "abstract": true,
            "local": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Mixed.doThing>",
          "metadata": {
            "abstract": true,
            "kind": "method"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<AbstractConstructor>",
            "type": "DECLARES"
          },
          {
            "src": "<AbstractConstructor>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<abstract new (...args: any[]) => T>",
            "dst": "<T>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<withMixin>",
            "type": "DECLARES"
          },
          {
            "src": "<withMixin>",
            "dst": "<T:withMixin>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<T:withMixin>",
            "dst": "<AbstractConstructor>",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<withMixin>",
            "dst": "<Base>",
            "type": "CONTAINS"
          },
          {
            "src": "<withMixin>",
            "dst": "<Mixed>",
            "type": "CONTAINS"
          },
          {
            "src": "<Mixed>",
            "dst": "<Mixed.doThing>",
            "type": "CONTAINS"
          },
          {
            "src": "<withMixin>",
            "dst": "<Mixed>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<AbstractConstructor>",
            "dst": "<abstract new (...args: any[]) => T>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<Mixed>",
            "dst": "<Base>",
            "type": "EXTENDS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-declaration-merging",
      "category": "ts-specific",
      "code": "class Box { x = 0; }\ninterface Box { y: number; }\n// Box now has both x (from class) and y (from interface)",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Box>",
          "metadata": {
            "declarationMerging": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Box.x>",
          "metadata": {
            "initializer": "0",
            "source": "class"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "INTERFACE",
          "id": "<Box:interface>",
          "metadata": {
            "declarationMerging": true
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Box.y>",
          "metadata": {
            "type": "number",
            "source": "interface"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Box>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<Box:interface>",
            "type": "DECLARES"
          },
          {
            "src": "<Box>",
            "dst": "<Box.x>",
            "type": "CONTAINS"
          },
          {
            "src": "<Box:interface>",
            "dst": "<Box.y>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<Box.x>",
            "dst": "<0>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Box.y>",
            "dst": "<number>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<Box>",
            "dst": "<Box:interface>",
            "type": "MERGES_WITH"
          },
          {
            "src": "<Box:interface>",
            "dst": "<Box>",
            "type": "MERGES_WITH"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-const-enum-computed",
      "category": "ts-specific",
      "code": "const enum BitFlags {\n  Read = 1 << 0,\n  Write = 1 << 1,\n  Execute = 1 << 2,\n  ReadWrite = Read | Write,\n}",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<BitFlags>",
          "metadata": {
            "kind": "const",
            "computed": true
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<BitFlags.Read>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<1 << 0>",
          "metadata": {
            "operator": "<<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<BitFlags.Write>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<1 << 1>",
          "metadata": {
            "operator": "<<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1_2>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1_literal>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<BitFlags.Execute>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<1 << 2>",
          "metadata": {
            "operator": "<<"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1_3>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<2>",
          "metadata": {
            "value": 2,
            "literalType": "number"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<BitFlags.ReadWrite>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<Read | Write>",
          "metadata": {
            "operator": "|"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<BitFlags>",
            "type": "DECLARES"
          },
          {
            "src": "<BitFlags>",
            "dst": "<BitFlags.Read>",
            "type": "CONTAINS"
          },
          {
            "src": "<BitFlags>",
            "dst": "<BitFlags.Write>",
            "type": "CONTAINS"
          },
          {
            "src": "<BitFlags>",
            "dst": "<BitFlags.Execute>",
            "type": "CONTAINS"
          },
          {
            "src": "<BitFlags>",
            "dst": "<BitFlags.ReadWrite>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<BitFlags.Read>",
            "dst": "<1 << 0>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<BitFlags.Write>",
            "dst": "<1 << 1>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<BitFlags.Execute>",
            "dst": "<1 << 2>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<BitFlags.ReadWrite>",
            "dst": "<Read | Write>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<1 << 0>",
            "dst": "<1>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 << 0>",
            "dst": "<0>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 << 1>",
            "dst": "<1_2>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 << 1>",
            "dst": "<1_literal>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 << 2>",
            "dst": "<1_3>",
            "type": "READS_FROM"
          },
          {
            "src": "<1 << 2>",
            "dst": "<2>",
            "type": "READS_FROM"
          },
          {
            "src": "<Read | Write>",
            "dst": "<BitFlags.Read>",
            "type": "READS_FROM"
          },
          {
            "src": "<Read | Write>",
            "dst": "<BitFlags.Write>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-class-method-overloads",
      "category": "ts-specific",
      "code": "class Parser {\n  parse(input: string): string;\n  parse(input: number): number;\n  parse(input: string | number): string | number {\n    return input;\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Parser>"
        },
        {
          "type": "METHOD",
          "id": "<Parser.parse>",
          "metadata": {
            "kind": "method",
            "overloaded": true
          }
        },
        {
          "type": "METHOD",
          "id": "<Parser.parse:overload1>",
          "metadata": {
            "signatureOnly": true,
            "originalType": "METHOD_OVERLOAD"
          }
        },
        {
          "type": "METHOD",
          "id": "<Parser.parse:overload2>",
          "metadata": {
            "signatureOnly": true,
            "originalType": "METHOD_OVERLOAD"
          }
        },
        {
          "type": "METHOD",
          "id": "<Parser.parse:implementation>",
          "metadata": {
            "signatureOnly": false,
            "originalType": "METHOD_OVERLOAD"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input:overload1>",
          "metadata": {
            "tsType": "string"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input:overload2>",
          "metadata": {
            "tsType": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input:implementation>",
          "metadata": {
            "tsType": "string | number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "primitive": true,
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string | number>",
          "metadata": {
            "unionType": true,
            "originalType": "TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Parser>",
            "type": "DECLARES"
          },
          {
            "src": "<Parser>",
            "dst": "<Parser.parse>",
            "type": "CONTAINS"
          },
          {
            "src": "<Parser.parse:overload1>",
            "dst": "<input:overload1>",
            "type": "CONTAINS"
          },
          {
            "src": "<Parser.parse:overload2>",
            "dst": "<input:overload2>",
            "type": "CONTAINS"
          },
          {
            "src": "<Parser.parse:implementation>",
            "dst": "<input:implementation>",
            "type": "CONTAINS"
          },
          {
            "src": "<Parser.parse:overload1>",
            "dst": "<string>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Parser.parse:overload2>",
            "dst": "<number>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Parser.parse:implementation>",
            "dst": "<string | number>",
            "type": "RETURNS_TYPE"
          },
          {
            "src": "<Parser.parse:implementation>",
            "dst": "<input:implementation>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Parser.parse>",
            "dst": "<Parser.parse:overload1>",
            "type": "HAS_OVERLOAD"
          },
          {
            "src": "<Parser.parse>",
            "dst": "<Parser.parse:overload2>",
            "type": "HAS_OVERLOAD"
          },
          {
            "src": "<Parser.parse>",
            "dst": "<Parser.parse:implementation>",
            "type": "IMPLEMENTS_OVERLOAD",
            "metadata": {
              "originalType": "HAS_IMPLEMENTATION"
            }
          },
          {
            "src": "<input:overload1>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<input:overload2>",
            "dst": "<number>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<input:implementation>",
            "dst": "<string | number>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-ambient-class-enum",
      "category": "ts-specific",
      "code": "declare class ExternalLib {\n  constructor(config: object);\n  process(): Promise<void>;\n}\ndeclare enum Platform { Web, Mobile, Desktop }\n\n// --- Decorator metadata (Stage 3 + TS experimental) ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ExternalLib>",
          "metadata": {
            "ambient": true
          }
        },
        {
          "type": "METHOD",
          "id": "<ExternalLib.constructor>",
          "metadata": {
            "kind": "constructor",
            "ambient": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<config>",
          "metadata": {
            "type": "object"
          }
        },
        {
          "type": "METHOD",
          "id": "<ExternalLib.process>",
          "metadata": {
            "kind": "method",
            "ambient": true,
            "returnType": "Promise<void>"
          }
        },
        {
          "type": "ENUM",
          "id": "<Platform>",
          "metadata": {
            "ambient": true
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Platform.Web>"
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Platform.Mobile>"
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Platform.Desktop>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ExternalLib>",
            "type": "DECLARES"
          },
          {
            "src": "<ExternalLib>",
            "dst": "<ExternalLib.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<ExternalLib>",
            "dst": "<ExternalLib.process>",
            "type": "CONTAINS"
          },
          {
            "src": "<ExternalLib.constructor>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<Platform>",
            "type": "DECLARES"
          },
          {
            "src": "<Platform>",
            "dst": "<Platform.Web>",
            "type": "CONTAINS"
          },
          {
            "src": "<Platform>",
            "dst": "<Platform.Mobile>",
            "type": "CONTAINS"
          },
          {
            "src": "<Platform>",
            "dst": "<Platform.Desktop>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-unique-symbol",
      "category": "ts-specific",
      "code": "declare const uniqueSym: unique symbol;\ntype WithSymKey = { [uniqueSym]: string };",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<uniqueSym>",
          "metadata": {
            "kind": "const",
            "declared": true,
            "tsType": "unique symbol"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<unique symbol>",
          "metadata": {
            "tsKind": "unique symbol",
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<WithSymKey>",
          "metadata": {
            "tsKind": "type alias",
            "originalType": "TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<WithSymKey:object>",
          "metadata": {
            "tsKind": "object type",
            "originalType": "TYPE"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<WithSymKey:[uniqueSym]>",
          "metadata": {
            "computed": true,
            "tsType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<uniqueSym>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<WithSymKey>",
            "type": "DECLARES"
          },
          {
            "src": "<WithSymKey:object>",
            "dst": "<WithSymKey:[uniqueSym]>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<WithSymKey>",
            "dst": "<WithSymKey:object>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<uniqueSym>",
            "dst": "<unique symbol>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<WithSymKey:[uniqueSym]>",
            "dst": "<uniqueSym>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "USES_AS_KEY"
            }
          },
          {
            "src": "<WithSymKey:[uniqueSym]>",
            "dst": "<string>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-enum-namespace-merge",
      "category": "ts-specific",
      "code": "enum Color { Red, Green, Blue }\nnamespace Color {\n  export function parse(s: string): Color { return Color[s as keyof typeof Color]; }\n}",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<Color>",
          "metadata": {
            "kind": "enum"
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Color.Red>",
          "metadata": {
            "value": 0
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Color.Green>",
          "metadata": {
            "value": 1
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<Color.Blue>",
          "metadata": {
            "value": 2
          }
        },
        {
          "type": "NAMESPACE",
          "id": "<Color:namespace>",
          "metadata": {
            "kind": "namespace"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Color.parse>",
          "metadata": {
            "exported": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<s>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<Color[s]>",
          "metadata": {
            "computed": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<s as keyof typeof Color>",
          "metadata": {
            "originalType": "TYPE_ASSERTION"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Color>",
            "type": "DECLARES"
          },
          {
            "src": "<Color>",
            "dst": "<Color.Red>",
            "type": "CONTAINS"
          },
          {
            "src": "<Color>",
            "dst": "<Color.Green>",
            "type": "CONTAINS"
          },
          {
            "src": "<Color>",
            "dst": "<Color.Blue>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<Color:namespace>",
            "type": "DECLARES"
          },
          {
            "src": "<Color:namespace>",
            "dst": "<Color.parse>",
            "type": "CONTAINS"
          },
          {
            "src": "<Color.parse>",
            "dst": "<s>",
            "type": "CONTAINS"
          },
          {
            "src": "<Color.parse>",
            "dst": "<Color[s]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Color[s]>",
            "dst": "<Color>",
            "type": "READS_FROM"
          },
          {
            "src": "<Color[s]>",
            "dst": "<s as keyof typeof Color>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "USES_INDEX"
            }
          },
          {
            "src": "<s as keyof typeof Color>",
            "dst": "<s>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "CASTS_FROM"
            }
          },
          {
            "src": "<Color:namespace>",
            "dst": "<Color>",
            "type": "MERGES_WITH"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-parameter-decorators",
      "category": "ts-specific",
      "code": "// Common in NestJS/Angular  parameter decorators\nfunction Inject(token: string) {\n  return function(target: any, propertyKey: string | symbol, parameterIndex: number) {};\n}\n\nclass AppController {\n  constructor(@Inject('DB') private db: any) {}\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<Inject>",
          "metadata": {
            "decoratorFactory": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<token>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<Inject:decorator>",
          "metadata": {
            "parameterDecorator": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<target>"
        },
        {
          "type": "PARAMETER",
          "id": "<propertyKey>"
        },
        {
          "type": "PARAMETER",
          "id": "<parameterIndex>"
        },
        {
          "type": "CLASS",
          "id": "<AppController>"
        },
        {
          "type": "METHOD",
          "id": "<AppController.constructor>",
          "metadata": {
            "kind": "constructor"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<db>",
          "metadata": {
            "visibility": "private",
            "type": "any"
          }
        },
        {
          "type": "DECORATOR",
          "id": "<@Inject('DB')>",
          "metadata": {
            "decoratorName": "Inject",
            "target": "parameter",
            "originalType": "DECORATOR_APPLICATION"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'DB'>",
          "metadata": {
            "value": "DB",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Inject>",
            "type": "DECLARES"
          },
          {
            "src": "<Inject>",
            "dst": "<token>",
            "type": "CONTAINS"
          },
          {
            "src": "<Inject>",
            "dst": "<Inject:decorator>",
            "type": "RETURNS"
          },
          {
            "src": "<Inject:decorator>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<Inject:decorator>",
            "dst": "<propertyKey>",
            "type": "CONTAINS"
          },
          {
            "src": "<Inject:decorator>",
            "dst": "<parameterIndex>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<AppController>",
            "type": "DECLARES"
          },
          {
            "src": "<AppController>",
            "dst": "<AppController.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<AppController.constructor>",
            "dst": "<db>",
            "type": "CONTAINS"
          },
          {
            "src": "<@Inject('DB')>",
            "dst": "<'DB'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<db>",
            "dst": "<@Inject('DB')>",
            "type": "DECORATED_BY"
          },
          {
            "src": "<@Inject('DB')>",
            "dst": "<Inject:decorator>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "EVALUATES_TO"
            }
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<@Inject('DB')>",
            "dst": "<Inject>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-decorator-metadata",
      "category": "ts-specific",
      "code": "function track(constructor: Function, context: ClassDecoratorContext) {\n  context.metadata.tracked = true;\n}\n\nfunction log(target: Function, context: ClassMethodDecoratorContext) {\n  context.addInitializer(function() {\n    console.log(`${String(context.name)} initialized`);\n  });\n}\n\n@track\nclass TrackedService {\n  @log\n  process(data: string) { return data; }\n}\n// const meta = TrackedService[Symbol.metadata]; // { tracked: true }",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<track>",
          "metadata": {
            "decorator": true,
            "decoratorType": "class"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<constructor>",
          "metadata": {
            "type": "Function"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<context>",
          "metadata": {
            "type": "ClassDecoratorContext"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<context.metadata.tracked>",
          "metadata": {
            "objectName": "context.metadata"
          }
        },
        {
          "type": "LITERAL",
          "id": "<true>",
          "metadata": {
            "value": true,
            "literalType": "boolean"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<log>",
          "metadata": {
            "decorator": true,
            "decoratorType": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<target>",
          "metadata": {
            "type": "Function"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<context2>",
          "metadata": {
            "type": "ClassMethodDecoratorContext"
          }
        },
        {
          "type": "CALL",
          "id": "<context.addInitializer(...)>",
          "metadata": {
            "callee": "context.addInitializer"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<addInitializer-callback>",
          "metadata": {
            "anonymous": true
          }
        },
        {
          "type": "CALL",
          "id": "<console.log(...)>",
          "metadata": {
            "callee": "console.log"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<String(context.name)>",
          "metadata": {
            "template": true
          }
        },
        {
          "type": "CLASS",
          "id": "<TrackedService>",
          "metadata": {
            "decorated": true
          }
        },
        {
          "type": "DECORATOR",
          "id": "<@track>",
          "metadata": {
            "decoratorName": "track",
            "originalType": "DECORATOR_APPLICATION"
          }
        },
        {
          "type": "METHOD",
          "id": "<TrackedService.process>",
          "metadata": {
            "kind": "method",
            "decorated": true
          }
        },
        {
          "type": "DECORATOR",
          "id": "<@log>",
          "metadata": {
            "decoratorName": "log",
            "originalType": "DECORATOR_APPLICATION"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>",
          "metadata": {
            "type": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<track>",
            "type": "DECLARES"
          },
          {
            "src": "<track>",
            "dst": "<constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<track>",
            "dst": "<context>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<log>",
            "type": "DECLARES"
          },
          {
            "src": "<log>",
            "dst": "<target>",
            "type": "CONTAINS"
          },
          {
            "src": "<log>",
            "dst": "<context2>",
            "type": "CONTAINS"
          },
          {
            "src": "<log>",
            "dst": "<context.addInitializer(...)>",
            "type": "CONTAINS"
          },
          {
            "src": "<context.addInitializer(...)>",
            "dst": "<addInitializer-callback>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<addInitializer-callback>",
            "dst": "<console.log(...)>",
            "type": "CONTAINS"
          },
          {
            "src": "<console.log(...)>",
            "dst": "<String(context.name)>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<module>",
            "dst": "<TrackedService>",
            "type": "DECLARES"
          },
          {
            "src": "<@track>",
            "dst": "<track>",
            "type": "DECORATED_BY",
            "metadata": {
              "originalType": "APPLIES_DECORATOR"
            }
          },
          {
            "src": "<TrackedService>",
            "dst": "<@track>",
            "type": "DECORATED_BY"
          },
          {
            "src": "<TrackedService>",
            "dst": "<TrackedService.process>",
            "type": "CONTAINS"
          },
          {
            "src": "<@log>",
            "dst": "<log>",
            "type": "DECORATED_BY",
            "metadata": {
              "originalType": "APPLIES_DECORATOR"
            }
          },
          {
            "src": "<TrackedService.process>",
            "dst": "<@log>",
            "type": "DECORATED_BY"
          },
          {
            "src": "<TrackedService.process>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<TrackedService.process>",
            "dst": "<data>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<track>",
            "dst": "<context.metadata.tracked>",
            "type": "WRITES_TO"
          },
          {
            "src": "<context.metadata.tracked>",
            "dst": "<true>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": []
      }
    },
    {
      "constructId": "ts-specific::ts-constructor-overloads",
      "category": "ts-specific",
      "code": "class Point {\n  x: number;\n  y: number;\n  constructor(x: number, y: number);\n  constructor(coords: [number, number]);\n  constructor(xOrCoords: number | [number, number], y?: number) {\n    if (Array.isArray(xOrCoords)) {\n      this.x = xOrCoords[0];\n      this.y = xOrCoords[1];\n    } else {\n      this.x = xOrCoords;\n      this.y = y!;\n    }\n  }\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<Point>"
        },
        {
          "type": "PROPERTY",
          "id": "<Point.x>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<Point.y>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Point.constructor:overload1>",
          "metadata": {
            "kind": "constructor",
            "overloadIndex": 0,
            "originalType": "METHOD_OVERLOAD"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<x:overload1>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<y:overload1>",
          "metadata": {
            "type": "number"
          }
        },
        {
          "type": "METHOD",
          "id": "<Point.constructor:overload2>",
          "metadata": {
            "kind": "constructor",
            "overloadIndex": 1,
            "originalType": "METHOD_OVERLOAD"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<coords:overload2>",
          "metadata": {
            "type": "[number, number]"
          }
        },
        {
          "type": "METHOD",
          "id": "<Point.constructor>",
          "metadata": {
            "kind": "constructor",
            "implementation": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<xOrCoords>",
          "metadata": {
            "type": "number | [number, number]"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<y>",
          "metadata": {
            "type": "number",
            "optional": true
          }
        },
        {
          "type": "BRANCH",
          "id": "<Array.isArray(xOrCoords)>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.x:branch1>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<xOrCoords[0]>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.y:branch1>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<xOrCoords[1]>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.x:branch2>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<this.y:branch2>",
          "metadata": {
            "objectName": "this"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<y!>",
          "metadata": {
            "operator": "!"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Point>",
            "type": "DECLARES"
          },
          {
            "src": "<Point>",
            "dst": "<Point.x>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point>",
            "dst": "<Point.y>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point>",
            "dst": "<Point.constructor:overload1>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point>",
            "dst": "<Point.constructor:overload2>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point>",
            "dst": "<Point.constructor>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point.constructor:overload1>",
            "dst": "<x:overload1>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point.constructor:overload1>",
            "dst": "<y:overload1>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point.constructor:overload2>",
            "dst": "<coords:overload2>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point.constructor>",
            "dst": "<xOrCoords>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point.constructor>",
            "dst": "<y>",
            "type": "CONTAINS"
          },
          {
            "src": "<Point.constructor>",
            "dst": "<Array.isArray(xOrCoords)>",
            "type": "CONTAINS"
          },
          {
            "src": "<Array.isArray(xOrCoords)>",
            "dst": "<this.x:branch1>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<Array.isArray(xOrCoords)>",
            "dst": "<this.y:branch1>",
            "type": "HAS_CONSEQUENT"
          }
        ],
        "postFile": [
          {
            "src": "<Array.isArray(xOrCoords)>",
            "dst": "<this.x:branch2>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<Array.isArray(xOrCoords)>",
            "dst": "<this.y:branch2>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<this.x:branch1>",
            "dst": "<xOrCoords[0]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.y:branch1>",
            "dst": "<xOrCoords[1]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.x:branch2>",
            "dst": "<xOrCoords>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<this.y:branch2>",
            "dst": "<y!>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Point.constructor>",
            "dst": "<Point.constructor:overload1>",
            "type": "IMPLEMENTS_OVERLOAD"
          },
          {
            "src": "<Point.constructor>",
            "dst": "<Point.constructor:overload2>",
            "type": "IMPLEMENTS_OVERLOAD"
          },
          {
            "src": "<Array.isArray(xOrCoords)>",
            "dst": "<xOrCoords>",
            "type": "READS_FROM"
          },
          {
            "src": "<xOrCoords[0]>",
            "dst": "<xOrCoords>",
            "type": "READS_FROM"
          },
          {
            "src": "<xOrCoords[1]>",
            "dst": "<xOrCoords>",
            "type": "READS_FROM"
          },
          {
            "src": "<y!>",
            "dst": "<y>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-mapped-type-as-clause",
      "category": "ts-specific",
      "code": "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\ntype RemoveKind<T> = {\n  [K in keyof T as Exclude<K, 'kind'>]: T[K]\n};",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Getters>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Getters:mapped>",
          "metadata": {
            "keyMapping": true,
            "originalType": "MAPPED_TYPE"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K>",
          "metadata": {
            "mappedTypeKey": true,
            "originalType": "TYPE_VARIABLE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<get${Capitalize<string & K>}>",
          "metadata": {
            "template": "get${Capitalize<string & K>}",
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<() => T[K]>",
          "metadata": {
            "originalType": "FUNCTION_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<RemoveKind>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T2>",
          "metadata": {
            "aliasFor": "T"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<RemoveKind:mapped>",
          "metadata": {
            "keyMapping": true,
            "originalType": "MAPPED_TYPE"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K2>",
          "metadata": {
            "mappedTypeKey": true,
            "aliasFor": "K",
            "originalType": "TYPE_VARIABLE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Exclude<K, 'kind'>>",
          "metadata": {
            "originalType": "UTILITY_TYPE"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'kind'>",
          "metadata": {
            "value": "kind",
            "literalType": "string"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Getters>",
            "type": "DECLARES"
          },
          {
            "src": "<Getters>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<Getters:mapped>",
            "dst": "<K>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<module>",
            "dst": "<RemoveKind>",
            "type": "DECLARES"
          },
          {
            "src": "<RemoveKind>",
            "dst": "<T2>",
            "type": "CONTAINS"
          },
          {
            "src": "<RemoveKind:mapped>",
            "dst": "<K2>",
            "type": "ITERATES_OVER"
          }
        ],
        "postFile": [
          {
            "src": "<Getters>",
            "dst": "<Getters:mapped>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<RemoveKind>",
            "dst": "<RemoveKind:mapped>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<Getters:mapped>",
            "dst": "<get${Capitalize<string & K>}>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_KEY_TO"
            }
          },
          {
            "src": "<Getters:mapped>",
            "dst": "<() => T[K]>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_VALUE_TO"
            }
          },
          {
            "src": "<get${Capitalize<string & K>}>",
            "dst": "<K>",
            "type": "READS_FROM"
          },
          {
            "src": "<() => T[K]>",
            "dst": "<T>",
            "type": "READS_FROM"
          },
          {
            "src": "<() => T[K]>",
            "dst": "<K>",
            "type": "READS_FROM"
          },
          {
            "src": "<RemoveKind:mapped>",
            "dst": "<Exclude<K, 'kind'>>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_KEY_TO"
            }
          },
          {
            "src": "<RemoveKind:mapped>",
            "dst": "<T2>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "MAPS_VALUE_TO"
            }
          },
          {
            "src": "<Exclude<K, 'kind'>>",
            "dst": "<K2>",
            "type": "READS_FROM"
          },
          {
            "src": "<Exclude<K, 'kind'>>",
            "dst": "<'kind'>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-this-type-guard",
      "category": "ts-specific",
      "code": "class FSNode {\n  isFile(): this is FSFileNode { return this instanceof FSFileNode; }\n  isDir(): this is FSDirNode { return this instanceof FSDirNode; }\n}\n\nclass FSFileNode extends FSNode {\n  content: string = '';\n}\n\nclass FSDirNode extends FSNode {\n  children: FSNode[] = [];\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<FSNode>"
        },
        {
          "type": "METHOD",
          "id": "<FSNode.isFile>",
          "metadata": {
            "kind": "method",
            "typeGuard": true,
            "returnType": "this is FSFileNode"
          }
        },
        {
          "type": "METHOD",
          "id": "<FSNode.isDir>",
          "metadata": {
            "kind": "method",
            "typeGuard": true,
            "returnType": "this is FSDirNode"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this instanceof FSFileNode>",
          "metadata": {
            "operator": "instanceof"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<this instanceof FSDirNode>",
          "metadata": {
            "operator": "instanceof"
          }
        },
        {
          "type": "CLASS",
          "id": "<FSFileNode>"
        },
        {
          "type": "PROPERTY",
          "id": "<FSFileNode.content>",
          "metadata": {
            "type": "string",
            "initialValue": "''"
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        },
        {
          "type": "CLASS",
          "id": "<FSDirNode>"
        },
        {
          "type": "PROPERTY",
          "id": "<FSDirNode.children>",
          "metadata": {
            "type": "FSNode[]",
            "initialValue": "[]"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[]>",
          "metadata": {
            "value": "[]",
            "literalType": "array"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<FSNode>",
            "type": "DECLARES"
          },
          {
            "src": "<FSNode>",
            "dst": "<FSNode.isFile>",
            "type": "CONTAINS"
          },
          {
            "src": "<FSNode>",
            "dst": "<FSNode.isDir>",
            "type": "CONTAINS"
          },
          {
            "src": "<FSNode.isFile>",
            "dst": "<this instanceof FSFileNode>",
            "type": "RETURNS"
          },
          {
            "src": "<FSNode.isDir>",
            "dst": "<this instanceof FSDirNode>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<FSFileNode>",
            "type": "DECLARES"
          },
          {
            "src": "<FSFileNode>",
            "dst": "<FSFileNode.content>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<FSDirNode>",
            "type": "DECLARES"
          },
          {
            "src": "<FSDirNode>",
            "dst": "<FSDirNode.children>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<FSFileNode.content>",
            "dst": "<''>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<FSDirNode.children>",
            "dst": "<[]>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<this instanceof FSFileNode>",
            "dst": "<FSFileNode>",
            "type": "READS_FROM"
          },
          {
            "src": "<this instanceof FSDirNode>",
            "dst": "<FSDirNode>",
            "type": "READS_FROM"
          },
          {
            "src": "<FSFileNode>",
            "dst": "<FSNode>",
            "type": "EXTENDS"
          },
          {
            "src": "<FSDirNode>",
            "dst": "<FSNode>",
            "type": "EXTENDS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-distributive-conditional",
      "category": "ts-specific",
      "code": "type ToArray<T> = T extends any ? T[] : never;\ntype DistResult = ToArray<string | number>; // string[] | number[]\n\ntype ToArrayND<T> = [T] extends [any] ? T[] : never;\ntype NonDistResult = ToArrayND<string | number>; // (string | number)[]",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<ToArray>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "scope": "ToArray"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends any ? T[] : never>",
          "metadata": {
            "distributive": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T extends any>",
          "metadata": {
            "constraintType": "any",
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T[]>",
          "metadata": {
            "elementType": "T",
            "originalType": "ARRAY_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never>",
          "metadata": {
            "value": "never"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<DistResult>",
          "metadata": {
            "generic": false
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<ToArray<string | number>>",
          "metadata": {
            "typeFunction": "ToArray",
            "originalType": "TYPE_APPLICATION"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<string | number>",
          "metadata": {
            "memberCount": 2,
            "originalType": "UNION_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string>",
          "metadata": {
            "primitive": "string",
            "originalType": "PRIMITIVE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number>",
          "metadata": {
            "primitive": "number",
            "originalType": "PRIMITIVE_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ToArrayND>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T_nd>",
          "metadata": {
            "scope": "ToArrayND"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<[T] extends [any] ? T[] : never>",
          "metadata": {
            "distributive": false
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<[T] extends [any]>",
          "metadata": {
            "constraintType": "[any]",
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[T]>",
          "metadata": {
            "elementCount": 1,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[any]>",
          "metadata": {
            "elementCount": 1,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T[]_nd>",
          "metadata": {
            "elementType": "T",
            "originalType": "ARRAY_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never_nd>",
          "metadata": {
            "value": "never"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<NonDistResult>",
          "metadata": {
            "generic": false
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<ToArrayND<string | number>>",
          "metadata": {
            "typeFunction": "ToArrayND",
            "originalType": "TYPE_APPLICATION"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<string | number_nd>",
          "metadata": {
            "memberCount": 2,
            "originalType": "UNION_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ToArray>",
            "type": "DECLARES"
          },
          {
            "src": "<ToArray>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends any ? T[] : never>",
            "dst": "<T extends any>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<T extends any ? T[] : never>",
            "dst": "<T[]>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<T extends any>",
            "dst": "<T>",
            "type": "CONSTRAINED_BY",
            "metadata": {
              "originalType": "CONSTRAINS"
            }
          },
          {
            "src": "<T[]>",
            "dst": "<T>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "ELEMENT_TYPE"
            }
          },
          {
            "src": "<module>",
            "dst": "<DistResult>",
            "type": "DECLARES"
          },
          {
            "src": "<string | number>",
            "dst": "<string>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<string | number>",
            "dst": "<number>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<module>",
            "dst": "<ToArrayND>",
            "type": "DECLARES"
          },
          {
            "src": "<ToArrayND>",
            "dst": "<T_nd>",
            "type": "CONTAINS"
          },
          {
            "src": "<[T] extends [any] ? T[] : never>",
            "dst": "<[T] extends [any]>",
            "type": "HAS_CONDITION"
          },
          {
            "src": "<[T] extends [any] ? T[] : never>",
            "dst": "<T[]_nd>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<[T] extends [any]>",
            "dst": "<[T]>",
            "type": "CONSTRAINED_BY",
            "metadata": {
              "originalType": "CONSTRAINS"
            }
          },
          {
            "src": "<[T] extends [any]>",
            "dst": "<[any]>",
            "type": "CONSTRAINED_BY",
            "metadata": {
              "originalType": "CONSTRAINT_TARGET"
            }
          },
          {
            "src": "<[T]>",
            "dst": "<T_nd>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "TUPLE_ELEMENT"
            }
          },
          {
            "src": "<T[]_nd>",
            "dst": "<T_nd>",
            "type": "CONTAINS",
            "metadata": {
              "originalType": "ELEMENT_TYPE"
            }
          },
          {
            "src": "<module>",
            "dst": "<NonDistResult>",
            "type": "DECLARES"
          },
          {
            "src": "<string | number_nd>",
            "dst": "<string>",
            "type": "UNION_MEMBER"
          },
          {
            "src": "<string | number_nd>",
            "dst": "<number>",
            "type": "UNION_MEMBER"
          }
        ],
        "postFile": [
          {
            "src": "<T extends any ? T[] : never>",
            "dst": "<never>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<[T] extends [any] ? T[] : never>",
            "dst": "<never_nd>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<ToArray>",
            "dst": "<T extends any ? T[] : never>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<DistResult>",
            "dst": "<ToArray<string | number>>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<ToArray<string | number>>",
            "dst": "<ToArray>",
            "type": "CALLS",
            "metadata": {
              "originalType": "INSTANTIATES"
            }
          },
          {
            "src": "<ToArray<string | number>>",
            "dst": "<string | number>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPE_ARGUMENT"
            }
          },
          {
            "src": "<ToArrayND>",
            "dst": "<[T] extends [any] ? T[] : never>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<NonDistResult>",
            "dst": "<ToArrayND<string | number>>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<ToArrayND<string | number>>",
            "dst": "<ToArrayND>",
            "type": "CALLS",
            "metadata": {
              "originalType": "INSTANTIATES"
            }
          },
          {
            "src": "<ToArrayND<string | number>>",
            "dst": "<string | number_nd>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPE_ARGUMENT"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-function-type-intersection",
      "category": "ts-specific",
      "code": "type StringHandler = (input: string) => string;\ntype NumberHandler = (input: number) => number;\ntype BothHandler = StringHandler & NumberHandler;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<StringHandler>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<StringHandler:fn-type>",
          "metadata": {
            "originalType": "FUNCTION_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<StringHandler:input>",
          "metadata": {
            "name": "input",
            "originalType": "PARAMETER_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string1>",
          "metadata": {
            "typeName": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<string2>",
          "metadata": {
            "typeName": "string"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<NumberHandler>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<NumberHandler:fn-type>",
          "metadata": {
            "originalType": "FUNCTION_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<NumberHandler:input>",
          "metadata": {
            "name": "input",
            "originalType": "PARAMETER_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number1>",
          "metadata": {
            "typeName": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<number2>",
          "metadata": {
            "typeName": "number"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<BothHandler>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<StringHandler & NumberHandler>",
          "metadata": {
            "operator": "&",
            "originalType": "INTERSECTION_TYPE"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<StringHandler>",
            "type": "DECLARES"
          },
          {
            "src": "<StringHandler:fn-type>",
            "dst": "<StringHandler:input>",
            "type": "CONTAINS"
          },
          {
            "src": "<StringHandler:fn-type>",
            "dst": "<string2>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<NumberHandler>",
            "type": "DECLARES"
          },
          {
            "src": "<NumberHandler:fn-type>",
            "dst": "<NumberHandler:input>",
            "type": "CONTAINS"
          },
          {
            "src": "<NumberHandler:fn-type>",
            "dst": "<number2>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<BothHandler>",
            "type": "DECLARES"
          },
          {
            "src": "<StringHandler & NumberHandler>",
            "dst": "<StringHandler>",
            "type": "INTERSECTS_WITH"
          },
          {
            "src": "<StringHandler & NumberHandler>",
            "dst": "<NumberHandler>",
            "type": "INTERSECTS_WITH"
          }
        ],
        "postFile": [
          {
            "src": "<StringHandler>",
            "dst": "<StringHandler:fn-type>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<NumberHandler>",
            "dst": "<NumberHandler:fn-type>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<BothHandler>",
            "dst": "<StringHandler & NumberHandler>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<StringHandler:input>",
            "dst": "<string1>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<NumberHandler:input>",
            "dst": "<number1>",
            "type": "HAS_TYPE"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-variadic-tuple",
      "category": "ts-specific",
      "code": "type Concat<A extends unknown[], B extends unknown[]> = [...A, ...B];\ntype HeadOf<T extends unknown[]> = T extends [infer H, ...unknown[]] ? H : never;\ntype TailOf<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;\ntype LastOf<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<Concat>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<A>",
          "metadata": {
            "constraint": "unknown[]"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<B>",
          "metadata": {
            "constraint": "unknown[]"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[...A, ...B]>",
          "metadata": {
            "variadic": true,
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...A>",
          "metadata": {
            "originalType": "SPREAD_ELEMENT"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<...B>",
          "metadata": {
            "originalType": "SPREAD_ELEMENT"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<HeadOf>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "constraint": "unknown[]"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends [infer H, ...unknown[]] ? H : never>"
        },
        {
          "type": "INFER_TYPE",
          "id": "<H>",
          "metadata": {
            "originalType": "INFERRED_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<TailOf>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T:TailOf>",
          "metadata": {
            "constraint": "unknown[]"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends [unknown, ...infer R] ? R : never>"
        },
        {
          "type": "INFER_TYPE",
          "id": "<R>",
          "metadata": {
            "originalType": "INFERRED_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never:TailOf>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<LastOf>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T:LastOf>",
          "metadata": {
            "constraint": "unknown[]"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<T extends [...unknown[], infer L] ? L : never>"
        },
        {
          "type": "INFER_TYPE",
          "id": "<L>",
          "metadata": {
            "originalType": "INFERRED_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never:LastOf>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<Concat>",
            "type": "DECLARES"
          },
          {
            "src": "<Concat>",
            "dst": "<A>",
            "type": "CONTAINS"
          },
          {
            "src": "<Concat>",
            "dst": "<B>",
            "type": "CONTAINS"
          },
          {
            "src": "<[...A, ...B]>",
            "dst": "<...A>",
            "type": "CONTAINS"
          },
          {
            "src": "<[...A, ...B]>",
            "dst": "<...B>",
            "type": "CONTAINS"
          },
          {
            "src": "<...A>",
            "dst": "<A>",
            "type": "SPREADS_FROM",
            "metadata": {
              "originalType": "SPREADS"
            }
          },
          {
            "src": "<...B>",
            "dst": "<B>",
            "type": "SPREADS_FROM",
            "metadata": {
              "originalType": "SPREADS"
            }
          },
          {
            "src": "<module>",
            "dst": "<HeadOf>",
            "type": "DECLARES"
          },
          {
            "src": "<HeadOf>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends [infer H, ...unknown[]] ? H : never>",
            "dst": "<T>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "TESTS"
            }
          },
          {
            "src": "<T extends [infer H, ...unknown[]] ? H : never>",
            "dst": "<H>",
            "type": "INFERS"
          },
          {
            "src": "<T extends [infer H, ...unknown[]] ? H : never>",
            "dst": "<H>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "RETURNS_TRUE"
            }
          },
          {
            "src": "<T extends [infer H, ...unknown[]] ? H : never>",
            "dst": "<never>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "RETURNS_FALSE"
            }
          },
          {
            "src": "<module>",
            "dst": "<TailOf>",
            "type": "DECLARES"
          },
          {
            "src": "<TailOf>",
            "dst": "<T:TailOf>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends [unknown, ...infer R] ? R : never>",
            "dst": "<T:TailOf>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "TESTS"
            }
          },
          {
            "src": "<T extends [unknown, ...infer R] ? R : never>",
            "dst": "<R>",
            "type": "INFERS"
          },
          {
            "src": "<T extends [unknown, ...infer R] ? R : never>",
            "dst": "<R>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "RETURNS_TRUE"
            }
          },
          {
            "src": "<T extends [unknown, ...infer R] ? R : never>",
            "dst": "<never:TailOf>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "RETURNS_FALSE"
            }
          },
          {
            "src": "<module>",
            "dst": "<LastOf>",
            "type": "DECLARES"
          },
          {
            "src": "<LastOf>",
            "dst": "<T:LastOf>",
            "type": "CONTAINS"
          },
          {
            "src": "<T extends [...unknown[], infer L] ? L : never>",
            "dst": "<T:LastOf>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "TESTS"
            }
          },
          {
            "src": "<T extends [...unknown[], infer L] ? L : never>",
            "dst": "<L>",
            "type": "INFERS"
          },
          {
            "src": "<T extends [...unknown[], infer L] ? L : never>",
            "dst": "<L>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "RETURNS_TRUE"
            }
          },
          {
            "src": "<T extends [...unknown[], infer L] ? L : never>",
            "dst": "<never:LastOf>",
            "type": "RETURNS",
            "metadata": {
              "originalType": "RETURNS_FALSE"
            }
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<Concat>",
            "dst": "<[...A, ...B]>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<HeadOf>",
            "dst": "<T extends [infer H, ...unknown[]] ? H : never>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<TailOf>",
            "dst": "<T extends [unknown, ...infer R] ? R : never>",
            "type": "RESOLVES_TO"
          },
          {
            "src": "<LastOf>",
            "dst": "<T extends [...unknown[], infer L] ? L : never>",
            "type": "RESOLVES_TO"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-import-type-inline",
      "category": "ts-specific",
      "code": "// Type-level import()  resolves types without runtime import\ntype InlineImported = import('./modules-helpers.js').default;\n// In function signatures: function handle(req: import('express').Request): void {}\n\n// --- TypeScript using with type annotations ---",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<InlineImported>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "IMPORT",
          "id": "<import('./modules-helpers.js')>",
          "metadata": {
            "source": "./modules-helpers.js",
            "importKind": "type-only",
            "originalType": "TYPE_IMPORT"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<import('./modules-helpers.js').default>",
          "metadata": {
            "property": "default",
            "originalType": "TYPE_ACCESS"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<InlineImported>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<InlineImported>",
            "dst": "<import('./modules-helpers.js').default>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import('./modules-helpers.js').default>",
            "dst": "<import('./modules-helpers.js')>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "ACCESSES_PROPERTY"
            }
          },
          {
            "src": "<import('./modules-helpers.js')>",
            "dst": "<./modules-helpers.js>",
            "type": "IMPORTS_FROM",
            "metadata": {
              "originalType": "IMPORTS_TYPE_FROM"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-typeof-class",
      "category": "ts-specific",
      "code": "class ExampleForTypeof {\n  static create() { return new ExampleForTypeof(); }\n  method() { return 1; }\n}\n\ntype ExampleInstance = ExampleForTypeof;            // instance type  has method()\ntype ExampleConstructor = typeof ExampleForTypeof;  // constructor type  has create()\n\nfunction classFactory(Cls: typeof ExampleForTypeof): ExampleForTypeof {\n  return Cls.create();\n}",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<ExampleForTypeof>"
        },
        {
          "type": "METHOD",
          "id": "<ExampleForTypeof.create>",
          "metadata": {
            "kind": "static"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<new ExampleForTypeof()>",
          "metadata": {
            "operator": "new"
          }
        },
        {
          "type": "METHOD",
          "id": "<ExampleForTypeof.method>",
          "metadata": {
            "kind": "instance"
          }
        },
        {
          "type": "LITERAL",
          "id": "<1>",
          "metadata": {
            "value": 1,
            "literalType": "number"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ExampleInstance>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<ExampleForTypeof:instance-type>"
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ExampleConstructor>",
          "metadata": {
            "kind": "type"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<typeof ExampleForTypeof>",
          "metadata": {
            "originalType": "TYPEOF_TYPE"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<classFactory>",
          "metadata": {
            "async": false,
            "generator": false
          }
        },
        {
          "type": "PARAMETER",
          "id": "<Cls>",
          "metadata": {
            "typeAnnotated": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<typeof ExampleForTypeof:param-type>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<ExampleForTypeof:return-type>"
        },
        {
          "type": "CALL",
          "id": "<Cls.create()>",
          "metadata": {
            "callee": "Cls.create"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<ExampleForTypeof>",
            "type": "DECLARES"
          },
          {
            "src": "<ExampleForTypeof>",
            "dst": "<ExampleForTypeof.create>",
            "type": "CONTAINS"
          },
          {
            "src": "<ExampleForTypeof>",
            "dst": "<ExampleForTypeof.method>",
            "type": "CONTAINS"
          },
          {
            "src": "<ExampleForTypeof.create>",
            "dst": "<new ExampleForTypeof()>",
            "type": "RETURNS"
          },
          {
            "src": "<ExampleForTypeof.method>",
            "dst": "<1>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<ExampleInstance>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<ExampleConstructor>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<classFactory>",
            "type": "DECLARES"
          },
          {
            "src": "<classFactory>",
            "dst": "<Cls>",
            "type": "CONTAINS"
          },
          {
            "src": "<classFactory>",
            "dst": "<ExampleForTypeof:return-type>",
            "type": "RETURNS_TYPE",
            "metadata": {
              "originalType": "HAS_RETURN_TYPE"
            }
          },
          {
            "src": "<classFactory>",
            "dst": "<Cls.create()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<new ExampleForTypeof()>",
            "dst": "<ExampleForTypeof>",
            "type": "CALLS",
            "metadata": {
              "originalType": "INSTANTIATES"
            }
          },
          {
            "src": "<ExampleInstance>",
            "dst": "<ExampleForTypeof:instance-type>",
            "type": "ALIASES"
          },
          {
            "src": "<ExampleForTypeof:instance-type>",
            "dst": "<ExampleForTypeof>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "INSTANCE_TYPE_OF"
            }
          },
          {
            "src": "<ExampleConstructor>",
            "dst": "<typeof ExampleForTypeof>",
            "type": "ALIASES"
          },
          {
            "src": "<typeof ExampleForTypeof>",
            "dst": "<ExampleForTypeof>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "CONSTRUCTOR_TYPE_OF"
            }
          },
          {
            "src": "<Cls>",
            "dst": "<typeof ExampleForTypeof:param-type>",
            "type": "HAS_TYPE"
          },
          {
            "src": "<typeof ExampleForTypeof:param-type>",
            "dst": "<ExampleForTypeof>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "CONSTRUCTOR_TYPE_OF"
            }
          },
          {
            "src": "<ExampleForTypeof:return-type>",
            "dst": "<ExampleForTypeof>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "INSTANCE_TYPE_OF"
            }
          },
          {
            "src": "<Cls.create()>",
            "dst": "<Cls>",
            "type": "CALLS_ON"
          },
          {
            "src": "<Cls.create()>",
            "dst": "<ExampleForTypeof.create>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-enum-reverse-mapping",
      "category": "ts-specific",
      "code": "enum HttpStatus {\n  OK = 200,\n  NotFound = 404,\n  ServerError = 500,\n}\nconst statusName = HttpStatus[200];           // 'OK'  reverse mapping\nconst statusCode = HttpStatus.OK;             // 200  forward mapping\n// String enums do NOT have reverse mapping",
      "expectedNodes": [
        {
          "type": "ENUM",
          "id": "<HttpStatus>",
          "metadata": {
            "hasReverseMappings": true
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<HttpStatus.OK>",
          "metadata": {
            "key": "OK",
            "value": 200
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<HttpStatus.NotFound>",
          "metadata": {
            "key": "NotFound",
            "value": 404
          }
        },
        {
          "type": "ENUM_MEMBER",
          "id": "<HttpStatus.ServerError>",
          "metadata": {
            "key": "ServerError",
            "value": 500
          }
        },
        {
          "type": "LITERAL",
          "id": "<200>",
          "metadata": {
            "value": 200,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<404>",
          "metadata": {
            "value": 404,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<500>",
          "metadata": {
            "value": 500,
            "literalType": "number"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<statusName>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<HttpStatus[200]>",
          "metadata": {
            "accessType": "computed",
            "isReverseMapping": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<statusCode>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<HttpStatus.OK>",
          "metadata": {
            "accessType": "member",
            "isForwardMapping": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<HttpStatus>",
            "type": "DECLARES"
          },
          {
            "src": "<HttpStatus>",
            "dst": "<HttpStatus.OK>",
            "type": "CONTAINS"
          },
          {
            "src": "<HttpStatus>",
            "dst": "<HttpStatus.NotFound>",
            "type": "CONTAINS"
          },
          {
            "src": "<HttpStatus>",
            "dst": "<HttpStatus.ServerError>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<statusName>",
            "type": "DECLARES"
          },
          {
            "src": "<module>",
            "dst": "<statusCode>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<HttpStatus.OK>",
            "dst": "<200>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<HttpStatus.NotFound>",
            "dst": "<404>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<HttpStatus.ServerError>",
            "dst": "<500>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<statusName>",
            "dst": "<HttpStatus[200]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<statusCode>",
            "dst": "<HttpStatus.OK>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<HttpStatus[200]>",
            "dst": "<HttpStatus>",
            "type": "READS_FROM"
          },
          {
            "src": "<HttpStatus[200]>",
            "dst": "<200>",
            "type": "READS_FROM",
            "metadata": {
              "originalType": "USES_KEY"
            }
          },
          {
            "src": "<HttpStatus.OK>",
            "dst": "<HttpStatus>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-generic-keyof-constraint",
      "category": "ts-specific",
      "code": "function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nfunction pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {\n  return items.map(item => item[key]);\n}",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<getProperty>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K>",
          "metadata": {
            "name": "K"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<keyof T>",
          "metadata": {
            "operator": "keyof",
            "target": "T",
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<obj>",
          "metadata": {
            "typeAnnotation": "T"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key>",
          "metadata": {
            "typeAnnotation": "K"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T[K]>",
          "metadata": {
            "indexedAccess": true,
            "object": "T",
            "key": "K",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<obj[key]>"
        },
        {
          "type": "FUNCTION",
          "id": "<pluck>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T2>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<K2>",
          "metadata": {
            "name": "K"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<keyof T2>",
          "metadata": {
            "operator": "keyof",
            "target": "T",
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<items>",
          "metadata": {
            "typeAnnotation": "T[]"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<key2>",
          "metadata": {
            "typeAnnotation": "K"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<T[K][]>",
          "metadata": {
            "arrayOf": "T[K]",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "CALL",
          "id": "<items.map(...)>",
          "metadata": {
            "method": "map"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<arrow-fn>",
          "metadata": {
            "arrowFunction": true
          }
        },
        {
          "type": "PARAMETER",
          "id": "<item>"
        },
        {
          "type": "PROPERTY_ACCESS",
          "id": "<item[key]>"
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<getProperty>",
            "type": "DECLARES"
          },
          {
            "src": "<getProperty>",
            "dst": "<T>",
            "type": "CONTAINS"
          },
          {
            "src": "<getProperty>",
            "dst": "<K>",
            "type": "CONTAINS"
          },
          {
            "src": "<K>",
            "dst": "<keyof T>",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<getProperty>",
            "dst": "<obj>",
            "type": "CONTAINS"
          },
          {
            "src": "<getProperty>",
            "dst": "<key>",
            "type": "CONTAINS"
          },
          {
            "src": "<getProperty>",
            "dst": "<T[K]>",
            "type": "RETURNS"
          },
          {
            "src": "<getProperty>",
            "dst": "<obj[key]>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<pluck>",
            "type": "DECLARES"
          },
          {
            "src": "<pluck>",
            "dst": "<T2>",
            "type": "CONTAINS"
          },
          {
            "src": "<pluck>",
            "dst": "<K2>",
            "type": "CONTAINS"
          },
          {
            "src": "<K2>",
            "dst": "<keyof T2>",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<pluck>",
            "dst": "<items>",
            "type": "CONTAINS"
          },
          {
            "src": "<pluck>",
            "dst": "<key2>",
            "type": "CONTAINS"
          },
          {
            "src": "<pluck>",
            "dst": "<T[K][]>",
            "type": "RETURNS"
          },
          {
            "src": "<pluck>",
            "dst": "<items.map(...)>",
            "type": "RETURNS"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<arrow-fn>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<arrow-fn>",
            "dst": "<item>",
            "type": "CONTAINS"
          },
          {
            "src": "<arrow-fn>",
            "dst": "<item[key]>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<keyof T>",
            "dst": "<T>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<obj>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          },
          {
            "src": "<key>",
            "dst": "<K>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          },
          {
            "src": "<T[K]>",
            "dst": "<T>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<T[K]>",
            "dst": "<K>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<obj[key]>",
            "dst": "<obj>",
            "type": "READS_FROM"
          },
          {
            "src": "<obj[key]>",
            "dst": "<key>",
            "type": "READS_FROM"
          },
          {
            "src": "<keyof T2>",
            "dst": "<T2>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<items>",
            "dst": "<T2>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          },
          {
            "src": "<key2>",
            "dst": "<K2>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "TYPED_AS"
            }
          },
          {
            "src": "<T[K][]>",
            "dst": "<T2>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<T[K][]>",
            "dst": "<K2>",
            "type": "DEPENDS_ON"
          },
          {
            "src": "<items.map(...)>",
            "dst": "<items>",
            "type": "CALLS"
          },
          {
            "src": "<item[key]>",
            "dst": "<item>",
            "type": "READS_FROM"
          },
          {
            "src": "<item[key]>",
            "dst": "<key2>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-import-equals-require",
      "category": "ts-specific",
      "code": "// CJS-style import  emits: const CjsLib = require('./module')\n// import CjsLib = require('./module');\n// const instance = new CjsLib();\n// (commented out: requires actual CJS module; syntax is ExportAssignment / ImportEqualsDeclaration)\n\n// --- Getter and setter with different types (TS 4.3+) ---",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-equals>",
          "metadata": {
            "source": "./module",
            "importType": "import-equals",
            "cjsStyle": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<CjsLib>",
          "metadata": {
            "kind": "const",
            "imported": true,
            "tsImportEquals": true
          }
        },
        {
          "type": "CALL",
          "id": "<new CjsLib()>",
          "metadata": {
            "callType": "constructor"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<instance>",
          "metadata": {
            "kind": "const"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-equals>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<instance>",
            "type": "DECLARES"
          }
        ],
        "postFile": [
          {
            "src": "<instance>",
            "dst": "<new CjsLib()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<import-equals>",
            "dst": "<CjsLib>",
            "type": "IMPORTS"
          },
          {
            "src": "<module>",
            "dst": "<./module>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<new CjsLib()>",
            "dst": "<CjsLib>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-export-equals",
      "category": "ts-specific",
      "code": "// CJS-style export assignment  emits: module.exports = CjsLibrary\nclass CjsLibrary {\n  static VERSION = '1.0';\n  process(data: string): string { return data.toUpperCase(); }\n}\n// export = CjsLibrary;\n// (commented out: only one module export mode per file; shown for AST coverage)",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<CjsLibrary>"
        },
        {
          "type": "PROPERTY",
          "id": "<CjsLibrary.VERSION>",
          "metadata": {
            "static": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<'1.0'>",
          "metadata": {
            "value": "1.0",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<CjsLibrary.process>",
          "metadata": {
            "kind": "method"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<data>",
          "metadata": {
            "type": "string"
          }
        },
        {
          "type": "CALL",
          "id": "<data.toUpperCase()>",
          "metadata": {
            "callee": "toUpperCase"
          }
        },
        {
          "type": "EXPORT",
          "id": "<export=CjsLibrary>",
          "metadata": {
            "exportType": "export=",
            "commented": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<CjsLibrary>",
            "type": "DECLARES"
          },
          {
            "src": "<CjsLibrary>",
            "dst": "<CjsLibrary.VERSION>",
            "type": "CONTAINS"
          },
          {
            "src": "<CjsLibrary>",
            "dst": "<CjsLibrary.process>",
            "type": "CONTAINS"
          },
          {
            "src": "<CjsLibrary.process>",
            "dst": "<data>",
            "type": "CONTAINS"
          },
          {
            "src": "<CjsLibrary.process>",
            "dst": "<data.toUpperCase()>",
            "type": "RETURNS"
          }
        ],
        "postFile": [
          {
            "src": "<CjsLibrary.VERSION>",
            "dst": "<'1.0'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<export=CjsLibrary>",
            "dst": "<CjsLibrary>",
            "type": "EXPORTS"
          }
        ],
        "postProject": [
          {
            "src": "<data.toUpperCase()>",
            "dst": "<data>",
            "type": "CALLS_ON"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-generic-default-prior-ref",
      "category": "ts-specific",
      "code": "function createGenericStore<\n  S extends object,\n  A extends object = {},\n  G extends Record<string, (state: S) => unknown> = {},\n>(config: { state: S; actions?: A; getters?: G }) {\n  return config;\n}\n\nfunction wrapInArray<T, R = T[]>(value: T): R {\n  return [value] as unknown as R;         // R defaults to T[]\n}\n\n// --- infer with constraints (TS 4.7+) ---",
      "expectedNodes": [
        {
          "type": "FUNCTION",
          "id": "<createGenericStore>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<S>",
          "metadata": {
            "constraint": "object"
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<A>",
          "metadata": {
            "constraint": "object",
            "hasDefault": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<G>",
          "metadata": {
            "constraint": "Record<string, (state: S) => unknown>",
            "hasDefault": true
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "LITERAL",
          "id": "<{}>",
          "metadata": {
            "value": "{}",
            "literalType": "object"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<config>",
          "metadata": {
            "type": "{ state: S; actions?: A; getters?: G }"
          }
        },
        {
          "type": "FUNCTION",
          "id": "<wrapInArray>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T>"
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<R>",
          "metadata": {
            "hasDefault": true,
            "defaultType": "T[]"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<value>",
          "metadata": {
            "type": "T"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[value] as unknown as R>",
          "metadata": {
            "operator": "type_assertion",
            "doubleAssertion": true
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<[value]>",
          "metadata": {
            "operator": "array_literal"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<createGenericStore>",
            "type": "DECLARES"
          },
          {
            "src": "<createGenericStore>",
            "dst": "<S>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<createGenericStore>",
            "dst": "<A>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<createGenericStore>",
            "dst": "<G>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<A>",
            "dst": "<{}>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<G>",
            "dst": "<{}>",
            "type": "DEFAULTS_TO"
          },
          {
            "src": "<createGenericStore>",
            "dst": "<config>",
            "type": "CONTAINS"
          },
          {
            "src": "<createGenericStore>",
            "dst": "<config>",
            "type": "RETURNS"
          },
          {
            "src": "<module>",
            "dst": "<wrapInArray>",
            "type": "DECLARES"
          },
          {
            "src": "<wrapInArray>",
            "dst": "<T>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<wrapInArray>",
            "dst": "<R>",
            "type": "HAS_TYPE_PARAMETER"
          },
          {
            "src": "<wrapInArray>",
            "dst": "<value>",
            "type": "CONTAINS"
          },
          {
            "src": "<wrapInArray>",
            "dst": "<[value] as unknown as R>",
            "type": "RETURNS"
          }
        ],
        "postFile": [],
        "postProject": [
          {
            "src": "<G>",
            "dst": "<S>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<config>",
            "dst": "<S>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<config>",
            "dst": "<A>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<config>",
            "dst": "<G>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<R>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<value>",
            "dst": "<T>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "REFERENCES_TYPE"
            }
          },
          {
            "src": "<[value] as unknown as R>",
            "dst": "<[value]>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "CASTS_FROM"
            }
          },
          {
            "src": "<[value]>",
            "dst": "<value>",
            "type": "READS_FROM"
          },
          {
            "src": "<[value] as unknown as R>",
            "dst": "<R>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "CASTS_TO"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-getter-setter-different-types",
      "category": "ts-specific",
      "code": "class SmartField {\n  #raw: string = '';\n\n  get value(): string {\n    return this.#raw;\n  }\n\n  // Setter accepts wider type than getter returns\n  set value(input: string | number) {\n    this.#raw = String(input);\n  }\n}\n\n// --- Inline type modifier on import/export specifiers (TS 4.5+) ---",
      "expectedNodes": [
        {
          "type": "CLASS",
          "id": "<SmartField>"
        },
        {
          "type": "PROPERTY",
          "id": "<SmartField.#raw>",
          "metadata": {
            "visibility": "private",
            "type": "string"
          }
        },
        {
          "type": "LITERAL",
          "id": "<''>",
          "metadata": {
            "value": "",
            "literalType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<SmartField.value:getter>",
          "metadata": {
            "kind": "getter",
            "returnType": "string"
          }
        },
        {
          "type": "METHOD",
          "id": "<SmartField.value:setter>",
          "metadata": {
            "kind": "setter",
            "parameterType": "string | number"
          }
        },
        {
          "type": "PARAMETER",
          "id": "<input>",
          "metadata": {
            "type": "string | number"
          }
        },
        {
          "type": "CALL",
          "id": "<String(input)>",
          "metadata": {
            "callee": "String"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<SmartField>",
            "type": "DECLARES"
          },
          {
            "src": "<SmartField>",
            "dst": "<SmartField.#raw>",
            "type": "CONTAINS"
          },
          {
            "src": "<SmartField>",
            "dst": "<SmartField.value:getter>",
            "type": "CONTAINS"
          },
          {
            "src": "<SmartField>",
            "dst": "<SmartField.value:setter>",
            "type": "CONTAINS"
          },
          {
            "src": "<SmartField.value:getter>",
            "dst": "<SmartField.#raw>",
            "type": "RETURNS"
          },
          {
            "src": "<SmartField.value:setter>",
            "dst": "<input>",
            "type": "CONTAINS"
          },
          {
            "src": "<String(input)>",
            "dst": "<input>",
            "type": "PASSES_ARGUMENT"
          }
        ],
        "postFile": [
          {
            "src": "<SmartField.#raw>",
            "dst": "<''>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<SmartField.#raw>",
            "dst": "<String(input)>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<SmartField.value:setter>",
            "dst": "<SmartField.#raw>",
            "type": "WRITES_TO"
          }
        ],
        "postProject": [
          {
            "src": "<SmartField.value:getter>",
            "dst": "<SmartField.#raw>",
            "type": "READS_FROM"
          },
          {
            "src": "<String(input)>",
            "dst": "<String>",
            "type": "CALLS"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-using-typed",
      "category": "ts-specific",
      "code": "// using with type annotations (TS extension of ES2025 Explicit Resource Management)\n// using handle: FileHandle = openFile('/tmp/data');\n// await using conn: DBConnection = await pool.connect();\n// for (using reader: Reader of getReaders()) { reader.process(); }\n\n// --- satisfies + as const combo ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<handle>",
          "metadata": {
            "kind": "using",
            "typeAnnotation": "FileHandle",
            "resourceManaged": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<FileHandle>",
          "metadata": {
            "typeName": "FileHandle",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "CALL",
          "id": "<openFile('/tmp/data')>",
          "metadata": {
            "callee": "openFile"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/tmp/data'>",
          "metadata": {
            "value": "/tmp/data",
            "literalType": "string"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<conn>",
          "metadata": {
            "kind": "await using",
            "typeAnnotation": "DBConnection",
            "resourceManaged": true,
            "async": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<DBConnection>",
          "metadata": {
            "typeName": "DBConnection",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "EXPRESSION",
          "id": "<await pool.connect()>",
          "metadata": {
            "async": true
          }
        },
        {
          "type": "CALL",
          "id": "<pool.connect()>",
          "metadata": {
            "callee": "pool.connect"
          }
        },
        {
          "type": "LOOP",
          "id": "<for-using>",
          "metadata": {
            "loopType": "for-using"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<reader>",
          "metadata": {
            "kind": "using",
            "typeAnnotation": "Reader",
            "resourceManaged": true
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Reader>",
          "metadata": {
            "typeName": "Reader",
            "originalType": "TYPE_ANNOTATION"
          }
        },
        {
          "type": "CALL",
          "id": "<getReaders()>",
          "metadata": {
            "callee": "getReaders"
          }
        },
        {
          "type": "CALL",
          "id": "<reader.process()>",
          "metadata": {
            "callee": "reader.process"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<handle>",
            "type": "DECLARES"
          },
          {
            "src": "<openFile('/tmp/data')>",
            "dst": "<'/tmp/data'>",
            "type": "PASSES_ARGUMENT"
          },
          {
            "src": "<module>",
            "dst": "<conn>",
            "type": "DECLARES"
          },
          {
            "src": "<await pool.connect()>",
            "dst": "<pool.connect()>",
            "type": "AWAITS"
          },
          {
            "src": "<for-using>",
            "dst": "<getReaders()>",
            "type": "ITERATES_OVER"
          },
          {
            "src": "<for-using>",
            "dst": "<reader>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<handle>",
            "dst": "<openFile('/tmp/data')>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<conn>",
            "dst": "<await pool.connect()>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<handle>",
            "dst": "<FileHandle>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "HAS_TYPE_ANNOTATION"
            }
          },
          {
            "src": "<openFile('/tmp/data')>",
            "dst": "<openFile>",
            "type": "CALLS"
          },
          {
            "src": "<conn>",
            "dst": "<DBConnection>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "HAS_TYPE_ANNOTATION"
            }
          },
          {
            "src": "<pool.connect()>",
            "dst": "<pool.connect>",
            "type": "CALLS"
          },
          {
            "src": "<reader>",
            "dst": "<Reader>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "HAS_TYPE_ANNOTATION"
            }
          },
          {
            "src": "<getReaders()>",
            "dst": "<getReaders>",
            "type": "CALLS"
          },
          {
            "src": "<reader.process()>",
            "dst": "<reader.process>",
            "type": "CALLS"
          },
          {
            "src": "<reader.process()>",
            "dst": "<reader>",
            "type": "READS_FROM"
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-inline-type-modifier",
      "category": "ts-specific",
      "code": "// Mixed value + type in single import:\n// import { Component, type Props, type State } from './ui';\n// Component  runtime import (IMPORTS_FROM edge)\n// Props, State  type-only (erased, NO runtime dependency)\n\n// Mixed value + type in single re-export:\n// export { handler, type HandlerConfig } from './handlers';\n\n// Contrast with import type (entire statement is type-only):\n// import type { OnlyTypes } from './types';\n\n// --- this parameter combined with destructuring ---",
      "expectedNodes": [
        {
          "type": "IMPORT",
          "id": "<import-ui>",
          "metadata": {
            "source": "./ui",
            "mixed": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<Component>",
          "metadata": {
            "imported": true,
            "runtime": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<Props>",
          "metadata": {
            "imported": true,
            "typeOnly": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<State>",
          "metadata": {
            "imported": true,
            "typeOnly": true
          }
        },
        {
          "type": "EXPORT",
          "id": "<export-handlers>",
          "metadata": {
            "source": "./handlers",
            "mixed": true
          }
        },
        {
          "type": "VARIABLE",
          "id": "<handler>",
          "metadata": {
            "reexported": true,
            "runtime": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<HandlerConfig>",
          "metadata": {
            "reexported": true,
            "typeOnly": true
          }
        },
        {
          "type": "IMPORT",
          "id": "<import-types>",
          "metadata": {
            "source": "./types",
            "typeOnly": true
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<OnlyTypes>",
          "metadata": {
            "imported": true,
            "typeOnly": true
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<import-ui>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<export-handlers>",
            "type": "CONTAINS"
          },
          {
            "src": "<module>",
            "dst": "<import-types>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<export-handlers>",
            "dst": "<handler>",
            "type": "EXPORTS"
          },
          {
            "src": "<export-handlers>",
            "dst": "<HandlerConfig>",
            "type": "EXPORTS",
            "metadata": {
              "originalType": "EXPORTS_TYPE"
            }
          }
        ],
        "postProject": [
          {
            "src": "<import-ui>",
            "dst": "<Component>",
            "type": "IMPORTS"
          },
          {
            "src": "<import-ui>",
            "dst": "<Props>",
            "type": "IMPORTS",
            "metadata": {
              "originalType": "IMPORTS_TYPE"
            }
          },
          {
            "src": "<import-ui>",
            "dst": "<State>",
            "type": "IMPORTS",
            "metadata": {
              "originalType": "IMPORTS_TYPE"
            }
          },
          {
            "src": "<module>",
            "dst": "<./ui>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<module>",
            "dst": "<./handlers>",
            "type": "IMPORTS_FROM"
          },
          {
            "src": "<import-types>",
            "dst": "<OnlyTypes>",
            "type": "IMPORTS",
            "metadata": {
              "originalType": "IMPORTS_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-satisfies-as-const",
      "category": "ts-specific",
      "code": "const routes = {\n  home: '/',\n  about: '/about',\n  user: '/user/:id',\n} as const satisfies Record<string, string>;\n\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n} satisfies Record<string, string | number[]>;\n\n// --- TS CJS interop: export = / import = require() ---",
      "expectedNodes": [
        {
          "type": "VARIABLE",
          "id": "<routes>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<routes:obj>",
          "metadata": {
            "asConst": true,
            "originalType": "OBJECT"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<routes:obj.home>",
          "metadata": {
            "key": "home"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/'>",
          "metadata": {
            "value": "/",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<routes:obj.about>",
          "metadata": {
            "key": "about"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/about'>",
          "metadata": {
            "value": "/about",
            "literalType": "string"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<routes:obj.user>",
          "metadata": {
            "key": "user"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'/user/:id'>",
          "metadata": {
            "value": "/user/:id",
            "literalType": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, string>>",
          "metadata": {
            "constraintType": "satisfies",
            "originalType": "TYPE_CONSTRAINT"
          }
        },
        {
          "type": "VARIABLE",
          "id": "<palette>",
          "metadata": {
            "kind": "const"
          }
        },
        {
          "type": "LITERAL",
          "id": "<palette:obj>",
          "metadata": {
            "originalType": "OBJECT"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<palette:obj.red>",
          "metadata": {
            "key": "red"
          }
        },
        {
          "type": "LITERAL",
          "id": "<[255, 0, 0]>",
          "metadata": {
            "originalType": "ARRAY"
          }
        },
        {
          "type": "LITERAL",
          "id": "<255>",
          "metadata": {
            "value": 255,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "LITERAL",
          "id": "<0_2>",
          "metadata": {
            "value": 0,
            "literalType": "number"
          }
        },
        {
          "type": "PROPERTY",
          "id": "<palette:obj.green>",
          "metadata": {
            "key": "green"
          }
        },
        {
          "type": "LITERAL",
          "id": "<'#00ff00'>",
          "metadata": {
            "value": "#00ff00",
            "literalType": "string"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<Record<string, string | number[]>>",
          "metadata": {
            "constraintType": "satisfies",
            "originalType": "TYPE_CONSTRAINT"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<routes>",
            "type": "DECLARES"
          },
          {
            "src": "<routes:obj>",
            "dst": "<routes:obj.home>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<routes:obj>",
            "dst": "<routes:obj.about>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<routes:obj>",
            "dst": "<routes:obj.user>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<module>",
            "dst": "<palette>",
            "type": "DECLARES"
          },
          {
            "src": "<palette:obj>",
            "dst": "<palette:obj.red>",
            "type": "HAS_PROPERTY"
          },
          {
            "src": "<[255, 0, 0]>",
            "dst": "<255>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[255, 0, 0]>",
            "dst": "<0>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<[255, 0, 0]>",
            "dst": "<0_2>",
            "type": "HAS_ELEMENT"
          },
          {
            "src": "<palette:obj>",
            "dst": "<palette:obj.green>",
            "type": "HAS_PROPERTY"
          }
        ],
        "postFile": [
          {
            "src": "<routes>",
            "dst": "<routes:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<routes:obj.home>",
            "dst": "<'/'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<routes:obj.about>",
            "dst": "<'/about'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<routes:obj.user>",
            "dst": "<'/user/:id'>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<palette>",
            "dst": "<palette:obj>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<palette:obj.red>",
            "dst": "<[255, 0, 0]>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<palette:obj.green>",
            "dst": "<'#00ff00'>",
            "type": "ASSIGNED_FROM"
          }
        ],
        "postProject": [
          {
            "src": "<routes:obj>",
            "dst": "<Record<string, string>>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "SATISFIES_TYPE"
            }
          },
          {
            "src": "<palette:obj>",
            "dst": "<Record<string, string | number[]>>",
            "type": "HAS_TYPE",
            "metadata": {
              "originalType": "SATISFIES_TYPE"
            }
          }
        ]
      }
    },
    {
      "constructId": "ts-specific::ts-infer-constrained",
      "category": "ts-specific",
      "code": "type FirstString<T> = T extends [infer S extends string, ...unknown[]] ? S : never;\ntype NumericKeys<T> = { [K in keyof T as K extends `${infer N extends number}` ? K : never]: T[K] };\ntype ParsePair<T> = T extends `${infer A extends number},${infer B extends number}` ? [A, B] : never;\n\n// --- Inline import() type expressions ---",
      "expectedNodes": [
        {
          "type": "TYPE_ALIAS",
          "id": "<FirstString>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T1>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<FirstString:conditional>"
        },
        {
          "type": "INFER_TYPE",
          "id": "<S>",
          "metadata": {
            "constraint": "string"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[infer S extends string, ...unknown[]]>",
          "metadata": {
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never1>",
          "metadata": {
            "value": "never"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<NumericKeys>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T2>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<NumericKeys:mapped>",
          "metadata": {
            "originalType": "MAPPED_TYPE"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<NumericKeys:remapping>",
          "metadata": {
            "originalType": "KEY_REMAPPING"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<N>",
          "metadata": {
            "constraint": "number"
          }
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<${infer N extends number}>",
          "metadata": {
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never2>",
          "metadata": {
            "value": "never"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<ParsePair>",
          "metadata": {
            "generic": true
          }
        },
        {
          "type": "TYPE_PARAMETER",
          "id": "<T3>",
          "metadata": {
            "name": "T"
          }
        },
        {
          "type": "CONDITIONAL_TYPE",
          "id": "<ParsePair:conditional>"
        },
        {
          "type": "TYPE_REFERENCE",
          "id": "<${infer A extends number},${infer B extends number}>",
          "metadata": {
            "originalType": "TEMPLATE_LITERAL_TYPE"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<A>",
          "metadata": {
            "constraint": "number"
          }
        },
        {
          "type": "INFER_TYPE",
          "id": "<B>",
          "metadata": {
            "constraint": "number"
          }
        },
        {
          "type": "TYPE_ALIAS",
          "id": "<[A, B]>",
          "metadata": {
            "originalType": "TUPLE_TYPE"
          }
        },
        {
          "type": "LITERAL_TYPE",
          "id": "<never3>",
          "metadata": {
            "value": "never"
          }
        }
      ],
      "expectedEdges": {
        "walk": [
          {
            "src": "<module>",
            "dst": "<FirstString>",
            "type": "DECLARES"
          },
          {
            "src": "<FirstString>",
            "dst": "<T1>",
            "type": "CONTAINS"
          },
          {
            "src": "<FirstString:conditional>",
            "dst": "<T1>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "CHECKS_TYPE"
            }
          },
          {
            "src": "<[infer S extends string, ...unknown[]]>",
            "dst": "<S>",
            "type": "INFERS"
          },
          {
            "src": "<S>",
            "dst": "string",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<FirstString:conditional>",
            "dst": "<S>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<module>",
            "dst": "<NumericKeys>",
            "type": "DECLARES"
          },
          {
            "src": "<NumericKeys>",
            "dst": "<T2>",
            "type": "CONTAINS"
          },
          {
            "src": "<NumericKeys:mapped>",
            "dst": "<T2>",
            "type": "ITERATES_OVER",
            "metadata": {
              "originalType": "MAPS_OVER"
            }
          },
          {
            "src": "<${infer N extends number}>",
            "dst": "<N>",
            "type": "INFERS"
          },
          {
            "src": "<N>",
            "dst": "number",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<module>",
            "dst": "<ParsePair>",
            "type": "DECLARES"
          },
          {
            "src": "<ParsePair>",
            "dst": "<T3>",
            "type": "CONTAINS"
          },
          {
            "src": "<ParsePair:conditional>",
            "dst": "<T3>",
            "type": "HAS_CONDITION",
            "metadata": {
              "originalType": "CHECKS_TYPE"
            }
          },
          {
            "src": "<${infer A extends number},${infer B extends number}>",
            "dst": "<A>",
            "type": "INFERS"
          },
          {
            "src": "<${infer A extends number},${infer B extends number}>",
            "dst": "<B>",
            "type": "INFERS"
          },
          {
            "src": "<A>",
            "dst": "number",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<B>",
            "dst": "number",
            "type": "CONSTRAINED_BY"
          },
          {
            "src": "<ParsePair:conditional>",
            "dst": "<[A, B]>",
            "type": "HAS_CONSEQUENT"
          },
          {
            "src": "<[A, B]>",
            "dst": "<A>",
            "type": "CONTAINS"
          },
          {
            "src": "<[A, B]>",
            "dst": "<B>",
            "type": "CONTAINS"
          }
        ],
        "postFile": [
          {
            "src": "<FirstString>",
            "dst": "<FirstString:conditional>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<FirstString:conditional>",
            "dst": "<never1>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<NumericKeys>",
            "dst": "<NumericKeys:mapped>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<NumericKeys:remapping>",
            "dst": "<never2>",
            "type": "HAS_ALTERNATE"
          },
          {
            "src": "<ParsePair>",
            "dst": "<ParsePair:conditional>",
            "type": "ASSIGNED_FROM"
          },
          {
            "src": "<ParsePair:conditional>",
            "dst": "<never3>",
            "type": "HAS_ALTERNATE"
          }
        ],
        "postProject": [
          {
            "src": "<FirstString:conditional>",
            "dst": "<[infer S extends string, ...unknown[]]>",
            "type": "EXTENDS",
            "metadata": {
              "originalType": "EXTENDS_TYPE"
            }
          },
          {
            "src": "<NumericKeys:mapped>",
            "dst": "<NumericKeys:remapping>",
            "type": "DERIVES_FROM",
            "metadata": {
              "originalType": "HAS_KEY_REMAPPING"
            }
          },
          {
            "src": "<NumericKeys:remapping>",
            "dst": "<${infer N extends number}>",
            "type": "EXTENDS",
            "metadata": {
              "originalType": "EXTENDS_TYPE"
            }
          },
          {
            "src": "<ParsePair:conditional>",
            "dst": "<${infer A extends number},${infer B extends number}>",
            "type": "EXTENDS",
            "metadata": {
              "originalType": "EXTENDS_TYPE"
            }
          }
        ]
      }
    }
  ],
  "coverage": {
    "nodeTypesExercised": [
      "BRANCH",
      "CALL",
      "CASE",
      "CATCH_BLOCK",
      "CLASS",
      "CONDITIONAL_TYPE",
      "DECORATOR",
      "ENUM",
      "ENUM_MEMBER",
      "EXPORT",
      "EXPRESSION",
      "EXTERNAL",
      "EXTERNAL_MODULE",
      "FILE",
      "FINALLY_BLOCK",
      "FUNCTION",
      "GETTER",
      "IMPORT",
      "INFER_TYPE",
      "INTERFACE",
      "LABEL",
      "LITERAL",
      "LITERAL_TYPE",
      "LOOP",
      "META_PROPERTY",
      "METHOD",
      "MODULE",
      "NAMESPACE",
      "PARAMETER",
      "PROPERTY",
      "PROPERTY_ACCESS",
      "SCOPE",
      "SETTER",
      "SIDE_EFFECT",
      "STATIC_BLOCK",
      "TRY_BLOCK",
      "TYPE_ALIAS",
      "TYPE_PARAMETER",
      "TYPE_REFERENCE",
      "VARIABLE"
    ],
    "edgeTypesExercised": [
      "ACCESSES_PRIVATE",
      "ALIASES",
      "ASSIGNED_FROM",
      "AWAITS",
      "BINDS_THIS_TO",
      "CALLS",
      "CALLS_ON",
      "CAPTURES",
      "CATCHES_FROM",
      "CHAINS_FROM",
      "CONSTRAINED_BY",
      "CONTAINS",
      "DECLARES",
      "DECORATED_BY",
      "DEFAULTS_TO",
      "DELEGATES_TO",
      "DELETES",
      "DEPENDS_ON",
      "DERIVES_FROM",
      "EXPORTS",
      "EXTENDS",
      "EXTENDS_SCOPE_WITH",
      "FLOWS_INTO",
      "HAS_ALTERNATE",
      "HAS_BODY",
      "HAS_CASE",
      "HAS_CATCH",
      "HAS_CONDITION",
      "HAS_CONSEQUENT",
      "HAS_DEFAULT",
      "HAS_ELEMENT",
      "HAS_FINALLY",
      "HAS_INIT",
      "HAS_OVERLOAD",
      "HAS_PROPERTY",
      "HAS_SCOPE",
      "HAS_TYPE",
      "HAS_TYPE_PARAMETER",
      "HAS_UPDATE",
      "IMPLEMENTS",
      "IMPLEMENTS_OVERLOAD",
      "IMPORTS",
      "IMPORTS_FROM",
      "INFERS",
      "INTERSECTS_WITH",
      "INVOKES",
      "ITERATES_OVER",
      "LISTENS_TO",
      "MERGES_WITH",
      "MODIFIES",
      "OVERRIDES",
      "PASSES_ARGUMENT",
      "READS_FROM",
      "RECEIVES_ARGUMENT",
      "RESOLVES_TO",
      "RETURNS",
      "RETURNS_TYPE",
      "SHADOWS",
      "SPREADS_FROM",
      "THROWS",
      "UNION_MEMBER",
      "USES",
      "WRITES_TO",
      "YIELDS"
    ],
    "nodeTypesMissing": [],
    "edgeTypesMissing": []
  }
}
