/**
 * Walk-phase tests for UnknownAnalyzer
 *
 * Auto-generated by @grafema/lang-spec stage 10.
 * 644 test cases from annotated corpus.
 */

import { describe, test } from 'node:test';

describe('UnknownAnalyzer — walk phase', () => {
  test('aliasing::alias-method-extraction', () => {
    const code = "const log = console.log;\nlog('extracted');";
    // Expect node: VARIABLE <log>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect node: CALL <log('extracted')>
    // Expect node: LITERAL <'extracted'>
    // Expect edge: <log('extracted')> -[PASSES_ARGUMENT]-> <'extracted'>
    void code;
  });

  test('aliasing::alias-reassign-function', () => {
    const code = "let handler = function first() { return 1; };\nhandler();\n\nhandler = function second() { return 2; };\nhandler();";
    // Expect node: VARIABLE <handler>
    // Expect node: FUNCTION <first>
    // Expect node: LITERAL <1>
    // Expect node: CALL <handler()_1>
    // Expect node: FUNCTION <second>
    // Expect node: LITERAL <2>
    // Expect node: CALL <handler()_2>
    // Expect edge: <first> -[RETURNS]-> <1>
    // Expect edge: <second> -[RETURNS]-> <2>
    void code;
  });

  test('aliasing::alias-destructured-method', () => {
    const code = "const { parse, stringify } = JSON;\nconst parsed = parse('{\"a\":1}');";
    // Expect node: VARIABLE <parse>
    // Expect node: VARIABLE <stringify>
    // Expect node: PROPERTY_ACCESS <JSON.parse>
    // Expect node: PROPERTY_ACCESS <JSON.stringify>
    // Expect node: VARIABLE <parsed>
    // Expect node: CALL <parse('{"a":1}')>
    // Expect node: LITERAL <'{"a":1}'>
    // Expect edge: <parse('{"a":1}')> -[PASSES_ARGUMENT]-> <'{"a":1}'>
    void code;
  });

  test('aliasing::alias-bind-partial', () => {
    const code = "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---";
    // Expect node: FUNCTION <multiply>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a * b>
    // Expect node: VARIABLE <doubleIt>
    // Expect node: CALL <multiply.bind(null, 2)>
    // Expect node: LITERAL <null>
    // Expect node: LITERAL <2>
    // Expect node: FUNCTION <doubleIt:bound>
    // Expect node: CALL <doubleIt(5)>
    // Expect node: LITERAL <5>
    // Expect edge: <multiply> -[CONTAINS]-> <a>
    // Expect edge: <multiply> -[CONTAINS]-> <b>
    // Expect edge: <multiply> -[RETURNS]-> <a * b>
    // Expect edge: <multiply.bind(null, 2)> -[PASSES_ARGUMENT]-> <null>
    // Expect edge: <multiply.bind(null, 2)> -[PASSES_ARGUMENT]-> <2>
    // Expect edge: <multiply.bind(null, 2)> -[RETURNS]-> <doubleIt:bound>
    // Expect edge: <doubleIt(5)> -[PASSES_ARGUMENT]-> <5>
    void code;
  });

  test('aliasing::alias-computed-method', () => {
    const code = "const mathObj = { add(a, b) { return a + b; } };\nconst methodName = 'add';\nconst fn = mathObj[methodName];\nfn(1, 2);\n\n// --- Function reassignment ---";
    // Expect node: VARIABLE <mathObj>
    // Expect node: LITERAL <mathObj-object>
    // Expect node: METHOD <add>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a + b>
    // Expect node: VARIABLE <methodName>
    // Expect node: LITERAL <'add'>
    // Expect node: VARIABLE <fn>
    // Expect node: PROPERTY_ACCESS <mathObj[methodName]>
    // Expect node: CALL <fn(1, 2)>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect edge: <mathObj-object> -[HAS_PROPERTY]-> <add>
    // Expect edge: <add> -[CONTAINS]-> <a>
    // Expect edge: <add> -[CONTAINS]-> <b>
    // Expect edge: <add> -[RETURNS]-> <a + b>
    // Expect edge: <fn(1, 2)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <fn(1, 2)> -[PASSES_ARGUMENT]-> <2>
    void code;
  });

  test('aliasing::alias-reassign-conditional', () => {
    const code = "let strategy;\nif (Math.random() > 0.5) {\n  strategy = function fast() { return 'fast'; };\n} else {\n  strategy = function slow() { return 'slow'; };\n}\nstrategy();\n\n// --- Callback identity through higher-order functions ---";
    // Expect node: VARIABLE <strategy>
    // Expect node: BRANCH <if-random>
    // Expect node: EXPRESSION <Math.random() > 0.5>
    // Expect node: CALL <Math.random()>
    // Expect node: LITERAL <0.5>
    // Expect node: FUNCTION <fast>
    // Expect node: LITERAL <'fast'>
    // Expect node: FUNCTION <slow>
    // Expect node: LITERAL <'slow'>
    // Expect node: CALL <strategy()>
    // Expect edge: <if-random> -[HAS_CONDITION]-> <Math.random() > 0.5>
    // Expect edge: <Math.random() > 0.5> -[CONTAINS]-> <Math.random()>
    // Expect edge: <Math.random() > 0.5> -[CONTAINS]-> <0.5>
    // Expect edge: <if-random> -[HAS_CONSEQUENT]-> <strategy>
    // Expect edge: <fast> -[RETURNS]-> <'fast'>
    // Expect edge: <slow> -[RETURNS]-> <'slow'>
    void code;
  });

  test('aliasing::alias-callback-passed', () => {
    const code = "function applyToArray(arr, callback) {\n  return arr.map(callback);\n}\nfunction double(x) { return x * 2; }\napplyToArray([1, 2, 3], double);";
    // Expect node: FUNCTION <applyToArray>
    // Expect node: PARAMETER <arr>
    // Expect node: PARAMETER <callback>
    // Expect node: CALL <arr.map(callback)>
    // Expect node: FUNCTION <double>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect node: CALL <applyToArray([1, 2, 3], double)>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect edge: <applyToArray> -[HAS_BODY]-> <arr>
    // Expect edge: <applyToArray> -[HAS_BODY]-> <callback>
    // Expect edge: <applyToArray> -[RETURNS]-> <arr.map(callback)>
    // Expect edge: <arr.map(callback)> -[PASSES_ARGUMENT]-> <callback>
    // Expect edge: <double> -[HAS_BODY]-> <x>
    // Expect edge: <double> -[RETURNS]-> <x * 2>
    // Expect edge: <applyToArray([1, 2, 3], double)> -[PASSES_ARGUMENT]-> <[1, 2, 3]>
    // Expect edge: <applyToArray([1, 2, 3], double)> -[PASSES_ARGUMENT]-> <double>
    void code;
  });

  test('aliasing::alias-callback-returned', () => {
    const code = "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---";
    // Expect node: FUNCTION <getComparator>
    // Expect node: PARAMETER <ascending>
    // Expect node: BRANCH <if-ascending>
    // Expect node: FUNCTION <ascending-comparator>
    // Expect node: PARAMETER <a1>
    // Expect node: PARAMETER <b1>
    // Expect node: EXPRESSION <a - b>
    // Expect node: FUNCTION <descending-comparator>
    // Expect node: PARAMETER <a2>
    // Expect node: PARAMETER <b2>
    // Expect node: EXPRESSION <b - a>
    // Expect node: VARIABLE <cmp>
    // Expect node: CALL <getComparator(true)>
    // Expect node: LITERAL <true>
    // Expect node: LITERAL <[3, 1, 2]>
    // Expect node: CALL <[3, 1, 2].sort(cmp)>
    // Expect edge: <getComparator> -[CONTAINS]-> <ascending>
    // Expect edge: <getComparator> -[CONTAINS]-> <if-ascending>
    // Expect edge: <if-ascending> -[HAS_CONDITION]-> <ascending>
    // Expect edge: <if-ascending> -[HAS_CONSEQUENT]-> <ascending-comparator>
    // Expect edge: <ascending-comparator> -[CONTAINS]-> <a1>
    // Expect edge: <ascending-comparator> -[CONTAINS]-> <b1>
    // Expect edge: <ascending-comparator> -[RETURNS]-> <a - b>
    // Expect edge: <descending-comparator> -[CONTAINS]-> <a2>
    // Expect edge: <descending-comparator> -[CONTAINS]-> <b2>
    // Expect edge: <descending-comparator> -[RETURNS]-> <b - a>
    // Expect edge: <getComparator(true)> -[PASSES_ARGUMENT]-> <true>
    // Expect edge: <[3, 1, 2].sort(cmp)> -[PASSES_ARGUMENT]-> <cmp>
    void code;
  });

  test('aliasing::alias-callback-returned', () => {
    const code = "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---";
    // Expect node: FUNCTION <getComparator>
    // Expect node: PARAMETER <ascending>
    // Expect node: BRANCH <if-ascending>
    // Expect node: FUNCTION <ascending-comparator>
    // Expect node: PARAMETER <a1>
    // Expect node: PARAMETER <b1>
    // Expect node: EXPRESSION <a1 - b1>
    // Expect node: FUNCTION <descending-comparator>
    // Expect node: PARAMETER <a2>
    // Expect node: PARAMETER <b2>
    // Expect node: EXPRESSION <b2 - a2>
    // Expect node: VARIABLE <cmp>
    // Expect node: CALL <getComparator(true)>
    // Expect node: LITERAL <true>
    // Expect node: LITERAL <[3, 1, 2]>
    // Expect node: CALL <[3, 1, 2].sort(cmp)>
    // Expect edge: <getComparator> -[CONTAINS]-> <ascending>
    // Expect edge: <getComparator> -[CONTAINS]-> <if-ascending>
    // Expect edge: <if-ascending> -[HAS_CONDITION]-> <ascending>
    // Expect edge: <if-ascending> -[HAS_CONSEQUENT]-> <ascending-comparator>
    // Expect edge: <ascending-comparator> -[CONTAINS]-> <a1>
    // Expect edge: <ascending-comparator> -[CONTAINS]-> <b1>
    // Expect edge: <ascending-comparator> -[RETURNS]-> <a1 - b1>
    // Expect edge: <descending-comparator> -[CONTAINS]-> <a2>
    // Expect edge: <descending-comparator> -[CONTAINS]-> <b2>
    // Expect edge: <descending-comparator> -[RETURNS]-> <b2 - a2>
    // Expect edge: <getComparator(true)> -[PASSES_ARGUMENT]-> <true>
    // Expect edge: <[3, 1, 2].sort(cmp)> -[PASSES_ARGUMENT]-> <cmp>
    void code;
  });

  test('aliasing::arguments-basic', () => {
    const code = "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}";
    // Expect node: FUNCTION <sum>
    // Expect node: VARIABLE <total>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i < arguments.length>
    // Expect node: PROPERTY_ACCESS <arguments.length>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <total += arguments[i]>
    // Expect node: PROPERTY_ACCESS <arguments[i]>
    // Expect node: EXTERNAL <arguments>
    // Expect edge: <sum> -[CONTAINS]-> <total>
    // Expect edge: <sum> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < arguments.length>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <total += arguments[i]>
    // Expect edge: <sum> -[RETURNS]-> <total>
    void code;
  });

  test('aliasing::alias-bind-partial', () => {
    const code = "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---";
    // Expect node: FUNCTION <multiply>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a * b>
    // Expect node: VARIABLE <doubleIt>
    // Expect node: CALL <multiply.bind(null, 2)>
    // Expect node: LITERAL <null>
    // Expect node: LITERAL <2>
    // Expect node: FUNCTION <doubleIt:bound>
    // Expect node: CALL <doubleIt(5)>
    // Expect node: LITERAL <5>
    // Expect edge: <multiply> -[HAS_BODY]-> <a>
    // Expect edge: <multiply> -[HAS_BODY]-> <b>
    // Expect edge: <multiply> -[RETURNS]-> <a * b>
    // Expect edge: <multiply.bind(null, 2)> -[PASSES_ARGUMENT]-> <null>
    // Expect edge: <multiply.bind(null, 2)> -[PASSES_ARGUMENT]-> <2>
    // Expect edge: <multiply.bind(null, 2)> -[RETURNS]-> <doubleIt:bound>
    // Expect edge: <doubleIt(5)> -[PASSES_ARGUMENT]-> <5>
    void code;
  });

  test('aliasing::alias-import-dynamic-variable', () => {
    const code = "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);";
    // Expect node: VARIABLE <modulePath>
    // Expect node: LITERAL <'./declarations.js'>
    // Expect node: VARIABLE <dynamicMod>
    // Expect node: CALL <import(modulePath)>
    // Expect node: EXTERNAL_MODULE <./declarations.js>
    // Expect edge: <import(modulePath)> -[PASSES_ARGUMENT]-> <modulePath>
    void code;
  });

  test('aliasing::arguments-callee', () => {
    const code = "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---";
    // Expect node: VARIABLE <factorial>
    // Expect node: FUNCTION <factorial:fn>
    // Expect node: PARAMETER <n>
    // Expect node: EXPRESSION <n <= 1>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <1-return>
    // Expect node: EXPRESSION <n * arguments.callee(n - 1)>
    // Expect node: PROPERTY_ACCESS <arguments.callee>
    // Expect node: EXPRESSION <n - 1>
    // Expect node: CALL <arguments.callee(n - 1)>
    // Expect node: EXPRESSION <ternary>
    // Expect edge: <factorial:fn> -[CONTAINS]-> <n>
    // Expect edge: <factorial:fn> -[RETURNS]-> <ternary>
    // Expect edge: <ternary> -[HAS_CONDITION]-> <n <= 1>
    // Expect edge: <ternary> -[HAS_CONSEQUENT]-> <1-return>
    // Expect edge: <arguments.callee(n - 1)> -[PASSES_ARGUMENT]-> <n - 1>
    void code;
  });

  test('aliasing::arguments-basic', () => {
    const code = "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}";
    // Expect node: FUNCTION <sum>
    // Expect node: VARIABLE <total>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i < arguments.length>
    // Expect node: PROPERTY_ACCESS <arguments.length>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <total += arguments[i]>
    // Expect node: PROPERTY_ACCESS <arguments[i]>
    // Expect node: EXTERNAL <arguments>
    // Expect edge: <sum> -[CONTAINS]-> <total>
    // Expect edge: <sum> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < arguments.length>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <total += arguments[i]>
    // Expect edge: <sum> -[RETURNS]-> <total>
    void code;
  });

  test('aliasing::arguments-array-conversion', () => {
    const code = "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}";
    // Expect node: FUNCTION <toArray>
    // Expect node: VARIABLE <fromArrayFn>
    // Expect node: CALL <Array.from(arguments)>
    // Expect node: PROPERTY_ACCESS <Array.from>
    // Expect node: VARIABLE <arguments>
    // Expect node: VARIABLE <fromSpread>
    // Expect node: EXPRESSION <[...arguments]>
    // Expect node: VARIABLE <fromSlice>
    // Expect node: CALL <[].slice.call(arguments)>
    // Expect node: PROPERTY_ACCESS <[].slice>
    // Expect node: LITERAL <[]>
    // Expect node: PROPERTY_ACCESS <[].slice.call>
    // Expect node: EXPRESSION <{ fromArrayFn, fromSpread, fromSlice }>
    // Expect edge: <toArray> -[CONTAINS]-> <fromArrayFn>
    // Expect edge: <Array.from(arguments)> -[PASSES_ARGUMENT]-> <arguments>
    // Expect edge: <toArray> -[CONTAINS]-> <fromSpread>
    // Expect edge: <[...arguments]> -[SPREADS_FROM]-> <arguments>
    // Expect edge: <toArray> -[CONTAINS]-> <fromSlice>
    // Expect edge: <[].slice.call(arguments)> -[PASSES_ARGUMENT]-> <arguments>
    // Expect edge: <toArray> -[RETURNS]-> <{ fromArrayFn, fromSpread, fromSlice }>
    void code;
  });

  test('aliasing::arguments-array-conversion', () => {
    const code = "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}";
    // Expect node: FUNCTION <toArray>
    // Expect node: VARIABLE <fromArrayFn>
    // Expect node: CALL <Array.from(arguments)>
    // Expect node: PROPERTY_ACCESS <Array.from>
    // Expect node: VARIABLE <arguments>
    // Expect node: VARIABLE <fromSpread>
    // Expect node: EXPRESSION <[...arguments]>
    // Expect node: VARIABLE <fromSlice>
    // Expect node: CALL <[].slice.call(arguments)>
    // Expect node: PROPERTY_ACCESS <[].slice>
    // Expect node: LITERAL <[]>
    // Expect node: PROPERTY_ACCESS <[].slice.call>
    // Expect node: EXPRESSION <{ fromArrayFn, fromSpread, fromSlice }>
    // Expect edge: <toArray> -[CONTAINS]-> <fromArrayFn>
    // Expect edge: <Array.from(arguments)> -[PASSES_ARGUMENT]-> <arguments>
    // Expect edge: <toArray> -[CONTAINS]-> <fromSpread>
    // Expect edge: <[...arguments]> -[SPREADS_FROM]-> <arguments>
    // Expect edge: <toArray> -[CONTAINS]-> <fromSlice>
    // Expect edge: <[].slice.call(arguments)> -[PASSES_ARGUMENT]-> <arguments>
    // Expect edge: <toArray> -[RETURNS]-> <{ fromArrayFn, fromSpread, fromSlice }>
    void code;
  });

  test('aliasing::alias-import-dynamic-conditional', () => {
    const code = "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);";
    // Expect node: VARIABLE <impl>
    // Expect node: CALL <import()>
    // Expect node: EXPRESSION <Math.random() > 0.5>
    // Expect node: CALL <Math.random()>
    // Expect node: LITERAL <0.5>
    // Expect node: BRANCH <conditional>
    // Expect node: LITERAL <'./declarations.js'>
    // Expect node: LITERAL <'./expressions.js'>
    // Expect edge: <import()> -[PASSES_ARGUMENT]-> <conditional>
    // Expect edge: <conditional> -[HAS_CONDITION]-> <Math.random() > 0.5>
    // Expect edge: <conditional> -[HAS_CONSEQUENT]-> <'./declarations.js'>
    void code;
  });

  test('aliasing::arguments-callee', () => {
    const code = "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---";
    // Expect node: VARIABLE <factorial>
    // Expect node: FUNCTION <factorial:fn>
    // Expect node: PARAMETER <n>
    // Expect node: EXPRESSION <n <= 1>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <1-return>
    // Expect node: EXPRESSION <n * arguments.callee(n - 1)>
    // Expect node: PROPERTY_ACCESS <arguments.callee>
    // Expect node: EXPRESSION <n - 1>
    // Expect node: CALL <arguments.callee(n - 1)>
    // Expect node: EXPRESSION <ternary>
    // Expect edge: <factorial:fn> -[CONTAINS]-> <n>
    // Expect edge: <factorial:fn> -[RETURNS]-> <ternary>
    // Expect edge: <ternary> -[HAS_CONDITION]-> <n <= 1>
    // Expect edge: <ternary> -[HAS_CONSEQUENT]-> <1-return>
    // Expect edge: <arguments.callee(n - 1)> -[PASSES_ARGUMENT]-> <n - 1>
    void code;
  });

  test('aliasing::alias-import-dynamic-variable', () => {
    const code = "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);";
    // Expect node: VARIABLE <modulePath>
    // Expect node: LITERAL <'./declarations.js'>
    // Expect node: VARIABLE <dynamicMod>
    // Expect node: CALL <import(modulePath)>
    // Expect node: EXTERNAL_MODULE <./declarations.js>
    // Expect edge: <import(modulePath)> -[PASSES_ARGUMENT]-> <modulePath>
    void code;
  });

  test('aliasing::alias-import-dynamic-template', () => {
    const code = "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}";
    // Expect node: FUNCTION <loadPlugin>
    // Expect node: PARAMETER <name>
    // Expect node: VARIABLE <plugin>
    // Expect node: IMPORT <dynamic-import>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: PROPERTY_ACCESS <plugin.default>
    // Expect edge: <loadPlugin> -[CONTAINS]-> <name>
    // Expect edge: <loadPlugin> -[CONTAINS]-> <plugin>
    // Expect edge: <loadPlugin> -[RETURNS]-> <plugin.default>
    void code;
  });

  test('aliasing::alias-import-dynamic-template', () => {
    const code = "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}";
    // Expect node: FUNCTION <loadPlugin>
    // Expect node: PARAMETER <name>
    // Expect node: VARIABLE <plugin>
    // Expect node: IMPORT <dynamic-import>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: PROPERTY_ACCESS <plugin.default>
    // Expect edge: <loadPlugin> -[CONTAINS]-> <name>
    // Expect edge: <loadPlugin> -[CONTAINS]-> <plugin>
    // Expect edge: <loadPlugin> -[RETURNS]-> <plugin.default>
    void code;
  });

  test('aliasing::alias-import-dynamic-conditional', () => {
    const code = "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);";
    // Expect node: VARIABLE <impl>
    // Expect node: CALL <import()>
    // Expect node: EXPRESSION <Math.random() > 0.5>
    // Expect node: CALL <Math.random()>
    // Expect node: LITERAL <0.5>
    // Expect node: BRANCH <conditional>
    // Expect node: LITERAL <'./declarations.js'>
    // Expect node: LITERAL <'./expressions.js'>
    // Expect edge: <import()> -[PASSES_ARGUMENT]-> <conditional>
    // Expect edge: <conditional> -[HAS_CONDITION]-> <Math.random() > 0.5>
    // Expect edge: <conditional> -[HAS_CONSEQUENT]-> <'./declarations.js'>
    void code;
  });

  test('aliasing::arrow-no-arguments', () => {
    const code = "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);";
    // Expect node: FUNCTION <outerWithArguments>
    // Expect node: VARIABLE <arrow>
    // Expect node: FUNCTION <arrow:fn>
    // Expect node: PROPERTY_ACCESS <arguments[0]>
    // Expect node: VARIABLE <arrowFromOuter>
    // Expect node: CALL <outerWithArguments(42)>
    // Expect node: LITERAL <42>
    // Expect edge: <outerWithArguments> -[CONTAINS]-> <arrow>
    // Expect edge: <outerWithArguments> -[RETURNS]-> <arrow:fn>
    // Expect edge: <arrow:fn> -[RETURNS]-> <arguments[0]>
    // Expect edge: <outerWithArguments(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('aliasing::arrow-no-arguments', () => {
    const code = "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);";
    // Expect node: FUNCTION <outerWithArguments>
    // Expect node: VARIABLE <arrow>
    // Expect node: FUNCTION <arrow:fn>
    // Expect node: PROPERTY_ACCESS <arguments[0]>
    // Expect node: VARIABLE <arrowFromOuter>
    // Expect node: CALL <outerWithArguments(42)>
    // Expect node: LITERAL <42>
    // Expect edge: <outerWithArguments> -[CONTAINS]-> <arrow>
    // Expect edge: <outerWithArguments> -[RETURNS]-> <arrow:fn>
    // Expect edge: <arrow:fn> -[RETURNS]-> <arguments[0]>
    // Expect edge: <outerWithArguments(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('aliasing::arguments-param-aliasing', () => {
    const code = "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode — bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}";
    // Expect node: FUNCTION <argumentsAliasing>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: VARIABLE <arguments>
    // Expect node: PROPERTY_ACCESS <arguments[0]>
    // Expect node: LITERAL <99>
    // Expect node: VARIABLE <aAfterMutation>
    // Expect node: LITERAL <'changed'>
    // Expect node: VARIABLE <arg0AfterReassign>
    // Expect node: EXPRESSION <{ aAfterMutation, arg0AfterReassign }>
    // Expect edge: <argumentsAliasing> -[CONTAINS]-> <a>
    // Expect edge: <argumentsAliasing> -[CONTAINS]-> <b>
    // Expect edge: <argumentsAliasing> -[CONTAINS]-> <arguments>
    // Expect edge: <argumentsAliasing> -[DECLARES]-> <aAfterMutation>
    // Expect edge: <argumentsAliasing> -[DECLARES]-> <arg0AfterReassign>
    // Expect edge: <argumentsAliasing> -[RETURNS]-> <{ aAfterMutation, arg0AfterReassign }>
    void code;
  });

  test('aliasing::arguments-param-aliasing', () => {
    const code = "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode — bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}";
    // Expect node: FUNCTION <argumentsAliasing>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: VARIABLE <arguments>
    // Expect node: PROPERTY_ACCESS <arguments[0]>
    // Expect node: LITERAL <99>
    // Expect node: VARIABLE <aAfterMutation>
    // Expect node: LITERAL <'changed'>
    // Expect node: VARIABLE <arg0AfterReassign>
    // Expect node: EXPRESSION <{ aAfterMutation, arg0AfterReassign }>
    // Expect edge: <argumentsAliasing> -[CONTAINS]-> <a>
    // Expect edge: <argumentsAliasing> -[CONTAINS]-> <b>
    // Expect edge: <argumentsAliasing> -[CONTAINS]-> <arguments>
    // Expect edge: <argumentsAliasing> -[DECLARES]-> <aAfterMutation>
    // Expect edge: <argumentsAliasing> -[DECLARES]-> <arg0AfterReassign>
    // Expect edge: <argumentsAliasing> -[RETURNS]-> <{ aAfterMutation, arg0AfterReassign }>
    void code;
  });

  test('aliasing::arguments-rest-coexistence', () => {
    const code = "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}";
    // Expect node: FUNCTION <argumentsWithRest>
    // Expect node: PARAMETER <first>
    // Expect node: PARAMETER <rest>
    // Expect node: VARIABLE <allCount>
    // Expect node: PROPERTY_ACCESS <arguments.length>
    // Expect node: VARIABLE <firstFromArgs>
    // Expect node: PROPERTY_ACCESS <arguments[0]>
    // Expect node: VARIABLE <restFromArgs>
    // Expect node: PROPERTY_ACCESS <arguments[1]>
    // Expect node: EXPRESSION <return-object>
    // Expect node: EXTERNAL <arguments>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <first>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <rest>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <allCount>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <firstFromArgs>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <restFromArgs>
    // Expect edge: <argumentsWithRest> -[RETURNS]-> <return-object>
    void code;
  });

  test('async-generators::async-await-basic', () => {
    const code = "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}";
    // Expect node: FUNCTION <fetchData>
    // Expect node: PARAMETER <url>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url)>
    // Expect node: EXTERNAL <fetch>
    // Expect node: VARIABLE <data>
    // Expect node: CALL <response.json()>
    // Expect node: PROPERTY_ACCESS <response.json>
    // Expect edge: <fetchData> -[CONTAINS]-> <url>
    // Expect edge: <fetchData> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetchData> -[CONTAINS]-> <data>
    // Expect edge: <fetchData> -[RETURNS]-> <data>
    // Expect edge: <fetchData> -[AWAITS]-> <fetch(url)>
    // Expect edge: <fetchData> -[AWAITS]-> <response.json()>
    void code;
  });

  test('aliasing::arguments-rest-coexistence', () => {
    const code = "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}";
    // Expect node: FUNCTION <argumentsWithRest>
    // Expect node: PARAMETER <first>
    // Expect node: PARAMETER <rest>
    // Expect node: VARIABLE <allCount>
    // Expect node: PROPERTY_ACCESS <arguments.length>
    // Expect node: VARIABLE <firstFromArgs>
    // Expect node: PROPERTY_ACCESS <arguments[0]>
    // Expect node: VARIABLE <restFromArgs>
    // Expect node: PROPERTY_ACCESS <arguments[1]>
    // Expect node: EXPRESSION <return-object>
    // Expect node: EXTERNAL <arguments>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <first>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <rest>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <allCount>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <firstFromArgs>
    // Expect edge: <argumentsWithRest> -[CONTAINS]-> <restFromArgs>
    // Expect edge: <argumentsWithRest> -[RETURNS]-> <return-object>
    void code;
  });

  test('async-generators::async-await-basic', () => {
    const code = "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}";
    // Expect node: FUNCTION <fetchData>
    // Expect node: PARAMETER <url>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url)>
    // Expect node: EXTERNAL <fetch>
    // Expect node: VARIABLE <data>
    // Expect node: CALL <response.json()>
    // Expect node: PROPERTY_ACCESS <response.json>
    // Expect edge: <fetchData> -[CONTAINS]-> <url>
    // Expect edge: <fetchData> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetchData> -[CONTAINS]-> <data>
    // Expect edge: <fetchData> -[RETURNS]-> <data>
    // Expect edge: <fetchData> -[AWAITS]-> <fetch(url)>
    // Expect edge: <fetchData> -[AWAITS]-> <response.json()>
    void code;
  });

  test('async-generators::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};";
    // Expect node: VARIABLE <asyncArrow>
    // Expect node: FUNCTION <asyncArrow:fn>
    // Expect node: EXPRESSION <await Promise.resolve(42)>
    // Expect node: CALL <Promise.resolve(42)>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <asyncArrow>
    // Expect edge: <asyncArrow:fn> -[RETURNS]-> <await Promise.resolve(42)>
    // Expect edge: <await Promise.resolve(42)> -[AWAITS]-> <Promise.resolve(42)>
    // Expect edge: <Promise.resolve(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('async-generators::promise-construction', () => {
    const code = "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}";
    // Expect node: FUNCTION <createPromise>
    // Expect node: PARAMETER <shouldResolve>
    // Expect node: CALL <new Promise(...)>
    // Expect node: FUNCTION <executor>
    // Expect node: PARAMETER <resolve>
    // Expect node: PARAMETER <reject>
    // Expect node: BRANCH <if-shouldResolve>
    // Expect node: CALL <resolve('success')>
    // Expect node: LITERAL <'success'>
    // Expect node: CALL <reject(new Error('failure'))>
    // Expect node: CALL <new Error('failure')>
    // Expect node: LITERAL <'failure'>
    // Expect edge: <createPromise> -[HAS_BODY]-> <shouldResolve>
    // Expect edge: <createPromise> -[RETURNS]-> <new Promise(...)>
    // Expect edge: <new Promise(...)> -[PASSES_ARGUMENT]-> <executor>
    // Expect edge: <executor> -[HAS_BODY]-> <resolve>
    // Expect edge: <executor> -[HAS_BODY]-> <reject>
    // Expect edge: <executor> -[HAS_BODY]-> <if-shouldResolve>
    // Expect edge: <if-shouldResolve> -[HAS_CONDITION]-> <shouldResolve>
    // Expect edge: <if-shouldResolve> -[HAS_CONSEQUENT]-> <resolve('success')>
    // Expect edge: <resolve('success')> -[PASSES_ARGUMENT]-> <'success'>
    // Expect edge: <reject(new Error('failure'))> -[PASSES_ARGUMENT]-> <new Error('failure')>
    // Expect edge: <new Error('failure')> -[PASSES_ARGUMENT]-> <'failure'>
    void code;
  });

  test('async-generators::async-await-try-catch', () => {
    const code = "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}";
    // Expect node: FUNCTION <fetchWithErrorHandling>
    // Expect node: PARAMETER <url>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url)>
    // Expect node: EXPRESSION <!response.ok>
    // Expect node: PROPERTY_ACCESS <response.ok>
    // Expect node: BRANCH <if-not-ok>
    // Expect node: CALL <new Error>
    // Expect node: LITERAL <`HTTP ${response.status}`>
    // Expect node: PROPERTY_ACCESS <response.status>
    // Expect node: CALL <response.json()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <console.error>
    // Expect node: LITERAL <'Fetch failed:'>
    // Expect node: LITERAL <null>
    // Expect edge: <fetchWithErrorHandling> -[CONTAINS]-> <url>
    // Expect edge: <fetchWithErrorHandling> -[HAS_BODY]-> <try-block>
    // Expect edge: <fetchWithErrorHandling> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <try-block> -[CONTAINS]-> <if-not-ok>
    // Expect edge: <if-not-ok> -[HAS_CONDITION]-> <!response.ok>
    // Expect edge: <new Error> -[PASSES_ARGUMENT]-> <`HTTP ${response.status}`>
    // Expect edge: <try-block> -[RETURNS]-> <response.json()>
    // Expect edge: <catch-block> -[CONTAINS]-> <error>
    // Expect edge: <catch-block> -[CONTAINS]-> <console.error>
    // Expect edge: <console.error> -[PASSES_ARGUMENT]-> <'Fetch failed:'>
    // Expect edge: <console.error> -[PASSES_ARGUMENT]-> <error>
    // Expect edge: <catch-block> -[RETURNS]-> <null>
    // Expect edge: <catch-block> -[CATCHES_FROM]-> <try-block>
    // Expect edge: <fetch(url)> -[AWAITS]-> <fetchWithErrorHandling>
    // Expect edge: <response.json()> -[AWAITS]-> <fetchWithErrorHandling>
    void code;
  });

  test('async-generators::promise-construction', () => {
    const code = "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}";
    // Expect node: FUNCTION <createPromise>
    // Expect node: PARAMETER <shouldResolve>
    // Expect node: CALL <new Promise(...)>
    // Expect node: FUNCTION <executor>
    // Expect node: PARAMETER <resolve>
    // Expect node: PARAMETER <reject>
    // Expect node: BRANCH <if-shouldResolve>
    // Expect node: CALL <resolve('success')>
    // Expect node: LITERAL <'success'>
    // Expect node: CALL <reject(new Error('failure'))>
    // Expect node: CALL <new Error('failure')>
    // Expect node: LITERAL <'failure'>
    // Expect edge: <createPromise> -[HAS_BODY]-> <shouldResolve>
    // Expect edge: <createPromise> -[RETURNS]-> <new Promise(...)>
    // Expect edge: <new Promise(...)> -[PASSES_ARGUMENT]-> <executor>
    // Expect edge: <executor> -[HAS_BODY]-> <resolve>
    // Expect edge: <executor> -[HAS_BODY]-> <reject>
    // Expect edge: <executor> -[HAS_BODY]-> <if-shouldResolve>
    // Expect edge: <if-shouldResolve> -[HAS_CONDITION]-> <shouldResolve>
    // Expect edge: <if-shouldResolve> -[HAS_CONSEQUENT]-> <resolve('success')>
    // Expect edge: <resolve('success')> -[PASSES_ARGUMENT]-> <'success'>
    // Expect edge: <reject(new Error('failure'))> -[PASSES_ARGUMENT]-> <new Error('failure')>
    // Expect edge: <new Error('failure')> -[PASSES_ARGUMENT]-> <'failure'>
    void code;
  });

  test('async-generators::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};";
    // Expect node: VARIABLE <asyncArrow>
    // Expect node: FUNCTION <asyncArrow:fn>
    // Expect node: EXPRESSION <await Promise.resolve(42)>
    // Expect node: CALL <Promise.resolve(42)>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <asyncArrow>
    // Expect edge: <asyncArrow:fn> -[RETURNS]-> <await Promise.resolve(42)>
    // Expect edge: <await Promise.resolve(42)> -[AWAITS]-> <Promise.resolve(42)>
    // Expect edge: <Promise.resolve(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('async-generators::async-await-try-catch', () => {
    const code = "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}";
    // Expect node: FUNCTION <fetchWithErrorHandling>
    // Expect node: PARAMETER <url>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url)>
    // Expect node: EXPRESSION <!response.ok>
    // Expect node: PROPERTY_ACCESS <response.ok>
    // Expect node: BRANCH <if-not-ok>
    // Expect node: CALL <new Error>
    // Expect node: LITERAL <`HTTP ${response.status}`>
    // Expect node: PROPERTY_ACCESS <response.status>
    // Expect node: CALL <response.json()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <console.error>
    // Expect node: LITERAL <'Fetch failed:'>
    // Expect node: LITERAL <null>
    // Expect edge: <fetchWithErrorHandling> -[CONTAINS]-> <url>
    // Expect edge: <fetchWithErrorHandling> -[HAS_BODY]-> <try-block>
    // Expect edge: <fetchWithErrorHandling> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <try-block> -[CONTAINS]-> <if-not-ok>
    // Expect edge: <if-not-ok> -[HAS_CONDITION]-> <!response.ok>
    // Expect edge: <new Error> -[PASSES_ARGUMENT]-> <`HTTP ${response.status}`>
    // Expect edge: <try-block> -[RETURNS]-> <response.json()>
    // Expect edge: <catch-block> -[CONTAINS]-> <error>
    // Expect edge: <catch-block> -[CONTAINS]-> <console.error>
    // Expect edge: <console.error> -[PASSES_ARGUMENT]-> <'Fetch failed:'>
    // Expect edge: <console.error> -[PASSES_ARGUMENT]-> <error>
    // Expect edge: <catch-block> -[RETURNS]-> <null>
    // Expect edge: <catch-block> -[CATCHES_FROM]-> <try-block>
    // Expect edge: <fetch(url)> -[AWAITS]-> <fetchWithErrorHandling>
    // Expect edge: <response.json()> -[AWAITS]-> <fetchWithErrorHandling>
    void code;
  });

  test('async-generators::async-arrow-with-params', () => {
    const code = "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};";
    // Expect node: VARIABLE <asyncArrowWithParams>
    // Expect node: FUNCTION <asyncArrowWithParams:fn>
    // Expect node: PARAMETER <url>
    // Expect node: PARAMETER <options>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url, options)>
    // Expect node: CALL <response.json()>
    // Expect edge: <asyncArrowWithParams:fn> -[CONTAINS]-> <url>
    // Expect edge: <asyncArrowWithParams:fn> -[CONTAINS]-> <options>
    // Expect edge: <asyncArrowWithParams:fn> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url, options)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetch(url, options)> -[PASSES_ARGUMENT]-> <options>
    // Expect edge: <asyncArrowWithParams:fn> -[RETURNS]-> <response.json()>
    // Expect edge: <asyncArrowWithParams:fn> -[AWAITS]-> <fetch(url, options)>
    void code;
  });

  test('async-generators::generator-basic', () => {
    const code = "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}";
    // Expect node: FUNCTION <counter>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i <= end>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <yield i>
    // Expect edge: <counter> -[CONTAINS]-> <start>
    // Expect edge: <counter> -[CONTAINS]-> <end>
    // Expect edge: <counter> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[HAS_INIT]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i <= end>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield i>
    // Expect edge: <counter> -[YIELDS]-> <yield i>
    void code;
  });

  test('async-generators::promise-chaining', () => {
    const code = "function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}";
    // Expect node: FUNCTION <promiseChaining>
    // Expect node: PARAMETER <url>
    // Expect node: CALL <fetch(url)>
    // Expect node: CALL <.then(response => response.json())>
    // Expect node: FUNCTION <response => response.json()>
    // Expect node: PARAMETER <response>
    // Expect node: CALL <response.json()>
    // Expect node: CALL <.then(data => data.result)>
    // Expect node: FUNCTION <data => data.result>
    // Expect node: PARAMETER <data>
    // Expect node: PROPERTY_ACCESS <data.result>
    // Expect node: CALL <.catch(error => console.error(error))>
    // Expect node: FUNCTION <error => console.error(error)>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <console.error(error)>
    // Expect node: CALL <.finally(() => console.log('done'))>
    // Expect node: FUNCTION <() => console.log('done')>
    // Expect node: CALL <console.log('done')>
    // Expect node: LITERAL <'done'>
    // Expect edge: <promiseChaining> -[CONTAINS]-> <url>
    // Expect edge: <promiseChaining> -[RETURNS]-> <fetch(url)>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetch(url)> -[CHAINS_FROM]-> <.then(response => response.json())>
    // Expect edge: <.then(response => response.json())> -[PASSES_ARGUMENT]-> <response => response.json()>
    // Expect edge: <response => response.json()> -[CONTAINS]-> <response>
    // Expect edge: <response => response.json()> -[RETURNS]-> <response.json()>
    // Expect edge: <.then(response => response.json())> -[CHAINS_FROM]-> <.then(data => data.result)>
    // Expect edge: <.then(data => data.result)> -[PASSES_ARGUMENT]-> <data => data.result>
    // Expect edge: <data => data.result> -[CONTAINS]-> <data>
    // Expect edge: <data => data.result> -[RETURNS]-> <data.result>
    // Expect edge: <.then(data => data.result)> -[CHAINS_FROM]-> <.catch(error => console.error(error))>
    // Expect edge: <.catch(error => console.error(error))> -[PASSES_ARGUMENT]-> <error => console.error(error)>
    // Expect edge: <error => console.error(error)> -[CONTAINS]-> <error>
    // Expect edge: <error => console.error(error)> -[RETURNS]-> <console.error(error)>
    // Expect edge: <console.error(error)> -[PASSES_ARGUMENT]-> <error>
    // Expect edge: <.catch(error => console.error(error))> -[CHAINS_FROM]-> <.finally(() => console.log('done'))>
    // Expect edge: <.finally(() => console.log('done'))> -[PASSES_ARGUMENT]-> <() => console.log('done')>
    // Expect edge: <() => console.log('done')> -[RETURNS]-> <console.log('done')>
    // Expect edge: <console.log('done')> -[PASSES_ARGUMENT]-> <'done'>
    void code;
  });

  test('async-generators::async-arrow-with-params', () => {
    const code = "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};";
    // Expect node: VARIABLE <asyncArrowWithParams>
    // Expect node: FUNCTION <asyncArrowWithParams:fn>
    // Expect node: PARAMETER <url>
    // Expect node: PARAMETER <options>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url, options)>
    // Expect node: CALL <response.json()>
    // Expect edge: <asyncArrowWithParams:fn> -[CONTAINS]-> <url>
    // Expect edge: <asyncArrowWithParams:fn> -[CONTAINS]-> <options>
    // Expect edge: <asyncArrowWithParams:fn> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url, options)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetch(url, options)> -[PASSES_ARGUMENT]-> <options>
    // Expect edge: <asyncArrowWithParams:fn> -[RETURNS]-> <response.json()>
    // Expect edge: <asyncArrowWithParams:fn> -[AWAITS]-> <fetch(url, options)>
    void code;
  });

  test('async-generators::generator-basic', () => {
    const code = "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}";
    // Expect node: FUNCTION <counter>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i <= end>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <yield i>
    // Expect edge: <counter> -[CONTAINS]-> <start>
    // Expect edge: <counter> -[CONTAINS]-> <end>
    // Expect edge: <counter> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[HAS_INIT]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i <= end>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield i>
    // Expect edge: <counter> -[YIELDS]-> <yield i>
    void code;
  });

  test('async-generators::promise-chaining', () => {
    const code = "function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}";
    // Expect node: FUNCTION <promiseChaining>
    // Expect node: PARAMETER <url>
    // Expect node: CALL <fetch(url)>
    // Expect node: CALL <.then(response => response.json())>
    // Expect node: FUNCTION <response => response.json()>
    // Expect node: PARAMETER <response>
    // Expect node: CALL <response.json()>
    // Expect node: CALL <.then(data => data.result)>
    // Expect node: FUNCTION <data => data.result>
    // Expect node: PARAMETER <data>
    // Expect node: PROPERTY_ACCESS <data.result>
    // Expect node: CALL <.catch(error => console.error(error))>
    // Expect node: FUNCTION <error => console.error(error)>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <console.error(error)>
    // Expect node: CALL <.finally(() => console.log('done'))>
    // Expect node: FUNCTION <() => console.log('done')>
    // Expect node: CALL <console.log('done')>
    // Expect node: LITERAL <'done'>
    // Expect edge: <promiseChaining> -[CONTAINS]-> <url>
    // Expect edge: <promiseChaining> -[RETURNS]-> <fetch(url)>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetch(url)> -[CHAINS_FROM]-> <.then(response => response.json())>
    // Expect edge: <.then(response => response.json())> -[PASSES_ARGUMENT]-> <response => response.json()>
    // Expect edge: <response => response.json()> -[CONTAINS]-> <response>
    // Expect edge: <response => response.json()> -[RETURNS]-> <response.json()>
    // Expect edge: <.then(response => response.json())> -[CHAINS_FROM]-> <.then(data => data.result)>
    // Expect edge: <.then(data => data.result)> -[PASSES_ARGUMENT]-> <data => data.result>
    // Expect edge: <data => data.result> -[CONTAINS]-> <data>
    // Expect edge: <data => data.result> -[RETURNS]-> <data.result>
    // Expect edge: <.then(data => data.result)> -[CHAINS_FROM]-> <.catch(error => console.error(error))>
    // Expect edge: <.catch(error => console.error(error))> -[PASSES_ARGUMENT]-> <error => console.error(error)>
    // Expect edge: <error => console.error(error)> -[CONTAINS]-> <error>
    // Expect edge: <error => console.error(error)> -[RETURNS]-> <console.error(error)>
    // Expect edge: <console.error(error)> -[PASSES_ARGUMENT]-> <error>
    // Expect edge: <.catch(error => console.error(error))> -[CHAINS_FROM]-> <.finally(() => console.log('done'))>
    // Expect edge: <.finally(() => console.log('done'))> -[PASSES_ARGUMENT]-> <() => console.log('done')>
    // Expect edge: <() => console.log('done')> -[RETURNS]-> <console.log('done')>
    // Expect edge: <console.log('done')> -[PASSES_ARGUMENT]-> <'done'>
    void code;
  });

  test('async-generators::generator-delegation', () => {
    const code = "function* innerGenerator() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* outerGenerator() {\n  yield 1;\n  yield* innerGenerator();\n  yield 2;\n}";
    // Expect node: FUNCTION <innerGenerator>
    // Expect node: LITERAL <'a'>
    // Expect node: LITERAL <'b'>
    // Expect node: FUNCTION <outerGenerator>
    // Expect node: LITERAL <1>
    // Expect node: CALL <innerGenerator()>
    // Expect node: LITERAL <2>
    // Expect edge: <innerGenerator> -[YIELDS]-> <'a'>
    // Expect edge: <innerGenerator> -[YIELDS]-> <'b'>
    // Expect edge: <outerGenerator> -[YIELDS]-> <1>
    // Expect edge: <outerGenerator> -[DELEGATES_TO]-> <innerGenerator()>
    // Expect edge: <outerGenerator> -[YIELDS]-> <2>
    void code;
  });

  test('async-generators::top-level-await', () => {
    const code = "const config = await import('./declarations.js');";
    // Expect node: VARIABLE <config>
    // Expect node: EXPRESSION <await import('./declarations.js')>
    // Expect node: CALL <import('./declarations.js')>
    // Expect node: LITERAL <'./declarations.js'>
    // Expect node: EXTERNAL_MODULE <./declarations.js>
    // Expect edge: <await import('./declarations.js')> -[AWAITS]-> <import('./declarations.js')>
    // Expect edge: <import('./declarations.js')> -[PASSES_ARGUMENT]-> <'./declarations.js'>
    void code;
  });

  test('async-generators::generator-infinite', () => {
    const code = "function* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}";
    // Expect node: FUNCTION <fibonacci>
    // Expect node: VARIABLE <a>
    // Expect node: VARIABLE <b>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <true>
    // Expect node: LOOP <while-true>
    // Expect node: EXPRESSION <yield-a>
    // Expect node: EXPRESSION <a-plus-b>
    // Expect node: EXPRESSION <destructure-array>
    // Expect edge: <fibonacci> -[CONTAINS]-> <a>
    // Expect edge: <fibonacci> -[CONTAINS]-> <b>
    // Expect edge: <fibonacci> -[CONTAINS]-> <while-true>
    // Expect edge: <while-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <while-true> -[CONTAINS]-> <yield-a>
    // Expect edge: <while-true> -[CONTAINS]-> <destructure-array>
    // Expect edge: <fibonacci> -[YIELDS]-> <yield-a>
    void code;
  });

  test('async-generators::async-return-thenable', () => {
    const code = "async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}";
    // Expect node: FUNCTION <returnsThenable>
    // Expect node: EXPRESSION <thenable-object>
    // Expect node: METHOD <then>
    // Expect node: PARAMETER <resolve>
    // Expect node: CALL <resolve(42)>
    // Expect node: LITERAL <42>
    // Expect edge: <returnsThenable> -[RETURNS]-> <thenable-object>
    // Expect edge: <thenable-object> -[HAS_PROPERTY]-> <then>
    // Expect edge: <then> -[HAS_BODY]-> <resolve>
    // Expect edge: <then> -[HAS_BODY]-> <resolve(42)>
    // Expect edge: <resolve(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('async-generators::generator-return-throw', () => {
    const code = "function* generatorReturnThrow() {\n  try {\n    yield 1;\n    yield 2;\n  } finally {\n    yield 'cleanup';\n  }\n}";
    // Expect node: FUNCTION <generatorReturnThrow>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: EXPRESSION <yield 1>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <yield 2>
    // Expect node: LITERAL <2>
    // Expect node: EXPRESSION <yield 'cleanup'>
    // Expect node: LITERAL <'cleanup'>
    // Expect edge: <generatorReturnThrow> -[CONTAINS]-> <try-block>
    // Expect edge: <generatorReturnThrow> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <yield 1>
    // Expect edge: <try-block> -[CONTAINS]-> <yield 2>
    // Expect edge: <yield 1> -[RETURNS]-> <1>
    // Expect edge: <yield 2> -[RETURNS]-> <2>
    // Expect edge: <finally-block> -[CONTAINS]-> <yield 'cleanup'>
    // Expect edge: <yield 'cleanup'> -[RETURNS]-> <'cleanup'>
    void code;
  });

  test('async-generators::async-generator', () => {
    const code = "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}";
    // Expect node: FUNCTION <asyncCounter>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i <= end>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <await new Promise(resolve => setTimeout(resolve, 100))>
    // Expect node: CALL <new Promise(resolve => setTimeout(resolve, 100))>
    // Expect node: FUNCTION <resolve => setTimeout(resolve, 100)>
    // Expect node: PARAMETER <resolve>
    // Expect node: CALL <setTimeout(resolve, 100)>
    // Expect node: LITERAL <100>
    // Expect node: EXPRESSION <yield i>
    // Expect edge: <asyncCounter> -[CONTAINS]-> <start>
    // Expect edge: <asyncCounter> -[CONTAINS]-> <end>
    // Expect edge: <asyncCounter> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[HAS_INIT]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i <= end>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <await new Promise(resolve => setTimeout(resolve, 100))>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield i>
    // Expect edge: <await new Promise(resolve => setTimeout(resolve, 100))> -[AWAITS]-> <new Promise(resolve => setTimeout(resolve, 100))>
    // Expect edge: <new Promise(resolve => setTimeout(resolve, 100))> -[PASSES_ARGUMENT]-> <resolve => setTimeout(resolve, 100)>
    // Expect edge: <resolve => setTimeout(resolve, 100)> -[CONTAINS]-> <resolve>
    // Expect edge: <resolve => setTimeout(resolve, 100)> -[RETURNS]-> <setTimeout(resolve, 100)>
    // Expect edge: <setTimeout(resolve, 100)> -[PASSES_ARGUMENT]-> <resolve>
    // Expect edge: <setTimeout(resolve, 100)> -[PASSES_ARGUMENT]-> <100>
    // Expect edge: <yield i> -[YIELDS]-> <i>
    // Expect edge: <asyncCounter> -[YIELDS]-> <yield i>
    void code;
  });

  test('async-generators::for-await-of', () => {
    const code = "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <consumeAsyncIterable>
    // Expect node: PARAMETER <asyncIterable>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-await-of>
    // Expect node: VARIABLE <item>
    // Expect node: CALL <results.push(item)>
    // Expect edge: <consumeAsyncIterable> -[CONTAINS]-> <asyncIterable>
    // Expect edge: <consumeAsyncIterable> -[CONTAINS]-> <results>
    // Expect edge: <consumeAsyncIterable> -[CONTAINS]-> <for-await-of>
    // Expect edge: <for-await-of> -[ITERATES_OVER]-> <asyncIterable>
    // Expect edge: <for-await-of> -[CONTAINS]-> <item>
    // Expect edge: <for-await-of> -[HAS_BODY]-> <results.push(item)>
    // Expect edge: <results.push(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <consumeAsyncIterable> -[RETURNS]-> <results>
    void code;
  });

  test('async-generators::for-await-of', () => {
    const code = "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <consumeAsyncIterable>
    // Expect node: PARAMETER <asyncIterable>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-await-of>
    // Expect node: VARIABLE <item>
    // Expect node: CALL <results.push(item)>
    // Expect edge: <consumeAsyncIterable> -[CONTAINS]-> <asyncIterable>
    // Expect edge: <consumeAsyncIterable> -[CONTAINS]-> <results>
    // Expect edge: <consumeAsyncIterable> -[CONTAINS]-> <for-await-of>
    // Expect edge: <for-await-of> -[ITERATES_OVER]-> <asyncIterable>
    // Expect edge: <for-await-of> -[CONTAINS]-> <item>
    // Expect edge: <for-await-of> -[HAS_BODY]-> <results.push(item)>
    // Expect edge: <results.push(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <consumeAsyncIterable> -[RETURNS]-> <results>
    void code;
  });

  test('async-generators::generator-finally-cleanup', () => {
    const code = "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}";
    // Expect node: FUNCTION <resourceGenerator>
    // Expect node: VARIABLE <resource>
    // Expect node: LITERAL <{ acquired: true }>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: EXPRESSION <yield resource>
    // Expect node: LITERAL <{ transformed: true }>
    // Expect node: EXPRESSION <yield { transformed: true }>
    // Expect node: PROPERTY_ACCESS <resource.acquired>
    // Expect node: LITERAL <false>
    // Expect edge: <resourceGenerator> -[CONTAINS]-> <resource>
    // Expect edge: <resourceGenerator> -[CONTAINS]-> <try-block>
    // Expect edge: <resourceGenerator> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <yield resource>
    // Expect edge: <try-block> -[CONTAINS]-> <yield { transformed: true }>
    void code;
  });

  test('async-generators::generator-observer-pattern', () => {
    const code = "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---";
    // Expect node: FUNCTION <observer>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: LOOP <while-true>
    // Expect node: LITERAL <true>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <yield>
    // Expect node: CALL <results.push(value)>
    // Expect node: PROPERTY_ACCESS <results.push>
    // Expect edge: <observer> -[CONTAINS]-> <results>
    // Expect edge: <observer> -[CONTAINS]-> <try-block>
    // Expect edge: <observer> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <while-true>
    // Expect edge: <while-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <while-true> -[CONTAINS]-> <value>
    // Expect edge: <while-true> -[CONTAINS]-> <results.push(value)>
    // Expect edge: <results.push(value)> -[PASSES_ARGUMENT]-> <value>
    // Expect edge: <finally-block> -[RETURNS]-> <results>
    void code;
  });

  test('async-generators::top-level-await', () => {
    const code = "const config = await import('./declarations.js');";
    // Expect node: VARIABLE <config>
    // Expect node: EXPRESSION <await import('./declarations.js')>
    // Expect node: CALL <import('./declarations.js')>
    // Expect node: LITERAL <'./declarations.js'>
    // Expect node: EXTERNAL_MODULE <./declarations.js>
    // Expect edge: <await import('./declarations.js')> -[AWAITS]-> <import('./declarations.js')>
    // Expect edge: <import('./declarations.js')> -[PASSES_ARGUMENT]-> <'./declarations.js'>
    void code;
  });

  test('async-generators::generator-two-way', () => {
    const code = "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}";
    // Expect node: FUNCTION <accumulator>
    // Expect node: VARIABLE <total>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <while-true>
    // Expect node: LITERAL <true>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <yield-total>
    // Expect node: EXPRESSION <total += value>
    // Expect edge: <accumulator> -[CONTAINS]-> <total>
    // Expect edge: <accumulator> -[CONTAINS]-> <while-true>
    // Expect edge: <while-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <while-true> -[CONTAINS]-> <value>
    // Expect edge: <while-true> -[CONTAINS]-> <yield-total>
    // Expect edge: <while-true> -[CONTAINS]-> <total += value>
    void code;
  });

  test('async-generators::generator-finally-yield-trap', () => {
    const code = "function* trickyFinally() {\n  try {\n    yield 1;\n  } finally {\n    yield 2; // return() pauses HERE, not at the return point\n  }\n}\n// const g = trickyFinally(); g.next(); g.return('end');\n// → { value: 2, done: false } — NOT 'end'!\n// g.next() → { value: 'end', done: true }\n\n// --- Async iterator cancellation ---";
    // Expect node: FUNCTION <trickyFinally>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: EXPRESSION <yield 1>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <yield 2>
    // Expect node: LITERAL <2>
    // Expect edge: <trickyFinally> -[CONTAINS]-> <try-block>
    // Expect edge: <trickyFinally> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <yield 1>
    // Expect edge: <finally-block> -[CONTAINS]-> <yield 2>
    // Expect edge: <yield 1> -[YIELDS]-> <1>
    // Expect edge: <yield 2> -[YIELDS]-> <2>
    // Expect edge: <try-block> -[HAS_FINALLY]-> <finally-block>
    void code;
  });

  test('async-generators::generator-break-triggers-finally', () => {
    const code = "function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return() → finally runs\n  }\n}";
    // Expect node: FUNCTION <consumeWithBreak>
    // Expect node: PARAMETER <gen>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <item>
    // Expect node: BRANCH <if-transformed>
    // Expect node: PROPERTY_ACCESS <item.transformed>
    // Expect node: EXPRESSION <break>
    // Expect edge: <consumeWithBreak> -[CONTAINS]-> <gen>
    // Expect edge: <consumeWithBreak> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <gen>
    // Expect edge: <for-of> -[CONTAINS]-> <item>
    // Expect edge: <for-of> -[CONTAINS]-> <if-transformed>
    // Expect edge: <if-transformed> -[HAS_CONDITION]-> <item.transformed>
    // Expect edge: <if-transformed> -[HAS_CONSEQUENT]-> <break>
    void code;
  });

  test('async-generators::promise-resolve-thenable', () => {
    const code = "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}";
    // Expect node: FUNCTION <nestedThenable>
    // Expect node: VARIABLE <thenable>
    // Expect node: LITERAL <thenable-object>
    // Expect node: METHOD <thenable.then>
    // Expect node: PARAMETER <resolve>
    // Expect node: CALL <resolve(nested-thenable)>
    // Expect node: LITERAL <nested-thenable-object>
    // Expect node: METHOD <nested-thenable.then>
    // Expect node: PARAMETER <resolve2>
    // Expect node: CALL <resolve2(42)>
    // Expect node: LITERAL <42>
    // Expect node: CALL <Promise.resolve(thenable)>
    // Expect node: EXPRESSION <await Promise.resolve(thenable)>
    // Expect edge: <nestedThenable> -[CONTAINS]-> <thenable>
    // Expect edge: <thenable-object> -[HAS_PROPERTY]-> <thenable.then>
    // Expect edge: <thenable.then> -[RECEIVES_ARGUMENT]-> <resolve>
    // Expect edge: <thenable.then> -[CONTAINS]-> <resolve(nested-thenable)>
    // Expect edge: <resolve(nested-thenable)> -[PASSES_ARGUMENT]-> <nested-thenable-object>
    // Expect edge: <nested-thenable-object> -[HAS_PROPERTY]-> <nested-thenable.then>
    // Expect edge: <nested-thenable.then> -[RECEIVES_ARGUMENT]-> <resolve2>
    // Expect edge: <nested-thenable.then> -[CONTAINS]-> <resolve2(42)>
    // Expect edge: <resolve2(42)> -[PASSES_ARGUMENT]-> <42>
    // Expect edge: <Promise.resolve(thenable)> -[PASSES_ARGUMENT]-> <thenable>
    // Expect edge: <await Promise.resolve(thenable)> -[AWAITS]-> <Promise.resolve(thenable)>
    // Expect edge: <nestedThenable> -[RETURNS]-> <await Promise.resolve(thenable)>
    void code;
  });

  test('async-generators::async-generator', () => {
    const code = "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}";
    // Expect node: FUNCTION <asyncCounter>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i <= end>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <await new Promise(resolve => setTimeout(resolve, 100))>
    // Expect node: CALL <new Promise(resolve => setTimeout(resolve, 100))>
    // Expect node: FUNCTION <resolve => setTimeout(resolve, 100)>
    // Expect node: PARAMETER <resolve>
    // Expect node: CALL <setTimeout(resolve, 100)>
    // Expect node: LITERAL <100>
    // Expect node: EXPRESSION <yield i>
    // Expect edge: <asyncCounter> -[CONTAINS]-> <start>
    // Expect edge: <asyncCounter> -[CONTAINS]-> <end>
    // Expect edge: <asyncCounter> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[HAS_INIT]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i <= end>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <await new Promise(resolve => setTimeout(resolve, 100))>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield i>
    // Expect edge: <await new Promise(resolve => setTimeout(resolve, 100))> -[AWAITS]-> <new Promise(resolve => setTimeout(resolve, 100))>
    // Expect edge: <new Promise(resolve => setTimeout(resolve, 100))> -[PASSES_ARGUMENT]-> <resolve => setTimeout(resolve, 100)>
    // Expect edge: <resolve => setTimeout(resolve, 100)> -[CONTAINS]-> <resolve>
    // Expect edge: <resolve => setTimeout(resolve, 100)> -[RETURNS]-> <setTimeout(resolve, 100)>
    // Expect edge: <setTimeout(resolve, 100)> -[PASSES_ARGUMENT]-> <resolve>
    // Expect edge: <setTimeout(resolve, 100)> -[PASSES_ARGUMENT]-> <100>
    // Expect edge: <yield i> -[YIELDS]-> <i>
    // Expect edge: <asyncCounter> -[YIELDS]-> <yield i>
    void code;
  });

  test('async-generators::yield-star-return-value', () => {
    const code = "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}";
    // Expect node: FUNCTION <innerWithReturn>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <'done'>
    // Expect node: FUNCTION <outerCapturesReturn>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <yield* innerWithReturn()>
    // Expect node: CALL <innerWithReturn()>
    // Expect edge: <innerWithReturn> -[YIELDS]-> <1>
    // Expect edge: <innerWithReturn> -[YIELDS]-> <2>
    // Expect edge: <innerWithReturn> -[RETURNS]-> <'done'>
    // Expect edge: <yield* innerWithReturn()> -[DELEGATES_TO]-> <innerWithReturn()>
    // Expect edge: <outerCapturesReturn> -[YIELDS]-> <result>
    void code;
  });

  test('async-generators::yield-yield-chained', () => {
    const code = "function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---";
    // Expect node: FUNCTION <chainedYield>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <yield yield 1>
    // Expect node: EXPRESSION <inner-yield>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <outer-yield>
    // Expect edge: <chainedYield> -[CONTAINS]-> <result>
    // Expect edge: <chainedYield> -[CONTAINS]-> <yield yield 1>
    // Expect edge: <yield yield 1> -[CONTAINS]-> <outer-yield>
    // Expect edge: <outer-yield> -[YIELDS]-> <inner-yield>
    // Expect edge: <inner-yield> -[YIELDS]-> <1>
    // Expect edge: <chainedYield> -[RETURNS]-> <result>
    void code;
  });

  test('async-generators::for-await-sync-iterable', () => {
    const code = "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array — each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <forAwaitSyncIterable>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-await>
    // Expect node: VARIABLE <item>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: CALL <results.push(item)>
    // Expect node: EXPRESSION <return results>
    // Expect edge: <forAwaitSyncIterable> -[CONTAINS]-> <results>
    // Expect edge: <forAwaitSyncIterable> -[CONTAINS]-> <for-await>
    // Expect edge: <for-await> -[ITERATES_OVER]-> <[1, 2, 3]>
    // Expect edge: <for-await> -[CONTAINS]-> <item>
    // Expect edge: <for-await> -[CONTAINS]-> <results.push(item)>
    // Expect edge: <results.push(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <forAwaitSyncIterable> -[CONTAINS]-> <return results>
    // Expect edge: <forAwaitSyncIterable> -[RETURNS]-> <return results>
    void code;
  });

  test('async-generators::async-iterator-cancel-manual', () => {
    const code = "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}";
    // Expect node: FUNCTION <manualAsyncCancel>
    // Expect node: PARAMETER <asyncGen>
    // Expect node: VARIABLE <iter>
    // Expect node: PROPERTY_ACCESS <asyncGen[Symbol.asyncIterator]>
    // Expect node: CALL <asyncGen[Symbol.asyncIterator]()>
    // Expect node: VARIABLE <first>
    // Expect node: PROPERTY_ACCESS <iter.next>
    // Expect node: CALL <iter.next()>
    // Expect node: PROPERTY_ACCESS <iter.return>
    // Expect node: CALL <iter.return()>
    // Expect node: EXPRESSION <return first>
    // Expect edge: <manualAsyncCancel> -[CONTAINS]-> <asyncGen>
    // Expect edge: <manualAsyncCancel> -[CONTAINS]-> <iter>
    // Expect edge: <manualAsyncCancel> -[CONTAINS]-> <first>
    // Expect edge: <manualAsyncCancel> -[RETURNS]-> <return first>
    void code;
  });

  test('builtins::builtin-json-stringify', () => {
    const code = "function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}";
    // Expect node: FUNCTION <jsonStringify>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <JSON.stringify(obj)>
    // Expect node: PROPERTY_ACCESS <JSON.stringify>
    // Expect node: EXTERNAL <JSON>
    // Expect edge: <module> -[DECLARES]-> <jsonStringify>
    // Expect edge: <jsonStringify> -[CONTAINS]-> <obj>
    // Expect edge: <jsonStringify> -[RETURNS]-> <JSON.stringify(obj)>
    // Expect edge: <JSON.stringify(obj)> -[PASSES_ARGUMENT]-> <obj>
    void code;
  });

  test('async-generators::async-generator-destructure-default', () => {
    const code = "async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---";
    // Expect node: FUNCTION <processStream>
    // Expect node: PARAMETER <source>
    // Expect node: LOOP <for-await-of>
    // Expect node: VARIABLE <data>
    // Expect node: VARIABLE <priority>
    // Expect node: LITERAL <'normal'>
    // Expect node: EXPRESSION <{ ...data, priority }>
    // Expect node: EXPRESSION <yield { ...data, priority }>
    // Expect edge: <processStream> -[HAS_BODY]-> <source>
    // Expect edge: <processStream> -[CONTAINS]-> <for-await-of>
    // Expect edge: <for-await-of> -[ITERATES_OVER]-> <source>
    // Expect edge: <for-await-of> -[CONTAINS]-> <data>
    // Expect edge: <for-await-of> -[CONTAINS]-> <priority>
    // Expect edge: <priority> -[DEFAULTS_TO]-> <'normal'>
    // Expect edge: <{ ...data, priority }> -[SPREADS_FROM]-> <data>
    // Expect edge: <yield { ...data, priority }> -[YIELDS]-> <{ ...data, priority }>
    // Expect edge: <for-await-of> -[CONTAINS]-> <yield { ...data, priority }>
    void code;
  });

  test('builtins::builtin-json-parse', () => {
    const code = "function jsonParse(str) {\n  return JSON.parse(str);\n}";
    // Expect node: FUNCTION <jsonParse>
    // Expect node: PARAMETER <str>
    // Expect node: CALL <JSON.parse(str)>
    // Expect node: PROPERTY_ACCESS <JSON.parse>
    // Expect node: EXTERNAL <JSON>
    // Expect edge: <jsonParse> -[CONTAINS]-> <str>
    // Expect edge: <jsonParse> -[RETURNS]-> <JSON.parse(str)>
    // Expect edge: <JSON.parse(str)> -[PASSES_ARGUMENT]-> <str>
    void code;
  });

  test('async-generators::generator-two-way', () => {
    const code = "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}";
    // Expect node: FUNCTION <accumulator>
    // Expect node: VARIABLE <total>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <while-true>
    // Expect node: LITERAL <true>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <yield-total>
    // Expect node: EXPRESSION <total += value>
    // Expect edge: <accumulator> -[CONTAINS]-> <total>
    // Expect edge: <accumulator> -[CONTAINS]-> <while-true>
    // Expect edge: <while-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <while-true> -[CONTAINS]-> <value>
    // Expect edge: <while-true> -[CONTAINS]-> <yield-total>
    // Expect edge: <while-true> -[CONTAINS]-> <total += value>
    void code;
  });

  test('async-generators::async-iter-manual', () => {
    const code = "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}";
    // Expect node: FUNCTION <manualAsyncIteration>
    // Expect node: PARAMETER <asyncIterable>
    // Expect node: VARIABLE <asyncIter>
    // Expect node: PROPERTY_ACCESS <asyncIterable[Symbol.asyncIterator]>
    // Expect node: CALL <asyncIterable[Symbol.asyncIterator]()>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: VARIABLE <step>
    // Expect node: CALL <asyncIter.next()>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <!step.done>
    // Expect node: PROPERTY_ACCESS <step.done>
    // Expect node: CALL <results.push(step.value)>
    // Expect node: PROPERTY_ACCESS <step.value>
    // Expect node: EXPRESSION <step = await asyncIter.next()>
    // Expect node: CALL <asyncIter.next()#2>
    // Expect node: CALL <asyncIter.return?.()>
    // Expect node: PROPERTY_ACCESS <asyncIter.return>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <asyncIterable>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <asyncIter>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <results>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <step>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <while>
    // Expect edge: <while> -[HAS_CONDITION]-> <!step.done>
    // Expect edge: <while> -[CONTAINS]-> <results.push(step.value)>
    // Expect edge: <results.push(step.value)> -[PASSES_ARGUMENT]-> <step.value>
    // Expect edge: <while> -[CONTAINS]-> <step = await asyncIter.next()>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <asyncIter.return?.()>
    // Expect edge: <manualAsyncIteration> -[RETURNS]-> <results>
    void code;
  });

  test('async-generators::generator-return-throw', () => {
    const code = "function* generatorReturnThrow() {\n  try {\n    yield 1;\n    yield 2;\n  } finally {\n    yield 'cleanup';\n  }\n}";
    // Expect node: FUNCTION <generatorReturnThrow>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: EXPRESSION <yield 1>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <yield 2>
    // Expect node: LITERAL <2>
    // Expect node: EXPRESSION <yield 'cleanup'>
    // Expect node: LITERAL <'cleanup'>
    // Expect edge: <generatorReturnThrow> -[CONTAINS]-> <try-block>
    // Expect edge: <generatorReturnThrow> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <yield 1>
    // Expect edge: <try-block> -[CONTAINS]-> <yield 2>
    // Expect edge: <yield 1> -[RETURNS]-> <1>
    // Expect edge: <yield 2> -[RETURNS]-> <2>
    // Expect edge: <finally-block> -[CONTAINS]-> <yield 'cleanup'>
    // Expect edge: <yield 'cleanup'> -[RETURNS]-> <'cleanup'>
    void code;
  });

  test('async-generators::async-iterator-cancel-break', () => {
    const code = "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}";
    // Expect node: FUNCTION <streamChunks>
    // Expect node: PARAMETER <url>
    // Expect node: VARIABLE <reader>
    // Expect node: LITERAL <{ locked: true }>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <10>
    // Expect node: EXPRESSION <i < 10>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <yield { chunk: i, size: i * 100 }>
    // Expect node: LITERAL <{ chunk: i, size: i * 100 }>
    // Expect node: EXPRESSION <i * 100>
    // Expect node: LITERAL <100>
    // Expect node: PROPERTY_ACCESS <reader.locked>
    // Expect node: LITERAL <false>
    // Expect edge: <streamChunks> -[CONTAINS]-> <url>
    // Expect edge: <streamChunks> -[CONTAINS]-> <reader>
    // Expect edge: <streamChunks> -[CONTAINS]-> <try-block>
    // Expect edge: <streamChunks> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 10>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield { chunk: i, size: i * 100 }>
    // Expect edge: <yield { chunk: i, size: i * 100 }> -[YIELDS]-> <{ chunk: i, size: i * 100 }>
    // Expect edge: <finally-block> -[CONTAINS]-> <reader.locked>
    void code;
  });

  test('builtins::builtin-weakref', () => {
    const code = "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}";
    // Expect node: FUNCTION <weakRefUsage>
    // Expect node: VARIABLE <target>
    // Expect node: LITERAL <{ data: 'important' }>
    // Expect node: VARIABLE <ref>
    // Expect node: CALL <new WeakRef(target)>
    // Expect node: VARIABLE <deref>
    // Expect node: CALL <ref.deref()>
    // Expect node: PROPERTY_ACCESS <deref?.data>
    // Expect edge: <weakRefUsage> -[CONTAINS]-> <target>
    // Expect edge: <weakRefUsage> -[CONTAINS]-> <ref>
    // Expect edge: <weakRefUsage> -[CONTAINS]-> <deref>
    // Expect edge: <new WeakRef(target)> -[PASSES_ARGUMENT]-> <target>
    // Expect edge: <weakRefUsage> -[RETURNS]-> <deref?.data>
    void code;
  });

  test('builtins::builtin-map-constructor', () => {
    const code = "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---";
    // Expect node: FUNCTION <mapFromEntries>
    // Expect node: VARIABLE <map>
    // Expect node: CALL <new Map([...])>
    // Expect node: LITERAL <[['x', 10], ['y', 20]]>
    // Expect node: LITERAL <['x', 10]>
    // Expect node: LITERAL <'x'>
    // Expect node: LITERAL <10>
    // Expect node: LITERAL <['y', 20]>
    // Expect node: LITERAL <'y'>
    // Expect node: LITERAL <20>
    // Expect node: EXTERNAL <Map>
    // Expect edge: <mapFromEntries> -[CONTAINS]-> <map>
    // Expect edge: <new Map([...])> -[PASSES_ARGUMENT]-> <[['x', 10], ['y', 20]]>
    // Expect edge: <[['x', 10], ['y', 20]]> -[HAS_ELEMENT]-> <['x', 10]>
    // Expect edge: <[['x', 10], ['y', 20]]> -[HAS_ELEMENT]-> <['y', 20]>
    // Expect edge: <['x', 10]> -[HAS_ELEMENT]-> <'x'>
    // Expect edge: <['x', 10]> -[HAS_ELEMENT]-> <10>
    // Expect edge: <['y', 20]> -[HAS_ELEMENT]-> <'y'>
    // Expect edge: <['y', 20]> -[HAS_ELEMENT]-> <20>
    // Expect edge: <mapFromEntries> -[RETURNS]-> <map>
    void code;
  });

  test('builtins::builtin-json-parse-reviver', () => {
    const code = "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}";
    // Expect node: FUNCTION <jsonParseReviver>
    // Expect node: PARAMETER <str>
    // Expect node: CALL <JSON.parse(str, reviver)>
    // Expect node: PROPERTY_ACCESS <JSON.parse>
    // Expect node: FUNCTION <reviver>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: BRANCH <if-date-check>
    // Expect node: EXPRESSION <key === 'date'>
    // Expect node: LITERAL <'date'>
    // Expect node: CALL <new Date(value)>
    // Expect node: EXTERNAL <Date>
    // Expect edge: <jsonParseReviver> -[CONTAINS]-> <str>
    // Expect edge: <jsonParseReviver> -[RETURNS]-> <JSON.parse(str, reviver)>
    // Expect edge: <JSON.parse(str, reviver)> -[PASSES_ARGUMENT]-> <str>
    // Expect edge: <JSON.parse(str, reviver)> -[PASSES_ARGUMENT]-> <reviver>
    // Expect edge: <reviver> -[CONTAINS]-> <key>
    // Expect edge: <reviver> -[CONTAINS]-> <value>
    // Expect edge: <reviver> -[CONTAINS]-> <if-date-check>
    // Expect edge: <if-date-check> -[HAS_CONDITION]-> <key === 'date'>
    // Expect edge: <if-date-check> -[HAS_CONSEQUENT]-> <new Date(value)>
    // Expect edge: <new Date(value)> -[PASSES_ARGUMENT]-> <value>
    void code;
  });

  test('async-generators::async-destructure-await-default', () => {
    const code = "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};";
    // Expect node: FUNCTION <getConfigValue>
    // Expect node: PARAMETER <key>
    // Expect node: VARIABLE <asyncDestructureHandler>
    // Expect node: FUNCTION <asyncDestructureHandler:fn>
    // Expect node: PARAMETER <destructured-param>
    // Expect node: PROPERTY <timeout>
    // Expect node: PROPERTY <retries>
    // Expect node: CALL <getConfigValue('timeout')>
    // Expect node: LITERAL <'timeout'>
    // Expect node: CALL <getConfigValue('retries')>
    // Expect node: LITERAL <'retries'>
    // Expect node: EXPRESSION <{ timeout, retries }>
    // Expect edge: <getConfigValue> -[CONTAINS]-> <key>
    // Expect edge: <getConfigValue> -[RETURNS]-> <key>
    // Expect edge: <asyncDestructureHandler:fn> -[CONTAINS]-> <destructured-param>
    // Expect edge: <destructured-param> -[HAS_PROPERTY]-> <timeout>
    // Expect edge: <destructured-param> -[HAS_PROPERTY]-> <retries>
    // Expect edge: <timeout> -[DEFAULTS_TO]-> <getConfigValue('timeout')>
    // Expect edge: <retries> -[DEFAULTS_TO]-> <getConfigValue('retries')>
    // Expect edge: <getConfigValue('timeout')> -[PASSES_ARGUMENT]-> <'timeout'>
    // Expect edge: <getConfigValue('retries')> -[PASSES_ARGUMENT]-> <'retries'>
    // Expect edge: <asyncDestructureHandler:fn> -[RETURNS]-> <{ timeout, retries }>
    // Expect edge: <getConfigValue('timeout')> -[AWAITS]-> <timeout>
    // Expect edge: <getConfigValue('retries')> -[AWAITS]-> <retries>
    void code;
  });

  test('builtins::builtin-json-stringify-replacer', () => {
    const code = "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---";
    // Expect node: FUNCTION <jsonStringifyReplacer>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <JSON.stringify(obj, replacer, 2)>
    // Expect node: PROPERTY_ACCESS <JSON.stringify>
    // Expect node: FUNCTION <replacer>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: EXPRESSION <typeof value === 'function'>
    // Expect node: EXPRESSION <typeof value>
    // Expect node: LITERAL <'function'>
    // Expect node: LITERAL <undefined>
    // Expect node: LITERAL <2>
    // Expect node: BRANCH <if-typeof-function>
    // Expect edge: <jsonStringifyReplacer> -[HAS_BODY]-> <obj>
    // Expect edge: <jsonStringifyReplacer> -[RETURNS]-> <JSON.stringify(obj, replacer, 2)>
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[PASSES_ARGUMENT]-> <replacer>
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[PASSES_ARGUMENT]-> <2>
    // Expect edge: <replacer> -[HAS_BODY]-> <key>
    // Expect edge: <replacer> -[HAS_BODY]-> <value>
    // Expect edge: <replacer> -[HAS_BODY]-> <if-typeof-function>
    // Expect edge: <if-typeof-function> -[HAS_CONDITION]-> <typeof value === 'function'>
    // Expect edge: <if-typeof-function> -[HAS_CONSEQUENT]-> <undefined>
    void code;
  });

  test('builtins::builtin-weakset', () => {
    const code = "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---";
    // Expect node: FUNCTION <weakSetUsage>
    // Expect node: VARIABLE <ws>
    // Expect node: CALL <new WeakSet()>
    // Expect node: VARIABLE <obj1>
    // Expect node: LITERAL <{}>
    // Expect node: VARIABLE <obj2>
    // Expect node: LITERAL <{}2>
    // Expect node: CALL <ws.add(obj1)>
    // Expect node: VARIABLE <has>
    // Expect node: CALL <ws.has(obj1)>
    // Expect node: CALL <ws.delete(obj1)>
    // Expect node: VARIABLE <hasAfter>
    // Expect node: CALL <ws.has(obj1)2>
    // Expect node: EXPRESSION <{ has, hasAfter }>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <ws>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <obj1>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <obj2>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <has>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <hasAfter>
    // Expect edge: <ws.add(obj1)> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <ws.has(obj1)> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <ws.delete(obj1)> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <ws.has(obj1)2> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <weakSetUsage> -[RETURNS]-> <{ has, hasAfter }>
    void code;
  });

  test('builtins::builtin-globalthis', () => {
    const code = "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---";
    // Expect node: FUNCTION <globalThisAccess>
    // Expect node: VARIABLE <g>
    // Expect node: EXTERNAL <globalThis>
    // Expect node: VARIABLE <hasConsole>
    // Expect node: EXPRESSION <'console' in globalThis>
    // Expect node: LITERAL <'console'>
    // Expect node: EXPRESSION <{ g, hasConsole }>
    // Expect edge: <globalThisAccess> -[CONTAINS]-> <g>
    // Expect edge: <globalThisAccess> -[CONTAINS]-> <hasConsole>
    // Expect edge: <globalThisAccess> -[RETURNS]-> <{ g, hasConsole }>
    void code;
  });

  test('async-generators::async-return-thenable', () => {
    const code = "async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}";
    // Expect node: FUNCTION <returnsThenable>
    // Expect node: EXPRESSION <thenable-object>
    // Expect node: METHOD <then>
    // Expect node: PARAMETER <resolve>
    // Expect node: CALL <resolve(42)>
    // Expect node: LITERAL <42>
    // Expect edge: <returnsThenable> -[RETURNS]-> <thenable-object>
    // Expect edge: <thenable-object> -[HAS_PROPERTY]-> <then>
    // Expect edge: <then> -[HAS_BODY]-> <resolve>
    // Expect edge: <then> -[HAS_BODY]-> <resolve(42)>
    // Expect edge: <resolve(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('builtins::builtin-finalization-registry', () => {
    const code = "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---";
    // Expect node: FUNCTION <finalizationUsage>
    // Expect node: VARIABLE <registry>
    // Expect node: CALL <new FinalizationRegistry(...)>
    // Expect node: FUNCTION <cleanup-callback>
    // Expect node: PARAMETER <heldValue>
    // Expect node: CALL <console.log(...)>
    // Expect node: EXPRESSION <`Cleaned up: ${heldValue}`>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ id: 1 }>
    // Expect node: CALL <registry.register(obj, 'resource-1')>
    // Expect node: LITERAL <'resource-1'>
    // Expect edge: <finalizationUsage> -[CONTAINS]-> <registry>
    // Expect edge: <finalizationUsage> -[CONTAINS]-> <obj>
    // Expect edge: <new FinalizationRegistry(...)> -[PASSES_ARGUMENT]-> <cleanup-callback>
    // Expect edge: <cleanup-callback> -[CONTAINS]-> <heldValue>
    // Expect edge: <cleanup-callback> -[CONTAINS]-> <console.log(...)>
    // Expect edge: <console.log(...)> -[PASSES_ARGUMENT]-> <`Cleaned up: ${heldValue}`>
    // Expect edge: <finalizationUsage> -[CONTAINS]-> <registry.register(obj, 'resource-1')>
    // Expect edge: <registry.register(obj, 'resource-1')> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <registry.register(obj, 'resource-1')> -[PASSES_ARGUMENT]-> <'resource-1'>
    // Expect edge: <finalizationUsage> -[RETURNS]-> <obj>
    void code;
  });

  test('builtins::regex-lookahead', () => {
    const code = "const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;";
    // Expect node: VARIABLE <posLookahead>
    // Expect node: LITERAL </\d+(?=px)/>
    // Expect node: VARIABLE <negLookahead>
    // Expect node: LITERAL </\d+(?!px)/>
    // Expect edge: <module> -[DECLARES]-> <posLookahead>
    // Expect edge: <module> -[DECLARES]-> <negLookahead>
    void code;
  });

  test('builtins::builtin-regex-named-groups', () => {
    const code = "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---";
    // Expect node: FUNCTION <regexNamedGroups>
    // Expect node: PARAMETER <dateStr>
    // Expect node: VARIABLE <pattern>
    // Expect node: LITERAL </(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/>
    // Expect node: VARIABLE <match>
    // Expect node: CALL <dateStr.match(pattern)>
    // Expect node: BRANCH <if (!match)>
    // Expect node: LITERAL <null>
    // Expect node: VARIABLE <year>
    // Expect node: VARIABLE <month>
    // Expect node: VARIABLE <day>
    // Expect node: PROPERTY_ACCESS <match.groups>
    // Expect node: EXPRESSION <{ year, month, day }>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <dateStr>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <pattern>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <match>
    // Expect edge: <dateStr.match(pattern)> -[PASSES_ARGUMENT]-> <pattern>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <if (!match)>
    // Expect edge: <if (!match)> -[HAS_CONDITION]-> <match>
    // Expect edge: <if (!match)> -[HAS_CONSEQUENT]-> <null>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <year>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <month>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <day>
    // Expect edge: <regexNamedGroups> -[RETURNS]-> <{ year, month, day }>
    void code;
  });

  test('builtins::regex-lookbehind', () => {
    const code = "const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;";
    // Expect node: VARIABLE <posLookbehind>
    // Expect node: LITERAL </(?<=\$)\d+/>
    // Expect node: VARIABLE <negLookbehind>
    // Expect node: LITERAL </(?<!\$)\d+/>
    // Expect edge: <module> -[DECLARES]-> <posLookbehind>
    // Expect edge: <module> -[DECLARES]-> <negLookbehind>
    void code;
  });

  test('builtins::builtin-regex-exec', () => {
    const code = "function regexExec(pattern, str) {\n  const regex = new RegExp(pattern, 'g');\n  const matches = [];\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    matches.push({ match: match[0], index: match.index });\n  }\n  return matches;\n}";
    // Expect node: FUNCTION <regexExec>
    // Expect node: PARAMETER <pattern>
    // Expect node: PARAMETER <str>
    // Expect node: VARIABLE <regex>
    // Expect node: CALL <new RegExp(pattern, 'g')>
    // Expect node: LITERAL <'g'>
    // Expect node: VARIABLE <matches>
    // Expect node: LITERAL <[]>
    // Expect node: VARIABLE <match>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <(match = regex.exec(str)) !== null>
    // Expect node: EXPRESSION <match = regex.exec(str)>
    // Expect node: CALL <regex.exec(str)>
    // Expect node: LITERAL <null>
    // Expect node: CALL <matches.push({ match: match[0], index: match.index })>
    // Expect node: LITERAL <{ match: match[0], index: match.index }>
    // Expect node: PROPERTY_ACCESS <match[0]>
    // Expect node: PROPERTY_ACCESS <match.index>
    // Expect edge: <regexExec> -[CONTAINS]-> <pattern>
    // Expect edge: <regexExec> -[CONTAINS]-> <str>
    // Expect edge: <regexExec> -[CONTAINS]-> <regex>
    // Expect edge: <regexExec> -[CONTAINS]-> <matches>
    // Expect edge: <regexExec> -[CONTAINS]-> <match>
    // Expect edge: <regexExec> -[CONTAINS]-> <while>
    // Expect edge: <new RegExp(pattern, 'g')> -[PASSES_ARGUMENT]-> <pattern>
    // Expect edge: <new RegExp(pattern, 'g')> -[PASSES_ARGUMENT]-> <'g'>
    // Expect edge: <while> -[HAS_CONDITION]-> <(match = regex.exec(str)) !== null>
    // Expect edge: <regex.exec(str)> -[PASSES_ARGUMENT]-> <str>
    // Expect edge: <while> -[HAS_BODY]-> <matches.push({ match: match[0], index: match.index })>
    // Expect edge: <matches.push({ match: match[0], index: match.index })> -[PASSES_ARGUMENT]-> <{ match: match[0], index: match.index }>
    // Expect edge: <regexExec> -[RETURNS]-> <matches>
    void code;
  });

  test('async-generators::async-iter-manual', () => {
    const code = "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}";
    // Expect node: FUNCTION <manualAsyncIteration>
    // Expect node: PARAMETER <asyncIterable>
    // Expect node: VARIABLE <asyncIter>
    // Expect node: PROPERTY_ACCESS <asyncIterable[Symbol.asyncIterator]>
    // Expect node: CALL <asyncIterable[Symbol.asyncIterator]()>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: VARIABLE <step>
    // Expect node: CALL <asyncIter.next()>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <!step.done>
    // Expect node: PROPERTY_ACCESS <step.done>
    // Expect node: CALL <results.push(step.value)>
    // Expect node: PROPERTY_ACCESS <step.value>
    // Expect node: EXPRESSION <step = await asyncIter.next()>
    // Expect node: CALL <asyncIter.next()#2>
    // Expect node: CALL <asyncIter.return?.()>
    // Expect node: PROPERTY_ACCESS <asyncIter.return>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <asyncIterable>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <asyncIter>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <results>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <step>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <while>
    // Expect edge: <while> -[HAS_CONDITION]-> <!step.done>
    // Expect edge: <while> -[CONTAINS]-> <results.push(step.value)>
    // Expect edge: <results.push(step.value)> -[PASSES_ARGUMENT]-> <step.value>
    // Expect edge: <while> -[CONTAINS]-> <step = await asyncIter.next()>
    // Expect edge: <manualAsyncIteration> -[CONTAINS]-> <asyncIter.return?.()>
    // Expect edge: <manualAsyncIteration> -[RETURNS]-> <results>
    void code;
  });

  test('builtins::string-raw-template', () => {
    const code = "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file' — no escape processing";
    // Expect node: VARIABLE <windowsPath>
    // Expect node: CALL <String.raw`C:\Users\name\file`>
    // Expect node: PROPERTY_ACCESS <String.raw>
    // Expect node: LITERAL <String>
    // Expect node: LITERAL <template-literal>
    // Expect edge: <module> -[DECLARES]-> <windowsPath>
    // Expect edge: <String.raw`C:\Users\name\file`> -[PASSES_ARGUMENT]-> <template-literal>
    void code;
  });

  test('builtins::regex-unicode-props', () => {
    const code = "const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;";
    // Expect node: VARIABLE <emoji>
    // Expect node: LITERAL </\p{Emoji}/u>
    // Expect node: VARIABLE <greek>
    // Expect node: LITERAL </\p{Script=Greek}/u>
    // Expect node: VARIABLE <letter>
    // Expect node: LITERAL </\p{Letter}/u>
    // Expect edge: <MODULE> -[DECLARES]-> <emoji>
    // Expect edge: <MODULE> -[DECLARES]-> <greek>
    // Expect edge: <MODULE> -[DECLARES]-> <letter>
    void code;
  });

  test('builtins::array-from-mapfn', () => {
    const code = "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---";
    // Expect node: FUNCTION <arrayFromMapFn>
    // Expect node: VARIABLE <indices>
    // Expect node: CALL <Array.from({ length: 5 }, (_, i) => i)>
    // Expect node: LITERAL <{ length: 5 }>
    // Expect node: FUNCTION <(_, i) => i>
    // Expect node: PARAMETER <_>
    // Expect node: PARAMETER <i>
    // Expect edge: <arrayFromMapFn> -[CONTAINS]-> <indices>
    // Expect edge: <Array.from({ length: 5 }, (_, i) => i)> -[PASSES_ARGUMENT]-> <{ length: 5 }>
    // Expect edge: <Array.from({ length: 5 }, (_, i) => i)> -[PASSES_ARGUMENT]-> <(_, i) => i>
    // Expect edge: <(_, i) => i> -[CONTAINS]-> <_>
    // Expect edge: <(_, i) => i> -[CONTAINS]-> <i>
    // Expect edge: <(_, i) => i> -[RETURNS]-> <i>
    // Expect edge: <arrayFromMapFn> -[RETURNS]-> <indices>
    void code;
  });

  test('callbacks::callback-error-first', () => {
    const code = "function readFileCallback(path, callback) {\n  try {\n    const data = `contents of ${path}`;\n    callback(null, data);\n  } catch (err) {\n    callback(err, null);\n  }\n}";
    // Expect node: FUNCTION <readFileCallback>
    // Expect node: PARAMETER <path>
    // Expect node: PARAMETER <callback>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: VARIABLE <data>
    // Expect node: EXPRESSION <`contents of ${path}`>
    // Expect node: CALL <callback(null, data)>
    // Expect node: LITERAL <null>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <callback(err, null)>
    // Expect edge: <readFileCallback> -[CONTAINS]-> <path>
    // Expect edge: <readFileCallback> -[CONTAINS]-> <callback>
    // Expect edge: <readFileCallback> -[HAS_BODY]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <data>
    // Expect edge: <try-block> -[CONTAINS]-> <callback(null, data)>
    // Expect edge: <callback(null, data)> -[PASSES_ARGUMENT]-> <null>
    // Expect edge: <callback(null, data)> -[PASSES_ARGUMENT]-> <data>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <err>
    // Expect edge: <catch-block> -[CONTAINS]-> <callback(err, null)>
    // Expect edge: <callback(err, null)> -[PASSES_ARGUMENT]-> <err>
    // Expect edge: <callback(err, null)> -[PASSES_ARGUMENT]-> <null>
    void code;
  });

  test('async-generators::promise-resolve-thenable', () => {
    const code = "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}";
    // Expect node: FUNCTION <nestedThenable>
    // Expect node: VARIABLE <thenable>
    // Expect node: LITERAL <thenable-object>
    // Expect node: METHOD <thenable.then>
    // Expect node: PARAMETER <resolve>
    // Expect node: CALL <resolve(nested-thenable)>
    // Expect node: LITERAL <nested-thenable-object>
    // Expect node: METHOD <nested-thenable.then>
    // Expect node: PARAMETER <resolve2>
    // Expect node: CALL <resolve2(42)>
    // Expect node: LITERAL <42>
    // Expect node: CALL <Promise.resolve(thenable)>
    // Expect node: EXPRESSION <await Promise.resolve(thenable)>
    // Expect edge: <nestedThenable> -[CONTAINS]-> <thenable>
    // Expect edge: <thenable-object> -[HAS_PROPERTY]-> <thenable.then>
    // Expect edge: <thenable.then> -[RECEIVES_ARGUMENT]-> <resolve>
    // Expect edge: <thenable.then> -[CONTAINS]-> <resolve(nested-thenable)>
    // Expect edge: <resolve(nested-thenable)> -[PASSES_ARGUMENT]-> <nested-thenable-object>
    // Expect edge: <nested-thenable-object> -[HAS_PROPERTY]-> <nested-thenable.then>
    // Expect edge: <nested-thenable.then> -[RECEIVES_ARGUMENT]-> <resolve2>
    // Expect edge: <nested-thenable.then> -[CONTAINS]-> <resolve2(42)>
    // Expect edge: <resolve2(42)> -[PASSES_ARGUMENT]-> <42>
    // Expect edge: <Promise.resolve(thenable)> -[PASSES_ARGUMENT]-> <thenable>
    // Expect edge: <await Promise.resolve(thenable)> -[AWAITS]-> <Promise.resolve(thenable)>
    // Expect edge: <nestedThenable> -[RETURNS]-> <await Promise.resolve(thenable)>
    void code;
  });

  test('callbacks::callback-error-first-usage', () => {
    const code = "function processFile(path) {\n  readFileCallback(path, function (err, data) {\n    if (err) {\n      console.error('Failed:', err);\n      return;\n    }\n    console.log('Data:', data);\n  });\n}\n\n// --- Callback hell (3+ levels) ---";
    // Expect node: FUNCTION <processFile>
    // Expect node: PARAMETER <path>
    // Expect node: CALL <readFileCallback(path, callback)>
    // Expect node: FUNCTION <callback>
    // Expect node: PARAMETER <err>
    // Expect node: PARAMETER <data>
    // Expect node: BRANCH <if-err>
    // Expect node: CALL <console.error('Failed:', err)>
    // Expect node: LITERAL <'Failed:'>
    // Expect node: CALL <console.log('Data:', data)>
    // Expect node: LITERAL <'Data:'>
    // Expect edge: <processFile> -[HAS_BODY]-> <path>
    // Expect edge: <processFile> -[HAS_BODY]-> <readFileCallback(path, callback)>
    // Expect edge: <readFileCallback(path, callback)> -[PASSES_ARGUMENT]-> <path>
    // Expect edge: <readFileCallback(path, callback)> -[PASSES_ARGUMENT]-> <callback>
    // Expect edge: <callback> -[HAS_BODY]-> <err>
    // Expect edge: <callback> -[HAS_BODY]-> <data>
    // Expect edge: <callback> -[HAS_BODY]-> <if-err>
    // Expect edge: <if-err> -[HAS_CONDITION]-> <err>
    // Expect edge: <if-err> -[HAS_CONSEQUENT]-> <console.error('Failed:', err)>
    // Expect edge: <console.error('Failed:', err)> -[PASSES_ARGUMENT]-> <'Failed:'>
    // Expect edge: <console.error('Failed:', err)> -[PASSES_ARGUMENT]-> <err>
    // Expect edge: <console.log('Data:', data)> -[PASSES_ARGUMENT]-> <'Data:'>
    // Expect edge: <console.log('Data:', data)> -[PASSES_ARGUMENT]-> <data>
    void code;
  });

  test('callbacks::callback-settimeout', () => {
    const code = "function delayedExecution(fn, ms) {\n  const id = setTimeout(fn, ms);\n  return function cancel() {\n    clearTimeout(id);\n  };\n}";
    // Expect node: FUNCTION <delayedExecution>
    // Expect node: PARAMETER <fn>
    // Expect node: PARAMETER <ms>
    // Expect node: VARIABLE <id>
    // Expect node: CALL <setTimeout(fn, ms)>
    // Expect node: EXTERNAL <setTimeout>
    // Expect node: FUNCTION <cancel>
    // Expect node: CALL <clearTimeout(id)>
    // Expect node: EXTERNAL <clearTimeout>
    // Expect edge: <delayedExecution> -[HAS_BODY]-> <fn>
    // Expect edge: <delayedExecution> -[HAS_BODY]-> <ms>
    // Expect edge: <delayedExecution> -[HAS_BODY]-> <id>
    // Expect edge: <setTimeout(fn, ms)> -[PASSES_ARGUMENT]-> <fn>
    // Expect edge: <setTimeout(fn, ms)> -[PASSES_ARGUMENT]-> <ms>
    // Expect edge: <delayedExecution> -[RETURNS]-> <cancel>
    // Expect edge: <cancel> -[HAS_BODY]-> <clearTimeout(id)>
    // Expect edge: <clearTimeout(id)> -[PASSES_ARGUMENT]-> <id>
    void code;
  });

  test('builtins::symbol-private-property', () => {
    const code = "const _private = Symbol('private');\nclass SymbolStore {\n  [_private] = new Map();\n  set(key, value) { this[_private].set(key, value); }\n  get(key) { return this[_private].get(key); }\n}";
    // Expect node: VARIABLE <_private>
    // Expect node: CALL <Symbol('private')>
    // Expect node: LITERAL <'private'>
    // Expect node: CLASS <SymbolStore>
    // Expect node: PROPERTY <SymbolStore[_private]>
    // Expect node: CALL <new Map()>
    // Expect node: METHOD <SymbolStore.set>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: PROPERTY_ACCESS <this[_private]>
    // Expect node: CALL <this[_private].set(key, value)>
    // Expect node: METHOD <SymbolStore.get>
    // Expect node: PARAMETER <key2>
    // Expect node: PROPERTY_ACCESS <this[_private]2>
    // Expect node: CALL <this[_private].get(key)>
    // Expect edge: <Symbol('private')> -[PASSES_ARGUMENT]-> <'private'>
    // Expect edge: <SymbolStore> -[CONTAINS]-> <SymbolStore[_private]>
    // Expect edge: <SymbolStore[_private]> -[USES]-> <_private>
    // Expect edge: <SymbolStore> -[CONTAINS]-> <SymbolStore.set>
    // Expect edge: <SymbolStore.set> -[CONTAINS]-> <key>
    // Expect edge: <SymbolStore.set> -[CONTAINS]-> <value>
    // Expect edge: <SymbolStore.set> -[CONTAINS]-> <this[_private].set(key, value)>
    // Expect edge: <this[_private].set(key, value)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <this[_private].set(key, value)> -[PASSES_ARGUMENT]-> <value>
    // Expect edge: <SymbolStore> -[CONTAINS]-> <SymbolStore.get>
    // Expect edge: <SymbolStore.get> -[CONTAINS]-> <key2>
    // Expect edge: <SymbolStore.get> -[RETURNS]-> <this[_private].get(key)>
    // Expect edge: <this[_private].get(key)> -[PASSES_ARGUMENT]-> <key2>
    void code;
  });

  test('async-generators::generator-observer-pattern', () => {
    const code = "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---";
    // Expect node: FUNCTION <observer>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: LOOP <while-true>
    // Expect node: LITERAL <true>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <yield>
    // Expect node: CALL <results.push(value)>
    // Expect node: PROPERTY_ACCESS <results.push>
    // Expect node: EXPRESSION <return results>
    // Expect edge: <observer> -[CONTAINS]-> <results>
    // Expect edge: <observer> -[CONTAINS]-> <try-block>
    // Expect edge: <observer> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <while-true>
    // Expect edge: <while-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <while-true> -[CONTAINS]-> <value>
    // Expect edge: <while-true> -[CONTAINS]-> <results.push(value)>
    // Expect edge: <results.push(value)> -[PASSES_ARGUMENT]-> <value>
    // Expect edge: <finally-block> -[CONTAINS]-> <return results>
    // Expect edge: <observer> -[RETURNS]-> <return results>
    void code;
  });

  test('callbacks::callback-promisify-usage', () => {
    const code = "const readFileAsync = promisify(readFileCallback);\n\n// --- Array callback patterns ---";
    // Expect node: VARIABLE <readFileAsync>
    // Expect node: CALL <promisify(readFileCallback)>
    // Expect edge: <module> -[DECLARES]-> <readFileAsync>
    // Expect edge: <promisify(readFileCallback)> -[PASSES_ARGUMENT]-> <readFileCallback>
    void code;
  });

  test('callbacks::callback-higher-order', () => {
    const code = "function retry(fn, attempts, callback) {\n  fn(function (err, result) {\n    if (err && attempts > 1) {\n      retry(fn, attempts - 1, callback);\n    } else {\n      callback(err, result);\n    }\n  });\n}";
    // Expect node: FUNCTION <retry>
    // Expect node: PARAMETER <fn>
    // Expect node: PARAMETER <attempts>
    // Expect node: PARAMETER <callback>
    // Expect node: FUNCTION <anonymous-callback>
    // Expect node: PARAMETER <err>
    // Expect node: PARAMETER <result>
    // Expect node: BRANCH <if-err-attempts>
    // Expect node: EXPRESSION <err && attempts > 1>
    // Expect node: EXPRESSION <attempts > 1>
    // Expect node: LITERAL <1>
    // Expect node: CALL <retry-recursive>
    // Expect node: EXPRESSION <attempts - 1>
    // Expect node: CALL <callback-call>
    // Expect node: CALL <fn-call>
    // Expect edge: <retry> -[CONTAINS]-> <fn>
    // Expect edge: <retry> -[CONTAINS]-> <attempts>
    // Expect edge: <retry> -[CONTAINS]-> <callback>
    // Expect edge: <retry> -[CONTAINS]-> <fn-call>
    // Expect edge: <fn-call> -[PASSES_ARGUMENT]-> <anonymous-callback>
    // Expect edge: <anonymous-callback> -[CONTAINS]-> <err>
    // Expect edge: <anonymous-callback> -[CONTAINS]-> <result>
    // Expect edge: <anonymous-callback> -[CONTAINS]-> <if-err-attempts>
    // Expect edge: <if-err-attempts> -[HAS_CONDITION]-> <err && attempts > 1>
    // Expect edge: <if-err-attempts> -[HAS_CONSEQUENT]-> <retry-recursive>
    // Expect edge: <retry-recursive> -[PASSES_ARGUMENT]-> <fn>
    // Expect edge: <retry-recursive> -[PASSES_ARGUMENT]-> <attempts - 1>
    // Expect edge: <retry-recursive> -[PASSES_ARGUMENT]-> <callback>
    // Expect edge: <callback-call> -[PASSES_ARGUMENT]-> <err>
    // Expect edge: <callback-call> -[PASSES_ARGUMENT]-> <result>
    void code;
  });

  test('builtins::sparse-array', () => {
    const code = "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false — hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}";
    // Expect node: FUNCTION <sparseArrayOps>
    // Expect node: VARIABLE <sparse>
    // Expect node: LITERAL <sparse-array>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <3>
    // Expect node: LITERAL <5>
    // Expect node: VARIABLE <length>
    // Expect node: PROPERTY_ACCESS <sparse.length>
    // Expect node: VARIABLE <hasIndex1>
    // Expect node: EXPRESSION <1 in sparse>
    // Expect node: LITERAL <1-key>
    // Expect node: VARIABLE <mapped>
    // Expect node: CALL <sparse.map(x => x * 2)>
    // Expect node: FUNCTION <map-callback>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect node: EXPRESSION <return-object>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <sparse>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <length>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <hasIndex1>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <mapped>
    // Expect edge: <sparse-array> -[HAS_ELEMENT]-> <1>
    // Expect edge: <sparse-array> -[HAS_ELEMENT]-> <3>
    // Expect edge: <sparse-array> -[HAS_ELEMENT]-> <5>
    // Expect edge: <sparse.map(x => x * 2)> -[PASSES_ARGUMENT]-> <map-callback>
    // Expect edge: <map-callback> -[CONTAINS]-> <x>
    // Expect edge: <map-callback> -[RETURNS]-> <x * 2>
    // Expect edge: <sparseArrayOps> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <length>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <hasIndex1>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <mapped>
    void code;
  });

  test('callbacks::callback-microtask', () => {
    const code = "function withMicrotask(fn) {\n  queueMicrotask(() => {\n    fn();\n  });\n}\n\n// --- Promisify ---";
    // Expect node: FUNCTION <withMicrotask>
    // Expect node: PARAMETER <fn>
    // Expect node: CALL <queueMicrotask(...)>
    // Expect node: FUNCTION <microtask-callback>
    // Expect node: CALL <fn()>
    // Expect edge: <withMicrotask> -[HAS_BODY]-> <fn>
    // Expect edge: <withMicrotask> -[HAS_BODY]-> <queueMicrotask(...)>
    // Expect edge: <queueMicrotask(...)> -[PASSES_ARGUMENT]-> <microtask-callback>
    // Expect edge: <microtask-callback> -[HAS_BODY]-> <fn()>
    void code;
  });

  test('cjs-patterns::require-simple', () => {
    const code = "const fs = require('fs');";
    // Expect node: VARIABLE <fs>
    // Expect node: CALL <require('fs')>
    // Expect node: LITERAL <'fs'>
    // Expect node: EXTERNAL_MODULE <fs-module>
    // Expect edge: <require('fs')> -[PASSES_ARGUMENT]-> <'fs'>
    void code;
  });

  test('cjs-patterns::require-destructured', () => {
    const code = "const { readFile, writeFile } = require('fs/promises');";
    // Expect node: VARIABLE <readFile>
    // Expect node: VARIABLE <writeFile>
    // Expect node: CALL <require('fs/promises')>
    // Expect node: LITERAL <'fs/promises'>
    // Expect node: EXTERNAL_MODULE <fs/promises>
    // Expect edge: <module> -[DECLARES]-> <readFile>
    // Expect edge: <module> -[DECLARES]-> <writeFile>
    // Expect edge: <require('fs/promises')> -[PASSES_ARGUMENT]-> <'fs/promises'>
    void code;
  });

  test('callbacks::callback-thisarg-filter', () => {
    const code = "class Validator {\n  threshold = 10;\n  filter(items) {\n    return items.filter(function(item) {\n      return item > this.threshold;\n    }, this);\n  }\n}";
    // Expect node: CLASS <Validator>
    // Expect node: PROPERTY <Validator.threshold>
    // Expect node: LITERAL <10>
    // Expect node: METHOD <Validator.filter>
    // Expect node: PARAMETER <items>
    // Expect node: CALL <items.filter(...)>
    // Expect node: FUNCTION <filter-callback>
    // Expect node: PARAMETER <item>
    // Expect node: EXPRESSION <item > this.threshold>
    // Expect node: PROPERTY_ACCESS <this.threshold>
    // Expect edge: <Validator> -[CONTAINS]-> <Validator.threshold>
    // Expect edge: <Validator> -[CONTAINS]-> <Validator.filter>
    // Expect edge: <Validator.filter> -[CONTAINS]-> <items>
    // Expect edge: <Validator.filter> -[RETURNS]-> <items.filter(...)>
    // Expect edge: <items.filter(...)> -[PASSES_ARGUMENT]-> <filter-callback>
    // Expect edge: <items.filter(...)> -[BINDS_THIS_TO]-> <Validator>
    // Expect edge: <filter-callback> -[CONTAINS]-> <item>
    // Expect edge: <filter-callback> -[RETURNS]-> <item > this.threshold>
    void code;
  });

  test('cjs-patterns::cjs-class-decl', () => {
    const code = "class CjsClass {\n  method() {\n    return true;\n  }\n}";
    // Expect node: CLASS <CjsClass>
    // Expect node: METHOD <CjsClass.method>
    // Expect node: LITERAL <true>
    // Expect edge: <module> -[DECLARES]-> <CjsClass>
    // Expect edge: <CjsClass> -[CONTAINS]-> <CjsClass.method>
    // Expect edge: <CjsClass.method> -[RETURNS]-> <true>
    void code;
  });

  test('callbacks::callback-thisarg-map', () => {
    const code = "class Processor {\n  multiplier = 3;\n  process(items) {\n    return items.map(function(item) {\n      return item * this.multiplier; // `this` = Processor instance via thisArg\n    }, this);\n  }\n}";
    // Expect node: CLASS <Processor>
    // Expect node: PROPERTY <Processor.multiplier>
    // Expect node: LITERAL <3>
    // Expect node: METHOD <Processor.process>
    // Expect node: PARAMETER <items>
    // Expect node: CALL <items.map(...)>
    // Expect node: FUNCTION <map-callback>
    // Expect node: PARAMETER <item>
    // Expect node: EXPRESSION <item * this.multiplier>
    // Expect node: PROPERTY_ACCESS <this.multiplier>
    // Expect edge: <Processor> -[CONTAINS]-> <Processor.multiplier>
    // Expect edge: <Processor> -[CONTAINS]-> <Processor.process>
    // Expect edge: <Processor.process> -[CONTAINS]-> <items>
    // Expect edge: <Processor.process> -[RETURNS]-> <items.map(...)>
    // Expect edge: <items.map(...)> -[PASSES_ARGUMENT]-> <map-callback>
    // Expect edge: <items.map(...)> -[BINDS_THIS_TO]-> <Processor>
    // Expect edge: <map-callback> -[CONTAINS]-> <item>
    // Expect edge: <map-callback> -[RETURNS]-> <item * this.multiplier>
    void code;
  });

  test('cjs-patterns::cjs-function-decl', () => {
    const code = "function cjsFunction() {\n  return 'cjs';\n}";
    // Expect node: FUNCTION <cjsFunction>
    // Expect node: LITERAL <'cjs'>
    // Expect edge: <module> -[DECLARES]-> <cjsFunction>
    // Expect edge: <cjsFunction> -[RETURNS]-> <'cjs'>
    void code;
  });

  test('cjs-patterns::cjs-const-decl', () => {
    const code = "const CJS_CONSTANT = 42;";
    // Expect node: VARIABLE <CJS_CONSTANT>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <CJS_CONSTANT>
    void code;
  });

  test('callbacks::callback-continuation-passing', () => {
    const code = "function waterfall(tasks, callback) {\n  let index = 0;\n  function next(err, result) {\n    if (err || index >= tasks.length) return callback(err, result);\n    tasks[index++](result, next);\n  }\n  next(null, null);\n}\n\n// --- Event emitter pattern ---";
    // Expect node: FUNCTION <waterfall>
    // Expect node: PARAMETER <tasks>
    // Expect node: PARAMETER <callback>
    // Expect node: VARIABLE <index>
    // Expect node: LITERAL <0>
    // Expect node: FUNCTION <next>
    // Expect node: PARAMETER <err>
    // Expect node: PARAMETER <result>
    // Expect node: EXPRESSION <err || index >= tasks.length>
    // Expect node: EXPRESSION <index >= tasks.length>
    // Expect node: PROPERTY_ACCESS <tasks.length>
    // Expect node: CALL <callback(err, result)>
    // Expect node: EXPRESSION <tasks[index++]>
    // Expect node: EXPRESSION <index++>
    // Expect node: CALL <tasks[index++](result, next)>
    // Expect node: CALL <next(null, null)>
    // Expect node: LITERAL <null1>
    // Expect node: LITERAL <null2>
    // Expect edge: <waterfall> -[CONTAINS]-> <tasks>
    // Expect edge: <waterfall> -[CONTAINS]-> <callback>
    // Expect edge: <waterfall> -[DECLARES]-> <index>
    // Expect edge: <waterfall> -[DECLARES]-> <next>
    // Expect edge: <next> -[CONTAINS]-> <err>
    // Expect edge: <next> -[CONTAINS]-> <result>
    // Expect edge: <callback(err, result)> -[PASSES_ARGUMENT]-> <err>
    // Expect edge: <callback(err, result)> -[PASSES_ARGUMENT]-> <result>
    // Expect edge: <tasks[index++](result, next)> -[PASSES_ARGUMENT]-> <result>
    // Expect edge: <tasks[index++](result, next)> -[PASSES_ARGUMENT]-> <next>
    // Expect edge: <next(null, null)> -[PASSES_ARGUMENT]-> <null1>
    // Expect edge: <next(null, null)> -[PASSES_ARGUMENT]-> <null2>
    void code;
  });

  test('async-generators::generator-finally-cleanup', () => {
    const code = "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}";
    // Expect node: FUNCTION <resourceGenerator>
    // Expect node: VARIABLE <resource>
    // Expect node: LITERAL <{ acquired: true }>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: EXPRESSION <yield resource>
    // Expect node: LITERAL <{ transformed: true }>
    // Expect node: EXPRESSION <yield { transformed: true }>
    // Expect node: PROPERTY_ACCESS <resource.acquired>
    // Expect node: LITERAL <false>
    // Expect edge: <resourceGenerator> -[CONTAINS]-> <resource>
    // Expect edge: <resourceGenerator> -[CONTAINS]-> <try-block>
    // Expect edge: <resourceGenerator> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <yield resource>
    // Expect edge: <try-block> -[CONTAINS]-> <yield { transformed: true }>
    void code;
  });

  test('callbacks::callback-thisarg-foreach', () => {
    const code = "function forEachWithContext(items, logger) {\n  items.forEach(function(item) {\n    this.log(item); // `this` = logger\n  }, logger);\n}";
    // Expect node: FUNCTION <forEachWithContext>
    // Expect node: PARAMETER <items>
    // Expect node: PARAMETER <logger>
    // Expect node: CALL <items.forEach>
    // Expect node: FUNCTION <forEach-callback>
    // Expect node: PARAMETER <item>
    // Expect node: CALL <this.log(item)>
    // Expect node: PROPERTY_ACCESS <this.log>
    // Expect edge: <forEachWithContext> -[CONTAINS]-> <items>
    // Expect edge: <forEachWithContext> -[CONTAINS]-> <logger>
    // Expect edge: <forEachWithContext> -[CONTAINS]-> <items.forEach>
    // Expect edge: <items.forEach> -[PASSES_ARGUMENT]-> <forEach-callback>
    // Expect edge: <items.forEach> -[PASSES_ARGUMENT]-> <logger>
    // Expect edge: <forEach-callback> -[CONTAINS]-> <item>
    // Expect edge: <forEach-callback> -[CONTAINS]-> <this.log(item)>
    // Expect edge: <this.log(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <this.log> -[BINDS_THIS_TO]-> <logger>
    void code;
  });

  test('cjs-patterns::require-path', () => {
    const code = "const path = require('path');";
    // Expect node: VARIABLE <path>
    // Expect node: CALL <require('path')>
    // Expect node: LITERAL <'path'>
    // Expect node: EXTERNAL_MODULE <path-module>
    // Expect edge: <module> -[DECLARES]-> <path>
    // Expect edge: <require('path')> -[PASSES_ARGUMENT]-> <'path'>
    void code;
  });

  test('cjs-patterns::cjs-exports-named-1', () => {
    const code = "exports.CjsClass = CjsClass;";
    // Expect node: EXPORT <exports.CjsClass>
    // Expect node: PROPERTY_ACCESS <exports.CjsClass:access>
    // Expect edge: <module> -[CONTAINS]-> <exports.CjsClass>
    void code;
  });

  test('cjs-patterns::cjs-exports-named-2', () => {
    const code = "exports.CJS_CONSTANT = CJS_CONSTANT;";
    // Expect node: PROPERTY_ACCESS <exports.CJS_CONSTANT>
    // Expect node: VARIABLE <CJS_CONSTANT>
    // Expect edge: <module> -[CONTAINS]-> <exports.CJS_CONSTANT>
    void code;
  });

  test('cjs-patterns::cjs-exports-named', () => {
    const code = "exports.cjsFunction = cjsFunction;";
    // Expect node: EXPORT <exports.cjsFunction>
    // Expect node: PROPERTY_ACCESS <exports.cjsFunction:access>
    // Expect edge: <module> -[CONTAINS]-> <exports.cjsFunction>
    void code;
  });

  test('callbacks::callback-promisify', () => {
    const code = "function promisify(fn) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args, function (err, result) {\n        if (err) reject(err);\n        else resolve(result);\n      });\n    });\n  };\n}";
    // Expect node: FUNCTION <promisify>
    // Expect node: PARAMETER <fn>
    // Expect node: FUNCTION <promisify:wrapper>
    // Expect node: PARAMETER <...args>
    // Expect node: CALL <new Promise>
    // Expect node: FUNCTION <promisify:executor>
    // Expect node: PARAMETER <resolve>
    // Expect node: PARAMETER <reject>
    // Expect node: CALL <fn(...args, callback)>
    // Expect node: FUNCTION <promisify:callback>
    // Expect node: PARAMETER <err>
    // Expect node: PARAMETER <result>
    // Expect node: BRANCH <if-err>
    // Expect node: CALL <reject(err)>
    // Expect node: CALL <resolve(result)>
    // Expect edge: <promisify> -[HAS_BODY]-> <fn>
    // Expect edge: <promisify> -[RETURNS]-> <promisify:wrapper>
    // Expect edge: <promisify:wrapper> -[HAS_BODY]-> <...args>
    // Expect edge: <promisify:wrapper> -[RETURNS]-> <new Promise>
    // Expect edge: <new Promise> -[PASSES_ARGUMENT]-> <promisify:executor>
    // Expect edge: <promisify:executor> -[HAS_BODY]-> <resolve>
    // Expect edge: <promisify:executor> -[HAS_BODY]-> <reject>
    // Expect edge: <promisify:executor> -[HAS_BODY]-> <fn(...args, callback)>
    // Expect edge: <fn(...args, callback)> -[PASSES_ARGUMENT]-> <...args>
    // Expect edge: <fn(...args, callback)> -[PASSES_ARGUMENT]-> <promisify:callback>
    // Expect edge: <promisify:callback> -[HAS_BODY]-> <err>
    // Expect edge: <promisify:callback> -[HAS_BODY]-> <result>
    // Expect edge: <promisify:callback> -[HAS_BODY]-> <if-err>
    // Expect edge: <if-err> -[HAS_CONSEQUENT]-> <reject(err)>
    // Expect edge: <reject(err)> -[PASSES_ARGUMENT]-> <err>
    // Expect edge: <resolve(result)> -[PASSES_ARGUMENT]-> <result>
    void code;
  });

  test('cjs-patterns::require-conditional', () => {
    const code = "let optionalDep;\ntry {\n  optionalDep = require('optional-package');\n} catch (e) {\n  optionalDep = null;\n}";
    // Expect node: VARIABLE <optionalDep>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <require('optional-package')>
    // Expect node: LITERAL <'optional-package'>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: LITERAL <null>
    // Expect edge: <module> -[DECLARES]-> <optionalDep>
    // Expect edge: <module> -[CONTAINS]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <require('optional-package')>
    // Expect edge: <require('optional-package')> -[PASSES_ARGUMENT]-> <'optional-package'>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <e>
    // Expect edge: <catch-block> -[CONTAINS]-> <null>
    void code;
  });

  test('async-generators::generator-break-triggers-finally', () => {
    const code = "function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return() → finally runs\n  }\n}";
    // Expect node: FUNCTION <consumeWithBreak>
    // Expect node: PARAMETER <gen>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <item>
    // Expect node: BRANCH <if-transformed>
    // Expect node: PROPERTY_ACCESS <item.transformed>
    // Expect node: SIDE_EFFECT <break>
    // Expect edge: <consumeWithBreak> -[CONTAINS]-> <gen>
    // Expect edge: <consumeWithBreak> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <gen>
    // Expect edge: <for-of> -[CONTAINS]-> <item>
    // Expect edge: <for-of> -[CONTAINS]-> <if-transformed>
    // Expect edge: <if-transformed> -[HAS_CONDITION]-> <item.transformed>
    // Expect edge: <if-transformed> -[HAS_CONSEQUENT]-> <break>
    void code;
  });

  test('callbacks::export-named-list', () => {
    const code = "export {\n  readFileCallback,\n  processFile,\n  callbackHell,\n  getUser,\n  getOrders,\n  getOrderDetails,\n  retry,\n  waterfall,\n  EventEmitter,\n  delayedExecution,\n  pollUntil,\n  withMicrotask,\n  promisify,\n  readFileAsync,\n  arrayCallbackPatterns,\n  Processor,\n  Validator,\n  forEachWithContext,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <readFileCallback>
    // Expect node: VARIABLE <processFile>
    // Expect node: VARIABLE <callbackHell>
    // Expect node: VARIABLE <getUser>
    // Expect node: VARIABLE <getOrders>
    // Expect node: VARIABLE <getOrderDetails>
    // Expect node: VARIABLE <retry>
    // Expect node: VARIABLE <waterfall>
    // Expect node: VARIABLE <EventEmitter>
    // Expect node: VARIABLE <delayedExecution>
    // Expect node: VARIABLE <pollUntil>
    // Expect node: VARIABLE <withMicrotask>
    // Expect node: VARIABLE <promisify>
    // Expect node: VARIABLE <readFileAsync>
    // Expect node: VARIABLE <arrayCallbackPatterns>
    // Expect node: VARIABLE <Processor>
    // Expect node: VARIABLE <Validator>
    // Expect node: VARIABLE <forEachWithContext>

    void code;
  });

  test('cjs-patterns::cjs-dynamic-require', () => {
    const code = "function loadImplementation(useNative) {\n  const impl = useNative ? require('path') : require('fs');\n  return impl;\n}";
    // Expect node: FUNCTION <loadImplementation>
    // Expect node: PARAMETER <useNative>
    // Expect node: VARIABLE <impl>
    // Expect node: EXPRESSION <ternary>
    // Expect node: CALL <require('path')>
    // Expect node: LITERAL <'path'>
    // Expect node: CALL <require('fs')>
    // Expect node: LITERAL <'fs'>
    // Expect node: EXTERNAL <require>
    // Expect edge: <loadImplementation> -[CONTAINS]-> <useNative>
    // Expect edge: <loadImplementation> -[CONTAINS]-> <impl>
    // Expect edge: <ternary> -[HAS_CONDITION]-> <useNative>
    // Expect edge: <ternary> -[HAS_CONSEQUENT]-> <require('path')>
    // Expect edge: <require('path')> -[PASSES_ARGUMENT]-> <'path'>
    // Expect edge: <require('fs')> -[PASSES_ARGUMENT]-> <'fs'>
    // Expect edge: <loadImplementation> -[RETURNS]-> <impl>
    void code;
  });

  test('cjs-patterns::with-statement', () => {
    const code = "function withStatement(obj) {\n  with (obj) {\n    return toString();\n  }\n}\n\nexports.withStatement = withStatement;";
    // Expect node: FUNCTION <withStatement>
    // Expect node: PARAMETER <obj>
    // Expect node: SCOPE <with-scope>
    // Expect node: CALL <toString()>
    // Expect node: PROPERTY_ACCESS <exports.withStatement>
    // Expect edge: <MODULE> -[DECLARES]-> <withStatement>
    // Expect edge: <withStatement> -[CONTAINS]-> <obj>
    // Expect edge: <withStatement> -[HAS_SCOPE]-> <with-scope>
    // Expect edge: <with-scope> -[EXTENDS_SCOPE_WITH]-> <obj>
    // Expect edge: <with-scope> -[CONTAINS]-> <toString()>
    // Expect edge: <withStatement> -[RETURNS]-> <toString()>
    void code;
  });

  test('cjs-patterns::block-function-decl-annex-b', () => {
    const code = "// Sloppy mode (CJS) — Annex B behavior: function leaks out of block\nfunction annexBDemo() {\n  console.log(typeof leaked); // \"undefined\" — var-hoisted but not initialized\n\n  if (true) {\n    function leaked() { return 'I escaped!'; }\n  }\n\n  return leaked(); // works in sloppy mode — Annex B hoisting\n}";
    // Expect node: FUNCTION <annexBDemo>
    // Expect node: CALL <console.log(typeof leaked)>
    // Expect node: EXPRESSION <typeof leaked>
    // Expect node: BRANCH <if-true>
    // Expect node: LITERAL <true>
    // Expect node: FUNCTION <leaked>
    // Expect node: LITERAL <'I escaped!'>
    // Expect node: CALL <leaked()>
    // Expect edge: <annexBDemo> -[CONTAINS]-> <console.log(typeof leaked)>
    // Expect edge: <console.log(typeof leaked)> -[PASSES_ARGUMENT]-> <typeof leaked>
    // Expect edge: <annexBDemo> -[CONTAINS]-> <if-true>
    // Expect edge: <if-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <if-true> -[CONTAINS]-> <leaked>
    // Expect edge: <leaked> -[RETURNS]-> <'I escaped!'>
    // Expect edge: <annexBDemo> -[CONTAINS]-> <leaked()>
    // Expect edge: <annexBDemo> -[RETURNS]-> <leaked()>
    void code;
  });

  test('async-generators::generator-finally-yield-trap', () => {
    const code = "function* trickyFinally() {\n  try {\n    yield 1;\n  } finally {\n    yield 2; // return() pauses HERE, not at the return point\n  }\n}\n// const g = trickyFinally(); g.next(); g.return('end');\n// → { value: 2, done: false } — NOT 'end'!\n// g.next() → { value: 'end', done: true }\n\n// --- Async iterator cancellation ---";
    // Expect node: FUNCTION <trickyFinally>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: EXPRESSION <yield 1>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <yield 2>
    // Expect node: LITERAL <2>
    // Expect edge: <trickyFinally> -[CONTAINS]-> <try-block>
    // Expect edge: <trickyFinally> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <yield 1>
    // Expect edge: <finally-block> -[CONTAINS]-> <yield 2>
    // Expect edge: <yield 1> -[YIELDS]-> <1>
    // Expect edge: <yield 2> -[YIELDS]-> <2>
    // Expect edge: <try-block> -[HAS_FINALLY]-> <finally-block>
    void code;
  });

  test('cjs-patterns::with-nested', () => {
    const code = "function withNested(defaults, overrides) {\n  with (defaults) {\n    with (overrides) {\n      return color; // overrides.color ?? defaults.color ?? outer scope\n    }\n  }\n}";
    // Expect node: FUNCTION <withNested>
    // Expect node: PARAMETER <defaults>
    // Expect node: PARAMETER <overrides>
    // Expect node: SCOPE <with-defaults-scope>
    // Expect node: SCOPE <with-overrides-scope>
    // Expect node: VARIABLE <color>
    // Expect edge: <withNested> -[CONTAINS]-> <defaults>
    // Expect edge: <withNested> -[CONTAINS]-> <overrides>
    // Expect edge: <with-defaults-scope> -[EXTENDS_SCOPE_WITH]-> <defaults>
    // Expect edge: <with-overrides-scope> -[EXTENDS_SCOPE_WITH]-> <overrides>
    // Expect edge: <with-overrides-scope> -[CONTAINS]-> <with-defaults-scope>
    // Expect edge: <withNested> -[RETURNS]-> <color>
    void code;
  });

  test('classes::class-basic', () => {
    const code = "class Animal {\n  constructor(name, sound) {\n    this.name = name;\n    this.sound = sound;\n  }\n\n  speak() {\n    return `${this.name} says ${this.sound}`;\n  }\n\n  toString() {\n    return `Animal(${this.name})`;\n  }\n}";
    // Expect node: CLASS <Animal>
    // Expect node: METHOD <Animal.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <sound>
    // Expect node: PROPERTY <Animal.name>
    // Expect node: PROPERTY <Animal.sound>
    // Expect node: METHOD <Animal.speak>
    // Expect node: EXPRESSION <template-literal-speak>
    // Expect node: METHOD <Animal.toString>
    // Expect node: EXPRESSION <template-literal-toString>
    // Expect edge: <Animal> -[CONTAINS]-> <Animal.constructor>
    // Expect edge: <Animal> -[CONTAINS]-> <Animal.speak>
    // Expect edge: <Animal> -[CONTAINS]-> <Animal.toString>
    // Expect edge: <Animal> -[HAS_PROPERTY]-> <Animal.name>
    // Expect edge: <Animal> -[HAS_PROPERTY]-> <Animal.sound>
    // Expect edge: <Animal.constructor> -[RECEIVES_ARGUMENT]-> <name>
    // Expect edge: <Animal.constructor> -[RECEIVES_ARGUMENT]-> <sound>
    // Expect edge: <Animal.speak> -[RETURNS]-> <template-literal-speak>
    // Expect edge: <Animal.toString> -[RETURNS]-> <template-literal-toString>
    void code;
  });

  test('cjs-patterns::cjs-conditional-exports', () => {
    const code = "if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n  exports._testHelper = function () { return 'test-only'; };\n  exports._internal = cjsFunction;\n}";
    // Expect node: BRANCH <conditional-exports>
    // Expect node: EXPRESSION <typeof-check>
    // Expect node: EXPRESSION <env-check>
    // Expect node: EXPRESSION <condition>
    // Expect node: PROPERTY_ACCESS <exports._testHelper>
    // Expect node: FUNCTION <testHelper:fn>
    // Expect node: LITERAL <'test-only'>
    // Expect node: PROPERTY_ACCESS <exports._internal>
    // Expect node: VARIABLE <cjsFunction>
    // Expect node: EXTERNAL <process>
    // Expect node: PROPERTY_ACCESS <process.env.NODE_ENV>
    // Expect edge: <conditional-exports> -[HAS_CONDITION]-> <condition>
    // Expect edge: <conditional-exports> -[HAS_CONSEQUENT]-> <exports._testHelper>
    // Expect edge: <conditional-exports> -[HAS_CONSEQUENT]-> <exports._internal>
    // Expect edge: <testHelper:fn> -[RETURNS]-> <'test-only'>
    void code;
  });

  test('classes::class-expr-anonymous', () => {
    const code = "const AnonymousClassExpr = class {\n  run() {\n    return 'running';\n  }\n};";
    // Expect node: VARIABLE <AnonymousClassExpr>
    // Expect node: CLASS <AnonymousClassExpr:class>
    // Expect node: METHOD <AnonymousClassExpr:class.run>
    // Expect node: LITERAL <'running'>
    // Expect edge: <module> -[DECLARES]-> <AnonymousClassExpr>
    // Expect edge: <AnonymousClassExpr:class> -[CONTAINS]-> <AnonymousClassExpr:class.run>
    // Expect edge: <AnonymousClassExpr:class.run> -[RETURNS]-> <'running'>
    void code;
  });

  test('classes::class-static-members', () => {
    const code = "class MathUtils {\n  static PI = 3.14159;\n\n  static add(a, b) {\n    return a + b;\n  }\n\n  static #internalHelper() {\n    return 42;\n  }\n\n  static create() {\n    return new MathUtils();\n  }\n}";
    // Expect node: CLASS <MathUtils>
    // Expect node: PROPERTY <MathUtils.PI>
    // Expect node: LITERAL <3.14159>
    // Expect node: METHOD <MathUtils.add>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a + b>
    // Expect node: METHOD <MathUtils.#internalHelper>
    // Expect node: LITERAL <42>
    // Expect node: METHOD <MathUtils.create>
    // Expect node: EXPRESSION <new MathUtils()>
    // Expect edge: <MathUtils> -[CONTAINS]-> <MathUtils.PI>
    // Expect edge: <MathUtils> -[CONTAINS]-> <MathUtils.add>
    // Expect edge: <MathUtils.add> -[CONTAINS]-> <a>
    // Expect edge: <MathUtils.add> -[CONTAINS]-> <b>
    // Expect edge: <MathUtils.add> -[RETURNS]-> <a + b>
    // Expect edge: <MathUtils> -[CONTAINS]-> <MathUtils.#internalHelper>
    // Expect edge: <MathUtils.#internalHelper> -[RETURNS]-> <42>
    // Expect edge: <MathUtils> -[CONTAINS]-> <MathUtils.create>
    // Expect edge: <MathUtils.create> -[RETURNS]-> <new MathUtils()>
    void code;
  });

  test('classes::class-expr-named', () => {
    const code = "const NamedClassExpr = class InternalName {\n  constructor(value) {\n    this.value = value;\n  }\n\n  getValue() {\n    return this.value;\n  }\n};";
    // Expect node: VARIABLE <NamedClassExpr>
    // Expect node: CLASS <InternalName>
    // Expect node: METHOD <InternalName.constructor>
    // Expect node: PARAMETER <value>
    // Expect node: PROPERTY_ACCESS <this.value>
    // Expect node: METHOD <InternalName.getValue>
    // Expect edge: <InternalName> -[CONTAINS]-> <InternalName.constructor>
    // Expect edge: <InternalName> -[CONTAINS]-> <InternalName.getValue>
    // Expect edge: <InternalName.constructor> -[CONTAINS]-> <value>
    // Expect edge: <InternalName.getValue> -[RETURNS]-> <this.value>
    void code;
  });

  test('cjs-patterns::with-property-fallback', () => {
    const code = "const fallbackColor = 'red';\nfunction withPropertyFallback(config) {\n  with (config) {\n    return fallbackColor; // config.fallbackColor ?? outer fallbackColor — ambiguous\n  }\n}\n\nexports.loadImplementation = loadImplementation;\nexports.annexBDemo = annexBDemo;\nexports.withNested = withNested;\nexports.withPropertyFallback = withPropertyFallback;";
    // Expect node: VARIABLE <fallbackColor>
    // Expect node: LITERAL <'red'>
    // Expect node: FUNCTION <withPropertyFallback>
    // Expect node: PARAMETER <config>
    // Expect node: SCOPE <with-scope>
    // Expect node: EXPRESSION <fallbackColor-ref>
    // Expect node: EXPORT <exports.loadImplementation>
    // Expect node: EXPORT <exports.annexBDemo>
    // Expect node: EXPORT <exports.withNested>
    // Expect node: EXPORT <exports.withPropertyFallback>
    // Expect edge: <withPropertyFallback> -[CONTAINS]-> <config>
    // Expect edge: <withPropertyFallback> -[HAS_SCOPE]-> <with-scope>
    // Expect edge: <with-scope> -[EXTENDS_SCOPE_WITH]-> <config>
    // Expect edge: <with-scope> -[CONTAINS]-> <fallbackColor-ref>
    // Expect edge: <withPropertyFallback> -[RETURNS]-> <fallbackColor-ref>
    void code;
  });

  test('classes::class-inline-new', () => {
    const code = "const inlineInstance = new (class {\n  constructor() { this.x = 1; }\n  getX() { return this.x; }\n})();";
    // Expect node: VARIABLE <inlineInstance>
    // Expect node: CLASS <anonymous-class>
    // Expect node: METHOD <anonymous-class.constructor>
    // Expect node: PROPERTY_ACCESS <this.x>
    // Expect node: LITERAL <1>
    // Expect node: METHOD <anonymous-class.getX>
    // Expect node: CALL <new-anonymous-class>
    // Expect edge: <module> -[DECLARES]-> <inlineInstance>
    // Expect edge: <anonymous-class> -[CONTAINS]-> <anonymous-class.constructor>
    // Expect edge: <anonymous-class> -[CONTAINS]-> <anonymous-class.getX>
    // Expect edge: <anonymous-class.getX> -[RETURNS]-> <this.x>
    void code;
  });

  test('classes::class-extends-super', () => {
    const code = "class Dog extends Animal {\n  constructor(name) {\n    super(name, 'woof');\n    this.tricks = [];\n  }\n\n  learn(trick) {\n    this.tricks.push(trick);\n  }\n\n  speak() {\n    return `${super.speak()}!`;\n  }\n}";
    // Expect node: CLASS <Dog>
    // Expect node: METHOD <Dog.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: CALL <super(name, 'woof')>
    // Expect node: LITERAL <'woof'>
    // Expect node: PROPERTY_ACCESS <this.tricks>
    // Expect node: LITERAL <[]>
    // Expect node: METHOD <Dog.learn>
    // Expect node: PARAMETER <trick>
    // Expect node: CALL <this.tricks.push(trick)>
    // Expect node: METHOD <Dog.speak>
    // Expect node: EXPRESSION <`${super.speak()}!`>
    // Expect node: CALL <super.speak()>
    // Expect edge: <Dog> -[CONTAINS]-> <Dog.constructor>
    // Expect edge: <Dog> -[CONTAINS]-> <Dog.learn>
    // Expect edge: <Dog> -[CONTAINS]-> <Dog.speak>
    // Expect edge: <Dog.constructor> -[CONTAINS]-> <name>
    // Expect edge: <Dog.constructor> -[CONTAINS]-> <super(name, 'woof')>
    // Expect edge: <super(name, 'woof')> -[PASSES_ARGUMENT]-> <name>
    // Expect edge: <super(name, 'woof')> -[PASSES_ARGUMENT]-> <'woof'>
    // Expect edge: <Dog.learn> -[CONTAINS]-> <trick>
    // Expect edge: <Dog.learn> -[CONTAINS]-> <this.tricks.push(trick)>
    // Expect edge: <this.tricks.push(trick)> -[PASSES_ARGUMENT]-> <trick>
    // Expect edge: <Dog.speak> -[RETURNS]-> <`${super.speak()}!`>
    void code;
  });

  test('classes::class-static-block', () => {
    const code = "class Config {\n  static defaults;\n\n  static {\n    Config.defaults = {\n      timeout: 5000,\n      retries: 3,\n    };\n  }\n\n  constructor(overrides = {}) {\n    this.settings = { ...Config.defaults, ...overrides };\n  }\n}";
    // Expect node: CLASS <Config>
    // Expect node: PROPERTY <Config.defaults>
    // Expect node: STATIC_BLOCK <Config:static-block>
    // Expect node: LITERAL <{timeout: 5000, retries: 3}>
    // Expect node: LITERAL <5000>
    // Expect node: LITERAL <3>
    // Expect node: METHOD <Config.constructor>
    // Expect node: PARAMETER <overrides>
    // Expect node: LITERAL <{}>
    // Expect node: PROPERTY_ACCESS <this.settings>
    // Expect node: EXPRESSION <{...Config.defaults, ...overrides}>
    // Expect edge: <Config> -[CONTAINS]-> <Config.defaults>
    // Expect edge: <Config> -[CONTAINS]-> <Config:static-block>
    // Expect edge: <Config> -[CONTAINS]-> <Config.constructor>
    // Expect edge: <{timeout: 5000, retries: 3}> -[HAS_PROPERTY]-> <5000>
    // Expect edge: <{timeout: 5000, retries: 3}> -[HAS_PROPERTY]-> <3>
    // Expect edge: <Config.constructor> -[CONTAINS]-> <overrides>
    // Expect edge: <overrides> -[DEFAULTS_TO]-> <{}>
    void code;
  });

  test('classes::class-computed-methods', () => {
    const code = "const METHOD_KEY = 'dynamicMethod';\n\nclass WithComputedMethods {\n  [METHOD_KEY]() {\n    return 'dynamic';\n  }\n\n  [Symbol.toPrimitive](hint) {\n    return hint === 'number' ? 42 : 'string';\n  }\n}";
    // Expect node: VARIABLE <METHOD_KEY>
    // Expect node: LITERAL <'dynamicMethod'>
    // Expect node: CLASS <WithComputedMethods>
    // Expect node: METHOD <WithComputedMethods.[METHOD_KEY]>
    // Expect node: LITERAL <'dynamic'>
    // Expect node: METHOD <WithComputedMethods.[Symbol.toPrimitive]>
    // Expect node: PARAMETER <hint>
    // Expect node: EXPRESSION <hint === 'number'>
    // Expect node: LITERAL <'number'>
    // Expect node: LITERAL <42>
    // Expect node: LITERAL <'string'>
    // Expect node: EXPRESSION <ternary>
    // Expect edge: <WithComputedMethods> -[CONTAINS]-> <WithComputedMethods.[METHOD_KEY]>
    // Expect edge: <WithComputedMethods.[METHOD_KEY]> -[RETURNS]-> <'dynamic'>
    // Expect edge: <WithComputedMethods> -[CONTAINS]-> <WithComputedMethods.[Symbol.toPrimitive]>
    // Expect edge: <WithComputedMethods.[Symbol.toPrimitive]> -[CONTAINS]-> <hint>
    // Expect edge: <WithComputedMethods.[Symbol.toPrimitive]> -[RETURNS]-> <ternary>
    // Expect edge: <ternary> -[HAS_CONDITION]-> <hint === 'number'>
    // Expect edge: <ternary> -[HAS_CONSEQUENT]-> <42>
    void code;
  });

  test('classes::class-new-target', () => {
    const code = "class AbstractBase {\n  constructor() {\n    if (new.target === AbstractBase) {\n      throw new Error('Cannot instantiate AbstractBase directly');\n    }\n  }\n}\n\nclass Concrete extends AbstractBase {\n  constructor() {\n    super();\n  }\n}";
    // Expect node: CLASS <AbstractBase>
    // Expect node: METHOD <AbstractBase.constructor>
    // Expect node: BRANCH <if-new.target>
    // Expect node: EXPRESSION <new.target === AbstractBase>
    // Expect node: META_PROPERTY <new.target>
    // Expect node: CALL <throw new Error>
    // Expect node: LITERAL <'Cannot instantiate AbstractBase directly'>
    // Expect node: CLASS <Concrete>
    // Expect node: METHOD <Concrete.constructor>
    // Expect node: CALL <super()>
    // Expect edge: <AbstractBase> -[CONTAINS]-> <AbstractBase.constructor>
    // Expect edge: <AbstractBase.constructor> -[CONTAINS]-> <if-new.target>
    // Expect edge: <if-new.target> -[HAS_CONDITION]-> <new.target === AbstractBase>
    // Expect edge: <if-new.target> -[HAS_CONSEQUENT]-> <throw new Error>
    // Expect edge: <throw new Error> -[PASSES_ARGUMENT]-> <'Cannot instantiate AbstractBase directly'>
    // Expect edge: <Concrete> -[CONTAINS]-> <Concrete.constructor>
    // Expect edge: <Concrete.constructor> -[CONTAINS]-> <super()>
    void code;
  });

  test('classes::class-getters-setters', () => {
    const code = "class Temperature {\n  #celsius;\n\n  constructor(celsius) {\n    this.#celsius = celsius;\n  }\n\n  get fahrenheit() {\n    return this.#celsius * 9 / 5 + 32;\n  }\n\n  set fahrenheit(f) {\n    this.#celsius = (f - 32) * 5 / 9;\n  }\n\n  get celsius() {\n    return this.#celsius;\n  }\n\n  set celsius(c) {\n    this.#celsius = c;\n  }\n}";
    // Expect node: CLASS <Temperature>
    // Expect node: PROPERTY <#celsius>
    // Expect node: METHOD <Temperature.constructor>
    // Expect node: PARAMETER <celsius>
    // Expect node: PROPERTY_ACCESS <this.#celsius>
    // Expect node: GETTER <Temperature.fahrenheit:getter>
    // Expect node: EXPRESSION <this.#celsius * 9 / 5 + 32>
    // Expect node: SETTER <Temperature.fahrenheit:setter>
    // Expect node: PARAMETER <f>
    // Expect node: EXPRESSION <(f - 32) * 5 / 9>
    // Expect node: GETTER <Temperature.celsius:getter>
    // Expect node: SETTER <Temperature.celsius:setter>
    // Expect node: PARAMETER <c>
    // Expect edge: <Temperature> -[CONTAINS]-> <#celsius>
    // Expect edge: <Temperature> -[CONTAINS]-> <Temperature.constructor>
    // Expect edge: <Temperature> -[CONTAINS]-> <Temperature.fahrenheit:getter>
    // Expect edge: <Temperature> -[CONTAINS]-> <Temperature.fahrenheit:setter>
    // Expect edge: <Temperature> -[CONTAINS]-> <Temperature.celsius:getter>
    // Expect edge: <Temperature> -[CONTAINS]-> <Temperature.celsius:setter>
    // Expect edge: <Temperature.constructor> -[CONTAINS]-> <celsius>
    // Expect edge: <Temperature.fahrenheit:getter> -[RETURNS]-> <this.#celsius * 9 / 5 + 32>
    // Expect edge: <Temperature.fahrenheit:setter> -[CONTAINS]-> <f>
    // Expect edge: <Temperature.celsius:getter> -[RETURNS]-> <this.#celsius>
    // Expect edge: <Temperature.celsius:setter> -[CONTAINS]-> <c>
    void code;
  });

  test('classes::in-brand-check', () => {
    const code = "class Branded {\n  #secret = true;\n  static isBranded(obj) {\n    return #secret in obj;\n  }\n}";
    // Expect node: CLASS <Branded>
    // Expect node: PROPERTY <#secret>
    // Expect node: LITERAL <true>
    // Expect node: METHOD <Branded.isBranded>
    // Expect node: PARAMETER <obj>
    // Expect node: EXPRESSION <#secret in obj>
    // Expect edge: <Branded> -[CONTAINS]-> <#secret>
    // Expect edge: <Branded> -[CONTAINS]-> <Branded.isBranded>
    // Expect edge: <Branded.isBranded> -[CONTAINS]-> <obj>
    // Expect edge: <Branded.isBranded> -[RETURNS]-> <#secret in obj>
    void code;
  });

  test('classes::new-arrow-throws', () => {
    const code = "const ArrowNotConstructable = () => {};\nconst methodShorthandObj = { method() {} };\n// new ArrowNotConstructable(); // TypeError: not a constructor\n// new methodShorthandObj.method(); // TypeError: not a constructor";
    // Expect node: VARIABLE <ArrowNotConstructable>
    // Expect node: FUNCTION <ArrowNotConstructable:fn>
    // Expect node: VARIABLE <methodShorthandObj>
    // Expect node: LITERAL <methodShorthandObj:obj>
    // Expect node: METHOD <method>
    // Expect edge: <module> -[DECLARES]-> <ArrowNotConstructable>
    // Expect edge: <module> -[DECLARES]-> <methodShorthandObj>
    // Expect edge: <methodShorthandObj:obj> -[HAS_PROPERTY]-> <method>
    void code;
  });

  test('classes::mixin-composition', () => {
    const code = "class User extends Serializable(Validatable(class {\n  constructor(name) { this.name = name; }\n})) {\n  greet() { return `Hi, ${this.name}`; }\n}";
    // Expect node: CLASS <User>
    // Expect node: CLASS <anonymous-base>
    // Expect node: METHOD <anonymous-base.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: CALL <Validatable(anonymous-base)>
    // Expect node: CALL <Serializable(Validatable-result)>
    // Expect node: METHOD <User.greet>
    // Expect node: LITERAL <'Hi, '>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: PROPERTY_ACCESS <this.name-read>
    // Expect edge: <User> -[CONTAINS]-> <User.greet>
    // Expect edge: <anonymous-base> -[CONTAINS]-> <anonymous-base.constructor>
    // Expect edge: <anonymous-base.constructor> -[RECEIVES_ARGUMENT]-> <name>
    // Expect edge: <Validatable(anonymous-base)> -[PASSES_ARGUMENT]-> <anonymous-base>
    // Expect edge: <Serializable(Validatable-result)> -[PASSES_ARGUMENT]-> <Validatable(anonymous-base)>
    // Expect edge: <User.greet> -[RETURNS]-> <template-literal>
    // Expect edge: <template-literal> -[HAS_ELEMENT]-> <'Hi, '>
    void code;
  });

  test('classes::class-multi-level-inheritance', () => {
    const code = "class Base {\n  baseMethod() {\n    return 'base';\n  }\n}\n\nclass Middle extends Base {\n  middleMethod() {\n    return 'middle';\n  }\n}\n\nclass Derived extends Middle {\n  derivedMethod() {\n    return 'derived';\n  }\n\n  allMethods() {\n    return [this.baseMethod(), this.middleMethod(), this.derivedMethod()];\n  }\n}";
    // Expect node: CLASS <Base>
    // Expect node: METHOD <Base.baseMethod>
    // Expect node: LITERAL <'base'>
    // Expect node: CLASS <Middle>
    // Expect node: METHOD <Middle.middleMethod>
    // Expect node: LITERAL <'middle'>
    // Expect node: CLASS <Derived>
    // Expect node: METHOD <Derived.derivedMethod>
    // Expect node: LITERAL <'derived'>
    // Expect node: METHOD <Derived.allMethods>
    // Expect node: CALL <this.baseMethod()>
    // Expect node: CALL <this.middleMethod()>
    // Expect node: CALL <this.derivedMethod()>
    // Expect node: EXPRESSION <[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>
    // Expect node: MODULE <module>
    // Expect edge: <module> -[DECLARES]-> <Base>
    // Expect edge: <Base> -[CONTAINS]-> <Base.baseMethod>
    // Expect edge: <Base.baseMethod> -[RETURNS]-> <'base'>
    // Expect edge: <module> -[DECLARES]-> <Middle>
    // Expect edge: <Middle> -[CONTAINS]-> <Middle.middleMethod>
    // Expect edge: <Middle.middleMethod> -[RETURNS]-> <'middle'>
    // Expect edge: <module> -[DECLARES]-> <Derived>
    // Expect edge: <Derived> -[CONTAINS]-> <Derived.derivedMethod>
    // Expect edge: <Derived.derivedMethod> -[RETURNS]-> <'derived'>
    // Expect edge: <Derived> -[CONTAINS]-> <Derived.allMethods>
    // Expect edge: <Derived.allMethods> -[RETURNS]-> <[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>
    // Expect edge: <[this.baseMethod(), this.middleMethod(), this.derivedMethod()]> -[HAS_ELEMENT]-> <this.baseMethod()>
    // Expect edge: <[this.baseMethod(), this.middleMethod(), this.derivedMethod()]> -[HAS_ELEMENT]-> <this.middleMethod()>
    // Expect edge: <[this.baseMethod(), this.middleMethod(), this.derivedMethod()]> -[HAS_ELEMENT]-> <this.derivedMethod()>
    void code;
  });

  test('classes::mixin-class-expression', () => {
    const code = "const Serializable = (SuperClass) => class extends SuperClass {\n  serialize() { return JSON.stringify(this); }\n};\n\nconst Validatable = (SuperClass) => class extends SuperClass {\n  validate() { return true; }\n};";
    // Expect node: VARIABLE <Serializable>
    // Expect node: FUNCTION <Serializable:fn>
    // Expect node: PARAMETER <SuperClass>
    // Expect node: CLASS <Serializable:class>
    // Expect node: METHOD <Serializable:class.serialize>
    // Expect node: CALL <JSON.stringify(this)>
    // Expect node: PROPERTY_ACCESS <JSON.stringify>
    // Expect node: VARIABLE <this>
    // Expect node: VARIABLE <Validatable>
    // Expect node: FUNCTION <Validatable:fn>
    // Expect node: PARAMETER <SuperClass2>
    // Expect node: CLASS <Validatable:class>
    // Expect node: METHOD <Validatable:class.validate>
    // Expect node: LITERAL <true>
    // Expect edge: <Serializable:fn> -[RECEIVES_ARGUMENT]-> <SuperClass>
    // Expect edge: <Serializable:fn> -[RETURNS]-> <Serializable:class>
    // Expect edge: <Serializable:class> -[CONTAINS]-> <Serializable:class.serialize>
    // Expect edge: <Serializable:class.serialize> -[RETURNS]-> <JSON.stringify(this)>
    // Expect edge: <JSON.stringify(this)> -[PASSES_ARGUMENT]-> <this>
    // Expect edge: <Validatable:fn> -[RECEIVES_ARGUMENT]-> <SuperClass2>
    // Expect edge: <Validatable:fn> -[RETURNS]-> <Validatable:class>
    // Expect edge: <Validatable:class> -[CONTAINS]-> <Validatable:class.validate>
    // Expect edge: <Validatable:class.validate> -[RETURNS]-> <true>
    void code;
  });

  test('classes::class-async-method', () => {
    const code = "class ApiClient {\n  async fetch(url) { return url; }\n  static async create() { return new ApiClient(); }\n}";
    // Expect node: CLASS <ApiClient>
    // Expect node: METHOD <ApiClient.fetch>
    // Expect node: PARAMETER <url>
    // Expect node: METHOD <ApiClient.create>
    // Expect node: EXPRESSION <new ApiClient()>
    // Expect edge: <ApiClient> -[CONTAINS]-> <ApiClient.fetch>
    // Expect edge: <ApiClient> -[CONTAINS]-> <ApiClient.create>
    // Expect edge: <ApiClient.fetch> -[RECEIVES_ARGUMENT]-> <url>
    // Expect edge: <ApiClient.fetch> -[RETURNS]-> <url>
    // Expect edge: <ApiClient.create> -[RETURNS]-> <new ApiClient()>
    void code;
  });

  test('classes::class-inline-extends', () => {
    const code = "const inlineChild = new (class extends Error {\n  constructor(msg) { super(msg); this.custom = true; }\n})('inline error');";
    // Expect node: VARIABLE <inlineChild>
    // Expect node: CALL <new (class extends Error {...})('inline error')>
    // Expect node: CLASS <anonymous-class>
    // Expect node: METHOD <anonymous-class.constructor>
    // Expect node: PARAMETER <msg>
    // Expect node: CALL <super(msg)>
    // Expect node: PROPERTY_ACCESS <this.custom>
    // Expect node: LITERAL <true>
    // Expect node: LITERAL <'inline error'>
    // Expect edge: <new (class extends Error {...})('inline error')> -[PASSES_ARGUMENT]-> <'inline error'>
    // Expect edge: <anonymous-class> -[CONTAINS]-> <anonymous-class.constructor>
    // Expect edge: <anonymous-class.constructor> -[CONTAINS]-> <msg>
    // Expect edge: <anonymous-class.constructor> -[CONTAINS]-> <super(msg)>
    // Expect edge: <super(msg)> -[PASSES_ARGUMENT]-> <msg>
    void code;
  });

  test('classes::class-constructor-return-non-this', () => {
    const code = "class Singleton {\n  static instance;\n  constructor() {\n    if (Singleton.instance) return Singleton.instance;\n    Singleton.instance = this;\n  }\n}";
    // Expect node: CLASS <Singleton>
    // Expect node: PROPERTY <Singleton.instance>
    // Expect node: METHOD <Singleton.constructor>
    // Expect node: BRANCH <if-instance-exists>
    // Expect node: PROPERTY_ACCESS <Singleton.instance-read>
    // Expect node: PROPERTY_ACCESS <Singleton.instance-write>
    // Expect node: LITERAL <this>
    // Expect edge: <Singleton> -[HAS_PROPERTY]-> <Singleton.instance>
    // Expect edge: <Singleton> -[HAS_PROPERTY]-> <Singleton.constructor>
    // Expect edge: <Singleton.constructor> -[CONTAINS]-> <if-instance-exists>
    // Expect edge: <if-instance-exists> -[HAS_CONDITION]-> <Singleton.instance-read>
    // Expect edge: <if-instance-exists> -[HAS_CONSEQUENT]-> <Singleton.instance-read>
    // Expect edge: <Singleton.constructor> -[RETURNS]-> <Singleton.instance-read>
    void code;
  });

  test('classes::class-field-no-initializer', () => {
    const code = "class Form {\n  errors;\n  static count;\n}\n\n// --- Dynamic super property access ---";
    // Expect node: CLASS <Form>
    // Expect node: PROPERTY <Form.errors>
    // Expect node: PROPERTY <Form.count>
    // Expect edge: <module> -[DECLARES]-> <Form>
    // Expect edge: <Form> -[CONTAINS]-> <Form.errors>
    // Expect edge: <Form> -[CONTAINS]-> <Form.count>
    void code;
  });

  test('classes::class-generator-method', () => {
    const code = "class Stream {\n  data = [];\n  *items() { for (const item of this.data) yield item; }\n  async *pages() { yield* this.data; }\n}";
    // Expect node: CLASS <Stream>
    // Expect node: PROPERTY <Stream.data>
    // Expect node: LITERAL <[]>
    // Expect node: METHOD <Stream.items>
    // Expect node: LOOP <for-of-data>
    // Expect node: VARIABLE <item>
    // Expect node: PROPERTY_ACCESS <this.data>
    // Expect node: EXPRESSION <yield item>
    // Expect node: METHOD <Stream.pages>
    // Expect node: EXPRESSION <yield* this.data>
    // Expect edge: <Stream> -[CONTAINS]-> <Stream.data>
    // Expect edge: <Stream> -[CONTAINS]-> <Stream.items>
    // Expect edge: <Stream> -[CONTAINS]-> <Stream.pages>
    // Expect edge: <Stream.items> -[CONTAINS]-> <for-of-data>
    // Expect edge: <for-of-data> -[ITERATES_OVER]-> <this.data>
    // Expect edge: <for-of-data> -[CONTAINS]-> <item>
    // Expect edge: <Stream.items> -[YIELDS]-> <yield item>
    // Expect edge: <Stream.pages> -[DELEGATES_TO]-> <yield* this.data>
    void code;
  });

  test('classes::class-static-getter-setter', () => {
    const code = "class Registry {\n  static #store = new Map();\n  static get size() { return this.#store.size; }\n  static set defaultValue(value) { this.#store.set('default', value); }\n}";
    // Expect node: CLASS <Registry>
    // Expect node: PROPERTY <Registry.#store>
    // Expect node: CALL <new Map()>
    // Expect node: GETTER <Registry.size>
    // Expect node: PROPERTY_ACCESS <this.#store.size>
    // Expect node: SETTER <Registry.defaultValue>
    // Expect node: PARAMETER <value>
    // Expect node: CALL <this.#store.set('default', value)>
    // Expect node: LITERAL <'default'>
    // Expect edge: <Registry> -[CONTAINS]-> <Registry.#store>
    // Expect edge: <Registry> -[CONTAINS]-> <Registry.size>
    // Expect edge: <Registry> -[CONTAINS]-> <Registry.defaultValue>
    // Expect edge: <Registry.size> -[RETURNS]-> <this.#store.size>
    // Expect edge: <Registry.defaultValue> -[CONTAINS]-> <value>
    // Expect edge: <Registry.defaultValue> -[CONTAINS]-> <this.#store.set('default', value)>
    // Expect edge: <this.#store.set('default', value)> -[PASSES_ARGUMENT]-> <'default'>
    // Expect edge: <this.#store.set('default', value)> -[PASSES_ARGUMENT]-> <value>
    void code;
  });

  test('async-generators::async-iterator-cancel-break', () => {
    const code = "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}";
    // Expect node: FUNCTION <streamChunks>
    // Expect node: PARAMETER <url>
    // Expect node: VARIABLE <reader>
    // Expect node: LITERAL <{ locked: true }>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <10>
    // Expect node: EXPRESSION <i < 10>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <yield { chunk: i, size: i * 100 }>
    // Expect node: LITERAL <{ chunk: i, size: i * 100 }>
    // Expect node: EXPRESSION <i * 100>
    // Expect node: LITERAL <100>
    // Expect node: PROPERTY_ACCESS <reader.locked>
    // Expect node: LITERAL <false>
    // Expect edge: <streamChunks> -[CONTAINS]-> <url>
    // Expect edge: <streamChunks> -[CONTAINS]-> <reader>
    // Expect edge: <streamChunks> -[CONTAINS]-> <try-block>
    // Expect edge: <streamChunks> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 10>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield { chunk: i, size: i * 100 }>
    // Expect edge: <yield { chunk: i, size: i * 100 }> -[YIELDS]-> <{ chunk: i, size: i * 100 }>
    // Expect edge: <finally-block> -[CONTAINS]-> <reader.locked>
    void code;
  });

  test('classes::super-computed-access', () => {
    const code = "class DynamicChild extends Animal {\n  callDynamic(methodName) {\n    return super[methodName](); // dynamic dispatch through prototype chain\n  }\n  delegateAll(methods) {\n    return methods.map(m => super[m]());\n  }\n}\n\n// --- Method chaining / fluent API ---";
    // Expect node: CLASS <DynamicChild>
    // Expect node: METHOD <DynamicChild.callDynamic>
    // Expect node: PARAMETER <methodName>
    // Expect node: PROPERTY_ACCESS <super[methodName]>
    // Expect node: CALL <super[methodName]()>
    // Expect node: METHOD <DynamicChild.delegateAll>
    // Expect node: PARAMETER <methods>
    // Expect node: CALL <methods.map(m => super[m]())>
    // Expect node: FUNCTION <m => super[m]()>
    // Expect node: PARAMETER <m>
    // Expect node: PROPERTY_ACCESS <super[m]>
    // Expect node: CALL <super[m]()>
    // Expect edge: <DynamicChild> -[CONTAINS]-> <DynamicChild.callDynamic>
    // Expect edge: <DynamicChild> -[CONTAINS]-> <DynamicChild.delegateAll>
    // Expect edge: <DynamicChild.callDynamic> -[CONTAINS]-> <methodName>
    // Expect edge: <DynamicChild.callDynamic> -[RETURNS]-> <super[methodName]()>
    // Expect edge: <DynamicChild.delegateAll> -[CONTAINS]-> <methods>
    // Expect edge: <methods.map(m => super[m]())> -[PASSES_ARGUMENT]-> <m => super[m]()>
    // Expect edge: <DynamicChild.delegateAll> -[RETURNS]-> <methods.map(m => super[m]())>
    // Expect edge: <m => super[m]()> -[CONTAINS]-> <m>
    // Expect edge: <m => super[m]()> -[RETURNS]-> <super[m]()>
    void code;
  });

  test('classes::method-chaining-usage', () => {
    const code = "const chainedQuery = new QueryBuilder()\n  .from('users')\n  .where('age > 18')\n  .orderBy('name')\n  .limit(10)\n  .build();";
    // Expect node: VARIABLE <chainedQuery>
    // Expect node: CALL <new QueryBuilder()>
    // Expect node: CALL <.from('users')>
    // Expect node: LITERAL <'users'>
    // Expect node: CALL <.where('age > 18')>
    // Expect node: LITERAL <'age > 18'>
    // Expect node: CALL <.orderBy('name')>
    // Expect node: LITERAL <'name'>
    // Expect node: CALL <.limit(10)>
    // Expect node: LITERAL <10>
    // Expect node: CALL <.build()>
    // Expect edge: <.from('users')> -[CHAINS_FROM]-> <new QueryBuilder()>
    // Expect edge: <.from('users')> -[PASSES_ARGUMENT]-> <'users'>
    // Expect edge: <.where('age > 18')> -[CHAINS_FROM]-> <.from('users')>
    // Expect edge: <.where('age > 18')> -[PASSES_ARGUMENT]-> <'age > 18'>
    // Expect edge: <.orderBy('name')> -[CHAINS_FROM]-> <.where('age > 18')>
    // Expect edge: <.orderBy('name')> -[PASSES_ARGUMENT]-> <'name'>
    // Expect edge: <.limit(10)> -[CHAINS_FROM]-> <.orderBy('name')>
    // Expect edge: <.limit(10)> -[PASSES_ARGUMENT]-> <10>
    // Expect edge: <.build()> -[CHAINS_FROM]-> <.limit(10)>
    void code;
  });

  test('async-generators::async-iterator-cancel-manual', () => {
    const code = "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}";
    // Expect node: FUNCTION <manualAsyncCancel>
    // Expect node: PARAMETER <asyncGen>
    // Expect node: VARIABLE <iter>
    // Expect node: PROPERTY_ACCESS <asyncGen[Symbol.asyncIterator]>
    // Expect node: CALL <asyncGen[Symbol.asyncIterator]()>
    // Expect node: VARIABLE <first>
    // Expect node: PROPERTY_ACCESS <iter.next>
    // Expect node: CALL <iter.next()>
    // Expect node: PROPERTY_ACCESS <iter.return>
    // Expect node: CALL <iter.return()>
    // Expect node: EXPRESSION <return first>
    // Expect edge: <manualAsyncCancel> -[CONTAINS]-> <asyncGen>
    // Expect edge: <manualAsyncCancel> -[RETURNS]-> <return first>
    void code;
  });

  test('classes::destructure-assign-to-this', () => {
    const code = "class ComponentState {\n  width = 0;\n  height = 0;\n\n  update(props) {\n    ({ width: this.width, height: this.height } = props);\n  }\n}";
    // Expect node: CLASS <ComponentState>
    // Expect node: PROPERTY <ComponentState.width>
    // Expect node: PROPERTY <ComponentState.height>
    // Expect node: LITERAL <0>
    // Expect node: METHOD <ComponentState.update>
    // Expect node: PARAMETER <props>
    // Expect node: EXPRESSION <destructure-props>
    // Expect node: PROPERTY_ACCESS <this.width>
    // Expect node: PROPERTY_ACCESS <this.height>
    // Expect node: PROPERTY_ACCESS <props.width>
    // Expect node: PROPERTY_ACCESS <props.height>
    // Expect edge: <ComponentState> -[CONTAINS]-> <ComponentState.width>
    // Expect edge: <ComponentState> -[CONTAINS]-> <ComponentState.height>
    // Expect edge: <ComponentState> -[CONTAINS]-> <ComponentState.update>
    // Expect edge: <ComponentState.update> -[CONTAINS]-> <props>
    // Expect edge: <ComponentState.update> -[CONTAINS]-> <destructure-props>
    void code;
  });

  test('classes::class-private-cross-instance', () => {
    const code = "class Vec {\n  #x; #y;\n  constructor(x, y) { this.#x = x; this.#y = y; }\n  equals(other) {\n    return this.#x === other.#x && this.#y === other.#y;\n  }\n}";
    // Expect node: CLASS <Vec>
    // Expect node: PROPERTY <Vec.#x>
    // Expect node: PROPERTY <Vec.#y>
    // Expect node: METHOD <Vec.constructor>
    // Expect node: PARAMETER <x>
    // Expect node: PARAMETER <y>
    // Expect node: PROPERTY_ACCESS <this.#x>
    // Expect node: PROPERTY_ACCESS <this.#y>
    // Expect node: METHOD <Vec.equals>
    // Expect node: PARAMETER <other>
    // Expect node: PROPERTY_ACCESS <other.#x>
    // Expect node: PROPERTY_ACCESS <other.#y>
    // Expect node: EXPRESSION <this.#x === other.#x>
    // Expect node: EXPRESSION <this.#y === other.#y>
    // Expect node: EXPRESSION <equals-return>
    // Expect edge: <Vec> -[HAS_PROPERTY]-> <Vec.#x>
    // Expect edge: <Vec> -[HAS_PROPERTY]-> <Vec.#y>
    // Expect edge: <Vec> -[CONTAINS]-> <Vec.constructor>
    // Expect edge: <Vec> -[CONTAINS]-> <Vec.equals>
    // Expect edge: <Vec.constructor> -[CONTAINS]-> <x>
    // Expect edge: <Vec.constructor> -[CONTAINS]-> <y>
    // Expect edge: <this.#x> -[ACCESSES_PRIVATE]-> <Vec.#x>
    // Expect edge: <this.#y> -[ACCESSES_PRIVATE]-> <Vec.#y>
    // Expect edge: <Vec.equals> -[CONTAINS]-> <other>
    // Expect edge: <Vec.equals> -[RETURNS]-> <equals-return>
    // Expect edge: <other.#x> -[ACCESSES_PRIVATE]-> <Vec.#x>
    // Expect edge: <other.#y> -[ACCESSES_PRIVATE]-> <Vec.#y>
    void code;
  });

  test('async-generators::yield-star-return-value', () => {
    const code = "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}";
    // Expect node: FUNCTION <innerWithReturn>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <'done'>
    // Expect node: FUNCTION <outerCapturesReturn>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <yield* innerWithReturn()>
    // Expect node: CALL <innerWithReturn()>
    // Expect edge: <innerWithReturn> -[YIELDS]-> <1>
    // Expect edge: <innerWithReturn> -[YIELDS]-> <2>
    // Expect edge: <innerWithReturn> -[RETURNS]-> <'done'>
    // Expect edge: <yield* innerWithReturn()> -[DELEGATES_TO]-> <innerWithReturn()>
    // Expect edge: <outerCapturesReturn> -[YIELDS]-> <result>
    void code;
  });

  test('classes::super-in-nested-arrows', () => {
    const code = "class DeepSuper extends ParentProcessor {\n  deepProcess(items) {\n    return items.map(item => {\n      return this.validate(item).then(valid => {\n        return super.transform(valid);   // super through 2 levels of arrows\n      });\n    });\n  }\n  validate(item) { return Promise.resolve(item); }\n}";
    // Expect node: CLASS <DeepSuper>
    // Expect node: METHOD <DeepSuper.deepProcess>
    // Expect node: PARAMETER <items>
    // Expect node: CALL <items.map(...)>
    // Expect node: FUNCTION <map-callback>
    // Expect node: PARAMETER <item>
    // Expect node: CALL <this.validate(item)>
    // Expect node: CALL <...then(...)>
    // Expect node: FUNCTION <then-callback>
    // Expect node: PARAMETER <valid>
    // Expect node: CALL <super.transform(valid)>
    // Expect node: METHOD <DeepSuper.validate>
    // Expect node: PARAMETER <item-validate>
    // Expect node: CALL <Promise.resolve(item)>
    // Expect node: EXTERNAL <ParentProcessor>
    // Expect node: EXTERNAL <Promise>
    // Expect edge: <DeepSuper> -[CONTAINS]-> <DeepSuper.deepProcess>
    // Expect edge: <DeepSuper> -[CONTAINS]-> <DeepSuper.validate>
    // Expect edge: <DeepSuper.deepProcess> -[CONTAINS]-> <items>
    // Expect edge: <DeepSuper.deepProcess> -[RETURNS]-> <items.map(...)>
    // Expect edge: <items.map(...)> -[PASSES_ARGUMENT]-> <map-callback>
    // Expect edge: <map-callback> -[CONTAINS]-> <item>
    // Expect edge: <map-callback> -[RETURNS]-> <this.validate(item)>
    // Expect edge: <this.validate(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <...then(...)> -[PASSES_ARGUMENT]-> <then-callback>
    // Expect edge: <then-callback> -[CONTAINS]-> <valid>
    // Expect edge: <then-callback> -[RETURNS]-> <super.transform(valid)>
    // Expect edge: <super.transform(valid)> -[PASSES_ARGUMENT]-> <valid>
    // Expect edge: <DeepSuper.validate> -[CONTAINS]-> <item-validate>
    // Expect edge: <DeepSuper.validate> -[RETURNS]-> <Promise.resolve(item)>
    // Expect edge: <Promise.resolve(item)> -[PASSES_ARGUMENT]-> <item-validate>
    void code;
  });

  test('classes::object-assign-this', () => {
    const code = "class MergeConfig {\n  constructor(opts) {\n    Object.assign(this, opts);           // copies ALL properties from opts\n  }\n}\n\nclass MergeConfigDefaults {\n  constructor(defaults, overrides) {\n    Object.assign(this, defaults, overrides); // merge with precedence\n  }\n}\n\n// --- super in static context ---";
    // Expect node: CLASS <MergeConfig>
    // Expect node: METHOD <MergeConfig.constructor>
    // Expect node: PARAMETER <opts>
    // Expect node: CALL <Object.assign(this, opts)>
    // Expect node: PROPERTY_ACCESS <Object.assign>
    // Expect node: CLASS <MergeConfigDefaults>
    // Expect node: METHOD <MergeConfigDefaults.constructor>
    // Expect node: PARAMETER <defaults>
    // Expect node: PARAMETER <overrides>
    // Expect node: CALL <Object.assign(this, defaults, overrides)>
    // Expect edge: <MergeConfig> -[CONTAINS]-> <MergeConfig.constructor>
    // Expect edge: <MergeConfig.constructor> -[CONTAINS]-> <opts>
    // Expect edge: <MergeConfig.constructor> -[CONTAINS]-> <Object.assign(this, opts)>
    // Expect edge: <Object.assign(this, opts)> -[PASSES_ARGUMENT]-> <opts>
    // Expect edge: <MergeConfigDefaults> -[CONTAINS]-> <MergeConfigDefaults.constructor>
    // Expect edge: <MergeConfigDefaults.constructor> -[CONTAINS]-> <defaults>
    // Expect edge: <MergeConfigDefaults.constructor> -[CONTAINS]-> <overrides>
    // Expect edge: <MergeConfigDefaults.constructor> -[CONTAINS]-> <Object.assign(this, defaults, overrides)>
    // Expect edge: <Object.assign(this, defaults, overrides)> -[PASSES_ARGUMENT]-> <defaults>
    // Expect edge: <Object.assign(this, defaults, overrides)> -[PASSES_ARGUMENT]-> <overrides>
    void code;
  });

  test('classes::destructure-assign-to-this-defaults', () => {
    const code = "class ConfigFromOpts {\n  host = '';\n  port = 3000;\n\n  constructor(opts) {\n    ({ host: this.host, port: this.port = 3000 } = opts);\n  }\n}";
    // Expect node: CLASS <ConfigFromOpts>
    // Expect node: PROPERTY <ConfigFromOpts.host>
    // Expect node: LITERAL <''>
    // Expect node: PROPERTY <ConfigFromOpts.port>
    // Expect node: LITERAL <3000>
    // Expect node: METHOD <ConfigFromOpts.constructor>
    // Expect node: PARAMETER <opts>
    // Expect node: EXPRESSION <destructure-opts>
    // Expect node: PROPERTY_ACCESS <this.host>
    // Expect node: PROPERTY_ACCESS <this.port>
    // Expect node: LITERAL <3000-default>
    // Expect edge: <ConfigFromOpts> -[CONTAINS]-> <ConfigFromOpts.host>
    // Expect edge: <ConfigFromOpts> -[CONTAINS]-> <ConfigFromOpts.port>
    // Expect edge: <ConfigFromOpts> -[CONTAINS]-> <ConfigFromOpts.constructor>
    // Expect edge: <ConfigFromOpts.constructor> -[CONTAINS]-> <opts>
    // Expect edge: <ConfigFromOpts.constructor> -[CONTAINS]-> <destructure-opts>
    // Expect edge: <this.port> -[DEFAULTS_TO]-> <3000-default>
    void code;
  });

  test('classes::default-param-this-access', () => {
    const code = "class ServiceWithDefaults {\n  defaultTimeout = 5000;\n  baseUrl = '/api';\n\n  fetch(url, timeout = this.defaultTimeout) {\n    return { url: this.baseUrl + url, timeout };\n  }\n}";
    // Expect node: CLASS <ServiceWithDefaults>
    // Expect node: PROPERTY <ServiceWithDefaults.defaultTimeout>
    // Expect node: LITERAL <5000>
    // Expect node: PROPERTY <ServiceWithDefaults.baseUrl>
    // Expect node: LITERAL <'/api'>
    // Expect node: METHOD <ServiceWithDefaults.fetch>
    // Expect node: PARAMETER <url>
    // Expect node: PARAMETER <timeout>
    // Expect node: PROPERTY_ACCESS <this.defaultTimeout>
    // Expect node: EXPRESSION <this.baseUrl + url>
    // Expect node: PROPERTY_ACCESS <this.baseUrl>
    // Expect node: EXPRESSION <{ url: this.baseUrl + url, timeout }>
    // Expect edge: <ServiceWithDefaults> -[CONTAINS]-> <ServiceWithDefaults.defaultTimeout>
    // Expect edge: <ServiceWithDefaults> -[CONTAINS]-> <ServiceWithDefaults.baseUrl>
    // Expect edge: <ServiceWithDefaults> -[CONTAINS]-> <ServiceWithDefaults.fetch>
    // Expect edge: <ServiceWithDefaults.fetch> -[CONTAINS]-> <url>
    // Expect edge: <ServiceWithDefaults.fetch> -[CONTAINS]-> <timeout>
    // Expect edge: <timeout> -[DEFAULTS_TO]-> <this.defaultTimeout>
    // Expect edge: <{ url: this.baseUrl + url, timeout }> -[HAS_PROPERTY]-> <this.baseUrl + url>
    // Expect edge: <{ url: this.baseUrl + url, timeout }> -[HAS_PROPERTY]-> <timeout>
    // Expect edge: <ServiceWithDefaults.fetch> -[RETURNS]-> <{ url: this.baseUrl + url, timeout }>
    void code;
  });

  test('classes::super-in-arrow-callback', () => {
    const code = "class ParentProcessor {\n  transform(item) { return { ...item, processed: true }; }\n  cleanup() { return 'cleaned'; }\n}\n\nclass ChildProcessor extends ParentProcessor {\n  processAll(items) {\n    return items.map(item => {\n      return super.transform(item);     // super captured via arrow\n    });\n  }\n\n  delayed() {\n    setTimeout(() => {\n      super.cleanup();                   // super in async callback arrow\n    }, 100);\n  }\n}";
    // Expect node: CLASS <ParentProcessor>
    // Expect node: METHOD <ParentProcessor.transform>
    // Expect node: PARAMETER <item>
    // Expect node: EXPRESSION <{ ...item, processed: true }>
    // Expect node: METHOD <ParentProcessor.cleanup>
    // Expect node: LITERAL <'cleaned'>
    // Expect node: CLASS <ChildProcessor>
    // Expect node: METHOD <ChildProcessor.processAll>
    // Expect node: PARAMETER <items>
    // Expect node: CALL <items.map(...)>
    // Expect node: FUNCTION <arrow-fn-1>
    // Expect node: PARAMETER <item-2>
    // Expect node: CALL <super.transform(item)>
    // Expect node: METHOD <ChildProcessor.delayed>
    // Expect node: CALL <setTimeout(...)>
    // Expect node: FUNCTION <arrow-fn-2>
    // Expect node: CALL <super.cleanup()>
    // Expect node: LITERAL <100>
    // Expect edge: <ParentProcessor> -[CONTAINS]-> <ParentProcessor.transform>
    // Expect edge: <ParentProcessor.transform> -[HAS_BODY]-> <item>
    // Expect edge: <ParentProcessor.transform> -[RETURNS]-> <{ ...item, processed: true }>
    // Expect edge: <ParentProcessor> -[CONTAINS]-> <ParentProcessor.cleanup>
    // Expect edge: <ParentProcessor.cleanup> -[RETURNS]-> <'cleaned'>
    // Expect edge: <ChildProcessor> -[CONTAINS]-> <ChildProcessor.processAll>
    // Expect edge: <ChildProcessor.processAll> -[HAS_BODY]-> <items>
    // Expect edge: <ChildProcessor.processAll> -[RETURNS]-> <items.map(...)>
    // Expect edge: <items.map(...)> -[PASSES_ARGUMENT]-> <arrow-fn-1>
    // Expect edge: <arrow-fn-1> -[HAS_BODY]-> <item-2>
    // Expect edge: <arrow-fn-1> -[RETURNS]-> <super.transform(item)>
    // Expect edge: <super.transform(item)> -[PASSES_ARGUMENT]-> <item-2>
    // Expect edge: <ChildProcessor> -[CONTAINS]-> <ChildProcessor.delayed>
    // Expect edge: <ChildProcessor.delayed> -[HAS_BODY]-> <setTimeout(...)>
    // Expect edge: <setTimeout(...)> -[PASSES_ARGUMENT]-> <arrow-fn-2>
    // Expect edge: <setTimeout(...)> -[PASSES_ARGUMENT]-> <100>
    // Expect edge: <arrow-fn-2> -[HAS_BODY]-> <super.cleanup()>
    void code;
  });

  test('classes::computed-class-member-side-effect', () => {
    const code = "let classFieldId = 0;\nclass AutoIdFields {\n  [`field_${classFieldId++}`] = 'first';\n  [`field_${classFieldId++}`] = 'second';\n  [`method_${classFieldId++}`]() { return 'dynamic'; }\n}";
    // Expect node: VARIABLE <classFieldId>
    // Expect node: LITERAL <0>
    // Expect node: CLASS <AutoIdFields>
    // Expect node: EXPRESSION <`field_${classFieldId++}`_1>
    // Expect node: PROPERTY <AutoIdFields[computed1]>
    // Expect node: LITERAL <'first'>
    // Expect node: EXPRESSION <`field_${classFieldId++}`_2>
    // Expect node: PROPERTY <AutoIdFields[computed2]>
    // Expect node: LITERAL <'second'>
    // Expect node: EXPRESSION <`method_${classFieldId++}`>
    // Expect node: METHOD <AutoIdFields[computedMethod]>
    // Expect node: LITERAL <'dynamic'>
    // Expect edge: <AutoIdFields> -[CONTAINS]-> <AutoIdFields[computed1]>
    // Expect edge: <AutoIdFields> -[CONTAINS]-> <AutoIdFields[computed2]>
    // Expect edge: <AutoIdFields> -[CONTAINS]-> <AutoIdFields[computedMethod]>
    // Expect edge: <AutoIdFields[computedMethod]> -[RETURNS]-> <'dynamic'>
    void code;
  });

  test('classes::class-in-array', () => {
    const code = "const classHandlers = [\n  class GetHandler { handle() { return 'get'; } },\n  class PostHandler { handle() { return 'post'; } },\n];";
    // Expect node: VARIABLE <classHandlers>
    // Expect node: LITERAL <classHandlers-array>
    // Expect node: CLASS <GetHandler>
    // Expect node: METHOD <GetHandler.handle>
    // Expect node: LITERAL <'get'>
    // Expect node: CLASS <PostHandler>
    // Expect node: METHOD <PostHandler.handle>
    // Expect node: LITERAL <'post'>
    // Expect edge: <classHandlers-array> -[HAS_ELEMENT]-> <GetHandler>
    // Expect edge: <classHandlers-array> -[HAS_ELEMENT]-> <PostHandler>
    // Expect edge: <GetHandler> -[CONTAINS]-> <GetHandler.handle>
    // Expect edge: <GetHandler.handle> -[RETURNS]-> <'get'>
    // Expect edge: <PostHandler> -[CONTAINS]-> <PostHandler.handle>
    // Expect edge: <PostHandler.handle> -[RETURNS]-> <'post'>
    void code;
  });

  test('classes::class-as-argument', () => {
    const code = "function registerClass(cls) { return new cls(); }\nregisterClass(class InlinePlugin { activate() { return true; } });";
    // Expect node: FUNCTION <registerClass>
    // Expect node: PARAMETER <cls>
    // Expect node: EXPRESSION <new cls()>
    // Expect node: CALL <registerClass(class InlinePlugin)>
    // Expect node: CLASS <InlinePlugin>
    // Expect node: METHOD <InlinePlugin.activate>
    // Expect node: LITERAL <true>
    // Expect edge: <registerClass> -[CONTAINS]-> <cls>
    // Expect edge: <registerClass> -[RETURNS]-> <new cls()>
    // Expect edge: <registerClass(class InlinePlugin)> -[PASSES_ARGUMENT]-> <InlinePlugin>
    // Expect edge: <InlinePlugin> -[CONTAINS]-> <InlinePlugin.activate>
    // Expect edge: <InlinePlugin.activate> -[RETURNS]-> <true>
    void code;
  });

  test('closures::closure-module-var-read', () => {
    const code = "let requestCount = 0;\n\nfunction getRequestCount() {\n  return requestCount;\n}";
    // Expect node: VARIABLE <requestCount>
    // Expect node: LITERAL <0>
    // Expect node: FUNCTION <getRequestCount>
    // Expect edge: <module> -[DECLARES]-> <requestCount>
    // Expect edge: <module> -[DECLARES]-> <getRequestCount>
    // Expect edge: <getRequestCount> -[RETURNS]-> <requestCount>
    void code;
  });

  test('classes::super-in-field-initializer', () => {
    const code = "class FieldParent {\n  getDefaults() { return { timeout: 5000 }; }\n}\n\nclass FieldChild extends FieldParent {\n  defaults = super.getDefaults(); // super in instance field initializer\n}\n\n// --- Interleaved static blocks and static fields ---";
    // Expect node: CLASS <FieldParent>
    // Expect node: METHOD <FieldParent.getDefaults>
    // Expect node: LITERAL <{ timeout: 5000 }>
    // Expect node: CLASS <FieldChild>
    // Expect node: PROPERTY <FieldChild.defaults>
    // Expect node: CALL <super.getDefaults()>
    // Expect node: PROPERTY_ACCESS <super.getDefaults>
    // Expect edge: <FieldParent> -[CONTAINS]-> <FieldParent.getDefaults>
    // Expect edge: <FieldParent.getDefaults> -[RETURNS]-> <{ timeout: 5000 }>
    // Expect edge: <FieldChild> -[CONTAINS]-> <FieldChild.defaults>
    void code;
  });

  test('closures::closure-module-var-write', () => {
    const code = "function incrementRequestCount() {\n  requestCount++;\n}";
    // Expect node: FUNCTION <incrementRequestCount>
    // Expect node: EXPRESSION <requestCount++>
    // Expect edge: <module> -[DECLARES]-> <incrementRequestCount>
    // Expect edge: <incrementRequestCount> -[CONTAINS]-> <requestCount++>
    void code;
  });

  test('classes::class-in-ternary', () => {
    const code = "const StrategyClass = Math.random() > 0.5\n  ? class Aggressive { execute() { return 'fast'; } }\n  : class Conservative { execute() { return 'slow'; } };";
    // Expect node: VARIABLE <StrategyClass>
    // Expect node: EXPRESSION <ternary>
    // Expect node: EXPRESSION <Math.random() > 0.5>
    // Expect node: CALL <Math.random()>
    // Expect node: LITERAL <0.5>
    // Expect node: CLASS <Aggressive>
    // Expect node: METHOD <Aggressive.execute>
    // Expect node: LITERAL <'fast'>
    // Expect node: CLASS <Conservative>
    // Expect node: METHOD <Conservative.execute>
    // Expect node: LITERAL <'slow'>
    // Expect edge: <ternary> -[HAS_CONDITION]-> <Math.random() > 0.5>
    // Expect edge: <ternary> -[HAS_CONSEQUENT]-> <Aggressive>
    // Expect edge: <Aggressive> -[CONTAINS]-> <Aggressive.execute>
    // Expect edge: <Aggressive.execute> -[RETURNS]-> <'fast'>
    // Expect edge: <Conservative> -[CONTAINS]-> <Conservative.execute>
    // Expect edge: <Conservative.execute> -[RETURNS]-> <'slow'>
    void code;
  });

  test('closures::closure-factory-multiplier', () => {
    const code = "function createMultiplier(factor) {\n  return (x) => x * factor;\n}";
    // Expect node: FUNCTION <createMultiplier>
    // Expect node: PARAMETER <factor>
    // Expect node: FUNCTION <createMultiplier:returnFn>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * factor>
    // Expect edge: <createMultiplier> -[HAS_BODY]-> <factor>
    // Expect edge: <createMultiplier> -[RETURNS]-> <createMultiplier:returnFn>
    // Expect edge: <createMultiplier:returnFn> -[HAS_BODY]-> <x>
    // Expect edge: <createMultiplier:returnFn> -[RETURNS]-> <x * factor>
    void code;
  });

  test('classes::super-in-static-method', () => {
    const code = "class StaticParent {\n  static defaultConfig() { return { timeout: 5000 }; }\n  static instances = [];\n}\n\nclass StaticChild extends StaticParent {\n  static defaultConfig() {\n    const base = super.defaultConfig(); // super = StaticParent (constructor, not prototype)\n    return { ...base, retries: 3 };\n  }\n\n  static allInstances = [...super.instances]; // super in static field initializer\n}\n\n// --- super in field initializers ---";
    // Expect node: CLASS <StaticParent>
    // Expect node: METHOD <StaticParent.defaultConfig>
    // Expect node: LITERAL <{ timeout: 5000 }>
    // Expect node: PROPERTY <StaticParent.instances>
    // Expect node: LITERAL <[]>
    // Expect node: CLASS <StaticChild>
    // Expect node: METHOD <StaticChild.defaultConfig>
    // Expect node: VARIABLE <base>
    // Expect node: CALL <super.defaultConfig()>
    // Expect node: EXPRESSION <{ ...base, retries: 3 }>
    // Expect node: PROPERTY <StaticChild.allInstances>
    // Expect node: EXPRESSION <[...super.instances]>
    // Expect node: PROPERTY_ACCESS <super.instances>
    // Expect edge: <StaticParent> -[CONTAINS]-> <StaticParent.defaultConfig>
    // Expect edge: <StaticParent> -[CONTAINS]-> <StaticParent.instances>
    // Expect edge: <StaticParent.defaultConfig> -[RETURNS]-> <{ timeout: 5000 }>
    // Expect edge: <StaticChild> -[CONTAINS]-> <StaticChild.defaultConfig>
    // Expect edge: <StaticChild> -[CONTAINS]-> <StaticChild.allInstances>
    // Expect edge: <StaticChild.defaultConfig> -[CONTAINS]-> <base>
    // Expect edge: <StaticChild.defaultConfig> -[RETURNS]-> <{ ...base, retries: 3 }>
    void code;
  });

  test('async-generators::for-await-sync-iterable', () => {
    const code = "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array — each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <forAwaitSyncIterable>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-await>
    // Expect node: VARIABLE <item>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: CALL <results.push(item)>
    // Expect node: EXPRESSION <return results>
    // Expect edge: <forAwaitSyncIterable> -[CONTAINS]-> <results>
    // Expect edge: <forAwaitSyncIterable> -[CONTAINS]-> <for-await>
    // Expect edge: <for-await> -[ITERATES_OVER]-> <[1, 2, 3]>
    // Expect edge: <for-await> -[CONTAINS]-> <item>
    // Expect edge: <for-await> -[CONTAINS]-> <results.push(item)>
    // Expect edge: <results.push(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <forAwaitSyncIterable> -[CONTAINS]-> <return results>
    // Expect edge: <forAwaitSyncIterable> -[RETURNS]-> <return results>
    void code;
  });

  test('closures::closure-factory-counter', () => {
    const code = "function createCounter(initial = 0) {\n  let count = initial;\n  return {\n    increment() { return ++count; },\n    decrement() { return --count; },\n    value() { return count; },\n  };\n}";
    // Expect node: FUNCTION <createCounter>
    // Expect node: PARAMETER <initial>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <count>
    // Expect node: EXPRESSION <object-literal>
    // Expect node: METHOD <increment>
    // Expect node: EXPRESSION <++count>
    // Expect node: METHOD <decrement>
    // Expect node: EXPRESSION <--count>
    // Expect node: METHOD <value>
    // Expect edge: <createCounter> -[CONTAINS]-> <initial>
    // Expect edge: <initial> -[DEFAULTS_TO]-> <0>
    // Expect edge: <createCounter> -[CONTAINS]-> <count>
    // Expect edge: <createCounter> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <increment>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <decrement>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <value>
    // Expect edge: <increment> -[RETURNS]-> <++count>
    // Expect edge: <decrement> -[RETURNS]-> <--count>
    // Expect edge: <value> -[RETURNS]-> <count>
    void code;
  });

  test('classes::private-field-proxy-trap', () => {
    const code = "class SecureService {\n  #secret = 42;\n  getSecret() { return this.#secret; }\n}\n\nfunction proxyPrivateDemo() {\n  const instance = new SecureService();\n  const proxy = new Proxy(instance, {});\n  // proxy.getSecret() → TypeError: #secret not accessible through Proxy\n  return { instance, proxy };\n}\n\n// --- Class expressions in various positions ---";
    // Expect node: CLASS <SecureService>
    // Expect node: PROPERTY <#secret>
    // Expect node: LITERAL <42>
    // Expect node: METHOD <SecureService.getSecret>
    // Expect node: PROPERTY_ACCESS <this.#secret>
    // Expect node: FUNCTION <proxyPrivateDemo>
    // Expect node: VARIABLE <instance>
    // Expect node: CALL <new SecureService()>
    // Expect node: VARIABLE <proxy>
    // Expect node: CALL <new Proxy(instance, {})>
    // Expect node: LITERAL <{}>
    // Expect node: EXPRESSION <{ instance, proxy }>
    // Expect edge: <SecureService> -[HAS_PROPERTY]-> <#secret>
    // Expect edge: <SecureService> -[CONTAINS]-> <SecureService.getSecret>
    // Expect edge: <SecureService.getSecret> -[RETURNS]-> <this.#secret>
    // Expect edge: <proxyPrivateDemo> -[CONTAINS]-> <instance>
    // Expect edge: <proxyPrivateDemo> -[CONTAINS]-> <proxy>
    // Expect edge: <new Proxy(instance, {})> -[PASSES_ARGUMENT]-> <instance>
    // Expect edge: <new Proxy(instance, {})> -[PASSES_ARGUMENT]-> <{}>
    // Expect edge: <proxyPrivateDemo> -[RETURNS]-> <{ instance, proxy }>
    void code;
  });

  test('closures::closure-shared-state', () => {
    const code = "let sharedCache = {};\n\nfunction setCache(key, value) {\n  sharedCache[key] = value;\n}\n\nfunction getCache(key) {\n  return sharedCache[key];\n}\n\nfunction clearCache() {\n  sharedCache = {};\n}\n\n// --- Factory functions returning closures ---";
    // Expect node: VARIABLE <sharedCache>
    // Expect node: LITERAL <{}>
    // Expect node: FUNCTION <setCache>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: PROPERTY_ACCESS <sharedCache[key]>
    // Expect node: FUNCTION <getCache>
    // Expect node: PARAMETER <key2>
    // Expect node: PROPERTY_ACCESS <sharedCache[key2]>
    // Expect node: FUNCTION <clearCache>
    // Expect node: LITERAL <{}2>
    // Expect edge: <setCache> -[CONTAINS]-> <key>
    // Expect edge: <setCache> -[CONTAINS]-> <value>
    // Expect edge: <getCache> -[CONTAINS]-> <key2>
    // Expect edge: <getCache> -[RETURNS]-> <sharedCache[key2]>
    void code;
  });

  test('closures::closure-factory-accumulator', () => {
    const code = "function createAccumulator() {\n  const items = [];\n  return {\n    add(item) { items.push(item); },\n    getAll() { return [...items]; },\n    count() { return items.length; },\n  };\n}\n\n// --- Closure over loop variable ---";
    // Expect node: FUNCTION <createAccumulator>
    // Expect node: VARIABLE <items>
    // Expect node: LITERAL <[]>
    // Expect node: EXPRESSION <object-literal>
    // Expect node: METHOD <add>
    // Expect node: PARAMETER <item>
    // Expect node: CALL <items.push(item)>
    // Expect node: PROPERTY_ACCESS <items.push>
    // Expect node: METHOD <getAll>
    // Expect node: EXPRESSION <[...items]>
    // Expect node: METHOD <count>
    // Expect node: PROPERTY_ACCESS <items.length>
    // Expect edge: <createAccumulator> -[CONTAINS]-> <items>
    // Expect edge: <createAccumulator> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <add>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <getAll>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <count>
    // Expect edge: <add> -[CONTAINS]-> <item>
    // Expect edge: <add> -[CONTAINS]-> <items.push(item)>
    // Expect edge: <items.push(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <getAll> -[RETURNS]-> <[...items]>
    // Expect edge: <count> -[RETURNS]-> <items.length>
    void code;
  });

  test('closures::closure-nested-deep', () => {
    const code = "function outermost(a) {\n  return function middle(b) {\n    return function innermost(c) {\n      return a + b + c;\n    };\n  };\n}";
    // Expect node: FUNCTION <outermost>
    // Expect node: PARAMETER <a>
    // Expect node: FUNCTION <middle>
    // Expect node: PARAMETER <b>
    // Expect node: FUNCTION <innermost>
    // Expect node: PARAMETER <c>
    // Expect node: EXPRESSION <a + b + c>
    // Expect edge: <outermost> -[CONTAINS]-> <a>
    // Expect edge: <outermost> -[RETURNS]-> <middle>
    // Expect edge: <middle> -[CONTAINS]-> <b>
    // Expect edge: <middle> -[RETURNS]-> <innermost>
    // Expect edge: <innermost> -[CONTAINS]-> <c>
    // Expect edge: <innermost> -[RETURNS]-> <a + b + c>
    void code;
  });

  test('classes::new-target-arrow-capture', () => {
    const code = "class AbstractFactory {\n  constructor() {\n    // new.target captured by arrow — like this/super, lexically bound\n    const getTarget = () => new.target;\n\n    if (getTarget() === AbstractFactory) {\n      throw new Error('AbstractFactory is abstract — use a subclass');\n    }\n\n    // Store for lazy cloning — arrow captures new.target from constructor\n    this._clone = () => new (new.target)();\n  }\n}\n\nclass ConcreteFactory extends AbstractFactory {\n  constructor() {\n    super(); // new.target === ConcreteFactory inside AbstractFactory\n  }\n}";
    // Expect node: CLASS <AbstractFactory>
    // Expect node: METHOD <AbstractFactory.constructor>
    // Expect node: VARIABLE <getTarget>
    // Expect node: FUNCTION <getTarget:fn>
    // Expect node: META_PROPERTY <new.target>
    // Expect node: CALL <getTarget()>
    // Expect node: EXPRESSION <getTarget() === AbstractFactory>
    // Expect node: BRANCH <if-abstract-check>
    // Expect node: CALL <throw new Error(...)>
    // Expect node: LITERAL <'AbstractFactory is abstract — use a subclass'>
    // Expect node: PROPERTY_ACCESS <this._clone>
    // Expect node: FUNCTION <_clone:fn>
    // Expect node: CALL <new (new.target)()>
    // Expect node: CLASS <ConcreteFactory>
    // Expect node: METHOD <ConcreteFactory.constructor>
    // Expect node: CALL <super()>
    // Expect edge: <AbstractFactory> -[CONTAINS]-> <AbstractFactory.constructor>
    // Expect edge: <AbstractFactory.constructor> -[DECLARES]-> <getTarget>
    // Expect edge: <getTarget:fn> -[RETURNS]-> <new.target>
    // Expect edge: <AbstractFactory.constructor> -[CONTAINS]-> <if-abstract-check>
    // Expect edge: <if-abstract-check> -[HAS_CONDITION]-> <getTarget() === AbstractFactory>
    // Expect edge: <if-abstract-check> -[HAS_CONSEQUENT]-> <throw new Error(...)>
    // Expect edge: <throw new Error(...)> -[PASSES_ARGUMENT]-> <'AbstractFactory is abstract — use a subclass'>
    // Expect edge: <_clone:fn> -[RETURNS]-> <new (new.target)()>
    // Expect edge: <ConcreteFactory> -[CONTAINS]-> <ConcreteFactory.constructor>
    // Expect edge: <ConcreteFactory.constructor> -[CONTAINS]-> <super()>
    void code;
  });

  test('closures::closure-loop-let-fix', () => {
    const code = "function closureLoopLetFix() {\n  const funcs = [];\n  for (let i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // each returns 0,1,2,3,4\n}";
    // Expect node: FUNCTION <closureLoopLetFix>
    // Expect node: VARIABLE <funcs>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <i < 5>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <i++>
    // Expect node: CALL <funcs.push(...)>
    // Expect node: FUNCTION <anonymous-closure>
    // Expect node: PROPERTY_ACCESS <funcs.push>
    // Expect edge: <closureLoopLetFix> -[CONTAINS]-> <funcs>
    // Expect edge: <closureLoopLetFix> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 5>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <funcs.push(...)>
    // Expect edge: <funcs.push(...)> -[PASSES_ARGUMENT]-> <anonymous-closure>
    // Expect edge: <anonymous-closure> -[RETURNS]-> <i>
    // Expect edge: <closureLoopLetFix> -[RETURNS]-> <funcs>
    void code;
  });

  test('async-generators::async-generator-destructure-default', () => {
    const code = "async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---";
    // Expect node: FUNCTION <processStream>
    // Expect node: PARAMETER <source>
    // Expect node: LOOP <for-await-of>
    // Expect node: VARIABLE <data>
    // Expect node: VARIABLE <priority>
    // Expect node: LITERAL <'normal'>
    // Expect node: EXPRESSION <{ ...data, priority }>
    // Expect node: EXPRESSION <yield { ...data, priority }>
    // Expect edge: <processStream> -[HAS_BODY]-> <source>
    // Expect edge: <processStream> -[CONTAINS]-> <for-await-of>
    // Expect edge: <for-await-of> -[ITERATES_OVER]-> <source>
    // Expect edge: <for-await-of> -[CONTAINS]-> <data>
    // Expect edge: <for-await-of> -[CONTAINS]-> <priority>
    // Expect edge: <priority> -[DEFAULTS_TO]-> <'normal'>
    // Expect edge: <{ ...data, priority }> -[SPREADS_FROM]-> <data>
    // Expect edge: <yield { ...data, priority }> -[YIELDS]-> <{ ...data, priority }>
    // Expect edge: <for-await-of> -[CONTAINS]-> <yield { ...data, priority }>
    void code;
  });

  test('closures::this-module-level', () => {
    const code = "// In ESM: `this` is `undefined` at top level\nconst thisAtModuleLevel = this; // undefined in ESM, module.exports in CJS\n\n// --- Named function expression as argument (self-referencing) ---";
    // Expect node: VARIABLE <thisAtModuleLevel>
    // Expect node: META_PROPERTY <this>
    // Expect node: MODULE <module>
    // Expect edge: <module> -[DECLARES]-> <thisAtModuleLevel>
    void code;
  });

  test('closures::this-method-context', () => {
    const code = "const obj = {\n  name: 'context',\n  getName() {\n    return this.name;\n  },\n  getNameArrow: () => {\n    return this.name; // `this` is module/global, not obj\n  },\n};";
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <obj-literal>
    // Expect node: LITERAL <'context'>
    // Expect node: METHOD <getName>
    // Expect node: PROPERTY_ACCESS <this.name-method>
    // Expect node: FUNCTION <getNameArrow>
    // Expect node: PROPERTY_ACCESS <this.name-arrow>
    // Expect edge: <obj-literal> -[HAS_PROPERTY]-> <'context'>
    // Expect edge: <obj-literal> -[HAS_PROPERTY]-> <getName>
    // Expect edge: <obj-literal> -[HAS_PROPERTY]-> <getNameArrow>
    // Expect edge: <getName> -[RETURNS]-> <this.name-method>
    // Expect edge: <getNameArrow> -[RETURNS]-> <this.name-arrow>
    void code;
  });

  test('closures::closure-loop-var-bug', () => {
    const code = "function closureLoopVarBug() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // all return 5\n}";
    // Expect node: FUNCTION <closureLoopVarBug>
    // Expect node: VARIABLE <funcs>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <i < 5>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <i++>
    // Expect node: CALL <funcs.push(...)>
    // Expect node: FUNCTION <anonymous-closure>
    // Expect node: EXPRESSION <return i>
    // Expect edge: <closureLoopVarBug> -[CONTAINS]-> <funcs>
    // Expect edge: <closureLoopVarBug> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 5>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <funcs.push(...)>
    // Expect edge: <funcs.push(...)> -[PASSES_ARGUMENT]-> <anonymous-closure>
    // Expect edge: <anonymous-closure> -[RETURNS]-> <return i>
    // Expect edge: <closureLoopVarBug> -[RETURNS]-> <funcs>
    void code;
  });

  test('closures::closure-loop-iife-fix', () => {
    const code = "function closureLoopIifeFix() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push((function (captured) {\n      return function () { return captured; };\n    })(i));\n  }\n  return funcs;\n}\n\n// --- Nested closures (3+ levels) ---";
    // Expect node: FUNCTION <closureLoopIifeFix>
    // Expect node: VARIABLE <funcs>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <i < 5>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <i++>
    // Expect node: CALL <funcs.push(...)>
    // Expect node: FUNCTION <iife>
    // Expect node: PARAMETER <captured>
    // Expect node: FUNCTION <inner-closure>
    // Expect node: CALL <iife-call>
    // Expect edge: <closureLoopIifeFix> -[CONTAINS]-> <funcs>
    // Expect edge: <closureLoopIifeFix> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 5>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <funcs.push(...)>
    // Expect edge: <funcs.push(...)> -[PASSES_ARGUMENT]-> <iife-call>
    // Expect edge: <iife-call> -[PASSES_ARGUMENT]-> <i>
    // Expect edge: <iife> -[CONTAINS]-> <captured>
    // Expect edge: <iife> -[RETURNS]-> <inner-closure>
    // Expect edge: <inner-closure> -[RETURNS]-> <captured>
    // Expect edge: <closureLoopIifeFix> -[RETURNS]-> <funcs>
    void code;
  });

  test('closures::closure-module-pattern', () => {
    const code = "const counterModule = (function () {\n  let count = 0;\n  return {\n    increment() { count++; },\n    decrement() { count--; },\n    getCount() { return count; },\n  };\n})();\n\n// --- Memoization via closure ---";
    // Expect node: VARIABLE <counterModule>
    // Expect node: FUNCTION <counterModule:iife>
    // Expect node: VARIABLE <count>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <counterModule:object>
    // Expect node: METHOD <increment>
    // Expect node: EXPRESSION <count++>
    // Expect node: METHOD <decrement>
    // Expect node: EXPRESSION <count-->
    // Expect node: METHOD <getCount>
    // Expect node: CALL <counterModule:iife-call>
    // Expect edge: <counterModule:iife> -[DECLARES]-> <count>
    // Expect edge: <counterModule:iife> -[RETURNS]-> <counterModule:object>
    // Expect edge: <counterModule:object> -[HAS_PROPERTY]-> <increment>
    // Expect edge: <counterModule:object> -[HAS_PROPERTY]-> <decrement>
    // Expect edge: <counterModule:object> -[HAS_PROPERTY]-> <getCount>
    // Expect edge: <increment> -[CONTAINS]-> <count++>
    // Expect edge: <decrement> -[CONTAINS]-> <count-->
    void code;
  });

  test('closures::this-bind', () => {
    const code = "function thisBind() {\n  function greet(greeting) {\n    return `${greeting}, ${this.name}`;\n  }\n  const user = { name: 'Alice' };\n  const bound = greet.bind(user);\n  return bound('Hello');\n}";
    // Expect node: FUNCTION <thisBind>
    // Expect node: FUNCTION <greet>
    // Expect node: PARAMETER <greeting>
    // Expect node: EXPRESSION <`${greeting}, ${this.name}`>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: VARIABLE <user>
    // Expect node: LITERAL <{ name: 'Alice' }>
    // Expect node: LITERAL <'Alice'>
    // Expect node: VARIABLE <bound>
    // Expect node: CALL <greet.bind(user)>
    // Expect node: CALL <bound('Hello')>
    // Expect node: LITERAL <'Hello'>
    // Expect edge: <thisBind> -[CONTAINS]-> <greet>
    // Expect edge: <greet> -[DECLARES]-> <greeting>
    // Expect edge: <greet> -[RETURNS]-> <`${greeting}, ${this.name}`>
    // Expect edge: <thisBind> -[DECLARES]-> <user>
    // Expect edge: <{ name: 'Alice' }> -[HAS_PROPERTY]-> <'Alice'>
    // Expect edge: <thisBind> -[DECLARES]-> <bound>
    // Expect edge: <greet.bind(user)> -[BINDS_THIS_TO]-> <user>
    // Expect edge: <thisBind> -[RETURNS]-> <bound('Hello')>
    // Expect edge: <bound('Hello')> -[PASSES_ARGUMENT]-> <'Hello'>
    void code;
  });

  test('closures::this-in-class-callback', () => {
    const code = "class EventHandler {\n  constructor(name) {\n    this.name = name;\n    this.handleBound = this.handle.bind(this);\n  }\n\n  handle(event) {\n    return `${this.name}: ${event}`;\n  }\n\n  handleArrow = (event) => {\n    return `${this.name}: ${event}`;\n  };\n}\n\n// --- Closure as private scope ---";
    // Expect node: CLASS <EventHandler>
    // Expect node: METHOD <EventHandler.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: PROPERTY_ACCESS <this.handleBound>
    // Expect node: CALL <this.handle.bind(this)>
    // Expect node: PROPERTY_ACCESS <this.handle>
    // Expect node: METHOD <EventHandler.handle>
    // Expect node: PARAMETER <event>
    // Expect node: EXPRESSION <`${this.name}: ${event}`>
    // Expect node: METHOD <EventHandler.handleArrow>
    // Expect node: PARAMETER <event:arrow>
    // Expect node: EXPRESSION <`${this.name}: ${event}`:arrow>
    // Expect edge: <EventHandler> -[CONTAINS]-> <EventHandler.constructor>
    // Expect edge: <EventHandler> -[CONTAINS]-> <EventHandler.handle>
    // Expect edge: <EventHandler> -[CONTAINS]-> <EventHandler.handleArrow>
    // Expect edge: <EventHandler.constructor> -[CONTAINS]-> <name>
    // Expect edge: <this.handle.bind(this)> -[PASSES_ARGUMENT]-> <this>
    // Expect edge: <EventHandler.handle> -[CONTAINS]-> <event>
    // Expect edge: <EventHandler.handle> -[RETURNS]-> <`${this.name}: ${event}`>
    // Expect edge: <EventHandler.handleArrow> -[CONTAINS]-> <event:arrow>
    // Expect edge: <EventHandler.handleArrow> -[RETURNS]-> <`${this.name}: ${event}`:arrow>
    void code;
  });

  test('closures::named-func-expr-as-argument', () => {
    const code = "let retryDone = false;\nsetTimeout(function retry() {\n  if (!retryDone) setTimeout(retry, 1000); // self-reference for recursive scheduling\n}, 1000);";
    // Expect node: VARIABLE <retryDone>
    // Expect node: LITERAL <false>
    // Expect node: CALL <setTimeout(function retry() {...}, 1000)>
    // Expect node: FUNCTION <retry>
    // Expect node: LITERAL <1000>
    // Expect node: BRANCH <if (!retryDone)>
    // Expect node: EXPRESSION <!retryDone>
    // Expect node: CALL <setTimeout(retry, 1000)>
    // Expect node: LITERAL <1000-inner>
    // Expect edge: <setTimeout(function retry() {...}, 1000)> -[PASSES_ARGUMENT]-> <retry>
    // Expect edge: <setTimeout(function retry() {...}, 1000)> -[PASSES_ARGUMENT]-> <1000>
    // Expect edge: <retry> -[CONTAINS]-> <if (!retryDone)>
    // Expect edge: <if (!retryDone)> -[HAS_CONDITION]-> <!retryDone>
    // Expect edge: <if (!retryDone)> -[HAS_CONSEQUENT]-> <setTimeout(retry, 1000)>
    // Expect edge: <setTimeout(retry, 1000)> -[PASSES_ARGUMENT]-> <1000-inner>
    void code;
  });

  test('closures::closure-nested-mutation', () => {
    const code = "function createTracker() {\n  let total = 0;\n  function addGroup(groupName) {\n    let groupTotal = 0;\n    return function addItem(value) {\n      groupTotal += value;\n      total += value;\n      return { groupName, groupTotal, total };\n    };\n  }\n  return { addGroup, getTotal: () => total };\n}\n\n// --- this binding ---";
    // Expect node: FUNCTION <createTracker>
    // Expect node: VARIABLE <total>
    // Expect node: LITERAL <0>
    // Expect node: FUNCTION <addGroup>
    // Expect node: PARAMETER <groupName>
    // Expect node: VARIABLE <groupTotal>
    // Expect node: LITERAL <0-inner>
    // Expect node: FUNCTION <addItem>
    // Expect node: PARAMETER <value>
    // Expect node: EXPRESSION <groupTotal += value>
    // Expect node: EXPRESSION <total += value>
    // Expect node: EXPRESSION <{ groupName, groupTotal, total }>
    // Expect node: FUNCTION <getTotal>
    // Expect node: EXPRESSION <{ addGroup, getTotal: () => total }>
    // Expect edge: <createTracker> -[CONTAINS]-> <total>
    // Expect edge: <createTracker> -[CONTAINS]-> <addGroup>
    // Expect edge: <addGroup> -[CONTAINS]-> <groupName>
    // Expect edge: <addGroup> -[CONTAINS]-> <groupTotal>
    // Expect edge: <addGroup> -[CONTAINS]-> <addItem>
    // Expect edge: <addGroup> -[RETURNS]-> <addItem>
    // Expect edge: <addItem> -[CONTAINS]-> <value>
    // Expect edge: <addItem> -[CONTAINS]-> <groupTotal += value>
    // Expect edge: <addItem> -[CONTAINS]-> <total += value>
    // Expect edge: <addItem> -[RETURNS]-> <{ groupName, groupTotal, total }>
    // Expect edge: <createTracker> -[CONTAINS]-> <getTotal>
    // Expect edge: <createTracker> -[RETURNS]-> <{ addGroup, getTotal: () => total }>
    void code;
  });

  test('closures::this-call-apply', () => {
    const code = "function thisCallApply() {\n  function introduce(role) {\n    return `${this.name} is ${role}`;\n  }\n  const person = { name: 'Bob' };\n  const viaCall = introduce.call(person, 'admin');\n  const viaApply = introduce.apply(person, ['admin']);\n  return { viaCall, viaApply };\n}";
    // Expect node: FUNCTION <thisCallApply>
    // Expect node: FUNCTION <introduce>
    // Expect node: PARAMETER <role>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: VARIABLE <person>
    // Expect node: LITERAL <object-literal>
    // Expect node: LITERAL <'Bob'>
    // Expect node: VARIABLE <viaCall>
    // Expect node: CALL <introduce.call>
    // Expect node: LITERAL <'admin'>
    // Expect node: VARIABLE <viaApply>
    // Expect node: CALL <introduce.apply>
    // Expect node: LITERAL <array-literal>
    // Expect node: LITERAL <return-object>
    // Expect edge: <thisCallApply> -[CONTAINS]-> <introduce>
    // Expect edge: <introduce> -[CONTAINS]-> <role>
    // Expect edge: <introduce> -[RETURNS]-> <template-literal>
    // Expect edge: <thisCallApply> -[CONTAINS]-> <person>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <'Bob'>
    // Expect edge: <thisCallApply> -[CONTAINS]-> <viaCall>
    // Expect edge: <introduce.call> -[BINDS_THIS_TO]-> <person>
    // Expect edge: <introduce.call> -[PASSES_ARGUMENT]-> <'admin'>
    // Expect edge: <thisCallApply> -[CONTAINS]-> <viaApply>
    // Expect edge: <introduce.apply> -[BINDS_THIS_TO]-> <person>
    // Expect edge: <introduce.apply> -[PASSES_ARGUMENT]-> <array-literal>
    // Expect edge: <array-literal> -[HAS_ELEMENT]-> <'admin'>
    // Expect edge: <thisCallApply> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <viaCall>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <viaApply>
    void code;
  });

  test('closures::closure-once', () => {
    const code = "function once(fn) {\n  let called = false;\n  let result;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  };\n}";
    // Expect node: FUNCTION <once>
    // Expect node: PARAMETER <fn>
    // Expect node: VARIABLE <called>
    // Expect node: LITERAL <false>
    // Expect node: VARIABLE <result>
    // Expect node: FUNCTION <once:inner>
    // Expect node: PARAMETER <...args>
    // Expect node: BRANCH <if-not-called>
    // Expect node: EXPRESSION <!called>
    // Expect node: EXPRESSION <called = true>
    // Expect node: LITERAL <true>
    // Expect node: CALL <fn.apply(this, args)>
    // Expect node: EXPRESSION <result = fn.apply(this, args)>
    // Expect edge: <once> -[HAS_BODY]-> <fn>
    // Expect edge: <once> -[DECLARES]-> <called>
    // Expect edge: <once> -[DECLARES]-> <result>
    // Expect edge: <once> -[RETURNS]-> <once:inner>
    // Expect edge: <once:inner> -[HAS_BODY]-> <...args>
    // Expect edge: <once:inner> -[HAS_BODY]-> <if-not-called>
    // Expect edge: <if-not-called> -[HAS_CONDITION]-> <!called>
    // Expect edge: <if-not-called> -[HAS_CONSEQUENT]-> <called = true>
    // Expect edge: <if-not-called> -[HAS_CONSEQUENT]-> <result = fn.apply(this, args)>
    // Expect edge: <fn.apply(this, args)> -[PASSES_ARGUMENT]-> <...args>
    // Expect edge: <once:inner> -[RETURNS]-> <result>
    void code;
  });

  test('coercion-hoisting::hoist-function-decl', () => {
    const code = "function functionHoisting() {\n  const result = hoisted(); // works — function declarations are fully hoisted\n  function hoisted() { return 'hoisted'; }\n  return result;\n}";
    // Expect node: FUNCTION <functionHoisting>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <hoisted()>
    // Expect node: FUNCTION <hoisted>
    // Expect node: LITERAL <'hoisted'>
    // Expect edge: <functionHoisting> -[CONTAINS]-> <result>
    // Expect edge: <functionHoisting> -[CONTAINS]-> <hoisted>
    // Expect edge: <hoisted> -[RETURNS]-> <'hoisted'>
    // Expect edge: <functionHoisting> -[RETURNS]-> <result>
    void code;
  });

  test('closures::closure-memoize', () => {
    const code = "function memoize(fn) {\n  const cache = new Map();\n  return function (...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// --- Once (call-at-most-once) ---";
    // Expect node: FUNCTION <memoize>
    // Expect node: PARAMETER <fn>
    // Expect node: VARIABLE <cache>
    // Expect node: CALL <new Map()>
    // Expect node: FUNCTION <memoize:returnFn>
    // Expect node: PARAMETER <...args>
    // Expect node: VARIABLE <key>
    // Expect node: CALL <JSON.stringify(args)>
    // Expect node: CALL <cache.has(key)>
    // Expect node: CALL <cache.get(key)>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <fn.apply(this, args)>
    // Expect node: CALL <cache.set(key, result)>
    // Expect edge: <memoize> -[HAS_BODY]-> <fn>
    // Expect edge: <memoize> -[CONTAINS]-> <cache>
    // Expect edge: <memoize> -[RETURNS]-> <memoize:returnFn>
    // Expect edge: <memoize:returnFn> -[HAS_BODY]-> <...args>
    // Expect edge: <memoize:returnFn> -[CONTAINS]-> <key>
    // Expect edge: <JSON.stringify(args)> -[PASSES_ARGUMENT]-> <...args>
    // Expect edge: <memoize:returnFn> -[CONTAINS]-> <result>
    // Expect edge: <fn.apply(this, args)> -[PASSES_ARGUMENT]-> <...args>
    // Expect edge: <cache.has(key)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <cache.get(key)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <cache.set(key, result)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <cache.set(key, result)> -[PASSES_ARGUMENT]-> <result>
    void code;
  });

  test('closures::this-lost-in-callback', () => {
    const code = "function thisLostInCallback() {\n  const timer = {\n    seconds: 0,\n    start() {\n      // `this` lost: regular function callback\n      setTimeout(function () {\n        this.seconds++; // `this` is undefined/global\n      }, 1000);\n    },\n    startFixed() {\n      // `this` preserved: arrow function callback\n      setTimeout(() => {\n        this.seconds++;\n      }, 1000);\n    },\n  };\n  return timer;\n}";
    // Expect node: FUNCTION <thisLostInCallback>
    // Expect node: VARIABLE <timer>
    // Expect node: LITERAL <timer-object>
    // Expect node: LITERAL <0>
    // Expect node: PROPERTY_ACCESS <timer.seconds>
    // Expect node: METHOD <timer.start>
    // Expect node: CALL <setTimeout-regular>
    // Expect node: FUNCTION <setTimeout-callback-regular>
    // Expect node: PROPERTY_ACCESS <this.seconds-regular>
    // Expect node: EXPRESSION <this.seconds++-regular>
    // Expect node: LITERAL <1000-1>
    // Expect node: METHOD <timer.startFixed>
    // Expect node: CALL <setTimeout-arrow>
    // Expect node: FUNCTION <setTimeout-callback-arrow>
    // Expect node: PROPERTY_ACCESS <this.seconds-arrow>
    // Expect node: EXPRESSION <this.seconds++-arrow>
    // Expect node: LITERAL <1000-2>
    // Expect edge: <thisLostInCallback> -[CONTAINS]-> <timer>
    // Expect edge: <timer-object> -[HAS_PROPERTY]-> <timer.seconds>
    // Expect edge: <timer-object> -[HAS_PROPERTY]-> <timer.start>
    // Expect edge: <timer-object> -[HAS_PROPERTY]-> <timer.startFixed>
    // Expect edge: <timer.start> -[CONTAINS]-> <setTimeout-regular>
    // Expect edge: <setTimeout-regular> -[PASSES_ARGUMENT]-> <setTimeout-callback-regular>
    // Expect edge: <setTimeout-regular> -[PASSES_ARGUMENT]-> <1000-1>
    // Expect edge: <setTimeout-callback-regular> -[CONTAINS]-> <this.seconds++-regular>
    // Expect edge: <timer.startFixed> -[CONTAINS]-> <setTimeout-arrow>
    // Expect edge: <setTimeout-arrow> -[PASSES_ARGUMENT]-> <setTimeout-callback-arrow>
    // Expect edge: <setTimeout-arrow> -[PASSES_ARGUMENT]-> <1000-2>
    // Expect edge: <setTimeout-callback-arrow> -[CONTAINS]-> <this.seconds++-arrow>
    // Expect edge: <thisLostInCallback> -[RETURNS]-> <timer>
    void code;
  });

  test('coercion-hoisting::hoist-var', () => {
    const code = "function varHoisting() {\n  console.log(x); // undefined — hoisted, not initialized\n  var x = 10;\n  console.log(x); // 10\n  return x;\n}";
    // Expect node: FUNCTION <varHoisting>
    // Expect node: VARIABLE <x>
    // Expect node: LITERAL <10>
    // Expect node: CALL <console.log(x):1>
    // Expect node: CALL <console.log(x):2>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect edge: <varHoisting> -[DECLARES]-> <x>
    // Expect edge: <console.log(x):1> -[PASSES_ARGUMENT]-> <x>
    // Expect edge: <console.log(x):2> -[PASSES_ARGUMENT]-> <x>
    // Expect edge: <varHoisting> -[RETURNS]-> <x>
    void code;
  });

  test('async-generators::yield-yield-chained', () => {
    const code = "function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---";
    // Expect node: FUNCTION <chainedYield>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <yield yield 1>
    // Expect node: EXPRESSION <inner-yield>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <outer-yield>
    // Expect edge: <chainedYield> -[CONTAINS]-> <result>
    // Expect edge: <chainedYield> -[CONTAINS]-> <yield yield 1>
    // Expect edge: <yield yield 1> -[CONTAINS]-> <outer-yield>
    // Expect edge: <outer-yield> -[YIELDS]-> <inner-yield>
    // Expect edge: <inner-yield> -[YIELDS]-> <1>
    // Expect edge: <chainedYield> -[RETURNS]-> <result>
    void code;
  });

  test('coercion-hoisting::hoist-function-expr-not', () => {
    const code = "function functionExprNotHoisted() {\n  try {\n    notHoisted(); // TypeError: notHoisted is not a function\n  } catch (e) {\n    // var notHoisted is hoisted as undefined, but assignment is not\n  }\n  var notHoisted = function () { return 'not hoisted'; };\n  return notHoisted();\n}\n\n// --- Temporal Dead Zone (TDZ) ---";
    // Expect node: FUNCTION <functionExprNotHoisted>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <notHoisted()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: VARIABLE <notHoisted>
    // Expect node: FUNCTION <notHoisted:fn>
    // Expect node: LITERAL <'not hoisted'>
    // Expect node: CALL <notHoisted()_return>
    // Expect edge: <functionExprNotHoisted> -[HAS_BODY]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <notHoisted()>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[RECEIVES_ARGUMENT]-> <e>
    // Expect edge: <functionExprNotHoisted> -[DECLARES]-> <notHoisted>
    // Expect edge: <notHoisted:fn> -[RETURNS]-> <'not hoisted'>
    // Expect edge: <functionExprNotHoisted> -[RETURNS]-> <notHoisted()_return>
    void code;
  });

  test('coercion-hoisting::tdz-let', () => {
    const code = "function tdzLet() {\n  try {\n    console.log(x); // ReferenceError — TDZ\n  } catch (e) {\n    // let x exists but cannot be accessed before declaration\n  }\n  let x = 10;\n  return x;\n}";
    // Expect node: FUNCTION <tdzLet>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: CALL <console.log(x)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect node: VARIABLE <x>
    // Expect node: LITERAL <10>
    // Expect edge: <tdzLet> -[HAS_BODY]-> <try-block>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <console.log(x)>
    // Expect edge: <catch-block> -[RECEIVES_ARGUMENT]-> <e>
    // Expect edge: <console.log(x)> -[PASSES_ARGUMENT]-> <x>
    // Expect edge: <tdzLet> -[DECLARES]-> <x>
    // Expect edge: <tdzLet> -[RETURNS]-> <x>
    void code;
  });

  test('coercion-hoisting::tdz-class', () => {
    const code = "function tdzClass() {\n  try {\n    new MyClass(); // ReferenceError — class TDZ\n  } catch (e) {\n    // class declarations have TDZ like let/const\n  }\n  class MyClass {}\n  return new MyClass();\n}\n\n// --- Variable shadowing ---";
    // Expect node: FUNCTION <tdzClass>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <new MyClass()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: CLASS <MyClass>
    // Expect node: CALL <new MyClass():return>
    // Expect edge: <tdzClass> -[CONTAINS]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <new MyClass()>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <e>
    // Expect edge: <tdzClass> -[DECLARES]-> <MyClass>
    // Expect edge: <tdzClass> -[RETURNS]-> <new MyClass():return>
    void code;
  });

  test('coercion-hoisting::coerce-symbol-toprimitive', () => {
    const code = "const toPrimitive = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return 10;\n    if (hint === 'string') return 'ten';\n    return true;\n  },\n};\n\n// --- Hoisting ---";
    // Expect node: VARIABLE <toPrimitive>
    // Expect node: LITERAL <object-literal>
    // Expect node: METHOD <[Symbol.toPrimitive]>
    // Expect node: PARAMETER <hint>
    // Expect node: BRANCH <if-number>
    // Expect node: EXPRESSION <hint === 'number'>
    // Expect node: LITERAL <'number'>
    // Expect node: LITERAL <10>
    // Expect node: BRANCH <if-string>
    // Expect node: EXPRESSION <hint === 'string'>
    // Expect node: LITERAL <'string'>
    // Expect node: LITERAL <'ten'>
    // Expect node: LITERAL <true>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <[Symbol.toPrimitive]>
    // Expect edge: <[Symbol.toPrimitive]> -[CONTAINS]-> <hint>
    // Expect edge: <[Symbol.toPrimitive]> -[CONTAINS]-> <if-number>
    // Expect edge: <if-number> -[HAS_CONDITION]-> <hint === 'number'>
    // Expect edge: <if-number> -[RETURNS]-> <10>
    // Expect edge: <[Symbol.toPrimitive]> -[CONTAINS]-> <if-string>
    // Expect edge: <if-string> -[HAS_CONDITION]-> <hint === 'string'>
    // Expect edge: <if-string> -[RETURNS]-> <'ten'>
    // Expect edge: <[Symbol.toPrimitive]> -[RETURNS]-> <true>
    void code;
  });

  test('coercion-hoisting::tdz-const', () => {
    const code = "function tdzConst() {\n  try {\n    console.log(C); // ReferenceError — TDZ\n  } catch (e) {\n    // const C in TDZ\n  }\n  const C = 42;\n  return C;\n}";
    // Expect node: FUNCTION <tdzConst>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: CALL <console.log(C)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect node: VARIABLE <C>
    // Expect node: LITERAL <42>
    // Expect edge: <tdzConst> -[CONTAINS]-> <try-block>
    // Expect edge: <tdzConst> -[CONTAINS]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <console.log(C)>
    // Expect edge: <catch-block> -[CONTAINS]-> <e>
    // Expect edge: <console.log(C)> -[PASSES_ARGUMENT]-> <C>
    // Expect edge: <tdzConst> -[DECLARES]-> <C>
    // Expect edge: <tdzConst> -[RETURNS]-> <C>
    void code;
  });

  test('coercion-hoisting::coerce-valueof-tostring', () => {
    const code = "const customCoerce = {\n  valueOf() { return 42; },\n  toString() { return 'custom'; },\n};\n\nconst usedInMath = customCoerce + 1;        // 43 (valueOf)\nconst usedInTemplate = `${customCoerce}`;   // 'custom' (toString)";
    // Expect node: VARIABLE <customCoerce>
    // Expect node: EXPRESSION <customCoerce:obj>
    // Expect node: METHOD <valueOf>
    // Expect node: LITERAL <42>
    // Expect node: METHOD <toString>
    // Expect node: LITERAL <'custom'>
    // Expect node: VARIABLE <usedInMath>
    // Expect node: EXPRESSION <customCoerce + 1>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <usedInTemplate>
    // Expect node: EXPRESSION <`${customCoerce}`>
    // Expect edge: <customCoerce:obj> -[CONTAINS]-> <valueOf>
    // Expect edge: <customCoerce:obj> -[CONTAINS]-> <toString>
    // Expect edge: <valueOf> -[RETURNS]-> <42>
    // Expect edge: <toString> -[RETURNS]-> <'custom'>
    void code;
  });

  test('coercion-hoisting::shadow-param-scope', () => {
    const code = "function paramShadowing(x) {\n  const x2 = x;\n  if (true) {\n    const x = 'shadowed'; // shadows parameter\n    console.log(x); // 'shadowed'\n  }\n  return x; // original param\n}";
    // Expect node: FUNCTION <paramShadowing>
    // Expect node: PARAMETER <x:param>
    // Expect node: VARIABLE <x2>
    // Expect node: SCOPE <if-block-scope>
    // Expect node: VARIABLE <x:shadowed>
    // Expect node: LITERAL <'shadowed'>
    // Expect node: CALL <console.log(x)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect edge: <paramShadowing> -[CONTAINS]-> <x:param>
    // Expect edge: <paramShadowing> -[CONTAINS]-> <x2>
    // Expect edge: <paramShadowing> -[CONTAINS]-> <if-block-scope>
    // Expect edge: <if-block-scope> -[CONTAINS]-> <x:shadowed>
    // Expect edge: <x:shadowed> -[SHADOWS]-> <x:param>
    // Expect edge: <console.log(x)> -[PASSES_ARGUMENT]-> <x:shadowed>
    // Expect edge: <paramShadowing> -[RETURNS]-> <x:param>
    void code;
  });

  test('coercion-hoisting::eval-direct', () => {
    const code = "function directEval(code) {\n  return eval(code);\n}";
    // Expect node: FUNCTION <directEval>
    // Expect node: PARAMETER <code>
    // Expect node: CALL <eval(code)>
    // Expect node: EXTERNAL <eval>
    // Expect edge: <module> -[DECLARES]-> <directEval>
    // Expect edge: <directEval> -[CONTAINS]-> <code>
    // Expect edge: <directEval> -[RETURNS]-> <eval(code)>
    // Expect edge: <eval(code)> -[PASSES_ARGUMENT]-> <code>
    void code;
  });

  test('coercion-hoisting::eval-indirect', () => {
    const code = "function indirectEval(code) {\n  const evaluate = eval;\n  return evaluate(code);\n}";
    // Expect node: FUNCTION <indirectEval>
    // Expect node: PARAMETER <code>
    // Expect node: VARIABLE <evaluate>
    // Expect node: EXTERNAL <eval>
    // Expect node: CALL <evaluate(code)>
    // Expect edge: <indirectEval> -[CONTAINS]-> <code>
    // Expect edge: <indirectEval> -[CONTAINS]-> <evaluate>
    // Expect edge: <indirectEval> -[RETURNS]-> <evaluate(code)>
    // Expect edge: <evaluate(code)> -[PASSES_ARGUMENT]-> <code>
    void code;
  });

  test('coercion-hoisting::eval-var-injection', () => {
    const code = "function evalVarInjection() {\n  eval('var injected = 42');\n  return injected; // 42 — eval injected into function scope\n}";
    // Expect node: FUNCTION <evalVarInjection>
    // Expect node: CALL <eval('var injected = 42')>
    // Expect node: LITERAL <'var injected = 42'>
    // Expect node: VARIABLE <injected>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <evalVarInjection>
    // Expect edge: <evalVarInjection> -[CONTAINS]-> <eval('var injected = 42')>
    // Expect edge: <eval('var injected = 42')> -[PASSES_ARGUMENT]-> <'var injected = 42'>
    // Expect edge: <evalVarInjection> -[RETURNS]-> <injected>
    void code;
  });

  test('coercion-hoisting::shadow-catch-scope', () => {
    const code = "function catchShadowing() {\n  const error = 'not an error';\n  try {\n    throw new Error('real error');\n  } catch (error) {\n    console.log(error.message); // 'real error' — shadows outer \"error\"\n  }\n  return error; // 'not an error'\n}\n\n// --- eval ---";
    // Expect node: FUNCTION <catchShadowing>
    // Expect node: VARIABLE <error:outer>
    // Expect node: LITERAL <'not an error'>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <error:catch>
    // Expect node: CALL <new Error('real error')>
    // Expect node: LITERAL <'real error'>
    // Expect node: CALL <console.log(error.message)>
    // Expect node: PROPERTY_ACCESS <error.message>
    // Expect edge: <catchShadowing> -[CONTAINS]-> <error:outer>
    // Expect edge: <catchShadowing> -[CONTAINS]-> <try-block>
    // Expect edge: <catchShadowing> -[CONTAINS]-> <catch-block>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <error:catch>
    // Expect edge: <new Error('real error')> -[PASSES_ARGUMENT]-> <'real error'>
    // Expect edge: <catch-block> -[CONTAINS]-> <console.log(error.message)>
    // Expect edge: <console.log(error.message)> -[PASSES_ARGUMENT]-> <error.message>
    // Expect edge: <catchShadowing> -[RETURNS]-> <error:outer>
    // Expect edge: <error:catch> -[SHADOWS]-> <error:outer>
    void code;
  });

  test('coercion-hoisting::contextual-keyword-as-identifier', () => {
    const code = "function contextualKeywords() {\n  var async = 1;       // valid — \"async\" is not a reserved word\n  // var yield = 3;    // SyntaxError in strict/ESM — valid in sloppy scripts\n  // var let = 2;      // SyntaxError in strict — valid with var in sloppy\n  return async;\n}";
    // Expect node: FUNCTION <contextualKeywords>
    // Expect node: VARIABLE <async>
    // Expect node: LITERAL <1>
    // Expect edge: <MODULE> -[DECLARES]-> <contextualKeywords>
    // Expect edge: <contextualKeywords> -[CONTAINS]-> <async>
    // Expect edge: <contextualKeywords> -[RETURNS]-> <async>
    void code;
  });

  test('coercion-hoisting::eval-function-injection', () => {
    const code = "function evalFunctionInjection() {\n  eval('function surprise() { return \"boo\"; }');\n  return surprise(); // \"boo\"\n}";
    // Expect node: FUNCTION <evalFunctionInjection>
    // Expect node: CALL <eval('function surprise() { return "boo"; }')>
    // Expect node: LITERAL <'function surprise() { return "boo"; }'>
    // Expect node: FUNCTION <surprise>
    // Expect node: LITERAL <"boo">
    // Expect node: CALL <surprise()>
    // Expect edge: <evalFunctionInjection> -[CONTAINS]-> <eval('function surprise() { return "boo"; }')>
    // Expect edge: <eval('function surprise() { return "boo"; }')> -[PASSES_ARGUMENT]-> <'function surprise() { return "boo"; }'>
    // Expect edge: <eval('function surprise() { return "boo"; }')> -[DECLARES]-> <surprise>
    // Expect edge: <surprise> -[RETURNS]-> <"boo">
    // Expect edge: <evalFunctionInjection> -[CONTAINS]-> <surprise()>
    // Expect edge: <evalFunctionInjection> -[RETURNS]-> <surprise()>
    void code;
  });

  test('coercion-hoisting::eval-new-function', () => {
    const code = "function newFunction(body) {\n  const fn = new Function('a', 'b', body);\n  return fn(1, 2);\n}\n\n// --- Comma operator for side effects ---";
    // Expect node: FUNCTION <newFunction>
    // Expect node: PARAMETER <body>
    // Expect node: VARIABLE <fn>
    // Expect node: CALL <new Function('a', 'b', body)>
    // Expect node: LITERAL <'a'>
    // Expect node: LITERAL <'b'>
    // Expect node: CALL <fn(1, 2)>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect edge: <newFunction> -[HAS_BODY]-> <body>
    // Expect edge: <newFunction> -[DECLARES]-> <fn>
    // Expect edge: <new Function('a', 'b', body)> -[PASSES_ARGUMENT]-> <'a'>
    // Expect edge: <new Function('a', 'b', body)> -[PASSES_ARGUMENT]-> <'b'>
    // Expect edge: <new Function('a', 'b', body)> -[PASSES_ARGUMENT]-> <body>
    // Expect edge: <newFunction> -[RETURNS]-> <fn(1, 2)>
    // Expect edge: <fn(1, 2)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <fn(1, 2)> -[PASSES_ARGUMENT]-> <2>
    void code;
  });

  test('coercion-hoisting::coerce-comma-sequence', () => {
    const code = "function commaSequence() {\n  let x = 0;\n  const result = (x++, x++, x++, x);\n  return result; // 3\n}";
    // Expect node: FUNCTION <commaSequence>
    // Expect node: VARIABLE <x>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <comma-sequence>
    // Expect node: EXPRESSION <x++[1]>
    // Expect node: EXPRESSION <x++[2]>
    // Expect node: EXPRESSION <x++[3]>
    // Expect node: EXPRESSION <x-final>
    // Expect edge: <commaSequence> -[CONTAINS]-> <x>
    // Expect edge: <commaSequence> -[CONTAINS]-> <result>
    // Expect edge: <comma-sequence> -[HAS_ELEMENT]-> <x++[1]>
    // Expect edge: <comma-sequence> -[HAS_ELEMENT]-> <x++[2]>
    // Expect edge: <comma-sequence> -[HAS_ELEMENT]-> <x++[3]>
    // Expect edge: <comma-sequence> -[HAS_ELEMENT]-> <x-final>
    // Expect edge: <commaSequence> -[RETURNS]-> <result>
    void code;
  });

  test('coercion-hoisting::shadow-block-scope', () => {
    const code = "const outerConst = 'outer';\n\nfunction shadowingExample() {\n  const outerConst = 'shadowed'; // shadows module-level\n  if (true) {\n    const outerConst = 'inner-shadowed'; // shadows function-level\n    console.log(outerConst); // 'inner-shadowed'\n  }\n  return outerConst; // 'shadowed'\n}";
    // Expect node: VARIABLE <outerConst:module>
    // Expect node: LITERAL <'outer'>
    // Expect node: FUNCTION <shadowingExample>
    // Expect node: SCOPE <shadowingExample:scope>
    // Expect node: VARIABLE <outerConst:function>
    // Expect node: LITERAL <'shadowed'>
    // Expect node: BRANCH <if-true>
    // Expect node: SCOPE <if-block:scope>
    // Expect node: VARIABLE <outerConst:block>
    // Expect node: LITERAL <'inner-shadowed'>
    // Expect node: CALL <console.log(outerConst)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect edge: <shadowingExample:scope> -[DECLARES]-> <outerConst:function>
    // Expect edge: <outerConst:function> -[SHADOWS]-> <outerConst:module>
    // Expect edge: <shadowingExample> -[HAS_SCOPE]-> <shadowingExample:scope>
    // Expect edge: <shadowingExample> -[CONTAINS]-> <if-true>
    // Expect edge: <if-true> -[HAS_SCOPE]-> <if-block:scope>
    // Expect edge: <if-block:scope> -[DECLARES]-> <outerConst:block>
    // Expect edge: <outerConst:block> -[SHADOWS]-> <outerConst:function>
    // Expect edge: <if-true> -[CONTAINS]-> <console.log(outerConst)>
    // Expect edge: <console.log(outerConst)> -[PASSES_ARGUMENT]-> <outerConst:block>
    // Expect edge: <shadowingExample> -[RETURNS]-> <outerConst:function>
    void code;
  });

  test('declarations::var-decl-uninit', () => {
    const code = "var uninitialized;";
    // Expect node: VARIABLE <uninitialized>
    // Expect edge: <module> -[DECLARES]-> <uninitialized>
    void code;
  });

  test('coercion-hoisting::block-label-ambiguity', () => {
    const code = "function blockLabelAmbiguity() {\n  // { a: 1 } in statement position is a block with labeled expression, NOT an object\n  // Parentheses force expression context:\n  const obj = eval('({ a: 1, b: 2 })'); // object literal\n  // eval('{ a: 1, b: 2 }');            // SyntaxError — block + label + illegal comma\n  return obj;\n}";
    // Expect node: FUNCTION <blockLabelAmbiguity>
    // Expect node: VARIABLE <obj>
    // Expect node: CALL <eval('({ a: 1, b: 2 })')>
    // Expect node: LITERAL <'({ a: 1, b: 2 })'>
    // Expect node: EXTERNAL <eval>
    // Expect edge: <module> -[DECLARES]-> <blockLabelAmbiguity>
    // Expect edge: <blockLabelAmbiguity> -[CONTAINS]-> <obj>
    // Expect edge: <eval('({ a: 1, b: 2 })')> -[PASSES_ARGUMENT]-> <'({ a: 1, b: 2 })'>
    // Expect edge: <blockLabelAmbiguity> -[RETURNS]-> <obj>
    void code;
  });

  test('async-generators::async-destructure-await-default', () => {
    const code = "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};";
    // Expect node: FUNCTION <getConfigValue>
    // Expect node: PARAMETER <key>
    // Expect node: VARIABLE <asyncDestructureHandler>
    // Expect node: FUNCTION <asyncDestructureHandler:fn>
    // Expect node: PARAMETER <destructured-param>
    // Expect node: PROPERTY <timeout>
    // Expect node: PROPERTY <retries>
    // Expect node: CALL <getConfigValue('timeout')>
    // Expect node: LITERAL <'timeout'>
    // Expect node: CALL <getConfigValue('retries')>
    // Expect node: LITERAL <'retries'>
    // Expect node: EXPRESSION <{ timeout, retries }>
    // Expect edge: <getConfigValue> -[CONTAINS]-> <key>
    // Expect edge: <getConfigValue> -[RETURNS]-> <key>
    // Expect edge: <asyncDestructureHandler:fn> -[CONTAINS]-> <destructured-param>
    // Expect edge: <destructured-param> -[HAS_PROPERTY]-> <timeout>
    // Expect edge: <destructured-param> -[HAS_PROPERTY]-> <retries>
    // Expect edge: <timeout> -[DEFAULTS_TO]-> <getConfigValue('timeout')>
    // Expect edge: <retries> -[DEFAULTS_TO]-> <getConfigValue('retries')>
    // Expect edge: <getConfigValue('timeout')> -[PASSES_ARGUMENT]-> <'timeout'>
    // Expect edge: <getConfigValue('retries')> -[PASSES_ARGUMENT]-> <'retries'>
    // Expect edge: <asyncDestructureHandler:fn> -[RETURNS]-> <{ timeout, retries }>
    // Expect edge: <getConfigValue('timeout')> -[AWAITS]-> <timeout>
    // Expect edge: <getConfigValue('retries')> -[AWAITS]-> <retries>
    void code;
  });

  test('coercion-hoisting::typeof-tdz-trap', () => {
    const code = "function typeofTdzTrap() {\n  try {\n    const result = typeof x; // ReferenceError — x is in TDZ, unlike undeclared\n  } catch (e) {\n    // typeof on TDZ variable THROWS, unlike typeof on undeclared\n  }\n  let x = 5;\n}";
    // Expect node: FUNCTION <typeofTdzTrap>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <typeof x>
    // Expect node: PARAMETER <e>
    // Expect node: VARIABLE <x>
    // Expect node: LITERAL <5>
    // Expect edge: <typeofTdzTrap> -[HAS_BODY]-> <try-block>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <try-block> -[DECLARES]-> <result>
    // Expect edge: <catch-block> -[DECLARES]-> <e>
    // Expect edge: <typeofTdzTrap> -[DECLARES]-> <x>
    void code;
  });

  test('coercion-hoisting::var-function-collision', () => {
    const code = "function varFunctionCollision() {\n  console.log(typeof collision); // \"function\" — function hoists over var\n  var collision = 1;\n  function collision() { return 2; }\n  console.log(typeof collision); // \"number\" — assignment runs after\n  return collision;\n}";
    // Expect node: FUNCTION <varFunctionCollision>
    // Expect node: CALL <console.log(typeof collision)1>
    // Expect node: EXPRESSION <typeof collision1>
    // Expect node: VARIABLE <collision:var>
    // Expect node: LITERAL <1>
    // Expect node: FUNCTION <collision:fn>
    // Expect node: LITERAL <2>
    // Expect node: CALL <console.log(typeof collision)2>
    // Expect node: EXPRESSION <typeof collision2>
    // Expect node: EXTERNAL <console.log>
    // Expect edge: <varFunctionCollision> -[CONTAINS]-> <console.log(typeof collision)1>
    // Expect edge: <console.log(typeof collision)1> -[PASSES_ARGUMENT]-> <typeof collision1>
    // Expect edge: <varFunctionCollision> -[DECLARES]-> <collision:var>
    // Expect edge: <varFunctionCollision> -[DECLARES]-> <collision:fn>
    // Expect edge: <collision:fn> -[RETURNS]-> <2>
    // Expect edge: <varFunctionCollision> -[CONTAINS]-> <console.log(typeof collision)2>
    // Expect edge: <console.log(typeof collision)2> -[PASSES_ARGUMENT]-> <typeof collision2>
    // Expect edge: <varFunctionCollision> -[RETURNS]-> <collision:var>
    // Expect edge: <collision:fn> -[SHADOWS]-> <collision:var>
    void code;
  });

  test('declarations::var-decl-init', () => {
    const code = "var mutableVar = 'hello';";
    // Expect node: VARIABLE <mutableVar>
    // Expect node: LITERAL <'hello'>
    // Expect edge: <module> -[DECLARES]-> <mutableVar>
    void code;
  });

  test('declarations::let-decl-init', () => {
    const code = "let reassignable = 42;";
    // Expect node: VARIABLE <reassignable>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <reassignable>
    void code;
  });

  test('declarations::let-decl-uninit', () => {
    const code = "let uninitializedLet;";
    // Expect node: VARIABLE <uninitializedLet>
    // Expect edge: <module> -[DECLARES]-> <uninitializedLet>
    void code;
  });

  test('coercion-hoisting::var-in-catch-clobber', () => {
    const code = "function varInCatchClobber() {\n  try {\n    throw new Error('oops');\n  } catch (e) {\n    var e = 'overwritten';  // var hoists to function scope, shares binding with catch param\n  }\n  return e; // 'overwritten' in sloppy; in strict var still hoists but catch e is separate\n}";
    // Expect node: FUNCTION <varInCatchClobber>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <new Error('oops')>
    // Expect node: LITERAL <'oops'>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e:catch>
    // Expect node: VARIABLE <e:var>
    // Expect node: LITERAL <'overwritten'>
    // Expect node: EXPRESSION <return e>
    // Expect edge: <varInCatchClobber> -[CONTAINS]-> <try-block>
    // Expect edge: <new Error('oops')> -[PASSES_ARGUMENT]-> <'oops'>
    // Expect edge: <varInCatchClobber> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <e:catch>
    // Expect edge: <catch-block> -[CONTAINS]-> <e:var>
    // Expect edge: <varInCatchClobber> -[RETURNS]-> <return e>
    // Expect edge: <varInCatchClobber> -[DECLARES]-> <e:var>
    void code;
  });

  test('coercion-hoisting::primitive-autoboxing', () => {
    const code = "function primitiveAutoboxing() {\n  const str = 'hello';\n  const upper = str.toUpperCase(); // auto-boxes to String object\n  str.customProp = 1; // sets on TEMPORARY boxed String, immediately GC'd\n  const lost = str.customProp; // undefined\n\n  const num = 42;\n  const fixed = num.toFixed(2); // auto-boxes to Number\n\n  return { upper, lost, fixed };\n}";
    // Expect node: FUNCTION <primitiveAutoboxing>
    // Expect node: VARIABLE <str>
    // Expect node: LITERAL <'hello'>
    // Expect node: VARIABLE <upper>
    // Expect node: CALL <str.toUpperCase()>
    // Expect node: PROPERTY_ACCESS <str.customProp>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <lost>
    // Expect node: PROPERTY_ACCESS <str.customProp:read>
    // Expect node: VARIABLE <num>
    // Expect node: LITERAL <42>
    // Expect node: VARIABLE <fixed>
    // Expect node: CALL <num.toFixed(2)>
    // Expect node: LITERAL <2>
    // Expect node: EXPRESSION <{ upper, lost, fixed }>
    // Expect edge: <primitiveAutoboxing> -[CONTAINS]-> <str>
    // Expect edge: <primitiveAutoboxing> -[CONTAINS]-> <upper>
    // Expect edge: <str.customProp> -[HAS_PROPERTY]-> <str>
    // Expect edge: <primitiveAutoboxing> -[CONTAINS]-> <lost>
    // Expect edge: <str.customProp:read> -[HAS_PROPERTY]-> <str>
    // Expect edge: <primitiveAutoboxing> -[CONTAINS]-> <num>
    // Expect edge: <primitiveAutoboxing> -[CONTAINS]-> <fixed>
    // Expect edge: <num.toFixed(2)> -[PASSES_ARGUMENT]-> <2>
    // Expect edge: <primitiveAutoboxing> -[RETURNS]-> <{ upper, lost, fixed }>
    void code;
  });

  test('coercion-hoisting::block-function-declaration-strict', () => {
    const code = "// NOTE: behavior differs between strict (ESM) and sloppy (script) mode.\n// This file is ESM (strict), so the function is block-scoped.\n// In sloppy mode (.cjs / <script>), the function would leak to function scope (Annex B).\nfunction blockFunctionDemo() {\n  let result = 'before';\n\n  if (true) {\n    function blockFn() { return 'inside'; }  // block-scoped in strict/ESM\n    result = blockFn();\n  }\n\n  // blockFn is NOT accessible here in strict mode\n  // In sloppy mode it WOULD be accessible (Annex B hoisting)\n  return result;\n}";
    // Expect node: FUNCTION <blockFunctionDemo>
    // Expect node: VARIABLE <result>
    // Expect node: LITERAL <'before'>
    // Expect node: BRANCH <if-true>
    // Expect node: LITERAL <true>
    // Expect node: SCOPE <if-block-scope>
    // Expect node: FUNCTION <blockFn>
    // Expect node: LITERAL <'inside'>
    // Expect node: CALL <blockFn()>
    // Expect node: EXPRESSION <result = blockFn()>
    // Expect edge: <blockFunctionDemo> -[CONTAINS]-> <result>
    // Expect edge: <blockFunctionDemo> -[CONTAINS]-> <if-true>
    // Expect edge: <if-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <if-true> -[HAS_BODY]-> <if-block-scope>
    // Expect edge: <if-block-scope> -[DECLARES]-> <blockFn>
    // Expect edge: <blockFn> -[RETURNS]-> <'inside'>
    // Expect edge: <if-block-scope> -[CONTAINS]-> <blockFn()>
    // Expect edge: <if-block-scope> -[CONTAINS]-> <result = blockFn()>
    // Expect edge: <blockFunctionDemo> -[RETURNS]-> <result>
    void code;
  });

  test('coercion-hoisting::var-redeclares-parameter', () => {
    const code = "function varRedeclaresParameter(x, y) {\n  var x = x || 'default'; // same binding as parameter x — NOT a new variable\n  var y;                    // re-declares y but does NOT reset it\n  return { x, y };\n}\n// varRedeclaresParameter(null, 42) → { x: 'default', y: 42 }\n// Contrast: let x = ... inside would be SyntaxError (cannot re-declare param)";
    // Expect node: FUNCTION <varRedeclaresParameter>
    // Expect node: PARAMETER <x>
    // Expect node: PARAMETER <y>
    // Expect node: EXPRESSION <x || 'default'>
    // Expect node: LITERAL <'default'>
    // Expect node: EXPRESSION <{ x, y }>
    // Expect edge: <varRedeclaresParameter> -[CONTAINS]-> <x>
    // Expect edge: <varRedeclaresParameter> -[CONTAINS]-> <y>
    // Expect edge: <varRedeclaresParameter> -[RETURNS]-> <{ x, y }>
    void code;
  });

  test('declarations::const-decl-bool-literal', () => {
    const code = "const immutable = true;";
    // Expect node: VARIABLE <immutable>
    // Expect node: LITERAL <true>
    // Expect edge: <module> -[DECLARES]-> <immutable>
    void code;
  });

  test('declarations::const-decl-bigint-literal', () => {
    const code = "const bigNumber = 42n;";
    // Expect node: VARIABLE <bigNumber>
    // Expect node: LITERAL <42n>
    // Expect edge: <module> -[DECLARES]-> <bigNumber>
    void code;
  });

  test('declarations::var-decl-multi', () => {
    const code = "var multi1 = 1, multi2 = 2, multi3 = 3;";
    // Expect node: VARIABLE <multi1>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <multi2>
    // Expect node: LITERAL <2>
    // Expect node: VARIABLE <multi3>
    // Expect node: LITERAL <3>
    // Expect edge: <module> -[DECLARES]-> <multi1>
    // Expect edge: <module> -[DECLARES]-> <multi2>
    // Expect edge: <module> -[DECLARES]-> <multi3>
    void code;
  });

  test('declarations::const-decl-object-literal', () => {
    const code = "const objectConst = { key: 'value' };";
    // Expect node: VARIABLE <objectConst>
    // Expect node: LITERAL <objectConst:object>
    // Expect node: LITERAL <'key'>
    // Expect node: LITERAL <'value'>
    // Expect edge: <module> -[DECLARES]-> <objectConst>
    // Expect edge: <objectConst:object> -[HAS_PROPERTY]-> <'key'>
    void code;
  });

  test('declarations::const-decl-call-result-1', () => {
    const code = "const uniqueKey = Symbol('description');";
    // Expect node: VARIABLE <uniqueKey>
    // Expect node: CALL <Symbol('description')>
    // Expect node: LITERAL <'description'>
    // Expect edge: <module> -[DECLARES]-> <uniqueKey>
    // Expect edge: <Symbol('description')> -[PASSES_ARGUMENT]-> <'description'>
    void code;
  });

  test('declarations::const-decl-array-literal', () => {
    const code = "const arrayConst = [1, 2, 3];";
    // Expect node: VARIABLE <arrayConst>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect edge: <module> -[DECLARES]-> <arrayConst>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <1>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <2>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <3>
    void code;
  });

  test('coercion-hoisting::eval-let-scope', () => {
    const code = "function evalLetScope() {\n  eval('let y = 2');   // y is block-scoped to the eval itself\n  try {\n    return y;          // ReferenceError — y doesn't exist here\n  } catch (e) {\n    return 'y not accessible';\n  }\n}";
    // Expect node: FUNCTION <evalLetScope>
    // Expect node: CALL <eval('let y = 2')>
    // Expect node: LITERAL <'let y = 2'>
    // Expect node: VARIABLE <y>
    // Expect node: LITERAL <2>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: EXPRESSION <return y>
    // Expect node: LITERAL <'y not accessible'>
    // Expect node: SCOPE <eval-scope>
    // Expect edge: <evalLetScope> -[CONTAINS]-> <eval('let y = 2')>
    // Expect edge: <eval('let y = 2')> -[PASSES_ARGUMENT]-> <'let y = 2'>
    // Expect edge: <eval('let y = 2')> -[HAS_SCOPE]-> <eval-scope>
    // Expect edge: <eval-scope> -[DECLARES]-> <y>
    // Expect edge: <evalLetScope> -[CONTAINS]-> <try-block>
    // Expect edge: <evalLetScope> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <return y>
    // Expect edge: <evalLetScope> -[RETURNS]-> <return y>
    // Expect edge: <catch-block> -[RECEIVES_ARGUMENT]-> <e>
    // Expect edge: <evalLetScope> -[RETURNS]-> <'y not accessible'>
    void code;
  });

  test('declarations::func-decl', () => {
    const code = "function regularFunction(param1, param2) {\n  return param1 + param2;\n}";
    // Expect node: FUNCTION <regularFunction>
    // Expect node: PARAMETER <param1>
    // Expect node: PARAMETER <param2>
    // Expect node: EXPRESSION <param1 + param2>
    // Expect edge: <module> -[DECLARES]-> <regularFunction>
    // Expect edge: <regularFunction> -[CONTAINS]-> <param1>
    // Expect edge: <regularFunction> -[CONTAINS]-> <param2>
    // Expect edge: <regularFunction> -[RETURNS]-> <param1 + param2>
    void code;
  });

  test('declarations::const-decl-call-result', () => {
    const code = "const bigComputed = BigInt(Number.MAX_SAFE_INTEGER);";
    // Expect node: VARIABLE <bigComputed>
    // Expect node: CALL <BigInt(Number.MAX_SAFE_INTEGER)>
    // Expect node: PROPERTY_ACCESS <Number.MAX_SAFE_INTEGER>
    // Expect edge: <module> -[DECLARES]-> <bigComputed>
    // Expect edge: <BigInt(Number.MAX_SAFE_INTEGER)> -[PASSES_ARGUMENT]-> <Number.MAX_SAFE_INTEGER>
    void code;
  });

  test('declarations::func-decl-rest-params', () => {
    const code = "function withRestParams(...args) {\n  return args.length;\n}";
    // Expect node: FUNCTION <withRestParams>
    // Expect node: PARAMETER <args>
    // Expect node: PROPERTY_ACCESS <args.length>
    // Expect edge: <module> -[DECLARES]-> <withRestParams>
    // Expect edge: <withRestParams> -[CONTAINS]-> <args>
    // Expect edge: <withRestParams> -[RETURNS]-> <args.length>
    void code;
  });

  test('declarations::const-decl-method-call-result', () => {
    const code = "const globalSymbol = Symbol.for('shared');";
    // Expect node: VARIABLE <globalSymbol>
    // Expect node: CALL <Symbol.for('shared')>
    // Expect node: PROPERTY_ACCESS <Symbol.for>
    // Expect node: LITERAL <'shared'>
    // Expect node: EXTERNAL <Symbol>
    // Expect edge: <module> -[DECLARES]-> <globalSymbol>
    // Expect edge: <Symbol.for('shared')> -[PASSES_ARGUMENT]-> <'shared'>
    void code;
  });

  test('coercion-hoisting::object-as-map-key-tostring', () => {
    const code = "function objectAsMapKey() {\n  const cache = {};\n  const obj = {};\n  cache[obj] = 'value';           // key is \"[object Object]\"\n  cache[{ a: 1 }] = 'another';   // SAME key \"[object Object]\" — overwrites!\n  return cache;\n}";
    // Expect node: FUNCTION <objectAsMapKey>
    // Expect node: VARIABLE <cache>
    // Expect node: LITERAL <{}>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <obj-literal>
    // Expect node: PROPERTY_ACCESS <cache[obj]>
    // Expect node: LITERAL <'value'>
    // Expect node: PROPERTY_ACCESS <cache[{ a: 1 }]>
    // Expect node: LITERAL <{ a: 1 }>
    // Expect node: LITERAL <'another'>
    // Expect node: SIDE_EFFECT <obj-toString>
    // Expect node: SIDE_EFFECT <inline-obj-toString>
    // Expect edge: <objectAsMapKey> -[CONTAINS]-> <cache>
    // Expect edge: <objectAsMapKey> -[CONTAINS]-> <obj>
    // Expect edge: <objectAsMapKey> -[RETURNS]-> <cache>
    void code;
  });

  test('declarations::const-decl-regex-literal', () => {
    const code = "const regexSimple = /hello/;\nconst regexFlags = /pattern/gi;\nconst regexComplex = /^start.*end$/ms;\n\n// Function Declarations";
    // Expect node: VARIABLE <regexSimple>
    // Expect node: LITERAL </hello/>
    // Expect node: VARIABLE <regexFlags>
    // Expect node: LITERAL </pattern/gi>
    // Expect node: VARIABLE <regexComplex>
    // Expect node: LITERAL </^start.*end$/ms>
    // Expect edge: <module> -[DECLARES]-> <regexSimple>
    // Expect edge: <module> -[DECLARES]-> <regexFlags>
    // Expect edge: <module> -[DECLARES]-> <regexComplex>
    void code;
  });

  test('declarations::func-decl-defaults', () => {
    const code = "function withDefaults(a = 10, b = 'default') {\n  return `${a}${b}`;\n}";
    // Expect node: FUNCTION <withDefaults>
    // Expect node: PARAMETER <a>
    // Expect node: LITERAL <10>
    // Expect node: PARAMETER <b>
    // Expect node: LITERAL <'default'>
    // Expect node: EXPRESSION <`${a}${b}`>
    // Expect edge: <withDefaults> -[CONTAINS]-> <a>
    // Expect edge: <withDefaults> -[CONTAINS]-> <b>
    // Expect edge: <a> -[DEFAULTS_TO]-> <10>
    // Expect edge: <b> -[DEFAULTS_TO]-> <'default'>
    // Expect edge: <withDefaults> -[RETURNS]-> <`${a}${b}`>
    void code;
  });

  test('coercion-hoisting::export-named-list', () => {
    const code = "export {\n  stringCoercion,\n  numberCoercion,\n  booleanCoercion,\n  equalityCoercion,\n  customCoerce,\n  usedInMath,\n  usedInTemplate,\n  toPrimitive,\n  varHoisting,\n  functionHoisting,\n  functionExprNotHoisted,\n  tdzLet,\n  tdzConst,\n  tdzClass,\n  outerConst,\n  shadowingExample,\n  paramShadowing,\n  catchShadowing,\n  directEval,\n  indirectEval,\n  newFunction,\n  commaSequence,\n  evalVarInjection,\n  evalFunctionInjection,\n  primitiveAutoboxing,\n  varFunctionCollision,\n  contextualKeywords,\n  objectAsMapKey,\n  blockFunctionDemo,\n  varInCatchClobber,\n  typeofTdzTrap,\n  evalLetScope,\n  blockLabelAmbiguity,\n  varRedeclaresParameter,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect edge: <module> -[CONTAINS]-> <export-named-list>
    void code;
  });

  test('declarations::func-expr-named', () => {
    const code = "const namedExpression = function multiply(x, y) {\n  return x * y;\n};";
    // Expect node: VARIABLE <namedExpression>
    // Expect node: FUNCTION <multiply>
    // Expect node: PARAMETER <x>
    // Expect node: PARAMETER <y>
    // Expect node: EXPRESSION <x * y>
    // Expect edge: <module> -[DECLARES]-> <namedExpression>
    // Expect edge: <multiply> -[CONTAINS]-> <x>
    // Expect edge: <multiply> -[CONTAINS]-> <y>
    // Expect edge: <multiply> -[RETURNS]-> <x * y>
    void code;
  });

  test('declarations::arrow-single-param', () => {
    const code = "const arrowSingleParam = x => x * 2;";
    // Expect node: VARIABLE <arrowSingleParam>
    // Expect node: FUNCTION <arrowSingleParam:fn>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect edge: <module> -[DECLARES]-> <arrowSingleParam>
    // Expect edge: <arrowSingleParam:fn> -[CONTAINS]-> <x>
    // Expect edge: <arrowSingleParam:fn> -[RETURNS]-> <x * 2>
    void code;
  });

  test('declarations::arrow-block-body', () => {
    const code = "const arrowBlock = (a, b) => {\n  return a + b;\n};";
    // Expect node: VARIABLE <arrowBlock>
    // Expect node: FUNCTION <arrowBlock:fn>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a + b>
    // Expect edge: <module> -[DECLARES]-> <arrowBlock>
    // Expect edge: <arrowBlock:fn> -[CONTAINS]-> <a>
    // Expect edge: <arrowBlock:fn> -[CONTAINS]-> <b>
    // Expect edge: <arrowBlock:fn> -[RETURNS]-> <a + b>
    void code;
  });

  test('declarations::arrow-expression-body', () => {
    const code = "const arrowExpression = (a, b) => a + b;";
    // Expect node: VARIABLE <arrowExpression>
    // Expect node: FUNCTION <arrowExpression:fn>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a + b>
    // Expect edge: <module> -[DECLARES]-> <arrowExpression>
    // Expect edge: <arrowExpression:fn> -[CONTAINS]-> <a>
    // Expect edge: <arrowExpression:fn> -[CONTAINS]-> <b>
    // Expect edge: <arrowExpression:fn> -[RETURNS]-> <a + b>
    void code;
  });

  test('declarations::arrow-no-params', () => {
    const code = "const arrowNoParams = () => 42;\n\n// Generator Functions";
    // Expect node: VARIABLE <arrowNoParams>
    // Expect node: FUNCTION <arrowNoParams:fn>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <arrowNoParams>
    // Expect edge: <arrowNoParams:fn> -[RETURNS]-> <42>
    void code;
  });

  test('declarations::func-expr-anonymous', () => {
    const code = "const anonymousExpression = function (x) {\n  return x * 2;\n};\n\n// Arrow Functions";
    // Expect node: VARIABLE <anonymousExpression>
    // Expect node: FUNCTION <anonymousExpression:fn>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect edge: <module> -[DECLARES]-> <anonymousExpression>
    // Expect edge: <anonymousExpression:fn> -[CONTAINS]-> <x>
    // Expect edge: <anonymousExpression:fn> -[RETURNS]-> <x * 2>
    void code;
  });

  test('declarations::func-decl-mixed-params', () => {
    const code = "function withMixedParams(required, optional = null, ...rest) {\n  return [required, optional, ...rest];\n}\n\n// Function Expressions";
    // Expect node: FUNCTION <withMixedParams>
    // Expect node: PARAMETER <required>
    // Expect node: PARAMETER <optional>
    // Expect node: LITERAL <null>
    // Expect node: PARAMETER <rest>
    // Expect node: EXPRESSION <[required, optional, ...rest]>
    // Expect edge: <withMixedParams> -[CONTAINS]-> <required>
    // Expect edge: <withMixedParams> -[CONTAINS]-> <optional>
    // Expect edge: <withMixedParams> -[CONTAINS]-> <rest>
    // Expect edge: <optional> -[DEFAULTS_TO]-> <null>
    // Expect edge: <withMixedParams> -[RETURNS]-> <[required, optional, ...rest]>
    void code;
  });

  test('builtins::builtin-json-parse', () => {
    const code = "function jsonParse(str) {\n  return JSON.parse(str);\n}";
    // Expect node: FUNCTION <jsonParse>
    // Expect node: PARAMETER <str>
    // Expect node: CALL <JSON.parse(str)>
    // Expect node: PROPERTY_ACCESS <JSON.parse>
    // Expect node: EXTERNAL <JSON>
    // Expect edge: <jsonParse> -[CONTAINS]-> <str>
    // Expect edge: <jsonParse> -[RETURNS]-> <JSON.parse(str)>
    // Expect edge: <JSON.parse(str)> -[PASSES_ARGUMENT]-> <str>
    void code;
  });

  test('declarations::generator-decl', () => {
    const code = "function* numberGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}";
    // Expect node: FUNCTION <numberGenerator>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect edge: <module> -[DECLARES]-> <numberGenerator>
    // Expect edge: <numberGenerator> -[YIELDS]-> <1>
    // Expect edge: <numberGenerator> -[YIELDS]-> <2>
    // Expect edge: <numberGenerator> -[YIELDS]-> <3>
    void code;
  });

  test('declarations::async-func-decl', () => {
    const code = "async function asyncFunction() {\n  return await Promise.resolve(42);\n}";
    // Expect node: FUNCTION <asyncFunction>
    // Expect node: CALL <Promise.resolve(42)>
    // Expect node: LITERAL <42>
    // Expect node: EXPRESSION <await Promise.resolve(42)>
    // Expect edge: <module> -[DECLARES]-> <asyncFunction>
    // Expect edge: <asyncFunction> -[RETURNS]-> <await Promise.resolve(42)>
    // Expect edge: <await Promise.resolve(42)> -[AWAITS]-> <Promise.resolve(42)>
    // Expect edge: <Promise.resolve(42)> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('declarations::generator-delegation', () => {
    const code = "function* delegatingGenerator() {\n  yield* numberGenerator();\n  yield 4;\n}\n\n// Async Functions";
    // Expect node: FUNCTION <delegatingGenerator>
    // Expect node: EXPRESSION <yield* numberGenerator()>
    // Expect node: CALL <numberGenerator()>
    // Expect node: EXPRESSION <yield 4>
    // Expect node: LITERAL <4>
    // Expect edge: <module> -[DECLARES]-> <delegatingGenerator>
    // Expect edge: <delegatingGenerator> -[CONTAINS]-> <yield* numberGenerator()>
    // Expect edge: <delegatingGenerator> -[CONTAINS]-> <yield 4>
    // Expect edge: <yield* numberGenerator()> -[DELEGATES_TO]-> <numberGenerator()>
    // Expect edge: <yield 4> -[YIELDS]-> <4>
    void code;
  });

  test('declarations::iife', () => {
    const code = "const iifeResult = (function () {\n  return 'iife';\n})();";
    // Expect node: VARIABLE <iifeResult>
    // Expect node: FUNCTION <iife:fn>
    // Expect node: LITERAL <'iife'>
    // Expect node: CALL <iife:call>
    // Expect edge: <module> -[DECLARES]-> <iifeResult>
    // Expect edge: <iife:fn> -[RETURNS]-> <'iife'>
    void code;
  });

  test('declarations::iife-arrow', () => {
    const code = "const arrowIifeResult = (() => {\n  return 'arrow iife';\n})();\n\n// Named Exports";
    // Expect node: VARIABLE <arrowIifeResult>
    // Expect node: FUNCTION <arrow-iife:fn>
    // Expect node: LITERAL <'arrow iife'>
    // Expect node: CALL <arrow-iife:call>
    // Expect edge: <module> -[DECLARES]-> <arrowIifeResult>
    // Expect edge: <arrow-iife:fn> -[RETURNS]-> <'arrow iife'>
    void code;
  });

  test('declarations::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve('async arrow');\n};\n\n// Async Generator Functions";
    // Expect node: VARIABLE <asyncArrow>
    // Expect node: FUNCTION <asyncArrow:fn>
    // Expect node: EXPRESSION <await Promise.resolve('async arrow')>
    // Expect node: CALL <Promise.resolve('async arrow')>
    // Expect node: LITERAL <'async arrow'>
    // Expect node: EXTERNAL <Promise.resolve>
    // Expect edge: <module> -[DECLARES]-> <asyncArrow>
    // Expect edge: <asyncArrow:fn> -[RETURNS]-> <await Promise.resolve('async arrow')>
    // Expect edge: <await Promise.resolve('async arrow')> -[AWAITS]-> <Promise.resolve('async arrow')>
    // Expect edge: <Promise.resolve('async arrow')> -[PASSES_ARGUMENT]-> <'async arrow'>
    void code;
  });

  test('declarations::arrow-return-object-literal', () => {
    const code = "const arrowReturnsObject = (x) => ({ key: x, value: x * 2 });\n// Without parens: (x) => { key: x } — parsed as block with label \"key\"!";
    // Expect node: VARIABLE <arrowReturnsObject>
    // Expect node: FUNCTION <arrowReturnsObject:fn>
    // Expect node: PARAMETER <x>
    // Expect node: LITERAL <object-literal>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect edge: <module> -[DECLARES]-> <arrowReturnsObject>
    // Expect edge: <arrowReturnsObject:fn> -[CONTAINS]-> <x>
    // Expect edge: <arrowReturnsObject:fn> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <x>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <x * 2>
    void code;
  });

  test('declarations::param-default-scope-quirk', () => {
    const code = "let outerX = 'outer';\nfunction paramDefaultScope(a = () => outerX, outerX) {\n  return a();\n}";
    // Expect node: VARIABLE <outerX>
    // Expect node: LITERAL <'outer'>
    // Expect node: FUNCTION <paramDefaultScope>
    // Expect node: PARAMETER <a>
    // Expect node: FUNCTION <a:default>
    // Expect node: PARAMETER <outerX:param>
    // Expect node: CALL <a()>
    // Expect edge: <paramDefaultScope> -[CONTAINS]-> <a>
    // Expect edge: <paramDefaultScope> -[CONTAINS]-> <outerX:param>
    // Expect edge: <a> -[DEFAULTS_TO]-> <a:default>
    // Expect edge: <paramDefaultScope> -[RETURNS]-> <a()>
    // Expect edge: <outerX:param> -[SHADOWS]-> <outerX>
    void code;
  });

  test('declarations::async-iife', () => {
    const code = "const asyncIifeResult = (async () => {\n  return await Promise.resolve('async iife');\n})();";
    // Expect node: VARIABLE <asyncIifeResult>
    // Expect node: FUNCTION <async-iife:fn>
    // Expect node: CALL <async-iife:call>
    // Expect node: CALL <Promise.resolve('async iife')>
    // Expect node: LITERAL <'async iife'>
    // Expect node: EXPRESSION <await Promise.resolve('async iife')>
    // Expect edge: <async-iife:fn> -[RETURNS]-> <await Promise.resolve('async iife')>
    // Expect edge: <await Promise.resolve('async iife')> -[AWAITS]-> <Promise.resolve('async iife')>
    // Expect edge: <Promise.resolve('async iife')> -[PASSES_ARGUMENT]-> <'async iife'>
    void code;
  });

  test('declarations::async-generator-decl', () => {
    const code = "async function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\n// IIFE (Immediately Invoked Function Expression)";
    // Expect node: FUNCTION <asyncGenerator>
    // Expect node: EXPRESSION <yield await Promise.resolve(1)>
    // Expect node: EXPRESSION <await Promise.resolve(1)>
    // Expect node: CALL <Promise.resolve(1)>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <yield await Promise.resolve(2)>
    // Expect node: EXPRESSION <await Promise.resolve(2)>
    // Expect node: CALL <Promise.resolve(2)>
    // Expect node: LITERAL <2>
    // Expect node: EXTERNAL <Promise>
    // Expect edge: <asyncGenerator> -[CONTAINS]-> <yield await Promise.resolve(1)>
    // Expect edge: <asyncGenerator> -[CONTAINS]-> <yield await Promise.resolve(2)>
    // Expect edge: <yield await Promise.resolve(1)> -[YIELDS]-> <await Promise.resolve(1)>
    // Expect edge: <await Promise.resolve(1)> -[AWAITS]-> <Promise.resolve(1)>
    // Expect edge: <Promise.resolve(1)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <yield await Promise.resolve(2)> -[YIELDS]-> <await Promise.resolve(2)>
    // Expect edge: <await Promise.resolve(2)> -[AWAITS]-> <Promise.resolve(2)>
    // Expect edge: <Promise.resolve(2)> -[PASSES_ARGUMENT]-> <2>
    void code;
  });

  test('declarations::param-default-depends-on-prior', () => {
    const code = "function paramDefaultChain(a, b = a * 2, c = a + b) {\n  return { a, b, c };\n}";
    // Expect node: FUNCTION <paramDefaultChain>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: EXPRESSION <a * 2>
    // Expect node: LITERAL <2>
    // Expect node: PARAMETER <c>
    // Expect node: EXPRESSION <a + b>
    // Expect node: EXPRESSION <{ a, b, c }>
    // Expect edge: <paramDefaultChain> -[CONTAINS]-> <a>
    // Expect edge: <paramDefaultChain> -[CONTAINS]-> <b>
    // Expect edge: <paramDefaultChain> -[CONTAINS]-> <c>
    // Expect edge: <b> -[DEFAULTS_TO]-> <a * 2>
    // Expect edge: <c> -[DEFAULTS_TO]-> <a + b>
    // Expect edge: <paramDefaultChain> -[RETURNS]-> <{ a, b, c }>
    void code;
  });

  test('declarations::new-target-in-function', () => {
    const code = "function FlexibleConstructor(name) {\n  if (!new.target) {\n    return new FlexibleConstructor(name); // redirect if called without new\n  }\n  this.name = name;\n}";
    // Expect node: FUNCTION <FlexibleConstructor>
    // Expect node: PARAMETER <name>
    // Expect node: BRANCH <if-new-target>
    // Expect node: EXPRESSION <!new.target>
    // Expect node: META_PROPERTY <new.target>
    // Expect node: CALL <new FlexibleConstructor(name)>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect edge: <FlexibleConstructor> -[CONTAINS]-> <name>
    // Expect edge: <FlexibleConstructor> -[CONTAINS]-> <if-new-target>
    // Expect edge: <if-new-target> -[HAS_CONDITION]-> <!new.target>
    // Expect edge: <if-new-target> -[HAS_CONSEQUENT]-> <new FlexibleConstructor(name)>
    // Expect edge: <new FlexibleConstructor(name)> -[PASSES_ARGUMENT]-> <name>
    // Expect edge: <if-new-target> -[RETURNS]-> <new FlexibleConstructor(name)>
    void code;
  });

  test('declarations::func-expr-recursive-self-ref', () => {
    const code = "const factorialNamedExpr = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1); // fact visible ONLY inside\n};\n// typeof fact === 'undefined' — internal name not in enclosing scope";
    // Expect node: VARIABLE <factorialNamedExpr>
    // Expect node: FUNCTION <fact>
    // Expect node: PARAMETER <n>
    // Expect node: EXPRESSION <n <= 1>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <1-return>
    // Expect node: EXPRESSION <n * fact(n - 1)>
    // Expect node: CALL <fact(n - 1)>
    // Expect node: EXPRESSION <n - 1>
    // Expect edge: <fact> -[CONTAINS]-> <n>
    // Expect edge: <fact> -[HAS_CONDITION]-> <n <= 1>
    // Expect edge: <fact> -[HAS_CONSEQUENT]-> <1-return>
    // Expect edge: <fact(n - 1)> -[PASSES_ARGUMENT]-> <n - 1>
    void code;
  });

  test('error-handling::error-custom-class', () => {
    const code = "class AppError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n  }\n}";
    // Expect node: CLASS <AppError>
    // Expect node: METHOD <AppError.constructor>
    // Expect node: PARAMETER <message>
    // Expect node: PARAMETER <code>
    // Expect node: CALL <super(message)>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: LITERAL <'AppError'>
    // Expect node: PROPERTY_ACCESS <this.code>
    // Expect edge: <AppError> -[CONTAINS]-> <AppError.constructor>
    // Expect edge: <AppError.constructor> -[CONTAINS]-> <message>
    // Expect edge: <AppError.constructor> -[CONTAINS]-> <code>
    // Expect edge: <super(message)> -[PASSES_ARGUMENT]-> <message>
    // Expect edge: <AppError.constructor> -[CONTAINS]-> <super(message)>
    void code;
  });

  test('declarations::let-const-multi-declaration', () => {
    const code = "const constMultiA = 1, constMultiB = constMultiA + 1, constMultiC = constMultiA + constMultiB;\nlet letMultiX = 0, letMultiY = letMultiX + 1;";
    // Expect node: VARIABLE <constMultiA>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <constMultiB>
    // Expect node: EXPRESSION <constMultiA + 1>
    // Expect node: VARIABLE <constMultiC>
    // Expect node: EXPRESSION <constMultiA + constMultiB>
    // Expect node: VARIABLE <letMultiX>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <letMultiY>
    // Expect node: EXPRESSION <letMultiX + 1>

    void code;
  });

  test('builtins::builtin-json-parse-reviver', () => {
    const code = "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}";
    // Expect node: FUNCTION <jsonParseReviver>
    // Expect node: PARAMETER <str>
    // Expect node: CALL <JSON.parse(str, reviver)>
    // Expect node: PROPERTY_ACCESS <JSON.parse>
    // Expect node: FUNCTION <reviver>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: BRANCH <if-date-check>
    // Expect node: EXPRESSION <key === 'date'>
    // Expect node: LITERAL <'date'>
    // Expect node: CALL <new Date(value)>
    // Expect node: EXTERNAL <Date>
    // Expect edge: <jsonParseReviver> -[CONTAINS]-> <str>
    // Expect edge: <jsonParseReviver> -[RETURNS]-> <JSON.parse(str, reviver)>
    // Expect edge: <JSON.parse(str, reviver)> -[PASSES_ARGUMENT]-> <str>
    // Expect edge: <JSON.parse(str, reviver)> -[PASSES_ARGUMENT]-> <reviver>
    // Expect edge: <reviver> -[CONTAINS]-> <key>
    // Expect edge: <reviver> -[CONTAINS]-> <value>
    // Expect edge: <reviver> -[CONTAINS]-> <if-date-check>
    // Expect edge: <if-date-check> -[HAS_CONDITION]-> <key === 'date'>
    // Expect edge: <if-date-check> -[HAS_CONSEQUENT]-> <new Date(value)>
    // Expect edge: <new Date(value)> -[PASSES_ARGUMENT]-> <value>
    void code;
  });

  test('builtins::builtin-json-stringify', () => {
    const code = "function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}";
    // Expect node: FUNCTION <jsonStringify>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <JSON.stringify(obj)>
    // Expect node: PROPERTY_ACCESS <JSON.stringify>
    // Expect node: EXTERNAL <JSON>
    // Expect edge: <MODULE> -[DECLARES]-> <jsonStringify>
    // Expect edge: <jsonStringify> -[CONTAINS]-> <obj>
    // Expect edge: <jsonStringify> -[RETURNS]-> <JSON.stringify(obj)>
    // Expect edge: <JSON.stringify(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <JSON.stringify> -[ACCESSES_PRIVATE]-> <JSON>
    void code;
  });

  test('declarations::numeric-separators', () => {
    const code = "const TIMEOUT_MS = 30_000;\nconst MAX_SAFE = 9_007_199_254_740_991;\nconst HEX_COLOR = 0xFF_EC_D9;\nconst BIT_MASK = 0b1111_0000_1010_0101;\nconst BIG_NUM = 1_000_000_000n;\nconst FLOAT_SEP = 1_000.123_456;";
    // Expect node: VARIABLE <TIMEOUT_MS>
    // Expect node: LITERAL <30_000>
    // Expect node: VARIABLE <MAX_SAFE>
    // Expect node: LITERAL <9_007_199_254_740_991>
    // Expect node: VARIABLE <HEX_COLOR>
    // Expect node: LITERAL <0xFF_EC_D9>
    // Expect node: VARIABLE <BIT_MASK>
    // Expect node: LITERAL <0b1111_0000_1010_0101>
    // Expect node: VARIABLE <BIG_NUM>
    // Expect node: LITERAL <1_000_000_000n>
    // Expect node: VARIABLE <FLOAT_SEP>
    // Expect node: LITERAL <1_000.123_456>
    // Expect edge: <module> -[DECLARES]-> <TIMEOUT_MS>
    // Expect edge: <module> -[DECLARES]-> <MAX_SAFE>
    // Expect edge: <module> -[DECLARES]-> <HEX_COLOR>
    // Expect edge: <module> -[DECLARES]-> <BIT_MASK>
    // Expect edge: <module> -[DECLARES]-> <BIG_NUM>
    // Expect edge: <module> -[DECLARES]-> <FLOAT_SEP>
    void code;
  });

  test('error-handling::error-cause', () => {
    const code = "async function fetchWithCause(url) {\n  try {\n    const response = await fetch(url);\n    return await response.json();\n  } catch (err) {\n    throw new Error(`Failed to fetch ${url}`, { cause: err });\n  }\n}\n\n// --- Error wrapping / re-throw ---";
    // Expect node: FUNCTION <fetchWithCause>
    // Expect node: PARAMETER <url>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url)>
    // Expect node: CALL <response.json()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <new Error>
    // Expect node: LITERAL <'Failed to fetch '>
    // Expect node: EXPRESSION <`Failed to fetch ${url}`>
    // Expect node: LITERAL <{ cause: err }>
    // Expect edge: <fetchWithCause> -[HAS_BODY]-> <url>
    // Expect edge: <fetchWithCause> -[HAS_BODY]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <try-block> -[RETURNS]-> <response.json()>
    // Expect edge: <fetchWithCause> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <err>
    // Expect edge: <new Error> -[PASSES_ARGUMENT]-> <`Failed to fetch ${url}`>
    // Expect edge: <new Error> -[PASSES_ARGUMENT]-> <{ cause: err }>
    // Expect edge: <`Failed to fetch ${url}`> -[CONTAINS]-> <'Failed to fetch '>
    void code;
  });

  test('error-handling::error-wrap-rethrow', () => {
    const code = "function parseConfig(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch (err) {\n    throw new AppError(`Invalid config: ${err.message}`, 'PARSE_ERROR');\n  }\n}";
    // Expect node: FUNCTION <parseConfig>
    // Expect node: PARAMETER <raw>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <JSON.parse(raw)>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <new AppError>
    // Expect node: EXPRESSION <`Invalid config: ${err.message}`>
    // Expect node: LITERAL <'PARSE_ERROR'>
    // Expect node: PROPERTY_ACCESS <err.message>
    // Expect node: EXTERNAL <JSON.parse>
    // Expect node: EXTERNAL <AppError>
    // Expect edge: <parseConfig> -[CONTAINS]-> <raw>
    // Expect edge: <parseConfig> -[CONTAINS]-> <try-block>
    // Expect edge: <parseConfig> -[CONTAINS]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <JSON.parse(raw)>
    // Expect edge: <parseConfig> -[RETURNS]-> <JSON.parse(raw)>
    // Expect edge: <JSON.parse(raw)> -[PASSES_ARGUMENT]-> <raw>
    // Expect edge: <catch-block> -[CONTAINS]-> <err>
    // Expect edge: <new AppError> -[PASSES_ARGUMENT]-> <`Invalid config: ${err.message}`>
    // Expect edge: <new AppError> -[PASSES_ARGUMENT]-> <'PARSE_ERROR'>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CATCHES_FROM]-> <try-block>
    void code;
  });

  test('error-handling::error-async-catch-all', () => {
    const code = "async function safeExecute(asyncFn) {\n  try {\n    return { ok: true, value: await asyncFn() };\n  } catch (err) {\n    return { ok: false, error: err };\n  }\n}\n\n// --- Promise rejection handling ---";
    // Expect node: FUNCTION <safeExecute>
    // Expect node: PARAMETER <asyncFn>
    // Expect node: TRY_BLOCK <safeExecute:try>
    // Expect node: CATCH_BLOCK <safeExecute:catch>
    // Expect node: PARAMETER <err>
    // Expect node: EXPRESSION <await asyncFn()>
    // Expect node: CALL <asyncFn()>
    // Expect node: LITERAL <{ ok: true, value: await asyncFn() }>
    // Expect node: LITERAL <true>
    // Expect node: LITERAL <{ ok: false, error: err }>
    // Expect node: LITERAL <false>
    // Expect edge: <safeExecute> -[CONTAINS]-> <asyncFn>
    // Expect edge: <safeExecute> -[HAS_BODY]-> <safeExecute:try>
    // Expect edge: <safeExecute> -[HAS_CATCH]-> <safeExecute:catch>
    // Expect edge: <safeExecute:catch> -[CONTAINS]-> <err>
    // Expect edge: <safeExecute:try> -[RETURNS]-> <{ ok: true, value: await asyncFn() }>
    // Expect edge: <safeExecute:catch> -[RETURNS]-> <{ ok: false, error: err }>
    // Expect edge: <await asyncFn()> -[AWAITS]-> <asyncFn()>
    // Expect edge: <{ ok: true, value: await asyncFn() }> -[HAS_PROPERTY]-> <true>
    // Expect edge: <{ ok: true, value: await asyncFn() }> -[HAS_PROPERTY]-> <await asyncFn()>
    // Expect edge: <{ ok: false, error: err }> -[HAS_PROPERTY]-> <false>
    // Expect edge: <{ ok: false, error: err }> -[HAS_PROPERTY]-> <err>
    // Expect edge: <safeExecute:catch> -[CATCHES_FROM]-> <err>
    void code;
  });

  test('declarations::param-default-from-destructured', () => {
    const code = "function paramDefaultFromDestructured({width, height}, area = width * height) {\n  return { width, height, area };\n}\n\n// Also with nested destructuring feeding later default:\nfunction queryBuilder({table, schema = 'public'}, fullName = `${schema}.${table}`) {\n  return `SELECT * FROM ${fullName}`;\n}";
    // Expect node: FUNCTION <paramDefaultFromDestructured>
    // Expect node: PARAMETER <{width, height}>
    // Expect node: VARIABLE <width>
    // Expect node: VARIABLE <height>
    // Expect node: PARAMETER <area>
    // Expect node: EXPRESSION <width * height>
    // Expect node: EXPRESSION <{ width, height, area }>
    // Expect node: FUNCTION <queryBuilder>
    // Expect node: PARAMETER <{table, schema = 'public'}>
    // Expect node: VARIABLE <table>
    // Expect node: VARIABLE <schema>
    // Expect node: LITERAL <'public'>
    // Expect node: PARAMETER <fullName>
    // Expect node: EXPRESSION <`${schema}.${table}`>
    // Expect node: EXPRESSION <`SELECT * FROM ${fullName}`>
    // Expect edge: <paramDefaultFromDestructured> -[CONTAINS]-> <{width, height}>
    // Expect edge: <paramDefaultFromDestructured> -[CONTAINS]-> <area>
    // Expect edge: <{width, height}> -[HAS_ELEMENT]-> <width>
    // Expect edge: <{width, height}> -[HAS_ELEMENT]-> <height>
    // Expect edge: <area> -[DEFAULTS_TO]-> <width * height>
    // Expect edge: <paramDefaultFromDestructured> -[RETURNS]-> <{ width, height, area }>
    // Expect edge: <queryBuilder> -[CONTAINS]-> <{table, schema = 'public'}>
    // Expect edge: <queryBuilder> -[CONTAINS]-> <fullName>
    // Expect edge: <{table, schema = 'public'}> -[HAS_ELEMENT]-> <table>
    // Expect edge: <{table, schema = 'public'}> -[HAS_ELEMENT]-> <schema>
    // Expect edge: <schema> -[DEFAULTS_TO]-> <'public'>
    // Expect edge: <fullName> -[DEFAULTS_TO]-> <`${schema}.${table}`>
    // Expect edge: <queryBuilder> -[RETURNS]-> <`SELECT * FROM ${fullName}`>
    void code;
  });

  test('declarations::export-named-list', () => {
    const code = "export {\n  mutableVar,\n  reassignable,\n  immutable,\n  objectConst,\n  arrayConst,\n  bigNumber,\n  uniqueKey,\n  globalSymbol,\n  regexSimple,\n  regularFunction,\n  withDefaults,\n  withRestParams,\n  withMixedParams,\n  namedExpression,\n  anonymousExpression,\n  arrowBlock,\n  arrowExpression,\n  arrowSingleParam,\n  arrowNoParams,\n  numberGenerator,\n  delegatingGenerator,\n  asyncFunction,\n  asyncArrow,\n  asyncGenerator,\n  iifeResult,\n  arrowIifeResult,\n  paramDefaultChain,\n  paramDefaultScope,\n  arrowReturnsObject,\n  asyncIifeResult,\n  constMultiC,\n  letMultiY,\n  factorialNamedExpr,\n  FlexibleConstructor,\n  paramDefaultFromDestructured,\n  queryBuilder,\n  TIMEOUT_MS,\n  MAX_SAFE,\n  HEX_COLOR,\n  BIT_MASK,\n  BIG_NUM,\n  FLOAT_SEP,\n  functionNameInference,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect edge: <module> -[CONTAINS]-> <export-named-list>
    void code;
  });

  test('error-handling::error-promise-catch', () => {
    const code = "function promiseErrorHandling() {\n  return Promise.reject(new Error('boom'))\n    .catch(err => {\n      console.error('Caught:', err.message);\n      return 'recovered';\n    });\n}";
    // Expect node: FUNCTION <promiseErrorHandling>
    // Expect node: CALL <Promise.reject(new Error('boom'))>
    // Expect node: CALL <new Error('boom')>
    // Expect node: LITERAL <'boom'>
    // Expect node: CALL <.catch(err => {...})>
    // Expect node: FUNCTION <catch-handler>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <console.error('Caught:', err.message)>
    // Expect node: LITERAL <'Caught:'>
    // Expect node: PROPERTY_ACCESS <err.message>
    // Expect node: LITERAL <'recovered'>
    // Expect edge: <promiseErrorHandling> -[RETURNS]-> <Promise.reject(new Error('boom'))>
    // Expect edge: <Promise.reject(new Error('boom'))> -[PASSES_ARGUMENT]-> <new Error('boom')>
    // Expect edge: <new Error('boom')> -[PASSES_ARGUMENT]-> <'boom'>
    // Expect edge: <Promise.reject(new Error('boom'))> -[CHAINS_FROM]-> <.catch(err => {...})>
    // Expect edge: <.catch(err => {...})> -[PASSES_ARGUMENT]-> <catch-handler>
    // Expect edge: <catch-handler> -[CONTAINS]-> <err>
    // Expect edge: <catch-handler> -[CONTAINS]-> <console.error('Caught:', err.message)>
    // Expect edge: <console.error('Caught:', err.message)> -[PASSES_ARGUMENT]-> <'Caught:'>
    // Expect edge: <console.error('Caught:', err.message)> -[PASSES_ARGUMENT]-> <err.message>
    // Expect edge: <catch-handler> -[RETURNS]-> <'recovered'>
    void code;
  });

  test('builtins::builtin-json-stringify-replacer', () => {
    const code = "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---";
    // Expect node: FUNCTION <jsonStringifyReplacer>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <JSON.stringify(obj, replacer, 2)>
    // Expect node: PROPERTY_ACCESS <JSON.stringify>
    // Expect node: FUNCTION <replacer>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: EXPRESSION <typeof value === 'function'>
    // Expect node: EXPRESSION <typeof value>
    // Expect node: LITERAL <'function'>
    // Expect node: LITERAL <undefined>
    // Expect node: LITERAL <2>
    // Expect node: BRANCH <if-typeof-function>
    // Expect edge: <jsonStringifyReplacer> -[HAS_BODY]-> <obj>
    // Expect edge: <jsonStringifyReplacer> -[RETURNS]-> <JSON.stringify(obj, replacer, 2)>
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[PASSES_ARGUMENT]-> <replacer>
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[PASSES_ARGUMENT]-> <2>
    // Expect edge: <replacer> -[HAS_BODY]-> <key>
    // Expect edge: <replacer> -[HAS_BODY]-> <value>
    // Expect edge: <replacer> -[HAS_BODY]-> <if-typeof-function>
    // Expect edge: <if-typeof-function> -[HAS_CONDITION]-> <typeof value === 'function'>
    // Expect edge: <if-typeof-function> -[HAS_CONSEQUENT]-> <undefined>
    void code;
  });

  test('error-handling::error-rethrow-conditional', () => {
    const code = "function processData(data) {\n  try {\n    return transform(data);\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err; // re-throw known errors as-is\n    }\n    throw new AppError(`Unexpected: ${err.message}`, 'INTERNAL');\n  }\n}\n\nfunction transform(data) {\n  if (!data) throw new ValidationError('data', 'Data is required');\n  return data;\n}\n\n// --- instanceof checks in catch ---";
    // Expect node: FUNCTION <processData>
    // Expect node: PARAMETER <data>
    // Expect node: TRY_BLOCK <processData:try>
    // Expect node: CALL <transform(data)>
    // Expect node: CATCH_BLOCK <processData:catch>
    // Expect node: PARAMETER <err>
    // Expect node: BRANCH <err instanceof ValidationError>
    // Expect node: EXPRESSION <err instanceof ValidationError>
    // Expect node: EXPRESSION <throw err>
    // Expect node: CALL <new AppError(...)>
    // Expect node: EXPRESSION <throw new AppError(...)>
    // Expect node: FUNCTION <transform>
    // Expect node: PARAMETER <transform:data>
    // Expect node: BRANCH <transform:if>
    // Expect node: EXPRESSION <!data>
    // Expect node: CALL <new ValidationError(...)>
    // Expect node: EXPRESSION <throw new ValidationError(...)>
    // Expect edge: <processData> -[CONTAINS]-> <data>
    // Expect edge: <processData> -[CONTAINS]-> <processData:try>
    // Expect edge: <processData:try> -[CONTAINS]-> <transform(data)>
    // Expect edge: <processData:try> -[RETURNS]-> <transform(data)>
    // Expect edge: <transform(data)> -[PASSES_ARGUMENT]-> <data>
    // Expect edge: <processData> -[HAS_CATCH]-> <processData:catch>
    // Expect edge: <processData:catch> -[CONTAINS]-> <err>
    // Expect edge: <processData:catch> -[CONTAINS]-> <err instanceof ValidationError>
    // Expect edge: <err instanceof ValidationError> -[HAS_CONDITION]-> <err instanceof ValidationError>
    // Expect edge: <err instanceof ValidationError> -[HAS_CONSEQUENT]-> <throw err>
    // Expect edge: <transform> -[CONTAINS]-> <transform:data>
    // Expect edge: <transform> -[CONTAINS]-> <transform:if>
    // Expect edge: <transform:if> -[HAS_CONDITION]-> <!data>
    // Expect edge: <transform:if> -[HAS_CONSEQUENT]-> <throw new ValidationError(...)>
    // Expect edge: <transform> -[RETURNS]-> <transform:data>
    void code;
  });

  test('error-handling::error-custom-hierarchy', () => {
    const code = "class ValidationError extends AppError {\n  constructor(field, message) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource, id) {\n    super(`${resource} not found: ${id}`, 'NOT_FOUND');\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.id = id;\n  }\n}\n\n// --- Error cause (ES2022) ---";
    // Expect node: CLASS <ValidationError>
    // Expect node: METHOD <ValidationError.constructor>
    // Expect node: PARAMETER <field>
    // Expect node: PARAMETER <message>
    // Expect node: CALL <super(message, 'VALIDATION_ERROR')>
    // Expect node: LITERAL <'VALIDATION_ERROR'>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: LITERAL <'ValidationError'>
    // Expect node: PROPERTY_ACCESS <this.field>
    // Expect node: CLASS <NotFoundError>
    // Expect node: METHOD <NotFoundError.constructor>
    // Expect node: PARAMETER <resource>
    // Expect node: PARAMETER <id>
    // Expect node: EXPRESSION <`${resource} not found: ${id}`>
    // Expect node: CALL <super(`${resource} not found: ${id}`, 'NOT_FOUND')>
    // Expect node: LITERAL <'NOT_FOUND'>
    // Expect node: PROPERTY_ACCESS <this.name2>
    // Expect node: LITERAL <'NotFoundError'>
    // Expect node: PROPERTY_ACCESS <this.resource>
    // Expect node: PROPERTY_ACCESS <this.id>
    // Expect edge: <ValidationError> -[CONTAINS]-> <ValidationError.constructor>
    // Expect edge: <ValidationError.constructor> -[CONTAINS]-> <field>
    // Expect edge: <ValidationError.constructor> -[CONTAINS]-> <message>
    // Expect edge: <ValidationError.constructor> -[CONTAINS]-> <super(message, 'VALIDATION_ERROR')>
    // Expect edge: <super(message, 'VALIDATION_ERROR')> -[PASSES_ARGUMENT]-> <message>
    // Expect edge: <super(message, 'VALIDATION_ERROR')> -[PASSES_ARGUMENT]-> <'VALIDATION_ERROR'>
    // Expect edge: <NotFoundError> -[CONTAINS]-> <NotFoundError.constructor>
    // Expect edge: <NotFoundError.constructor> -[CONTAINS]-> <resource>
    // Expect edge: <NotFoundError.constructor> -[CONTAINS]-> <id>
    // Expect edge: <NotFoundError.constructor> -[CONTAINS]-> <super(`${resource} not found: ${id}`, 'NOT_FOUND')>
    // Expect edge: <super(`${resource} not found: ${id}`, 'NOT_FOUND')> -[PASSES_ARGUMENT]-> <`${resource} not found: ${id}`>
    // Expect edge: <super(`${resource} not found: ${id}`, 'NOT_FOUND')> -[PASSES_ARGUMENT]-> <'NOT_FOUND'>
    void code;
  });

  test('error-handling::export-named-list', () => {
    const code = "export {\n  AppError,\n  ValidationError,\n  NotFoundError,\n  fetchWithCause,\n  parseConfig,\n  processData,\n  handleError,\n  pipeline,\n  safeExecute,\n  promiseErrorHandling,\n  chainedErrors,\n  aggregatedErrors,\n  withCleanup,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <AppError>
    // Expect node: VARIABLE <ValidationError>
    // Expect node: VARIABLE <NotFoundError>
    // Expect node: VARIABLE <fetchWithCause>
    // Expect node: VARIABLE <parseConfig>
    // Expect node: VARIABLE <processData>
    // Expect node: VARIABLE <handleError>
    // Expect node: VARIABLE <pipeline>
    // Expect node: VARIABLE <safeExecute>
    // Expect node: VARIABLE <promiseErrorHandling>
    // Expect node: VARIABLE <chainedErrors>
    // Expect node: VARIABLE <aggregatedErrors>
    // Expect node: VARIABLE <withCleanup>

    void code;
  });

  test('error-handling::error-aggregate', () => {
    const code = "function aggregatedErrors() {\n  const errors = [\n    new Error('first'),\n    new Error('second'),\n    new Error('third'),\n  ];\n  throw new AggregateError(errors, 'Multiple failures');\n}\n\n// --- Finally for cleanup ---";
    // Expect node: FUNCTION <aggregatedErrors>
    // Expect node: VARIABLE <errors>
    // Expect node: LITERAL <['first', 'second', 'third']>
    // Expect node: CALL <new Error('first')>
    // Expect node: LITERAL <'first'>
    // Expect node: CALL <new Error('second')>
    // Expect node: LITERAL <'second'>
    // Expect node: CALL <new Error('third')>
    // Expect node: LITERAL <'third'>
    // Expect node: CALL <new AggregateError(errors, 'Multiple failures')>
    // Expect node: LITERAL <'Multiple failures'>
    // Expect node: EXTERNAL <Error>
    // Expect node: EXTERNAL <AggregateError>
    // Expect edge: <aggregatedErrors> -[CONTAINS]-> <errors>
    // Expect edge: <['first', 'second', 'third']> -[HAS_ELEMENT]-> <new Error('first')>
    // Expect edge: <['first', 'second', 'third']> -[HAS_ELEMENT]-> <new Error('second')>
    // Expect edge: <['first', 'second', 'third']> -[HAS_ELEMENT]-> <new Error('third')>
    // Expect edge: <new Error('first')> -[PASSES_ARGUMENT]-> <'first'>
    // Expect edge: <new Error('second')> -[PASSES_ARGUMENT]-> <'second'>
    // Expect edge: <new Error('third')> -[PASSES_ARGUMENT]-> <'third'>
    // Expect edge: <new AggregateError(errors, 'Multiple failures')> -[PASSES_ARGUMENT]-> <errors>
    // Expect edge: <new AggregateError(errors, 'Multiple failures')> -[PASSES_ARGUMENT]-> <'Multiple failures'>
    void code;
  });

  test('expressions::delete-op', () => {
    const code = "function deleteOperator() {\n  const obj = { a: 1, b: 2 };\n  delete obj.a;\n  return obj;\n}";
    // Expect node: FUNCTION <deleteOperator>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ a: 1, b: 2 }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: EXPRESSION <delete obj.a>
    // Expect node: PROPERTY_ACCESS <obj.a>
    // Expect edge: <deleteOperator> -[CONTAINS]-> <obj>
    // Expect edge: <{ a: 1, b: 2 }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ a: 1, b: 2 }> -[HAS_PROPERTY]-> <2>
    // Expect edge: <deleteOperator> -[CONTAINS]-> <delete obj.a>
    // Expect edge: <delete obj.a> -[DELETES]-> <obj.a>
    // Expect edge: <deleteOperator> -[RETURNS]-> <obj>
    void code;
  });

  test('expressions::update-expr', () => {
    const code = "function updateExpressions() {\n  let x = 0;\n  x++;\n  x--;\n  ++x;\n  --x;\n  return x;\n}";
    // Expect node: FUNCTION <updateExpressions>
    // Expect node: VARIABLE <x>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <x++>
    // Expect node: EXPRESSION <x-->
    // Expect node: EXPRESSION <++x>
    // Expect node: EXPRESSION <--x>
    // Expect edge: <updateExpressions> -[CONTAINS]-> <x>
    // Expect edge: <updateExpressions> -[RETURNS]-> <x>
    void code;
  });

  test('expressions::logical-ops', () => {
    const code = "function logicalOperators(a, b) {\n  const and = a && b;\n  const or = a || b;\n  const nullish = a ?? b;\n  const not = !a;\n  return { and, or, nullish, not };\n}";
    // Expect node: FUNCTION <logicalOperators>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: VARIABLE <and>
    // Expect node: EXPRESSION <a && b>
    // Expect node: VARIABLE <or>
    // Expect node: EXPRESSION <a || b>
    // Expect node: VARIABLE <nullish>
    // Expect node: EXPRESSION <a ?? b>
    // Expect node: VARIABLE <not>
    // Expect node: EXPRESSION <!a>
    // Expect node: EXPRESSION <{ and, or, nullish, not }>
    // Expect edge: <logicalOperators> -[CONTAINS]-> <a>
    // Expect edge: <logicalOperators> -[CONTAINS]-> <b>
    // Expect edge: <logicalOperators> -[CONTAINS]-> <and>
    // Expect edge: <logicalOperators> -[CONTAINS]-> <or>
    // Expect edge: <logicalOperators> -[CONTAINS]-> <nullish>
    // Expect edge: <logicalOperators> -[CONTAINS]-> <not>
    // Expect edge: <logicalOperators> -[RETURNS]-> <{ and, or, nullish, not }>
    void code;
  });

  test('expressions::tagged-template-usage', () => {
    const code = "const tagged = tag`Hello ${'world'} number ${42}`;";
    // Expect node: VARIABLE <tagged>
    // Expect node: CALL <tag`Hello ${'world'} number ${42}`>
    // Expect node: LITERAL <'Hello '>
    // Expect node: LITERAL <'world'>
    // Expect node: LITERAL <' number '>
    // Expect node: LITERAL <42>
    // Expect node: LITERAL <''>
    // Expect edge: <module> -[DECLARES]-> <tagged>
    // Expect edge: <tag`Hello ${'world'} number ${42}`> -[PASSES_ARGUMENT]-> <'Hello '>
    // Expect edge: <tag`Hello ${'world'} number ${42}`> -[PASSES_ARGUMENT]-> <' number '>
    // Expect edge: <tag`Hello ${'world'} number ${42}`> -[PASSES_ARGUMENT]-> <''>
    // Expect edge: <tag`Hello ${'world'} number ${42}`> -[PASSES_ARGUMENT]-> <'world'>
    // Expect edge: <tag`Hello ${'world'} number ${42}`> -[PASSES_ARGUMENT]-> <42>
    void code;
  });

  test('expressions::tagged-template-fn', () => {
    const code = "function tag(strings, ...values) {\n  return strings.raw.join('') + values.join('');\n}";
    // Expect node: FUNCTION <tag>
    // Expect node: PARAMETER <strings>
    // Expect node: PARAMETER <values>
    // Expect node: PROPERTY_ACCESS <strings.raw>
    // Expect node: CALL <strings.raw.join('')>
    // Expect node: LITERAL <''>
    // Expect node: CALL <values.join('')>
    // Expect node: EXPRESSION <strings.raw.join('') + values.join('')>
    // Expect edge: <tag> -[HAS_BODY]-> <strings>
    // Expect edge: <tag> -[HAS_BODY]-> <values>
    // Expect edge: <strings.raw.join('')> -[PASSES_ARGUMENT]-> <''>
    // Expect edge: <values.join('')> -[PASSES_ARGUMENT]-> <''>
    // Expect edge: <tag> -[RETURNS]-> <strings.raw.join('') + values.join('')>
    void code;
  });

  test('expressions::optional-chaining', () => {
    const code = "function optionalChaining(obj) {\n  const prop = obj?.nested?.deep;\n  const method = obj?.method?.();\n  const computed = obj?.items?.[0];\n  return { prop, method, computed };\n}";
    // Expect node: FUNCTION <optionalChaining>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <prop>
    // Expect node: EXPRESSION <obj?.nested?.deep>
    // Expect node: VARIABLE <method>
    // Expect node: EXPRESSION <obj?.method?.()>
    // Expect node: VARIABLE <computed>
    // Expect node: EXPRESSION <obj?.items?.[0]>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <{ prop, method, computed }>
    // Expect edge: <optionalChaining> -[CONTAINS]-> <obj>
    // Expect edge: <optionalChaining> -[CONTAINS]-> <prop>
    // Expect edge: <optionalChaining> -[CONTAINS]-> <method>
    // Expect edge: <optionalChaining> -[CONTAINS]-> <computed>
    // Expect edge: <optionalChaining> -[RETURNS]-> <{ prop, method, computed }>
    void code;
  });

  test('expressions::unary-ops', () => {
    const code = "function unaryOperators(x) {\n  const pos = +x;\n  const neg = -x;\n  const logNot = !x;\n  const bitNot = ~x;\n  const typeOfX = typeof x;\n  const voidX = void x;\n  return { pos, neg, logNot, bitNot, typeOfX, voidX };\n}";
    // Expect node: FUNCTION <unaryOperators>
    // Expect node: PARAMETER <x>
    // Expect node: VARIABLE <pos>
    // Expect node: EXPRESSION <+x>
    // Expect node: VARIABLE <neg>
    // Expect node: EXPRESSION <-x>
    // Expect node: VARIABLE <logNot>
    // Expect node: EXPRESSION <!x>
    // Expect node: VARIABLE <bitNot>
    // Expect node: EXPRESSION <~x>
    // Expect node: VARIABLE <typeOfX>
    // Expect node: EXPRESSION <typeof x>
    // Expect node: VARIABLE <voidX>
    // Expect node: EXPRESSION <void x>
    // Expect node: EXPRESSION <{ pos, neg, logNot, bitNot, typeOfX, voidX }>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <x>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <pos>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <neg>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <logNot>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <bitNot>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <typeOfX>
    // Expect edge: <unaryOperators> -[CONTAINS]-> <voidX>
    // Expect edge: <unaryOperators> -[RETURNS]-> <{ pos, neg, logNot, bitNot, typeOfX, voidX }>
    void code;
  });

  test('builtins::builtin-map-constructor', () => {
    const code = "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---";
    // Expect node: FUNCTION <mapFromEntries>
    // Expect node: VARIABLE <map>
    // Expect node: CALL <new Map([...])>
    // Expect node: LITERAL <[['x', 10], ['y', 20]]>
    // Expect node: LITERAL <['x', 10]>
    // Expect node: LITERAL <'x'>
    // Expect node: LITERAL <10>
    // Expect node: LITERAL <['y', 20]>
    // Expect node: LITERAL <'y'>
    // Expect node: LITERAL <20>
    // Expect node: EXTERNAL <Map>
    // Expect edge: <mapFromEntries> -[CONTAINS]-> <map>
    // Expect edge: <new Map([...])> -[PASSES_ARGUMENT]-> <[['x', 10], ['y', 20]]>
    // Expect edge: <[['x', 10], ['y', 20]]> -[HAS_ELEMENT]-> <['x', 10]>
    // Expect edge: <[['x', 10], ['y', 20]]> -[HAS_ELEMENT]-> <['y', 20]>
    // Expect edge: <['x', 10]> -[HAS_ELEMENT]-> <'x'>
    // Expect edge: <['x', 10]> -[HAS_ELEMENT]-> <10>
    // Expect edge: <['y', 20]> -[HAS_ELEMENT]-> <'y'>
    // Expect edge: <['y', 20]> -[HAS_ELEMENT]-> <20>
    // Expect edge: <mapFromEntries> -[RETURNS]-> <map>
    void code;
  });

  test('expressions::chained-assignment-mixed', () => {
    const code = "function chainedAssignmentMixed() {\n  const obj = {};\n  obj.x = obj.y = [];\n  return obj;\n}";
    // Expect node: FUNCTION <chainedAssignmentMixed>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{}>
    // Expect node: PROPERTY_ACCESS <obj.x>
    // Expect node: PROPERTY_ACCESS <obj.y>
    // Expect node: LITERAL <[]>
    // Expect node: EXPRESSION <obj.x = obj.y = []>
    // Expect edge: <chainedAssignmentMixed> -[CONTAINS]-> <obj>
    // Expect edge: <chainedAssignmentMixed> -[RETURNS]-> <obj>
    void code;
  });

  test('expressions::chained-assignment', () => {
    const code = "function chainedAssignment() {\n  let a, b, c;\n  a = b = c = 42;\n  return { a, b, c };\n}";
    // Expect node: FUNCTION <chainedAssignment>
    // Expect node: VARIABLE <a>
    // Expect node: VARIABLE <b>
    // Expect node: VARIABLE <c>
    // Expect node: LITERAL <42>
    // Expect node: EXPRESSION <{ a, b, c }>
    // Expect edge: <chainedAssignment> -[DECLARES]-> <a>
    // Expect edge: <chainedAssignment> -[DECLARES]-> <b>
    // Expect edge: <chainedAssignment> -[DECLARES]-> <c>
    // Expect edge: <chainedAssignment> -[RETURNS]-> <{ a, b, c }>
    void code;
  });

  test('expressions::ternary', () => {
    const code = "function ternaryOperator(condition, value) {\n  const simple = condition ? 'yes' : 'no';\n  const nested = condition ? (value > 5 ? 'high' : 'low') : 'none';\n  return { simple, nested };\n}";
    // Expect node: FUNCTION <ternaryOperator>
    // Expect node: PARAMETER <condition>
    // Expect node: PARAMETER <value>
    // Expect node: VARIABLE <simple>
    // Expect node: EXPRESSION <condition ? 'yes' : 'no'>
    // Expect node: LITERAL <'yes'>
    // Expect node: LITERAL <'no'>
    // Expect node: VARIABLE <nested>
    // Expect node: EXPRESSION <condition ? (value > 5 ? 'high' : 'low') : 'none'>
    // Expect node: EXPRESSION <value > 5 ? 'high' : 'low'>
    // Expect node: EXPRESSION <value > 5>
    // Expect node: LITERAL <5>
    // Expect node: LITERAL <'high'>
    // Expect node: LITERAL <'low'>
    // Expect node: LITERAL <'none'>
    // Expect node: EXPRESSION <{ simple, nested }>
    // Expect edge: <ternaryOperator> -[CONTAINS]-> <condition>
    // Expect edge: <ternaryOperator> -[CONTAINS]-> <value>
    // Expect edge: <ternaryOperator> -[CONTAINS]-> <simple>
    // Expect edge: <ternaryOperator> -[CONTAINS]-> <nested>
    // Expect edge: <condition ? 'yes' : 'no'> -[HAS_CONDITION]-> <condition>
    // Expect edge: <condition ? 'yes' : 'no'> -[HAS_CONSEQUENT]-> <'yes'>
    // Expect edge: <condition ? (value > 5 ? 'high' : 'low') : 'none'> -[HAS_CONDITION]-> <condition>
    // Expect edge: <condition ? (value > 5 ? 'high' : 'low') : 'none'> -[HAS_CONSEQUENT]-> <value > 5 ? 'high' : 'low'>
    // Expect edge: <value > 5 ? 'high' : 'low'> -[HAS_CONDITION]-> <value > 5>
    // Expect edge: <value > 5 ? 'high' : 'low'> -[HAS_CONSEQUENT]-> <'high'>
    // Expect edge: <ternaryOperator> -[RETURNS]-> <{ simple, nested }>
    // Expect edge: <{ simple, nested }> -[HAS_PROPERTY]-> <simple>
    // Expect edge: <{ simple, nested }> -[HAS_PROPERTY]-> <nested>
    void code;
  });

  test('expressions::grouping', () => {
    const code = "function groupingOperator(a, b, c) {\n  const withGrouping = (a + b) * c;\n  const withoutGrouping = a + b * c;\n  return { withGrouping, withoutGrouping };\n}";
    // Expect node: FUNCTION <groupingOperator>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: PARAMETER <c>
    // Expect node: VARIABLE <withGrouping>
    // Expect node: EXPRESSION <(a + b) * c>
    // Expect node: EXPRESSION <a + b>
    // Expect node: VARIABLE <withoutGrouping>
    // Expect node: EXPRESSION <a + b * c>
    // Expect node: EXPRESSION <b * c>
    // Expect node: EXPRESSION <{ withGrouping, withoutGrouping }>
    // Expect edge: <groupingOperator> -[CONTAINS]-> <a>
    // Expect edge: <groupingOperator> -[CONTAINS]-> <b>
    // Expect edge: <groupingOperator> -[CONTAINS]-> <c>
    // Expect edge: <groupingOperator> -[CONTAINS]-> <withGrouping>
    // Expect edge: <groupingOperator> -[CONTAINS]-> <withoutGrouping>
    // Expect edge: <groupingOperator> -[RETURNS]-> <{ withGrouping, withoutGrouping }>
    void code;
  });

  test('expressions::comma-in-return', () => {
    const code = "function commaInReturn() {\n  return (1, 2, 3);\n}";
    // Expect node: FUNCTION <commaInReturn>
    // Expect node: EXPRESSION <(1, 2, 3)>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect edge: <module> -[DECLARES]-> <commaInReturn>
    // Expect edge: <commaInReturn> -[RETURNS]-> <(1, 2, 3)>
    // Expect edge: <(1, 2, 3)> -[CONTAINS]-> <1>
    // Expect edge: <(1, 2, 3)> -[CONTAINS]-> <2>
    // Expect edge: <(1, 2, 3)> -[CONTAINS]-> <3>
    void code;
  });

  test('expressions::tagged-template-raw', () => {
    const code = "function rawTemplate(strings) {\n  return strings.raw[0];\n}\nconst rawResult = rawTemplate`\\n`;";
    // Expect node: FUNCTION <rawTemplate>
    // Expect node: PARAMETER <strings>
    // Expect node: PROPERTY_ACCESS <strings.raw[0]>
    // Expect node: VARIABLE <rawResult>
    // Expect node: CALL <rawTemplate`\n`>
    // Expect edge: <module> -[DECLARES]-> <rawTemplate>
    // Expect edge: <rawTemplate> -[CONTAINS]-> <strings>
    // Expect edge: <rawTemplate> -[RETURNS]-> <strings.raw[0]>
    // Expect edge: <module> -[DECLARES]-> <rawResult>
    void code;
  });

  test('expressions::void-promise', () => {
    const code = "void async function () { await Promise.resolve('ping'); }();";
    // Expect node: EXPRESSION <void-expression>
    // Expect node: CALL <iife-call>
    // Expect node: FUNCTION <async-iife>
    // Expect node: EXPRESSION <await-expression>
    // Expect node: CALL <Promise.resolve('ping')>
    // Expect node: PROPERTY_ACCESS <Promise.resolve>
    // Expect node: LITERAL <'ping'>
    // Expect node: EXTERNAL <Promise>
    // Expect edge: <void-expression> -[CONTAINS]-> <iife-call>
    // Expect edge: <async-iife> -[CONTAINS]-> <await-expression>
    // Expect edge: <await-expression> -[AWAITS]-> <Promise.resolve('ping')>
    // Expect edge: <Promise.resolve('ping')> -[PASSES_ARGUMENT]-> <'ping'>
    void code;
  });

  test('expressions::void-iife', () => {
    const code = "void function () { console.log('fire and forget'); }();";
    // Expect node: EXPRESSION <void-expression>
    // Expect node: FUNCTION <anonymous-fn>
    // Expect node: CALL <iife-call>
    // Expect node: CALL <console.log('fire and forget')>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect node: LITERAL <'fire and forget'>
    // Expect edge: <void-expression> -[CONTAINS]-> <iife-call>
    // Expect edge: <anonymous-fn> -[CONTAINS]-> <console.log('fire and forget')>
    // Expect edge: <console.log('fire and forget')> -[PASSES_ARGUMENT]-> <'fire and forget'>
    void code;
  });

  test('expressions::new-constructor-return-non-this', () => {
    const code = "function NonThisConstructor() {\n  return { custom: true }; // returns different object than `this`\n}\nconst nonThisInstance = new NonThisConstructor(); // NOT instanceof NonThisConstructor!";
    // Expect node: FUNCTION <NonThisConstructor>
    // Expect node: LITERAL <{ custom: true }>
    // Expect node: VARIABLE <nonThisInstance>
    // Expect node: CALL <new NonThisConstructor()>
    // Expect edge: <MODULE> -[DECLARES]-> <NonThisConstructor>
    // Expect edge: <NonThisConstructor> -[RETURNS]-> <{ custom: true }>
    // Expect edge: <MODULE> -[DECLARES]-> <nonThisInstance>
    void code;
  });

  test('expressions::comma-in-arrow-body', () => {
    const code = "const commaArrow = (x) => (console.log(x), x * 2);";
    // Expect node: VARIABLE <commaArrow>
    // Expect node: FUNCTION <commaArrow:fn>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <(console.log(x), x * 2)>
    // Expect node: CALL <console.log(x)>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect edge: <commaArrow:fn> -[CONTAINS]-> <x>
    // Expect edge: <commaArrow:fn> -[RETURNS]-> <(console.log(x), x * 2)>
    // Expect edge: <(console.log(x), x * 2)> -[HAS_ELEMENT]-> <console.log(x)>
    // Expect edge: <(console.log(x), x * 2)> -[HAS_ELEMENT]-> <x * 2>
    // Expect edge: <console.log(x)> -[PASSES_ARGUMENT]-> <x>
    void code;
  });

  test('expressions::comma-in-array-subscript', () => {
    const code = "function commaSubscript() {\n  const matrix = [[1, 2], [3, 4]];\n  const result = matrix[0, 1]; // comma evaluates to 1 → matrix[1]\n  return result; // [3, 4]\n}";
    // Expect node: FUNCTION <commaSubscript>
    // Expect node: VARIABLE <matrix>
    // Expect node: LITERAL <[[1, 2], [3, 4]]>
    // Expect node: VARIABLE <result>
    // Expect node: PROPERTY_ACCESS <matrix[0, 1]>
    // Expect node: EXPRESSION <0, 1>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <1>
    // Expect edge: <commaSubscript> -[CONTAINS]-> <matrix>
    // Expect edge: <commaSubscript> -[CONTAINS]-> <result>
    // Expect edge: <0, 1> -[CONTAINS]-> <0>
    // Expect edge: <0, 1> -[CONTAINS]-> <1>
    // Expect edge: <commaSubscript> -[RETURNS]-> <result>
    void code;
  });

  test('expressions::conditional-method-call', () => {
    const code = "function conditionalMethodCall(input) {\n  const value = (typeof input === 'string' ? input : String(input)).trim();\n  return value;\n}";
    // Expect node: FUNCTION <conditionalMethodCall>
    // Expect node: PARAMETER <input>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <typeof input === 'string'>
    // Expect node: EXPRESSION <typeof input>
    // Expect node: LITERAL <'string'>
    // Expect node: CALL <String(input)>
    // Expect node: EXPRESSION <conditional>
    // Expect node: CALL <.trim()>
    // Expect edge: <conditionalMethodCall> -[CONTAINS]-> <input>
    // Expect edge: <conditionalMethodCall> -[CONTAINS]-> <value>
    // Expect edge: <conditional> -[HAS_CONDITION]-> <typeof input === 'string'>
    // Expect edge: <conditional> -[HAS_CONSEQUENT]-> <input>
    // Expect edge: <String(input)> -[PASSES_ARGUMENT]-> <input>
    // Expect edge: <conditionalMethodCall> -[RETURNS]-> <value>
    void code;
  });

  test('expressions::typeof-undeclared', () => {
    const code = "function typeofUndeclared() {\n  const safe = typeof undeclaredVar; // \"undefined\" — NO ReferenceError\n  return safe;\n}";
    // Expect node: FUNCTION <typeofUndeclared>
    // Expect node: VARIABLE <safe>
    // Expect node: EXPRESSION <typeof undeclaredVar>
    // Expect node: VARIABLE <undeclaredVar>
    // Expect node: LITERAL <'undefined'>
    // Expect edge: <module> -[DECLARES]-> <typeofUndeclared>
    // Expect edge: <typeofUndeclared> -[CONTAINS]-> <safe>
    // Expect edge: <typeofUndeclared> -[RETURNS]-> <safe>
    void code;
  });

  test('expressions::new-precedence-trap', () => {
    const code = "function newPrecedence() {\n  const withParens = new Date().getTime();       // (new Date()).getTime()\n  // new Date.getTime()                          // new (Date.getTime)() — TypeError!\n  const noParens = new Map;                      // valid — no parens needed\n  return { withParens, noParens };\n}";
    // Expect node: FUNCTION <newPrecedence>
    // Expect node: VARIABLE <withParens>
    // Expect node: CALL <new Date()>
    // Expect node: CALL <getTime()>
    // Expect node: PROPERTY_ACCESS <Date().getTime>
    // Expect node: VARIABLE <noParens>
    // Expect node: CALL <new Map>
    // Expect node: EXPRESSION <{ withParens, noParens }>
    // Expect node: EXTERNAL <Date>
    // Expect node: EXTERNAL <Map>
    // Expect edge: <newPrecedence> -[CONTAINS]-> <withParens>
    // Expect edge: <newPrecedence> -[CONTAINS]-> <noParens>
    // Expect edge: <newPrecedence> -[RETURNS]-> <{ withParens, noParens }>
    void code;
  });

  test('expressions::nullish-coalescing-chain', () => {
    const code = "function nullishChain(a, b, c, defaultValue) {\n  const value = a ?? b ?? c ?? defaultValue;\n  return value;\n}";
    // Expect node: FUNCTION <nullishChain>
    // Expect node: PARAMETER <a>
    // Expect node: PARAMETER <b>
    // Expect node: PARAMETER <c>
    // Expect node: PARAMETER <defaultValue>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <a ?? b ?? c ?? defaultValue>
    // Expect edge: <nullishChain> -[CONTAINS]-> <a>
    // Expect edge: <nullishChain> -[CONTAINS]-> <b>
    // Expect edge: <nullishChain> -[CONTAINS]-> <c>
    // Expect edge: <nullishChain> -[CONTAINS]-> <defaultValue>
    // Expect edge: <nullishChain> -[DECLARES]-> <value>
    // Expect edge: <nullishChain> -[RETURNS]-> <value>
    void code;
  });

  test('expressions::new-member-expression', () => {
    const code = "function newMemberExpression(mod) {\n  const instance = new mod.MyClass();\n  const nested = new mod.sub.Factory();\n  return { instance, nested };\n}";
    // Expect node: FUNCTION <newMemberExpression>
    // Expect node: PARAMETER <mod>
    // Expect node: VARIABLE <instance>
    // Expect node: EXPRESSION <new mod.MyClass()>
    // Expect node: PROPERTY_ACCESS <mod.MyClass>
    // Expect node: VARIABLE <nested>
    // Expect node: EXPRESSION <new mod.sub.Factory()>
    // Expect node: PROPERTY_ACCESS <mod.sub.Factory>
    // Expect node: PROPERTY_ACCESS <mod.sub>
    // Expect node: EXPRESSION <{ instance, nested }>
    // Expect edge: <newMemberExpression> -[CONTAINS]-> <mod>
    // Expect edge: <newMemberExpression> -[DECLARES]-> <instance>
    // Expect edge: <newMemberExpression> -[DECLARES]-> <nested>
    // Expect edge: <newMemberExpression> -[RETURNS]-> <{ instance, nested }>
    void code;
  });

  test('expressions::comma-in-condition', () => {
    const code = "function commaInWhile() {\n  let i = 0, total = 0;\n  while ((total += i, ++i < 5)) {\n    // comma in condition\n  }\n  return total; // 10\n}";
    // Expect node: FUNCTION <commaInWhile>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <total>
    // Expect node: LITERAL <0_2>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <comma-condition>
    // Expect node: EXPRESSION <total += i>
    // Expect node: EXPRESSION <++i>
    // Expect node: EXPRESSION <++i < 5>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <return total>
    // Expect edge: <commaInWhile> -[CONTAINS]-> <i>
    // Expect edge: <commaInWhile> -[CONTAINS]-> <total>
    // Expect edge: <commaInWhile> -[CONTAINS]-> <while>
    // Expect edge: <while> -[HAS_CONDITION]-> <comma-condition>
    // Expect edge: <comma-condition> -[HAS_ELEMENT]-> <total += i>
    // Expect edge: <comma-condition> -[HAS_ELEMENT]-> <++i < 5>
    // Expect edge: <++i < 5> -[HAS_ELEMENT]-> <++i>
    // Expect edge: <++i < 5> -[HAS_ELEMENT]-> <5>
    // Expect edge: <commaInWhile> -[CONTAINS]-> <return total>
    // Expect edge: <commaInWhile> -[RETURNS]-> <return total>
    void code;
  });

  test('expressions::reflect-construct-factory', () => {
    const code = "function createInstance(Cls, args) {\n  return Reflect.construct(Cls, args); // factory pattern — construct without `new`\n}\n\n// --- Tagged template returning non-string ---";
    // Expect node: FUNCTION <createInstance>
    // Expect node: PARAMETER <Cls>
    // Expect node: PARAMETER <args>
    // Expect node: CALL <Reflect.construct(Cls, args)>
    // Expect node: PROPERTY_ACCESS <Reflect.construct>
    // Expect node: EXTERNAL <Reflect>
    // Expect edge: <createInstance> -[CONTAINS]-> <Cls>
    // Expect edge: <createInstance> -[CONTAINS]-> <args>
    // Expect edge: <createInstance> -[RETURNS]-> <Reflect.construct(Cls, args)>
    // Expect edge: <Reflect.construct(Cls, args)> -[PASSES_ARGUMENT]-> <Cls>
    // Expect edge: <Reflect.construct(Cls, args)> -[PASSES_ARGUMENT]-> <args>
    void code;
  });

  test('expressions::assignment-in-if', () => {
    const code = "function assignmentInIf(compute) {\n  let result;\n  if (result = compute()) {            // assignment + truthiness check\n    return result;\n  }\n  return null;\n}";
    // Expect node: FUNCTION <assignmentInIf>
    // Expect node: PARAMETER <compute>
    // Expect node: VARIABLE <result>
    // Expect node: BRANCH <if-assignment>
    // Expect node: EXPRESSION <result = compute()>
    // Expect node: CALL <compute()>
    // Expect node: LITERAL <null>
    // Expect edge: <assignmentInIf> -[CONTAINS]-> <compute>
    // Expect edge: <assignmentInIf> -[CONTAINS]-> <result>
    // Expect edge: <assignmentInIf> -[CONTAINS]-> <if-assignment>
    // Expect edge: <if-assignment> -[HAS_CONDITION]-> <result = compute()>
    // Expect edge: <if-assignment> -[HAS_CONSEQUENT]-> <result>
    // Expect edge: <assignmentInIf> -[RETURNS]-> <result>
    // Expect edge: <assignmentInIf> -[RETURNS]-> <null>
    void code;
  });

  test('expressions::conditional-tag-template', () => {
    const code = "function conditionalTagTemplate(dangerous) {\n  const escape = dangerous ? (s) => s[0].toUpperCase() : (s) => s[0];\n  const result = escape`hello`;\n  return result;\n}";
    // Expect node: FUNCTION <conditionalTagTemplate>
    // Expect node: PARAMETER <dangerous>
    // Expect node: VARIABLE <escape>
    // Expect node: EXPRESSION <dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>
    // Expect node: FUNCTION <(s) => s[0].toUpperCase()>
    // Expect node: PARAMETER <s1>
    // Expect node: PROPERTY_ACCESS <s[0]>
    // Expect node: CALL <s[0].toUpperCase()>
    // Expect node: FUNCTION <(s) => s[0]>
    // Expect node: PARAMETER <s2>
    // Expect node: PROPERTY_ACCESS <s2[0]>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <escape`hello`>
    // Expect node: LITERAL <`hello`>
    // Expect edge: <conditionalTagTemplate> -[CONTAINS]-> <dangerous>
    // Expect edge: <conditionalTagTemplate> -[CONTAINS]-> <escape>
    // Expect edge: <dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]> -[HAS_CONSEQUENT]-> <(s) => s[0].toUpperCase()>
    // Expect edge: <(s) => s[0].toUpperCase()> -[CONTAINS]-> <s1>
    // Expect edge: <(s) => s[0].toUpperCase()> -[RETURNS]-> <s[0].toUpperCase()>
    // Expect edge: <(s) => s[0]> -[CONTAINS]-> <s2>
    // Expect edge: <(s) => s[0]> -[RETURNS]-> <s2[0]>
    // Expect edge: <conditionalTagTemplate> -[CONTAINS]-> <result>
    // Expect edge: <escape`hello`> -[PASSES_ARGUMENT]-> <`hello`>
    // Expect edge: <conditionalTagTemplate> -[RETURNS]-> <result>
    void code;
  });

  test('expressions::reflect-construct-newtarget', () => {
    const code = "class ReflectBase {\n  constructor() {\n    this.constructedBy = new.target.name;\n  }\n}\nclass ReflectDerived extends ReflectBase {}\n\nfunction reflectConstructDemo() {\n  const normal = new ReflectDerived();                       // constructedBy: 'ReflectDerived'\n  const spoofed = Reflect.construct(ReflectBase, [], ReflectDerived); // constructedBy: 'ReflectDerived' but runs Base constructor\n  return { normal, spoofed };\n}";
    // Expect node: CLASS <ReflectBase>
    // Expect node: METHOD <ReflectBase.constructor>
    // Expect node: PROPERTY_ACCESS <this.constructedBy>
    // Expect node: META_PROPERTY <new.target.name>
    // Expect node: CLASS <ReflectDerived>
    // Expect node: FUNCTION <reflectConstructDemo>
    // Expect node: VARIABLE <normal>
    // Expect node: CALL <new ReflectDerived()>
    // Expect node: VARIABLE <spoofed>
    // Expect node: CALL <Reflect.construct(ReflectBase, [], ReflectDerived)>
    // Expect node: LITERAL <[]>
    // Expect node: EXPRESSION <{ normal, spoofed }>
    // Expect edge: <ReflectBase> -[CONTAINS]-> <ReflectBase.constructor>
    // Expect edge: <reflectConstructDemo> -[CONTAINS]-> <normal>
    // Expect edge: <reflectConstructDemo> -[CONTAINS]-> <spoofed>
    // Expect edge: <Reflect.construct(ReflectBase, [], ReflectDerived)> -[PASSES_ARGUMENT]-> <ReflectBase>
    // Expect edge: <Reflect.construct(ReflectBase, [], ReflectDerived)> -[PASSES_ARGUMENT]-> <[]>
    // Expect edge: <Reflect.construct(ReflectBase, [], ReflectDerived)> -[PASSES_ARGUMENT]-> <ReflectDerived>
    // Expect edge: <reflectConstructDemo> -[RETURNS]-> <{ normal, spoofed }>
    void code;
  });

  test('expressions::logical-assign-property', () => {
    const code = "function logicalAssignProperty() {\n  const config = { timeout: 0, retries: null, debug: false };\n  config.timeout ||= 5000;    // 5000 — 0 is falsy\n  config.retries ??= 3;       // 3 — null is nullish\n  config.debug &&= true;      // false — short-circuits\n  return config;\n}";
    // Expect node: FUNCTION <logicalAssignProperty>
    // Expect node: VARIABLE <config>
    // Expect node: LITERAL <object-literal>
    // Expect node: PROPERTY <timeout-prop>
    // Expect node: LITERAL <0>
    // Expect node: PROPERTY <retries-prop>
    // Expect node: LITERAL <null>
    // Expect node: PROPERTY <debug-prop>
    // Expect node: LITERAL <false>
    // Expect node: EXPRESSION <config.timeout ||= 5000>
    // Expect node: PROPERTY_ACCESS <config.timeout>
    // Expect node: LITERAL <5000>
    // Expect node: EXPRESSION <config.retries ??= 3>
    // Expect node: PROPERTY_ACCESS <config.retries>
    // Expect node: LITERAL <3>
    // Expect node: EXPRESSION <config.debug &&= true>
    // Expect node: PROPERTY_ACCESS <config.debug>
    // Expect node: LITERAL <true>
    // Expect edge: <logicalAssignProperty> -[CONTAINS]-> <config>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <timeout-prop>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <retries-prop>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <debug-prop>
    // Expect edge: <logicalAssignProperty> -[CONTAINS]-> <config.timeout ||= 5000>
    // Expect edge: <logicalAssignProperty> -[CONTAINS]-> <config.retries ??= 3>
    // Expect edge: <logicalAssignProperty> -[CONTAINS]-> <config.debug &&= true>
    // Expect edge: <logicalAssignProperty> -[RETURNS]-> <config>
    void code;
  });

  test('expressions::tagged-template-chained', () => {
    const code = "function chainTag(strings) {\n  return (strings2) => strings[0] + strings2[0];\n}\nconst chainedResult = chainTag`hello``world`;";
    // Expect node: FUNCTION <chainTag>
    // Expect node: PARAMETER <strings>
    // Expect node: FUNCTION <chainTag:inner>
    // Expect node: PARAMETER <strings2>
    // Expect node: EXPRESSION <strings[0] + strings2[0]>
    // Expect node: PROPERTY_ACCESS <strings[0]>
    // Expect node: PROPERTY_ACCESS <strings2[0]>
    // Expect node: VARIABLE <chainedResult>
    // Expect node: CALL <chainTag`hello`>
    // Expect node: LITERAL <`hello`>
    // Expect node: CALL <chainTag`hello``world`>
    // Expect node: LITERAL <`world`>
    // Expect edge: <chainTag> -[HAS_BODY]-> <strings>
    // Expect edge: <chainTag> -[RETURNS]-> <chainTag:inner>
    // Expect edge: <chainTag:inner> -[HAS_BODY]-> <strings2>
    // Expect edge: <chainTag:inner> -[RETURNS]-> <strings[0] + strings2[0]>
    // Expect edge: <chainTag`hello`> -[PASSES_ARGUMENT]-> <`hello`>
    // Expect edge: <chainTag`hello``world`> -[PASSES_ARGUMENT]-> <`world`>
    void code;
  });

  test('expressions::tagged-template-returns-class', () => {
    const code = "const styledDiv = {\n  div(strings, ...exprs) {\n    return class StyledComponent {\n      styles = strings.join('');\n    };\n  },\n};\nconst Component = styledDiv.div`color: red; font-size: 14px;`;";
    // Expect node: VARIABLE <styledDiv>
    // Expect node: EXPRESSION <styledDiv:obj>
    // Expect node: METHOD <div>
    // Expect node: PARAMETER <strings>
    // Expect node: PARAMETER <exprs>
    // Expect node: CLASS <StyledComponent>
    // Expect node: PROPERTY <styles>
    // Expect node: CALL <strings.join('')>
    // Expect node: LITERAL <''>
    // Expect node: VARIABLE <Component>
    // Expect node: CALL <styledDiv.div`color: red; font-size: 14px;`>
    // Expect node: PROPERTY_ACCESS <styledDiv.div>
    // Expect node: LITERAL <`color: red; font-size: 14px;`>
    // Expect edge: <styledDiv:obj> -[HAS_PROPERTY]-> <div>
    // Expect edge: <div> -[CONTAINS]-> <strings>
    // Expect edge: <div> -[CONTAINS]-> <exprs>
    // Expect edge: <div> -[RETURNS]-> <StyledComponent>
    // Expect edge: <StyledComponent> -[CONTAINS]-> <styles>
    // Expect edge: <strings.join('')> -[PASSES_ARGUMENT]-> <''>
    // Expect edge: <styledDiv.div`color: red; font-size: 14px;`> -[PASSES_ARGUMENT]-> <`color: red; font-size: 14px;`>
    void code;
  });

  test('expressions::optional-chaining-syntax-errors', () => {
    const code = "// SyntaxError cases — cannot appear in valid AST:\n// obj?.prop = value;    // cannot assign through ?.\n// obj?.['key'] = value; // cannot assign through ?.\n// arr?.[0] = value;     // cannot assign through ?.\n// super?.method();      // super doesn't support optional chaining\n// obj?.tag`template`;   // tagged templates don't support optional chaining";
    // Expect node: EXPRESSION <obj?.prop = value>
    // Expect node: EXPRESSION <obj?.['key'] = value>
    // Expect node: EXPRESSION <arr?.[0] = value>
    // Expect node: EXPRESSION <super?.method()>
    // Expect node: EXPRESSION <obj?.tag`template`>
    // Expect edge: <module> -[CONTAINS]-> <obj?.prop = value>
    // Expect edge: <module> -[CONTAINS]-> <obj?.['key'] = value>
    // Expect edge: <module> -[CONTAINS]-> <arr?.[0] = value>
    // Expect edge: <module> -[CONTAINS]-> <super?.method()>
    // Expect edge: <module> -[CONTAINS]-> <obj?.tag`template`>
    void code;
  });

  test('expressions::tagged-template-returns-object', () => {
    const code = "function sql(strings, ...values) {\n  return { text: strings.join('?'), params: values }; // returns object, not string!\n}\nconst userId = 42;\nconst query = sql`SELECT * FROM users WHERE id = ${userId}`;";
    // Expect node: FUNCTION <sql>
    // Expect node: PARAMETER <strings>
    // Expect node: PARAMETER <values>
    // Expect node: LITERAL <'text'>
    // Expect node: CALL <strings.join('?')>
    // Expect node: LITERAL <'?'>
    // Expect node: LITERAL <'params'>
    // Expect node: EXPRESSION <{ text: strings.join('?'), params: values }>
    // Expect node: VARIABLE <userId>
    // Expect node: LITERAL <42>
    // Expect node: VARIABLE <query>
    // Expect node: CALL <sql`SELECT * FROM users WHERE id = ${userId}`>
    // Expect node: LITERAL <'SELECT * FROM users WHERE id = '>
    // Expect node: LITERAL <''>
    // Expect edge: <sql> -[HAS_BODY]-> <strings>
    // Expect edge: <sql> -[HAS_BODY]-> <values>
    // Expect edge: <sql> -[RETURNS]-> <{ text: strings.join('?'), params: values }>
    // Expect edge: <{ text: strings.join('?'), params: values }> -[HAS_PROPERTY]-> <'text'>
    // Expect edge: <{ text: strings.join('?'), params: values }> -[HAS_PROPERTY]-> <strings.join('?')>
    // Expect edge: <{ text: strings.join('?'), params: values }> -[HAS_PROPERTY]-> <'params'>
    // Expect edge: <{ text: strings.join('?'), params: values }> -[HAS_PROPERTY]-> <values>
    // Expect edge: <strings.join('?')> -[PASSES_ARGUMENT]-> <'?'>
    // Expect edge: <sql`SELECT * FROM users WHERE id = ${userId}`> -[PASSES_ARGUMENT]-> <'SELECT * FROM users WHERE id = '>
    // Expect edge: <sql`SELECT * FROM users WHERE id = ${userId}`> -[PASSES_ARGUMENT]-> <''>
    // Expect edge: <sql`SELECT * FROM users WHERE id = ${userId}`> -[PASSES_ARGUMENT]-> <userId>
    void code;
  });

  test('expressions::short-circuit-guard-call', () => {
    const code = "function shortCircuitGuard(callback, data) {\n  callback && callback(data);           // guard + call\n  const result = callback?.(data);      // optional call equivalent\n  return result;\n}";
    // Expect node: FUNCTION <shortCircuitGuard>
    // Expect node: PARAMETER <callback>
    // Expect node: PARAMETER <data>
    // Expect node: EXPRESSION <callback && callback(data)>
    // Expect node: CALL <callback(data)>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <callback?.(data)>
    // Expect edge: <shortCircuitGuard> -[CONTAINS]-> <callback>
    // Expect edge: <shortCircuitGuard> -[CONTAINS]-> <data>
    // Expect edge: <shortCircuitGuard> -[CONTAINS]-> <callback && callback(data)>
    // Expect edge: <callback && callback(data)> -[CONTAINS]-> <callback(data)>
    // Expect edge: <callback(data)> -[PASSES_ARGUMENT]-> <data>
    // Expect edge: <shortCircuitGuard> -[DECLARES]-> <result>
    // Expect edge: <callback?.(data)> -[PASSES_ARGUMENT]-> <data>
    // Expect edge: <shortCircuitGuard> -[RETURNS]-> <result>
    void code;
  });

  test('expressions::in-operator-array', () => {
    const code = "function inOperatorArray() {\n  const hasIndex = 0 in [1, 2, 3];     // true — checks INDEX, not value\n  const hasStr = '0' in [1, 2, 3];     // true — coerced to string\n  const noIndex = 5 in [1, 2, 3];      // false\n  return { hasIndex, hasStr, noIndex };\n}\n\n// --- Reflect.construct with newTarget (constructor spoofing) ---";
    // Expect node: FUNCTION <inOperatorArray>
    // Expect node: VARIABLE <hasIndex>
    // Expect node: EXPRESSION <0 in [1, 2, 3]>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect node: VARIABLE <hasStr>
    // Expect node: EXPRESSION <'0' in [1, 2, 3]>
    // Expect node: LITERAL <'0'>
    // Expect node: VARIABLE <noIndex>
    // Expect node: EXPRESSION <5 in [1, 2, 3]>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <{ hasIndex, hasStr, noIndex }>
    // Expect edge: <inOperatorArray> -[CONTAINS]-> <hasIndex>
    // Expect edge: <inOperatorArray> -[CONTAINS]-> <hasStr>
    // Expect edge: <inOperatorArray> -[CONTAINS]-> <noIndex>
    // Expect edge: <0 in [1, 2, 3]> -[USES]-> <0>
    // Expect edge: <0 in [1, 2, 3]> -[USES]-> <[1, 2, 3]>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <1>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <2>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <3>
    // Expect edge: <'0' in [1, 2, 3]> -[USES]-> <'0'>
    // Expect edge: <'0' in [1, 2, 3]> -[USES]-> <[1, 2, 3]>
    // Expect edge: <5 in [1, 2, 3]> -[USES]-> <5>
    // Expect edge: <5 in [1, 2, 3]> -[USES]-> <[1, 2, 3]>
    // Expect edge: <inOperatorArray> -[RETURNS]-> <{ hasIndex, hasStr, noIndex }>
    // Expect edge: <{ hasIndex, hasStr, noIndex }> -[USES]-> <hasIndex>
    // Expect edge: <{ hasIndex, hasStr, noIndex }> -[USES]-> <hasStr>
    // Expect edge: <{ hasIndex, hasStr, noIndex }> -[USES]-> <noIndex>
    void code;
  });

  test('expressions::await-comma-expression', () => {
    const code = "async function awaitCommaExpression(sideEffect, fetchData) {\n  const result = await (sideEffect(), fetchData());\n  // sideEffect() runs sync, fetchData() is awaited\n  return result;\n}";
    // Expect node: FUNCTION <awaitCommaExpression>
    // Expect node: PARAMETER <sideEffect>
    // Expect node: PARAMETER <fetchData>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <await (sideEffect(), fetchData())>
    // Expect node: EXPRESSION <(sideEffect(), fetchData())>
    // Expect node: CALL <sideEffect()>
    // Expect node: CALL <fetchData()>
    // Expect edge: <awaitCommaExpression> -[CONTAINS]-> <sideEffect>
    // Expect edge: <awaitCommaExpression> -[CONTAINS]-> <fetchData>
    // Expect edge: <awaitCommaExpression> -[CONTAINS]-> <result>
    // Expect edge: <await (sideEffect(), fetchData())> -[AWAITS]-> <(sideEffect(), fetchData())>
    // Expect edge: <(sideEffect(), fetchData())> -[CONTAINS]-> <sideEffect()>
    // Expect edge: <(sideEffect(), fetchData())> -[CONTAINS]-> <fetchData()>
    // Expect edge: <awaitCommaExpression> -[RETURNS]-> <result>
    void code;
  });

  test('expressions::new-with-spread', () => {
    const code = "function newWithSpread() {\n  const args = [2024, 0, 15];\n  const date = new Date(...args);\n\n  function instantiate(Cls, ctorArgs) {\n    return new Cls(...ctorArgs);       // dynamic class + spread\n  }\n\n  return { date, instantiate };\n}";
    // Expect node: FUNCTION <newWithSpread>
    // Expect node: VARIABLE <args>
    // Expect node: LITERAL <[2024, 0, 15]>
    // Expect node: LITERAL <2024>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <15>
    // Expect node: VARIABLE <date>
    // Expect node: CALL <new Date(...args)>
    // Expect node: EXTERNAL <Date>
    // Expect node: FUNCTION <instantiate>
    // Expect node: PARAMETER <Cls>
    // Expect node: PARAMETER <ctorArgs>
    // Expect node: CALL <new Cls(...ctorArgs)>
    // Expect node: EXPRESSION <{ date, instantiate }>
    // Expect edge: <newWithSpread> -[CONTAINS]-> <args>
    // Expect edge: <[2024, 0, 15]> -[HAS_ELEMENT]-> <2024>
    // Expect edge: <[2024, 0, 15]> -[HAS_ELEMENT]-> <0>
    // Expect edge: <[2024, 0, 15]> -[HAS_ELEMENT]-> <15>
    // Expect edge: <newWithSpread> -[CONTAINS]-> <date>
    // Expect edge: <newWithSpread> -[CONTAINS]-> <instantiate>
    // Expect edge: <instantiate> -[CONTAINS]-> <Cls>
    // Expect edge: <instantiate> -[CONTAINS]-> <ctorArgs>
    // Expect edge: <instantiate> -[RETURNS]-> <new Cls(...ctorArgs)>
    // Expect edge: <newWithSpread> -[RETURNS]-> <{ date, instantiate }>
    // Expect edge: <{ date, instantiate }> -[HAS_PROPERTY]-> <date>
    // Expect edge: <{ date, instantiate }> -[HAS_PROPERTY]-> <instantiate>
    void code;
  });

  test('expressions::nullish-logical-mixing-error', () => {
    const code = "// SyntaxError — cannot mix ?? with || or && without explicit parentheses:\n// a ?? b || c;    // SyntaxError\n// a || b ?? c;    // SyntaxError\n// a ?? b && c;    // SyntaxError\n// Must use: (a ?? b) || c  or  a ?? (b || c)";
    // Expect node: SIDE_EFFECT <nullish-logical-mixing-error>
    // Expect node: EXPRESSION <a ?? b || c>
    // Expect node: EXPRESSION <a || b ?? c>
    // Expect node: EXPRESSION <a ?? b && c>
    // Expect node: EXPRESSION <(a ?? b) || c>
    // Expect node: EXPRESSION <a ?? (b || c)>

    void code;
  });

  test('expressions::assignment-in-condition', () => {
    const code = "function assignmentInCondition(regex, str) {\n  const matches = [];\n  let match;\n  while (match = regex.exec(str)) {   // assignment AS condition (no explicit comparison)\n    matches.push(match[0]);\n  }\n  return matches;\n}";
    // Expect node: FUNCTION <assignmentInCondition>
    // Expect node: PARAMETER <regex>
    // Expect node: PARAMETER <str>
    // Expect node: VARIABLE <matches>
    // Expect node: LITERAL <[]>
    // Expect node: VARIABLE <match>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <match = regex.exec(str)>
    // Expect node: CALL <regex.exec(str)>
    // Expect node: PROPERTY_ACCESS <regex.exec>
    // Expect node: CALL <matches.push(match[0])>
    // Expect node: PROPERTY_ACCESS <matches.push>
    // Expect node: EXPRESSION <match[0]>
    // Expect node: LITERAL <0>
    // Expect edge: <assignmentInCondition> -[CONTAINS]-> <regex>
    // Expect edge: <assignmentInCondition> -[CONTAINS]-> <str>
    // Expect edge: <assignmentInCondition> -[CONTAINS]-> <matches>
    // Expect edge: <assignmentInCondition> -[CONTAINS]-> <match>
    // Expect edge: <assignmentInCondition> -[CONTAINS]-> <while>
    // Expect edge: <while> -[HAS_CONDITION]-> <match = regex.exec(str)>
    // Expect edge: <regex.exec(str)> -[PASSES_ARGUMENT]-> <str>
    // Expect edge: <while> -[HAS_BODY]-> <matches.push(match[0])>
    // Expect edge: <matches.push(match[0])> -[PASSES_ARGUMENT]-> <match[0]>
    // Expect edge: <assignmentInCondition> -[RETURNS]-> <matches>
    void code;
  });

  test('hashbang-entry::export-named-list', () => {
    const code = "export { hashbangMain };";
    // Expect node: EXPORT <export-hashbangMain>
    // Expect node: VARIABLE <hashbangMain>
    // Expect edge: <module> -[CONTAINS]-> <export-hashbangMain>
    void code;
  });

  test('index::import-named', () => {
    const code = "import { helperFunction, HELPER_CONST } from './modules-helpers.js';";
    // Expect node: IMPORT <import-modules-helpers>
    // Expect node: VARIABLE <helperFunction>
    // Expect node: VARIABLE <HELPER_CONST>
    // Expect edge: <module> -[CONTAINS]-> <import-modules-helpers>
    void code;
  });

  test('index::import-default', () => {
    const code = "import defaultExport from './modules-helpers.js';";
    // Expect node: IMPORT <import-modules-helpers>
    // Expect node: VARIABLE <defaultExport>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>
    // Expect edge: <module> -[CONTAINS]-> <import-modules-helpers>
    // Expect edge: <module> -[DECLARES]-> <defaultExport>
    void code;
  });

  test('expressions::async-arrow-returns-object', () => {
    const code = "const asyncArrowObject = async (data, processFn) => ({\n  id: data.id,\n  result: await processFn(data),\n  timestamp: Date.now(),\n});\n// Without parens: async (data) => { id: data.id } — parsed as block + label!";
    // Expect node: VARIABLE <asyncArrowObject>
    // Expect node: FUNCTION <asyncArrowObject:fn>
    // Expect node: PARAMETER <data>
    // Expect node: PARAMETER <processFn>
    // Expect node: EXPRESSION <object-literal>
    // Expect node: PROPERTY_ACCESS <data.id>
    // Expect node: EXPRESSION <await processFn(data)>
    // Expect node: CALL <processFn(data)>
    // Expect node: CALL <Date.now()>
    // Expect node: PROPERTY_ACCESS <Date.now>
    // Expect edge: <asyncArrowObject:fn> -[CONTAINS]-> <data>
    // Expect edge: <asyncArrowObject:fn> -[CONTAINS]-> <processFn>
    // Expect edge: <asyncArrowObject:fn> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <data.id>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <await processFn(data)>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <Date.now()>
    // Expect edge: <await processFn(data)> -[AWAITS]-> <processFn(data)>
    // Expect edge: <processFn(data)> -[PASSES_ARGUMENT]-> <data>
    void code;
  });

  test('index::import-aliased', () => {
    const code = "import { HelperClass as Helper } from './modules-helpers.js';";
    // Expect node: IMPORT <import-modules-helpers>
    // Expect node: VARIABLE <Helper>
    // Expect edge: <module> -[CONTAINS]-> <import-modules-helpers>
    // Expect edge: <module> -[DECLARES]-> <Helper>
    void code;
  });

  test('hashbang-entry::hashbang-comment', () => {
    const code = "// The #!/usr/bin/env node line above is a HashbangComment node in the AST.\n// It is the ONLY position where # is legal outside a string/comment/private-field.\n\nfunction hashbangMain(args) {\n  return { ran: true, args };\n}";
    // Expect node: EXTERNAL <#!/usr/bin/env node>
    // Expect node: FUNCTION <hashbangMain>
    // Expect node: PARAMETER <args>
    // Expect node: LITERAL <true>
    // Expect node: EXPRESSION <{ ran: true, args }>
    // Expect edge: <module> -[CONTAINS]-> <#!/usr/bin/env node>
    // Expect edge: <module> -[DECLARES]-> <hashbangMain>
    // Expect edge: <hashbangMain> -[CONTAINS]-> <args>
    // Expect edge: <hashbangMain> -[RETURNS]-> <{ ran: true, args }>
    // Expect edge: <{ ran: true, args }> -[HAS_PROPERTY]-> <true>
    void code;
  });

  test('expressions::getter-returns-function', () => {
    const code = "function getterReturnsFunction() {\n  const obj = {\n    get handler() {\n      return (x) => x * 2;             // getter returns a function\n    },\n  };\n  const result = obj.handler(21);       // getter call + returned function call\n  return result; // 42\n}";
    // Expect node: FUNCTION <getterReturnsFunction>
    // Expect node: VARIABLE <obj>
    // Expect node: EXPRESSION <obj-literal>
    // Expect node: GETTER <handler-getter>
    // Expect node: FUNCTION <arrow-fn>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <obj.handler(21)>
    // Expect node: PROPERTY_ACCESS <obj.handler>
    // Expect node: LITERAL <21>
    // Expect edge: <getterReturnsFunction> -[CONTAINS]-> <obj>
    // Expect edge: <obj-literal> -[HAS_PROPERTY]-> <handler-getter>
    // Expect edge: <handler-getter> -[RETURNS]-> <arrow-fn>
    // Expect edge: <arrow-fn> -[CONTAINS]-> <x>
    // Expect edge: <arrow-fn> -[RETURNS]-> <x * 2>
    // Expect edge: <getterReturnsFunction> -[CONTAINS]-> <result>
    // Expect edge: <obj.handler(21)> -[PASSES_ARGUMENT]-> <21>
    // Expect edge: <getterReturnsFunction> -[RETURNS]-> <result>
    void code;
  });

  test('index::import-namespace', () => {
    const code = "import * as allHelpers from './modules-helpers.js';";
    // Expect node: IMPORT <import-allHelpers>
    // Expect node: VARIABLE <allHelpers>
    // Expect edge: <module> -[CONTAINS]-> <import-allHelpers>
    // Expect edge: <module> -[DECLARES]-> <allHelpers>
    void code;
  });

  test('index::import-default-as-named', () => {
    const code = "import { default as mainFn } from './modules-helpers.js';";
    // Expect node: IMPORT <import-modules-helpers>
    // Expect node: VARIABLE <mainFn>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>

    void code;
  });

  test('index::reexport-star', () => {
    const code = "export * from './modules-reexport.js';";
    // Expect node: EXPORT <export-star>
    // Expect node: EXTERNAL_MODULE <./modules-reexport.js>

    void code;
  });

  test('index::import-meta', () => {
    const code = "const currentUrl = import.meta.url;\n\n// --- Module namespace object as first-class value ---";
    // Expect node: VARIABLE <currentUrl>
    // Expect node: PROPERTY_ACCESS <import.meta.url>
    // Expect node: META_PROPERTY <import.meta>
    // Expect edge: <module> -[DECLARES]-> <currentUrl>
    void code;
  });

  test('builtins::builtin-weakset', () => {
    const code = "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---";
    // Expect node: FUNCTION <weakSetUsage>
    // Expect node: VARIABLE <ws>
    // Expect node: CALL <new WeakSet()>
    // Expect node: VARIABLE <obj1>
    // Expect node: LITERAL <{}>
    // Expect node: VARIABLE <obj2>
    // Expect node: LITERAL <{}2>
    // Expect node: CALL <ws.add(obj1)>
    // Expect node: VARIABLE <has>
    // Expect node: CALL <ws.has(obj1)>
    // Expect node: CALL <ws.delete(obj1)>
    // Expect node: VARIABLE <hasAfter>
    // Expect node: CALL <ws.has(obj1)2>
    // Expect node: EXPRESSION <{ has, hasAfter }>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <ws>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <obj1>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <obj2>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <has>
    // Expect edge: <weakSetUsage> -[CONTAINS]-> <hasAfter>
    // Expect edge: <ws.add(obj1)> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <ws.has(obj1)> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <ws.delete(obj1)> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <ws.has(obj1)2> -[PASSES_ARGUMENT]-> <obj1>
    // Expect edge: <weakSetUsage> -[RETURNS]-> <{ has, hasAfter }>
    void code;
  });

  test('expressions::tag-on-call-result', () => {
    const code = "function tagOnCallResult() {\n  function getFormatter(type) {\n    return (strings, ...values) => ({ type, parts: strings, values });\n  }\n  const result = getFormatter('sql')`SELECT * FROM ${'users'}`;\n  return result;\n}";
    // Expect node: FUNCTION <tagOnCallResult>
    // Expect node: FUNCTION <getFormatter>
    // Expect node: PARAMETER <type>
    // Expect node: FUNCTION <getFormatter:arrow>
    // Expect node: PARAMETER <strings>
    // Expect node: PARAMETER <...values>
    // Expect node: EXPRESSION <{ type, parts: strings, values }>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <getFormatter('sql')>
    // Expect node: LITERAL <'sql'>
    // Expect node: CALL <tagged_template_call>
    // Expect node: EXPRESSION <`SELECT * FROM ${'users'}`>
    // Expect node: LITERAL <'users'>
    // Expect edge: <tagOnCallResult> -[CONTAINS]-> <getFormatter>
    // Expect edge: <getFormatter> -[RECEIVES_ARGUMENT]-> <type>
    // Expect edge: <getFormatter> -[RETURNS]-> <getFormatter:arrow>
    // Expect edge: <getFormatter:arrow> -[RECEIVES_ARGUMENT]-> <strings>
    // Expect edge: <getFormatter:arrow> -[RECEIVES_ARGUMENT]-> <...values>
    // Expect edge: <getFormatter:arrow> -[RETURNS]-> <{ type, parts: strings, values }>
    // Expect edge: <tagOnCallResult> -[CONTAINS]-> <result>
    // Expect edge: <getFormatter('sql')> -[PASSES_ARGUMENT]-> <'sql'>
    // Expect edge: <tagged_template_call> -[PASSES_ARGUMENT]-> <`SELECT * FROM ${'users'}`>
    // Expect edge: <`SELECT * FROM ${'users'}`> -[CONTAINS]-> <'users'>
    // Expect edge: <tagOnCallResult> -[RETURNS]-> <result>
    void code;
  });

  test('builtins::builtin-weakref', () => {
    const code = "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}";
    // Expect node: FUNCTION <weakRefUsage>
    // Expect node: VARIABLE <target>
    // Expect node: LITERAL <{ data: 'important' }>
    // Expect node: VARIABLE <ref>
    // Expect node: CALL <new WeakRef(target)>
    // Expect node: VARIABLE <deref>
    // Expect node: CALL <ref.deref()>
    // Expect node: PROPERTY_ACCESS <deref?.data>
    // Expect edge: <weakRefUsage> -[CONTAINS]-> <target>
    // Expect edge: <weakRefUsage> -[CONTAINS]-> <ref>
    // Expect edge: <weakRefUsage> -[CONTAINS]-> <deref>
    // Expect edge: <new WeakRef(target)> -[PASSES_ARGUMENT]-> <target>
    // Expect edge: <weakRefUsage> -[RETURNS]-> <deref?.data>
    void code;
  });

  test('index::import-dynamic', () => {
    const code = "const dynamicModule = await import('./patterns.js');";
    // Expect node: VARIABLE <dynamicModule>
    // Expect node: CALL <import('./patterns.js')>
    // Expect node: LITERAL <'./patterns.js'>
    // Expect edge: <module> -[DECLARES]-> <dynamicModule>
    // Expect edge: <import('./patterns.js')> -[PASSES_ARGUMENT]-> <'./patterns.js'>
    void code;
  });

  test('expressions::deep-optional-chain', () => {
    const code = "function deepOptionalChain(response) {\n  const value = response?.data?.items?.[0]?.getName?.();\n  const nested = response?.config?.headers?.['Content-Type']?.split?.('/');\n  return { value, nested };\n}";
    // Expect node: FUNCTION <deepOptionalChain>
    // Expect node: PARAMETER <response>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <response?.data?.items?.[0]?.getName?.()>
    // Expect node: PROPERTY_ACCESS <response?.data>
    // Expect node: PROPERTY_ACCESS <data?.items>
    // Expect node: PROPERTY_ACCESS <items?.[0]>
    // Expect node: PROPERTY_ACCESS <[0]?.getName>
    // Expect node: CALL <getName?.()>
    // Expect node: VARIABLE <nested>
    // Expect node: EXPRESSION <response?.config?.headers?.['Content-Type']?.split?.('/')>
    // Expect node: PROPERTY_ACCESS <response?.config>
    // Expect node: PROPERTY_ACCESS <config?.headers>
    // Expect node: PROPERTY_ACCESS <headers?.['Content-Type']>
    // Expect node: PROPERTY_ACCESS <['Content-Type']?.split>
    // Expect node: CALL <split?.('/')>
    // Expect node: LITERAL <'/'>
    // Expect node: EXPRESSION <{ value, nested }>
    // Expect edge: <deepOptionalChain> -[CONTAINS]-> <response>
    // Expect edge: <deepOptionalChain> -[CONTAINS]-> <value>
    // Expect edge: <deepOptionalChain> -[CONTAINS]-> <nested>
    // Expect edge: <response?.data?.items?.[0]?.getName?.()> -[CHAINS_FROM]-> <response?.data>
    // Expect edge: <data?.items> -[CHAINS_FROM]-> <response?.data>
    // Expect edge: <items?.[0]> -[CHAINS_FROM]-> <data?.items>
    // Expect edge: <[0]?.getName> -[CHAINS_FROM]-> <items?.[0]>
    // Expect edge: <getName?.()> -[CHAINS_FROM]-> <[0]?.getName>
    // Expect edge: <response?.config?.headers?.['Content-Type']?.split?.('/')> -[CHAINS_FROM]-> <response?.config>
    // Expect edge: <config?.headers> -[CHAINS_FROM]-> <response?.config>
    // Expect edge: <headers?.['Content-Type']> -[CHAINS_FROM]-> <config?.headers>
    // Expect edge: <['Content-Type']?.split> -[CHAINS_FROM]-> <headers?.['Content-Type']>
    // Expect edge: <split?.('/')> -[CHAINS_FROM]-> <['Content-Type']?.split>
    // Expect edge: <split?.('/')> -[PASSES_ARGUMENT]-> <'/'>
    // Expect edge: <deepOptionalChain> -[RETURNS]-> <{ value, nested }>
    void code;
  });

  test('index::module-namespace-destructured', () => {
    const code = "const { helperFunction: destructuredHelper } = allHelpers;";
    // Expect node: VARIABLE <destructuredHelper>
    // Expect node: EXPRESSION <{helperFunction: destructuredHelper}>
    // Expect node: PROPERTY_ACCESS <allHelpers.helperFunction>
    // Expect edge: <module> -[DECLARES]-> <destructuredHelper>
    void code;
  });

  test('index::export-named-list', () => {
    const code = "export { defaultExport, helperFunction, HELPER_CONST, Helper, allHelpers, mainFn, helperResult, destructuredHelper };";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <defaultExport>
    // Expect node: VARIABLE <helperFunction>
    // Expect node: VARIABLE <HELPER_CONST>
    // Expect node: VARIABLE <Helper>
    // Expect node: VARIABLE <allHelpers>
    // Expect node: VARIABLE <mainFn>
    // Expect node: VARIABLE <helperResult>
    // Expect node: VARIABLE <destructuredHelper>

    void code;
  });

  test('expressions::arrow-return-assignment', () => {
    const code = "function arrowReturnAssignment() {\n  let cache = null;\n\n  // Arrow returning assignment — parenthesized to make it expression body\n  const setCache = (val) => (cache = val);\n  setCache(42);\n\n  // With destructuring assignment in arrow\n  let first, second;\n  const swap = () => ([first, second] = [second, first]);\n\n  return { cache, setCache, swap };\n}";
    // Expect node: FUNCTION <arrowReturnAssignment>
    // Expect node: VARIABLE <cache>
    // Expect node: LITERAL <null>
    // Expect node: VARIABLE <setCache>
    // Expect node: FUNCTION <setCache:fn>
    // Expect node: PARAMETER <val>
    // Expect node: EXPRESSION <cache = val>
    // Expect node: CALL <setCache(42)>
    // Expect node: LITERAL <42>
    // Expect node: VARIABLE <first>
    // Expect node: VARIABLE <second>
    // Expect node: VARIABLE <swap>
    // Expect node: FUNCTION <swap:fn>
    // Expect node: EXPRESSION <[first, second] = [second, first]>
    // Expect node: EXPRESSION <[second, first]>
    // Expect node: EXPRESSION <{ cache, setCache, swap }>
    // Expect edge: <arrowReturnAssignment> -[CONTAINS]-> <cache>
    // Expect edge: <arrowReturnAssignment> -[CONTAINS]-> <setCache>
    // Expect edge: <setCache:fn> -[CONTAINS]-> <val>
    // Expect edge: <setCache:fn> -[RETURNS]-> <cache = val>
    // Expect edge: <arrowReturnAssignment> -[CONTAINS]-> <setCache(42)>
    // Expect edge: <setCache(42)> -[PASSES_ARGUMENT]-> <42>
    // Expect edge: <arrowReturnAssignment> -[CONTAINS]-> <first>
    // Expect edge: <arrowReturnAssignment> -[CONTAINS]-> <second>
    // Expect edge: <arrowReturnAssignment> -[CONTAINS]-> <swap>
    // Expect edge: <swap:fn> -[RETURNS]-> <[first, second] = [second, first]>
    // Expect edge: <arrowReturnAssignment> -[RETURNS]-> <{ cache, setCache, swap }>
    void code;
  });

  test('expressions::void-as-undefined', () => {
    const code = "function voidAsUndefined(val) {\n  // void 0 is shorter than undefined and immune to shadowing\n  const isUndef = val === void 0;\n\n  // void with side effect — expression runs, result discarded\n  let sideEffectRan = false;\n  void (sideEffectRan = true);\n\n  // void in ternary — explicit undefined branch\n  const result = val !== void 0 ? val : 'fallback';\n\n  return { isUndef, sideEffectRan, result };\n}";
    // Expect node: FUNCTION <voidAsUndefined>
    // Expect node: PARAMETER <val>
    // Expect node: VARIABLE <isUndef>
    // Expect node: EXPRESSION <val === void 0>
    // Expect node: EXPRESSION <void 0>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <sideEffectRan>
    // Expect node: LITERAL <false>
    // Expect node: EXPRESSION <void (sideEffectRan = true)>
    // Expect node: EXPRESSION <sideEffectRan = true>
    // Expect node: LITERAL <true>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <val !== void 0 ? val : 'fallback'>
    // Expect node: EXPRESSION <val !== void 0>
    // Expect node: EXPRESSION <void 0 (ternary)>
    // Expect node: LITERAL <0 (ternary)>
    // Expect node: LITERAL <'fallback'>
    // Expect node: EXPRESSION <{ isUndef, sideEffectRan, result }>
    // Expect edge: <voidAsUndefined> -[CONTAINS]-> <val>
    // Expect edge: <voidAsUndefined> -[DECLARES]-> <isUndef>
    // Expect edge: <voidAsUndefined> -[DECLARES]-> <sideEffectRan>
    // Expect edge: <voidAsUndefined> -[DECLARES]-> <result>
    // Expect edge: <val !== void 0 ? val : 'fallback'> -[HAS_CONDITION]-> <val !== void 0>
    // Expect edge: <val !== void 0 ? val : 'fallback'> -[HAS_CONSEQUENT]-> <val>
    // Expect edge: <voidAsUndefined> -[RETURNS]-> <{ isUndef, sideEffectRan, result }>
    void code;
  });

  test('iterators::iter-usage-spread', () => {
    const code = "function spreadRange(start, end) {\n  return [...new Range(start, end)];\n}";
    // Expect node: FUNCTION <spreadRange>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: EXPRESSION <...new Range(start, end)>
    // Expect node: CALL <new Range(start, end)>
    // Expect node: LITERAL <[]>
    // Expect edge: <spreadRange> -[CONTAINS]-> <start>
    // Expect edge: <spreadRange> -[CONTAINS]-> <end>
    // Expect edge: <spreadRange> -[RETURNS]-> <...new Range(start, end)>
    // Expect edge: <...new Range(start, end)> -[SPREADS_FROM]-> <new Range(start, end)>
    // Expect edge: <...new Range(start, end)> -[HAS_ELEMENT]-> <[]>
    // Expect edge: <new Range(start, end)> -[PASSES_ARGUMENT]-> <start>
    // Expect edge: <new Range(start, end)> -[PASSES_ARGUMENT]-> <end>
    void code;
  });

  test('iterators::iter-usage-for-of', () => {
    const code = "function consumeRange(start, end) {\n  const range = new Range(start, end);\n  const values = [];\n  for (const n of range) {\n    values.push(n);\n  }\n  return values;\n}";
    // Expect node: FUNCTION <consumeRange>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: VARIABLE <range>
    // Expect node: CALL <new Range(start, end)>
    // Expect node: VARIABLE <values>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <n>
    // Expect node: CALL <values.push(n)>
    // Expect edge: <consumeRange> -[CONTAINS]-> <start>
    // Expect edge: <consumeRange> -[CONTAINS]-> <end>
    // Expect edge: <consumeRange> -[CONTAINS]-> <range>
    // Expect edge: <new Range(start, end)> -[PASSES_ARGUMENT]-> <start>
    // Expect edge: <new Range(start, end)> -[PASSES_ARGUMENT]-> <end>
    // Expect edge: <consumeRange> -[CONTAINS]-> <values>
    // Expect edge: <consumeRange> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <range>
    // Expect edge: <for-of> -[CONTAINS]-> <n>
    // Expect edge: <for-of> -[CONTAINS]-> <values.push(n)>
    // Expect edge: <values.push(n)> -[PASSES_ARGUMENT]-> <n>
    // Expect edge: <consumeRange> -[RETURNS]-> <values>
    void code;
  });

  test('iterators::iter-usage-destructuring', () => {
    const code = "function destructureRange(start, end) {\n  const [first, second, ...rest] = new Range(start, end);\n  return { first, second, rest };\n}\n\n// --- Iterator protocol manual ---";
    // Expect node: FUNCTION <destructureRange>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: VARIABLE <first>
    // Expect node: VARIABLE <second>
    // Expect node: VARIABLE <rest>
    // Expect node: CALL <new Range(start, end)>
    // Expect node: EXPRESSION <{ first, second, rest }>
    // Expect edge: <destructureRange> -[CONTAINS]-> <start>
    // Expect edge: <destructureRange> -[CONTAINS]-> <end>
    // Expect edge: <destructureRange> -[CONTAINS]-> <first>
    // Expect edge: <destructureRange> -[CONTAINS]-> <second>
    // Expect edge: <destructureRange> -[CONTAINS]-> <rest>
    // Expect edge: <new Range(start, end)> -[PASSES_ARGUMENT]-> <start>
    // Expect edge: <new Range(start, end)> -[PASSES_ARGUMENT]-> <end>
    // Expect edge: <destructureRange> -[RETURNS]-> <{ first, second, rest }>
    void code;
  });

  test('builtins::builtin-finalization-registry', () => {
    const code = "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---";
    // Expect node: FUNCTION <finalizationUsage>
    // Expect node: VARIABLE <registry>
    // Expect node: CALL <new FinalizationRegistry(...)>
    // Expect node: FUNCTION <cleanup-callback>
    // Expect node: PARAMETER <heldValue>
    // Expect node: CALL <console.log(...)>
    // Expect node: EXPRESSION <`Cleaned up: ${heldValue}`>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ id: 1 }>
    // Expect node: CALL <registry.register(obj, 'resource-1')>
    // Expect node: LITERAL <'resource-1'>
    // Expect edge: <finalizationUsage> -[CONTAINS]-> <registry>
    // Expect edge: <finalizationUsage> -[CONTAINS]-> <obj>
    // Expect edge: <new FinalizationRegistry(...)> -[PASSES_ARGUMENT]-> <cleanup-callback>
    // Expect edge: <cleanup-callback> -[CONTAINS]-> <heldValue>
    // Expect edge: <cleanup-callback> -[CONTAINS]-> <console.log(...)>
    // Expect edge: <console.log(...)> -[PASSES_ARGUMENT]-> <`Cleaned up: ${heldValue}`>
    // Expect edge: <finalizationUsage> -[CONTAINS]-> <registry.register(obj, 'resource-1')>
    // Expect edge: <registry.register(obj, 'resource-1')> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <registry.register(obj, 'resource-1')> -[PASSES_ARGUMENT]-> <'resource-1'>
    // Expect edge: <finalizationUsage> -[RETURNS]-> <obj>
    void code;
  });

  test('index::module-namespace-as-value', () => {
    const code = "function useNamespaceAsValue(ns) {\n  const fn = ns[arguments[1]]; // dynamic dispatch through namespace\n  return typeof fn === 'function' ? fn() : undefined;\n}\nconst helperResult = useNamespaceAsValue(allHelpers, 'helperFunction');";
    // Expect node: FUNCTION <useNamespaceAsValue>
    // Expect node: PARAMETER <ns>
    // Expect node: VARIABLE <fn>
    // Expect node: PROPERTY_ACCESS <ns[arguments[1]]>
    // Expect node: EXPRESSION <typeof fn === 'function'>
    // Expect node: EXPRESSION <typeof fn>
    // Expect node: LITERAL <'function'>
    // Expect node: CALL <fn()>
    // Expect node: LITERAL <undefined>
    // Expect node: VARIABLE <helperResult>
    // Expect node: CALL <useNamespaceAsValue(allHelpers, 'helperFunction')>
    // Expect node: LITERAL <'helperFunction'>
    // Expect edge: <useNamespaceAsValue> -[CONTAINS]-> <ns>
    // Expect edge: <useNamespaceAsValue> -[HAS_CONDITION]-> <typeof fn === 'function'>
    // Expect edge: <useNamespaceAsValue> -[HAS_CONSEQUENT]-> <fn()>
    // Expect edge: <useNamespaceAsValue(allHelpers, 'helperFunction')> -[PASSES_ARGUMENT]-> <'helperFunction'>
    void code;
  });

  test('iterators::iter-generator-iterable', () => {
    const code = "function* rangeGenerator(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\n// --- Custom async iterable ---";
    // Expect node: FUNCTION <rangeGenerator>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: EXPRESSION <i <= end>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <yield i>
    // Expect edge: <rangeGenerator> -[CONTAINS]-> <start>
    // Expect edge: <rangeGenerator> -[CONTAINS]-> <end>
    // Expect edge: <rangeGenerator> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[HAS_INIT]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i <= end>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <yield i>
    // Expect edge: <yield i> -[YIELDS]-> <i>
    void code;
  });

  test('iterators::iter-infinite', () => {
    const code = "function naturals() {\n  let n = 1;\n  return {\n    [Symbol.iterator]() { return this; },\n    next() {\n      return { value: n++, done: false };\n    },\n  };\n}";
    // Expect node: FUNCTION <naturals>
    // Expect node: VARIABLE <n>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <object-literal>
    // Expect node: METHOD <[Symbol.iterator]>
    // Expect node: METHOD <next>
    // Expect node: EXPRESSION <return-object>
    // Expect node: EXPRESSION <n++>
    // Expect node: LITERAL <false>
    // Expect edge: <naturals> -[CONTAINS]-> <n>
    // Expect edge: <naturals> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <[Symbol.iterator]>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <next>
    // Expect edge: <[Symbol.iterator]> -[RETURNS]-> <object-literal>
    // Expect edge: <next> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <n++>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <false>
    void code;
  });

  test('iterators::iter-async-generator', () => {
    const code = "async function* asyncMap(iterable, fn) {\n  for await (const item of iterable) {\n    yield fn(item);\n  }\n}\n\n// --- Composable iterators ---";
    // Expect node: FUNCTION <asyncMap>
    // Expect node: PARAMETER <iterable>
    // Expect node: PARAMETER <fn>
    // Expect node: LOOP <for-await-of>
    // Expect node: VARIABLE <item>
    // Expect node: CALL <fn(item)>
    // Expect node: EXPRESSION <yield fn(item)>
    // Expect edge: <asyncMap> -[HAS_BODY]-> <iterable>
    // Expect edge: <asyncMap> -[HAS_BODY]-> <fn>
    // Expect edge: <asyncMap> -[HAS_BODY]-> <for-await-of>
    // Expect edge: <for-await-of> -[ITERATES_OVER]-> <iterable>
    // Expect edge: <for-await-of> -[CONTAINS]-> <item>
    // Expect edge: <for-await-of> -[HAS_BODY]-> <yield fn(item)>
    // Expect edge: <fn(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <yield fn(item)> -[YIELDS]-> <fn(item)>
    // Expect edge: <asyncMap> -[YIELDS]-> <yield fn(item)>
    void code;
  });

  test('iterators::iter-compose-chain', () => {
    const code = "function* chainIter(...iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}";
    // Expect node: FUNCTION <chainIter>
    // Expect node: PARAMETER <...iterables>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <iterable>
    // Expect node: EXPRESSION <yield* iterable>
    // Expect edge: <chainIter> -[CONTAINS]-> <...iterables>
    // Expect edge: <chainIter> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <...iterables>
    // Expect edge: <for-of> -[CONTAINS]-> <iterable>
    // Expect edge: <for-of> -[HAS_BODY]-> <yield* iterable>
    // Expect edge: <yield* iterable> -[DELEGATES_TO]-> <iterable>
    void code;
  });

  test('iterators::iter-take', () => {
    const code = "function take(iterable, count) {\n  const result = [];\n  let i = 0;\n  for (const value of iterable) {\n    if (i++ >= count) break;\n    result.push(value);\n  }\n  return result;\n}\n\n// --- Generator as iterable ---";
    // Expect node: FUNCTION <take>
    // Expect node: PARAMETER <iterable>
    // Expect node: PARAMETER <count>
    // Expect node: VARIABLE <result>
    // Expect node: LITERAL <[]>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <value>
    // Expect node: BRANCH <if-break>
    // Expect node: EXPRESSION <i++ >= count>
    // Expect node: EXPRESSION <i++>
    // Expect node: CALL <result.push(value)>
    // Expect node: PROPERTY_ACCESS <result.push>
    // Expect edge: <take> -[CONTAINS]-> <iterable>
    // Expect edge: <take> -[CONTAINS]-> <count>
    // Expect edge: <take> -[CONTAINS]-> <result>
    // Expect edge: <take> -[CONTAINS]-> <i>
    // Expect edge: <take> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <iterable>
    // Expect edge: <for-of> -[CONTAINS]-> <value>
    // Expect edge: <for-of> -[CONTAINS]-> <if-break>
    // Expect edge: <if-break> -[HAS_CONDITION]-> <i++ >= count>
    // Expect edge: <for-of> -[CONTAINS]-> <result.push(value)>
    // Expect edge: <result.push(value)> -[PASSES_ARGUMENT]-> <value>
    // Expect edge: <take> -[RETURNS]-> <result>
    void code;
  });

  test('iterators::iter-compose-map', () => {
    const code = "function* mapIter(iterable, fn) {\n  for (const item of iterable) {\n    yield fn(item);\n  }\n}";
    // Expect node: FUNCTION <mapIter>
    // Expect node: PARAMETER <iterable>
    // Expect node: PARAMETER <fn>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <item>
    // Expect node: CALL <fn(item)>
    // Expect node: EXPRESSION <yield fn(item)>
    // Expect edge: <mapIter> -[HAS_BODY]-> <iterable>
    // Expect edge: <mapIter> -[HAS_BODY]-> <fn>
    // Expect edge: <mapIter> -[HAS_BODY]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <iterable>
    // Expect edge: <for-of> -[HAS_BODY]-> <item>
    // Expect edge: <for-of> -[HAS_BODY]-> <yield fn(item)>
    // Expect edge: <fn(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <yield fn(item)> -[YIELDS]-> <fn(item)>
    // Expect edge: <mapIter> -[YIELDS]-> <yield fn(item)>
    void code;
  });

  test('iterators::iter-manual-next', () => {
    const code = "function manualIteration(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  const results = [];\n  let step = iterator.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = iterator.next();\n  }\n  return results;\n}\n\n// --- Iterator with return() ---";
    // Expect node: FUNCTION <manualIteration>
    // Expect node: PARAMETER <iterable>
    // Expect node: VARIABLE <iterator>
    // Expect node: PROPERTY_ACCESS <iterable[Symbol.iterator]>
    // Expect node: CALL <iterable[Symbol.iterator]()>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: VARIABLE <step>
    // Expect node: CALL <iterator.next()>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <!step.done>
    // Expect node: PROPERTY_ACCESS <step.done>
    // Expect node: CALL <results.push(step.value)>
    // Expect node: PROPERTY_ACCESS <step.value>
    // Expect node: EXPRESSION <step = iterator.next()>
    // Expect node: CALL <iterator.next()#2>
    // Expect edge: <manualIteration> -[CONTAINS]-> <iterable>
    // Expect edge: <manualIteration> -[CONTAINS]-> <iterator>
    // Expect edge: <manualIteration> -[CONTAINS]-> <results>
    // Expect edge: <manualIteration> -[CONTAINS]-> <step>
    // Expect edge: <manualIteration> -[CONTAINS]-> <while>
    // Expect edge: <while> -[HAS_CONDITION]-> <!step.done>
    // Expect edge: <while> -[CONTAINS]-> <results.push(step.value)>
    // Expect edge: <results.push(step.value)> -[PASSES_ARGUMENT]-> <step.value>
    // Expect edge: <while> -[CONTAINS]-> <step = iterator.next()>
    // Expect edge: <manualIteration> -[RETURNS]-> <results>
    void code;
  });

  test('iterators::iter-compose-filter', () => {
    const code = "function* filterIter(iterable, predicate) {\n  for (const item of iterable) {\n    if (predicate(item)) yield item;\n  }\n}";
    // Expect node: FUNCTION <filterIter>
    // Expect node: PARAMETER <iterable>
    // Expect node: PARAMETER <predicate>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <item>
    // Expect node: BRANCH <if-predicate>
    // Expect node: CALL <predicate(item)>
    // Expect node: EXPRESSION <yield item>
    // Expect edge: <filterIter> -[CONTAINS]-> <iterable>
    // Expect edge: <filterIter> -[CONTAINS]-> <predicate>
    // Expect edge: <filterIter> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <iterable>
    // Expect edge: <for-of> -[CONTAINS]-> <item>
    // Expect edge: <for-of> -[CONTAINS]-> <if-predicate>
    // Expect edge: <if-predicate> -[HAS_CONDITION]-> <predicate(item)>
    // Expect edge: <predicate(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <if-predicate> -[HAS_CONSEQUENT]-> <yield item>
    // Expect edge: <yield item> -[YIELDS]-> <item>
    void code;
  });

  test('iterators::iter-async-for-await', () => {
    const code = "async function consumeAsyncRange(start, end) {\n  const values = [];\n  for await (const n of new AsyncRange(start, end, 0)) {\n    values.push(n);\n  }\n  return values;\n}\n\n// --- Async generator as async iterable ---";
    // Expect node: FUNCTION <consumeAsyncRange>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: VARIABLE <values>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-await>
    // Expect node: VARIABLE <n>
    // Expect node: CALL <new AsyncRange(start, end, 0)>
    // Expect node: LITERAL <0>
    // Expect node: CALL <values.push(n)>
    // Expect node: PROPERTY_ACCESS <values.push>
    // Expect edge: <consumeAsyncRange> -[CONTAINS]-> <start>
    // Expect edge: <consumeAsyncRange> -[CONTAINS]-> <end>
    // Expect edge: <consumeAsyncRange> -[CONTAINS]-> <values>
    // Expect edge: <consumeAsyncRange> -[CONTAINS]-> <for-await>
    // Expect edge: <for-await> -[ITERATES_OVER]-> <new AsyncRange(start, end, 0)>
    // Expect edge: <for-await> -[CONTAINS]-> <n>
    // Expect edge: <new AsyncRange(start, end, 0)> -[PASSES_ARGUMENT]-> <start>
    // Expect edge: <new AsyncRange(start, end, 0)> -[PASSES_ARGUMENT]-> <end>
    // Expect edge: <new AsyncRange(start, end, 0)> -[PASSES_ARGUMENT]-> <0>
    // Expect edge: <for-await> -[HAS_BODY]-> <values.push(n)>
    // Expect edge: <values.push(n)> -[PASSES_ARGUMENT]-> <n>
    // Expect edge: <consumeAsyncRange> -[RETURNS]-> <values>
    void code;
  });

  test('jsdoc-types::jsdoc-type-variable', () => {
    const code = "/** @type {Map<string, Function>} */\nconst handlers = new Map();\n\n/** @type {string | null} */\nlet currentUser = null;\n\n/** @type {readonly number[]} */\nconst PRIMES = [2, 3, 5, 7, 11];";
    // Expect node: TYPE_REFERENCE <Map<string, Function>>
    // Expect node: VARIABLE <handlers>
    // Expect node: CALL <new Map()>
    // Expect node: TYPE_REFERENCE <string | null>
    // Expect node: VARIABLE <currentUser>
    // Expect node: LITERAL <null>
    // Expect node: TYPE_REFERENCE <readonly number[]>
    // Expect node: VARIABLE <PRIMES>
    // Expect node: LITERAL <[2, 3, 5, 7, 11]>

    void code;
  });

  test('jsdoc-types::jsdoc-param-returns', () => {
    const code = "/**\n * @param {string} name\n * @param {number} age\n * @returns {{ name: string, age: number }}\n */\nfunction createUser(name, age) {\n  return { name, age };\n}";
    // Expect node: FUNCTION <createUser>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <age>
    // Expect node: EXTERNAL <@param-name>
    // Expect node: EXTERNAL <@param-age>
    // Expect node: EXTERNAL <@returns>
    // Expect node: EXPRESSION <{ name, age }>
    // Expect edge: <module> -[DECLARES]-> <createUser>
    // Expect edge: <createUser> -[CONTAINS]-> <name>
    // Expect edge: <createUser> -[CONTAINS]-> <age>
    // Expect edge: <createUser> -[RETURNS]-> <{ name, age }>
    void code;
  });

  test('jsdoc-types::jsdoc-enum', () => {
    const code = "/** @enum {string} */\nconst Priority = {\n  Low: 'low',\n  Medium: 'medium',\n  High: 'high',\n};";
    // Expect node: VARIABLE <Priority>
    // Expect node: LITERAL <Priority-object>
    // Expect node: LITERAL <'low'>
    // Expect node: LITERAL <'medium'>
    // Expect node: LITERAL <'high'>
    // Expect edge: <Priority-object> -[HAS_PROPERTY]-> <'low'>
    // Expect edge: <Priority-object> -[HAS_PROPERTY]-> <'medium'>
    // Expect edge: <Priority-object> -[HAS_PROPERTY]-> <'high'>
    void code;
  });

  test('jsdoc-types::jsdoc-typedef', () => {
    const code = "/**\n * @typedef {Object} UserDef\n * @property {number} id\n * @property {string} name\n * @property {string} [email]\n */\n\n/** @type {UserDef} */\nconst admin = { id: 1, name: 'admin' };";
    // Expect node: TYPE_ALIAS <UserDef>
    // Expect node: PROPERTY <UserDef.id>
    // Expect node: PROPERTY <UserDef.name>
    // Expect node: PROPERTY <UserDef.email>
    // Expect node: VARIABLE <admin>
    // Expect node: LITERAL <{ id: 1, name: 'admin' }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <'admin'>
    // Expect edge: <module> -[DECLARES]-> <UserDef>
    // Expect edge: <UserDef> -[HAS_PROPERTY]-> <UserDef.id>
    // Expect edge: <UserDef> -[HAS_PROPERTY]-> <UserDef.name>
    // Expect edge: <UserDef> -[HAS_PROPERTY]-> <UserDef.email>
    // Expect edge: <module> -[DECLARES]-> <admin>
    // Expect edge: <{ id: 1, name: 'admin' }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ id: 1, name: 'admin' }> -[HAS_PROPERTY]-> <'admin'>
    void code;
  });

  test('iterators::export-named-list', () => {
    const code = "export {\n  Range,\n  consumeRange,\n  spreadRange,\n  destructureRange,\n  manualIteration,\n  createCleanupIterator,\n  naturals,\n  take,\n  rangeGenerator,\n  AsyncRange,\n  consumeAsyncRange,\n  asyncMap,\n  mapIter,\n  filterIter,\n  chainIter,\n  zipIter,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <Range>
    // Expect node: VARIABLE <consumeRange>
    // Expect node: VARIABLE <spreadRange>
    // Expect node: VARIABLE <destructureRange>
    // Expect node: VARIABLE <manualIteration>
    // Expect node: VARIABLE <createCleanupIterator>
    // Expect node: VARIABLE <naturals>
    // Expect node: VARIABLE <take>
    // Expect node: VARIABLE <rangeGenerator>
    // Expect node: VARIABLE <AsyncRange>
    // Expect node: VARIABLE <consumeAsyncRange>
    // Expect node: VARIABLE <asyncMap>
    // Expect node: VARIABLE <mapIter>
    // Expect node: VARIABLE <filterIter>
    // Expect node: VARIABLE <chainIter>
    // Expect node: VARIABLE <zipIter>

    void code;
  });

  test('jsdoc-types::jsdoc-template-constraint', () => {
    const code = "/**\n * @template {object} T\n * @param {T} target\n * @param {Partial<T>} overrides\n * @returns {T}\n */\nfunction applyDefaults(target, overrides) {\n  return { ...target, ...overrides };\n}";
    // Expect node: FUNCTION <applyDefaults>
    // Expect node: PARAMETER <target>
    // Expect node: PARAMETER <overrides>
    // Expect node: EXPRESSION <{ ...target, ...overrides }>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_REFERENCE <target:T>
    // Expect node: TYPE_REFERENCE <overrides:Partial<T>>
    // Expect node: TYPE_REFERENCE <returns:T>
    // Expect node: LITERAL_TYPE <object>
    // Expect edge: <applyDefaults> -[CONTAINS]-> <target>
    // Expect edge: <applyDefaults> -[CONTAINS]-> <overrides>
    // Expect edge: <applyDefaults> -[RETURNS]-> <{ ...target, ...overrides }>
    // Expect edge: <applyDefaults> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <T> -[CONSTRAINED_BY]-> <object>
    // Expect edge: <applyDefaults> -[RETURNS_TYPE]-> <returns:T>
    // Expect edge: <target:T> -[USES]-> <T>
    // Expect edge: <overrides:Partial<T>> -[USES]-> <T>
    // Expect edge: <returns:T> -[USES]-> <T>
    void code;
  });

  test('jsdoc-types::jsdoc-import-type', () => {
    const code = "/** @type {import('./modules-helpers.js').HelperClass} */\nlet helperRef;";
    // Expect node: VARIABLE <helperRef>
    // Expect node: TYPE_REFERENCE <@type-helperRef>
    // Expect node: TYPE_REFERENCE <import('./modules-helpers.js').HelperClass>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>
    // Expect edge: <module> -[DECLARES]-> <helperRef>
    void code;
  });

  test('jsdoc-types::jsdoc-deprecated', () => {
    const code = "/**\n * @deprecated Use newProcess() instead\n * @param {string} input\n * @returns {string}\n */\nfunction oldProcess(input) {\n  return input;\n}";
    // Expect node: FUNCTION <oldProcess>
    // Expect node: PARAMETER <input>
    // Expect node: EXTERNAL <oldProcess:jsdoc>
    // Expect edge: <module> -[DECLARES]-> <oldProcess>
    // Expect edge: <oldProcess> -[CONTAINS]-> <input>
    // Expect edge: <oldProcess> -[RETURNS]-> <input>
    void code;
  });

  test('jsdoc-types::jsdoc-template', () => {
    const code = "/**\n * @template T\n * @param {T[]} items\n * @returns {T | undefined}\n */\nfunction first(items) {\n  return items[0];\n}\n\n/**\n * @template K, V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} fallback\n * @returns {V}\n */\nfunction getOrDefault(map, key, fallback) {\n  return map.has(key) ? map.get(key) : fallback;\n}";
    // Expect node: FUNCTION <first>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: PARAMETER <items>
    // Expect node: PROPERTY_ACCESS <items[0]>
    // Expect node: FUNCTION <getOrDefault>
    // Expect node: TYPE_PARAMETER <K>
    // Expect node: TYPE_PARAMETER <V>
    // Expect node: PARAMETER <map>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <fallback>
    // Expect node: EXPRESSION <map.has(key) ? map.get(key) : fallback>
    // Expect node: CALL <map.has(key)>
    // Expect node: CALL <map.get(key)>
    // Expect edge: <first> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <first> -[CONTAINS]-> <items>
    // Expect edge: <first> -[RETURNS]-> <items[0]>
    // Expect edge: <getOrDefault> -[HAS_TYPE_PARAMETER]-> <K>
    // Expect edge: <getOrDefault> -[HAS_TYPE_PARAMETER]-> <V>
    // Expect edge: <getOrDefault> -[CONTAINS]-> <map>
    // Expect edge: <getOrDefault> -[CONTAINS]-> <key>
    // Expect edge: <getOrDefault> -[CONTAINS]-> <fallback>
    // Expect edge: <getOrDefault> -[RETURNS]-> <map.has(key) ? map.get(key) : fallback>
    // Expect edge: <map.has(key) ? map.get(key) : fallback> -[HAS_CONDITION]-> <map.has(key)>
    // Expect edge: <map.has(key) ? map.get(key) : fallback> -[HAS_CONSEQUENT]-> <map.get(key)>
    // Expect edge: <map.has(key)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <map.get(key)> -[PASSES_ARGUMENT]-> <key>
    void code;
  });

  test('jsdoc-types::jsdoc-this', () => {
    const code = "/**\n * @this {{ name: string }}\n * @param {string} greeting\n * @returns {string}\n */\nfunction greetThis(greeting) {\n  return `${greeting}, ${this.name}`;\n}";
    // Expect node: FUNCTION <greetThis>
    // Expect node: PARAMETER <greeting>
    // Expect node: TYPE_REFERENCE <@this>
    // Expect node: TYPE_REFERENCE <@param-greeting>
    // Expect node: TYPE_REFERENCE <@returns>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect edge: <greetThis> -[CONTAINS]-> <greeting>
    // Expect edge: <greetThis> -[RETURNS_TYPE]-> <@returns>
    // Expect edge: <greetThis> -[RETURNS]-> <template-literal>
    void code;
  });

  test('legacy-patterns::amd-require-call', () => {
    const code = "// require(['app/main', 'app/config'], function(main, config) {\n//   main.start(config);\n// });\n\n// --- UMD (Universal Module Definition) ---";
    // Expect node: CALL <require-call>
    // Expect node: LITERAL <'app/main'>
    // Expect node: LITERAL <'app/config'>
    // Expect node: FUNCTION <amd-callback>
    // Expect node: PARAMETER <main>
    // Expect node: PARAMETER <config>
    // Expect node: CALL <main.start(config)>
    // Expect node: PROPERTY_ACCESS <main.start>
    // Expect edge: <require-call> -[PASSES_ARGUMENT]-> <'app/main'>
    // Expect edge: <require-call> -[PASSES_ARGUMENT]-> <'app/config'>
    // Expect edge: <require-call> -[PASSES_ARGUMENT]-> <amd-callback>
    // Expect edge: <amd-callback> -[CONTAINS]-> <main>
    // Expect edge: <amd-callback> -[CONTAINS]-> <config>
    // Expect edge: <amd-callback> -[CONTAINS]-> <main.start(config)>
    // Expect edge: <main.start(config)> -[PASSES_ARGUMENT]-> <config>
    void code;
  });

  test('jsdoc-types::export-named-list', () => {
    const code = "export {\n  createUser,\n  handlers,\n  currentUser,\n  PRIMES,\n  admin,\n  first,\n  getOrDefault,\n  applyDefaults,\n  NumberRange,\n  Priority,\n  isPositive,\n  convert,\n  greetThis,\n  oldProcess,\n  DataStore,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <createUser>
    // Expect node: VARIABLE <handlers>
    // Expect node: VARIABLE <currentUser>
    // Expect node: VARIABLE <PRIMES>
    // Expect node: VARIABLE <admin>
    // Expect node: VARIABLE <first>
    // Expect node: VARIABLE <getOrDefault>
    // Expect node: VARIABLE <applyDefaults>
    // Expect node: VARIABLE <NumberRange>
    // Expect node: VARIABLE <Priority>
    // Expect node: VARIABLE <isPositive>
    // Expect node: VARIABLE <convert>
    // Expect node: VARIABLE <greetThis>
    // Expect node: VARIABLE <oldProcess>
    // Expect node: VARIABLE <DataStore>

    void code;
  });

  test('jsdoc-types::jsdoc-callback', () => {
    const code = "/**\n * @callback Predicate\n * @param {unknown} value\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst isPositive = (value) => typeof value === 'number' && value > 0;";
    // Expect node: TYPE_ALIAS <Predicate>
    // Expect node: PARAMETER <value>
    // Expect node: TYPE_REFERENCE <Predicate:return>
    // Expect node: VARIABLE <isPositive>
    // Expect node: FUNCTION <isPositive:fn>
    // Expect node: PARAMETER <isPositive:value>
    // Expect node: EXPRESSION <typeof value === 'number' && value > 0>
    // Expect node: EXPRESSION <typeof value === 'number'>
    // Expect node: EXPRESSION <typeof value>
    // Expect node: LITERAL <'number'>
    // Expect node: EXPRESSION <value > 0>
    // Expect node: LITERAL <0>
    // Expect edge: <Predicate> -[CONTAINS]-> <value>
    // Expect edge: <Predicate> -[RETURNS_TYPE]-> <Predicate:return>
    // Expect edge: <isPositive:fn> -[CONTAINS]-> <isPositive:value>
    // Expect edge: <isPositive:fn> -[RETURNS]-> <typeof value === 'number' && value > 0>
    void code;
  });

  test('legacy-patterns::amd-define-named', () => {
    const code = "// define('myModule', ['dep1', 'dep2'], function(dep1, dep2) {\n//   return { init: function() {} };\n// });";
    // Expect node: CALL <define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>
    // Expect node: LITERAL <'myModule'>
    // Expect node: LITERAL <['dep1', 'dep2']>
    // Expect node: LITERAL <'dep1'>
    // Expect node: LITERAL <'dep2'>
    // Expect node: FUNCTION <factory-function>
    // Expect node: PARAMETER <dep1>
    // Expect node: PARAMETER <dep2>
    // Expect node: LITERAL <{ init: function() {} }>
    // Expect node: FUNCTION <init>
    // Expect edge: <define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })> -[PASSES_ARGUMENT]-> <'myModule'>
    // Expect edge: <define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })> -[PASSES_ARGUMENT]-> <['dep1', 'dep2']>
    // Expect edge: <define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })> -[PASSES_ARGUMENT]-> <factory-function>
    // Expect edge: <['dep1', 'dep2']> -[HAS_ELEMENT]-> <'dep1'>
    // Expect edge: <['dep1', 'dep2']> -[HAS_ELEMENT]-> <'dep2'>
    // Expect edge: <factory-function> -[CONTAINS]-> <dep1>
    // Expect edge: <factory-function> -[CONTAINS]-> <dep2>
    // Expect edge: <factory-function> -[RETURNS]-> <{ init: function() {} }>
    // Expect edge: <{ init: function() {} }> -[HAS_PROPERTY]-> <init>
    void code;
  });

  test('jsdoc-types::jsdoc-overload', () => {
    const code = "/**\n * @overload\n * @param {string} value\n * @returns {number}\n */\n/**\n * @overload\n * @param {number} value\n * @returns {string}\n */\n/**\n * @param {string | number} value\n * @returns {number | string}\n */\nfunction convert(value) {\n  return typeof value === 'string' ? Number(value) : String(value);\n}";
    // Expect node: FUNCTION <convert>
    // Expect node: PARAMETER <value>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <number>
    // Expect node: TYPE_REFERENCE <string | number>
    // Expect node: TYPE_REFERENCE <number | string>
    // Expect node: EXPRESSION <typeof value === 'string'>
    // Expect node: CALL <Number(value)>
    // Expect node: CALL <String(value)>
    // Expect node: EXPRESSION <ternary>
    // Expect node: EXTERNAL <Number>
    // Expect node: EXTERNAL <String>
    // Expect edge: <convert> -[CONTAINS]-> <value>
    // Expect edge: <convert> -[RETURNS_TYPE]-> <number | string>
    // Expect edge: <convert> -[RETURNS]-> <ternary>
    // Expect edge: <ternary> -[HAS_CONDITION]-> <typeof value === 'string'>
    // Expect edge: <ternary> -[HAS_CONSEQUENT]-> <Number(value)>
    // Expect edge: <Number(value)> -[PASSES_ARGUMENT]-> <value>
    // Expect edge: <String(value)> -[PASSES_ARGUMENT]-> <value>
    void code;
  });

  test('jsdoc-types::jsdoc-implements', () => {
    const code = "/** @implements {Iterable<number>} */\nclass NumberRange {\n  /** @param {number} start @param {number} end */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  [Symbol.iterator]() {\n    let i = this.start;\n    const end = this.end;\n    return { next() { return i <= end ? { value: i++, done: false } : { done: true }; } };\n  }\n}";
    // Expect node: CLASS <NumberRange>
    // Expect node: INTERFACE <Iterable<number>>
    // Expect node: METHOD <NumberRange.constructor>
    // Expect node: PARAMETER <start>
    // Expect node: PARAMETER <end>
    // Expect node: PROPERTY_ACCESS <this.start>
    // Expect node: PROPERTY_ACCESS <this.end>
    // Expect node: METHOD <NumberRange[Symbol.iterator]>
    // Expect node: VARIABLE <i>
    // Expect node: VARIABLE <end:local>
    // Expect node: LITERAL <return-object>
    // Expect node: METHOD <next>
    // Expect node: EXPRESSION <i <= end>
    // Expect node: LITERAL <iterator-result-value>
    // Expect node: LITERAL <iterator-result-done>
    // Expect node: EXPRESSION <i++>
    // Expect edge: <NumberRange> -[CONTAINS]-> <NumberRange.constructor>
    // Expect edge: <NumberRange> -[CONTAINS]-> <NumberRange[Symbol.iterator]>
    // Expect edge: <NumberRange.constructor> -[CONTAINS]-> <start>
    // Expect edge: <NumberRange.constructor> -[CONTAINS]-> <end>
    // Expect edge: <NumberRange[Symbol.iterator]> -[DECLARES]-> <i>
    // Expect edge: <NumberRange[Symbol.iterator]> -[DECLARES]-> <end:local>
    // Expect edge: <NumberRange[Symbol.iterator]> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <next>
    // Expect edge: <next> -[CONTAINS]-> <i <= end>
    // Expect edge: <next> -[RETURNS]-> <iterator-result-value>
    // Expect edge: <next> -[RETURNS]-> <iterator-result-done>
    // Expect edge: <iterator-result-value> -[HAS_PROPERTY]-> <i++>
    void code;
  });

  test('jsdoc-types::jsdoc-class-fields', () => {
    const code = "class DataStore {\n  /** @type {Map<string, unknown>} */\n  store = new Map();\n\n  /** @private */\n  _cache = {};\n\n  /**\n   * @param {string} key\n   * @param {unknown} value\n   */\n  set(key, value) {\n    this.store.set(key, value);\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this.store.size;\n  }\n}";
    // Expect node: CLASS <DataStore>
    // Expect node: PROPERTY <DataStore.store>
    // Expect node: CALL <new Map()>
    // Expect node: PROPERTY <DataStore._cache>
    // Expect node: LITERAL <{}>
    // Expect node: METHOD <DataStore.set>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: CALL <this.store.set(key, value)>
    // Expect node: PROPERTY_ACCESS <this.store>
    // Expect node: GETTER <DataStore.size>
    // Expect node: PROPERTY_ACCESS <this.store.size>
    // Expect edge: <DataStore> -[HAS_PROPERTY]-> <DataStore.store>
    // Expect edge: <DataStore> -[HAS_PROPERTY]-> <DataStore._cache>
    // Expect edge: <DataStore> -[CONTAINS]-> <DataStore.set>
    // Expect edge: <DataStore> -[CONTAINS]-> <DataStore.size>
    // Expect edge: <DataStore.set> -[CONTAINS]-> <key>
    // Expect edge: <DataStore.set> -[CONTAINS]-> <value>
    // Expect edge: <DataStore.set> -[HAS_BODY]-> <this.store.set(key, value)>
    // Expect edge: <this.store.set(key, value)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <this.store.set(key, value)> -[PASSES_ARGUMENT]-> <value>
    // Expect edge: <DataStore.size> -[RETURNS]-> <this.store.size>
    void code;
  });

  test('legacy-patterns::global-namespace-init', () => {
    const code = "var MyApp = MyApp || {};\nMyApp.utils = MyApp.utils || {};\nMyApp.utils.format = function (str) { return str.trim(); };";
    // Expect node: VARIABLE <MyApp>
    // Expect node: EXPRESSION <MyApp || {}>
    // Expect node: LITERAL <{}>
    // Expect node: PROPERTY_ACCESS <MyApp.utils>
    // Expect node: EXPRESSION <MyApp.utils || {}>
    // Expect node: LITERAL <{} (utils)>
    // Expect node: PROPERTY_ACCESS <MyApp.utils.format>
    // Expect node: FUNCTION <format>
    // Expect node: PARAMETER <str>
    // Expect node: CALL <str.trim()>
    // Expect edge: <module> -[DECLARES]-> <MyApp>
    // Expect edge: <format> -[CONTAINS]-> <str>
    // Expect edge: <format> -[RETURNS]-> <str.trim()>
    void code;
  });

  test('legacy-patterns::amd-define-deps', () => {
    const code = "// define(['jquery', 'underscore'], function($, _) {\n//   return {\n//     render: function(data) {\n//       return _.template($('#tpl').html())(data);\n//     }\n//   };\n// });";
    // Expect node: CALL <define-call>
    // Expect node: LITERAL <'jquery'>
    // Expect node: LITERAL <'underscore'>
    // Expect node: FUNCTION <factory-function>
    // Expect node: PARAMETER <$>
    // Expect node: PARAMETER <_>
    // Expect node: LITERAL <module-object>
    // Expect node: METHOD <render>
    // Expect node: PARAMETER <data>
    // Expect node: CALL <_.template-call>
    // Expect node: CALL <$('#tpl').html()>
    // Expect node: LITERAL <'#tpl'>
    // Expect node: CALL <template-invocation>
    // Expect node: MODULE <module>
    // Expect edge: <module> -[CONTAINS]-> <define-call>
    // Expect edge: <define-call> -[PASSES_ARGUMENT]-> <'jquery'>
    // Expect edge: <define-call> -[PASSES_ARGUMENT]-> <'underscore'>
    // Expect edge: <define-call> -[PASSES_ARGUMENT]-> <factory-function>
    // Expect edge: <factory-function> -[CONTAINS]-> <$>
    // Expect edge: <factory-function> -[CONTAINS]-> <_>
    // Expect edge: <factory-function> -[RETURNS]-> <module-object>
    // Expect edge: <module-object> -[HAS_PROPERTY]-> <render>
    // Expect edge: <render> -[CONTAINS]-> <data>
    // Expect edge: <render> -[RETURNS]-> <template-invocation>
    // Expect edge: <_.template-call> -[PASSES_ARGUMENT]-> <$('#tpl').html()>
    // Expect edge: <$('#tpl').html()> -[PASSES_ARGUMENT]-> <'#tpl'>
    // Expect edge: <template-invocation> -[PASSES_ARGUMENT]-> <data>
    void code;
  });

  test('legacy-patterns::global-namespace-revealing', () => {
    const code = "var RevealingModule = (function () {\n  var secret = 'hidden';\n  function getSecret() { return secret; }\n  function setSecret(s) { secret = s; }\n  return { get: getSecret, set: setSecret };\n})();\n\n// --- Polyfill Patterns ---";
    // Expect node: VARIABLE <RevealingModule>
    // Expect node: FUNCTION <IIFE>
    // Expect node: VARIABLE <secret>
    // Expect node: LITERAL <'hidden'>
    // Expect node: FUNCTION <getSecret>
    // Expect node: FUNCTION <setSecret>
    // Expect node: PARAMETER <s>
    // Expect node: EXPRESSION <{ get: getSecret, set: setSecret }>
    // Expect node: CALL <IIFE-call>
    // Expect edge: <IIFE> -[CONTAINS]-> <secret>
    // Expect edge: <IIFE> -[CONTAINS]-> <getSecret>
    // Expect edge: <IIFE> -[CONTAINS]-> <setSecret>
    // Expect edge: <setSecret> -[CONTAINS]-> <s>
    // Expect edge: <getSecret> -[RETURNS]-> <secret>
    // Expect edge: <IIFE> -[RETURNS]-> <{ get: getSecret, set: setSecret }>
    // Expect edge: <{ get: getSecret, set: setSecret }> -[HAS_PROPERTY]-> <getSecret>
    // Expect edge: <{ get: getSecret, set: setSecret }> -[HAS_PROPERTY]-> <setSecret>
    void code;
  });

  test('legacy-patterns::babel-class-call-check', () => {
    const code = "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}";
    // Expect node: FUNCTION <_classCallCheck>
    // Expect node: PARAMETER <instance>
    // Expect node: PARAMETER <Constructor>
    // Expect node: BRANCH <instanceof-check>
    // Expect node: EXPRESSION <!(instance instanceof Constructor)>
    // Expect node: CALL <new TypeError(...)>
    // Expect node: LITERAL <'Cannot call a class as a function'>
    // Expect edge: <_classCallCheck> -[CONTAINS]-> <instance>
    // Expect edge: <_classCallCheck> -[CONTAINS]-> <Constructor>
    // Expect edge: <_classCallCheck> -[CONTAINS]-> <instanceof-check>
    // Expect edge: <instanceof-check> -[HAS_CONDITION]-> <!(instance instanceof Constructor)>
    // Expect edge: <instanceof-check> -[HAS_CONSEQUENT]-> <new TypeError(...)>
    // Expect edge: <new TypeError(...)> -[PASSES_ARGUMENT]-> <'Cannot call a class as a function'>
    void code;
  });

  test('legacy-patterns::global-namespace-iife', () => {
    const code = "var MyApp2 = (function (ns) {\n  var _private = 0;\n  ns.increment = function () { return ++_private; };\n  ns.getValue = function () { return _private; };\n  return ns;\n}(MyApp2 || {}));";
    // Expect node: VARIABLE <MyApp2>
    // Expect node: FUNCTION <iife>
    // Expect node: PARAMETER <ns>
    // Expect node: VARIABLE <_private>
    // Expect node: LITERAL <0>
    // Expect node: PROPERTY_ACCESS <ns.increment>
    // Expect node: FUNCTION <increment:fn>
    // Expect node: EXPRESSION <++_private>
    // Expect node: PROPERTY_ACCESS <ns.getValue>
    // Expect node: FUNCTION <getValue:fn>
    // Expect node: EXPRESSION <MyApp2 || {}>
    // Expect node: LITERAL <{}>
    // Expect edge: <iife> -[CONTAINS]-> <ns>
    // Expect edge: <iife> -[CONTAINS]-> <_private>
    // Expect edge: <increment:fn> -[RETURNS]-> <++_private>
    // Expect edge: <getValue:fn> -[RETURNS]-> <_private>
    // Expect edge: <iife> -[RETURNS]-> <ns>
    // Expect edge: <iife> -[RECEIVES_ARGUMENT]-> <MyApp2 || {}>
    void code;
  });

  test('legacy-patterns::babel-class-compiled', () => {
    const code = "// Source: class Dog extends Animal { constructor(name) { super(name); } }\n// Compiled:\nvar Dog = (function (_Animal) {\n  _inherits(Dog, _Animal);\n  function Dog(name) {\n    _classCallCheck(this, Dog);\n    return _Animal.call(this, name);\n  }\n  return Dog;\n}(Animal));\n\n// --- TypeScript Compiled Output ---";
    // Expect node: VARIABLE <Dog>
    // Expect node: FUNCTION <Dog:iife>
    // Expect node: PARAMETER <_Animal>
    // Expect node: CALL <_inherits(Dog, _Animal)>
    // Expect node: FUNCTION <Dog:constructor>
    // Expect node: PARAMETER <name>
    // Expect node: CALL <_classCallCheck(this, Dog)>
    // Expect node: CALL <_Animal.call(this, name)>
    // Expect node: EXTERNAL <_inherits>
    // Expect node: EXTERNAL <_classCallCheck>
    // Expect node: EXTERNAL <Animal>
    // Expect edge: <Dog:iife> -[CONTAINS]-> <_Animal>
    // Expect edge: <Dog:iife> -[CONTAINS]-> <_inherits(Dog, _Animal)>
    // Expect edge: <Dog:iife> -[CONTAINS]-> <Dog:constructor>
    // Expect edge: <Dog:iife> -[RETURNS]-> <Dog:constructor>
    // Expect edge: <Dog:constructor> -[CONTAINS]-> <name>
    // Expect edge: <Dog:constructor> -[CONTAINS]-> <_classCallCheck(this, Dog)>
    // Expect edge: <Dog:constructor> -[RETURNS]-> <_Animal.call(this, name)>
    // Expect edge: <_inherits(Dog, _Animal)> -[PASSES_ARGUMENT]-> <Dog>
    // Expect edge: <_inherits(Dog, _Animal)> -[PASSES_ARGUMENT]-> <_Animal>
    // Expect edge: <_classCallCheck(this, Dog)> -[PASSES_ARGUMENT]-> <Dog>
    // Expect edge: <_Animal.call(this, name)> -[PASSES_ARGUMENT]-> <name>
    void code;
  });

  test('legacy-patterns::babel-inherits', () => {
    const code = "function _inherits(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true }\n  });\n  if (superClass) Object.setPrototypeOf(subClass, superClass);\n}";
    // Expect node: FUNCTION <_inherits>
    // Expect node: PARAMETER <subClass>
    // Expect node: PARAMETER <superClass>
    // Expect node: PROPERTY_ACCESS <subClass.prototype>
    // Expect node: CALL <Object.create>
    // Expect node: PROPERTY_ACCESS <superClass.prototype>
    // Expect node: EXPRESSION <superClass && superClass.prototype>
    // Expect node: LITERAL <constructor-descriptor>
    // Expect node: BRANCH <if-superClass>
    // Expect node: CALL <Object.setPrototypeOf>
    // Expect edge: <_inherits> -[HAS_BODY]-> <subClass>
    // Expect edge: <_inherits> -[HAS_BODY]-> <superClass>
    // Expect edge: <Object.create> -[PASSES_ARGUMENT]-> <superClass && superClass.prototype>
    // Expect edge: <Object.create> -[PASSES_ARGUMENT]-> <constructor-descriptor>
    // Expect edge: <_inherits> -[HAS_BODY]-> <if-superClass>
    // Expect edge: <if-superClass> -[HAS_CONDITION]-> <superClass>
    // Expect edge: <if-superClass> -[HAS_CONSEQUENT]-> <Object.setPrototypeOf>
    // Expect edge: <Object.setPrototypeOf> -[PASSES_ARGUMENT]-> <subClass>
    // Expect edge: <Object.setPrototypeOf> -[PASSES_ARGUMENT]-> <superClass>
    void code;
  });

  test('legacy-patterns::polyfill-promise', () => {
    const code = "if (typeof Promise === 'undefined') {\n  // Simplified polyfill shape — real ones are 200+ lines\n  function Promise(executor) {\n    this._state = 'pending';\n    this._value = undefined;\n    this._callbacks = [];\n    executor(this._resolve.bind(this), this._reject.bind(this));\n  }\n  Promise.prototype.then = function (onFulfilled, onRejected) { /* ... */ };\n  Promise.prototype._resolve = function (value) { /* ... */ };\n  Promise.prototype._reject = function (reason) { /* ... */ };\n}";
    // Expect node: BRANCH <if-Promise-undefined>
    // Expect node: EXPRESSION <typeof Promise === 'undefined'>
    // Expect node: FUNCTION <Promise>
    // Expect node: PARAMETER <executor>
    // Expect node: PROPERTY_ACCESS <this._state>
    // Expect node: LITERAL <'pending'>
    // Expect node: PROPERTY_ACCESS <this._value>
    // Expect node: LITERAL <undefined>
    // Expect node: PROPERTY_ACCESS <this._callbacks>
    // Expect node: LITERAL <[]>
    // Expect node: CALL <executor(this._resolve.bind(this), this._reject.bind(this))>
    // Expect node: CALL <this._resolve.bind(this)>
    // Expect node: CALL <this._reject.bind(this)>
    // Expect node: METHOD <Promise.prototype.then>
    // Expect node: PARAMETER <onFulfilled>
    // Expect node: PARAMETER <onRejected>
    // Expect node: METHOD <Promise.prototype._resolve>
    // Expect node: PARAMETER <value>
    // Expect node: METHOD <Promise.prototype._reject>
    // Expect node: PARAMETER <reason>
    // Expect edge: <if-Promise-undefined> -[HAS_CONDITION]-> <typeof Promise === 'undefined'>
    // Expect edge: <if-Promise-undefined> -[HAS_CONSEQUENT]-> <Promise>
    // Expect edge: <Promise> -[CONTAINS]-> <executor>
    // Expect edge: <Promise> -[CONTAINS]-> <executor(this._resolve.bind(this), this._reject.bind(this))>
    // Expect edge: <executor(this._resolve.bind(this), this._reject.bind(this))> -[PASSES_ARGUMENT]-> <this._resolve.bind(this)>
    // Expect edge: <executor(this._resolve.bind(this), this._reject.bind(this))> -[PASSES_ARGUMENT]-> <this._reject.bind(this)>
    // Expect edge: <Promise.prototype.then> -[CONTAINS]-> <onFulfilled>
    // Expect edge: <Promise.prototype.then> -[CONTAINS]-> <onRejected>
    // Expect edge: <Promise.prototype._resolve> -[CONTAINS]-> <value>
    // Expect edge: <Promise.prototype._reject> -[CONTAINS]-> <reason>
    void code;
  });

  test('legacy-patterns::jquery-extend-pattern', () => {
    const code = "// $.extend(true, target, source1, source2); // deep merge\n// $.extend($.fn, { newPlugin: function() {} }); // add to prototype";
    // Expect node: CALL <$.extend(true, target, source1, source2)>
    // Expect node: PROPERTY_ACCESS <$.extend>
    // Expect node: LITERAL <true>
    // Expect node: VARIABLE <target>
    // Expect node: VARIABLE <source1>
    // Expect node: VARIABLE <source2>
    // Expect node: CALL <$.extend($.fn, { newPlugin: function() {} })>
    // Expect node: PROPERTY_ACCESS <$.fn>
    // Expect node: LITERAL <{ newPlugin: function() {} }>
    // Expect node: FUNCTION <newPlugin:fn>
    // Expect edge: <$.extend(true, target, source1, source2)> -[PASSES_ARGUMENT]-> <true>
    // Expect edge: <$.extend(true, target, source1, source2)> -[PASSES_ARGUMENT]-> <target>
    // Expect edge: <$.extend(true, target, source1, source2)> -[PASSES_ARGUMENT]-> <source1>
    // Expect edge: <$.extend(true, target, source1, source2)> -[PASSES_ARGUMENT]-> <source2>
    // Expect edge: <$.extend($.fn, { newPlugin: function() {} })> -[PASSES_ARGUMENT]-> <$.fn>
    // Expect edge: <$.extend($.fn, { newPlugin: function() {} })> -[PASSES_ARGUMENT]-> <{ newPlugin: function() {} }>
    // Expect edge: <{ newPlugin: function() {} }> -[HAS_PROPERTY]-> <newPlugin:fn>
    void code;
  });

  test('legacy-patterns::polyfill-symbol-shim', () => {
    const code = "if (typeof Symbol === 'undefined') {\n  var Symbol = function (description) {\n    return '__symbol_' + (description || '') + '_' + Math.random().toString(36);\n  };\n  Symbol.iterator = '@@iterator';\n}\n\n// --- Babel Compiled Output ---";
    // Expect node: BRANCH <if-symbol-undefined>
    // Expect node: EXPRESSION <typeof Symbol === 'undefined'>
    // Expect node: EXPRESSION <typeof Symbol>
    // Expect node: LITERAL <'undefined'>
    // Expect node: VARIABLE <Symbol>
    // Expect node: FUNCTION <Symbol:polyfill>
    // Expect node: PARAMETER <description>
    // Expect node: EXPRESSION <'__symbol_' + (description || '') + '_' + Math.random().toString(36)>
    // Expect node: LITERAL <'__symbol_'>
    // Expect node: EXPRESSION <description || ''>
    // Expect node: LITERAL <''>
    // Expect node: LITERAL <'_'>
    // Expect node: CALL <Math.random().toString(36)>
    // Expect node: CALL <Math.random()>
    // Expect node: PROPERTY_ACCESS <Math.random>
    // Expect node: LITERAL <36>
    // Expect node: PROPERTY_ACCESS <Symbol.iterator>
    // Expect node: LITERAL <'@@iterator'>
    // Expect edge: <if-symbol-undefined> -[HAS_CONDITION]-> <typeof Symbol === 'undefined'>
    // Expect edge: <if-symbol-undefined> -[DECLARES]-> <Symbol>
    // Expect edge: <Symbol:polyfill> -[CONTAINS]-> <description>
    // Expect edge: <Symbol:polyfill> -[RETURNS]-> <'__symbol_' + (description || '') + '_' + Math.random().toString(36)>
    // Expect edge: <Math.random().toString(36)> -[PASSES_ARGUMENT]-> <36>
    void code;
  });

  test('legacy-patterns::polyfill-prototype-method', () => {
    const code = "if (!Array.prototype.flat) {\n  Array.prototype.flat = function (depth) {\n    depth = depth === undefined ? 1 : Math.floor(depth);\n    if (depth < 1) return Array.prototype.slice.call(this);\n    return Array.prototype.reduce.call(this, function (acc, val) {\n      return acc.concat(Array.isArray(val) && depth > 1 ? val.flat(depth - 1) : val);\n    }, []);\n  };\n}";
    // Expect node: BRANCH <if-polyfill>
    // Expect node: EXPRESSION <!Array.prototype.flat>
    // Expect node: PROPERTY_ACCESS <Array.prototype.flat>
    // Expect node: FUNCTION <polyfill-flat>
    // Expect node: PARAMETER <depth>
    // Expect node: EXPRESSION <depth-ternary>
    // Expect node: LITERAL <1>
    // Expect node: CALL <Math.floor>
    // Expect node: BRANCH <early-return>
    // Expect node: CALL <slice-call>
    // Expect node: CALL <reduce-call>
    // Expect node: FUNCTION <reduce-callback>
    // Expect node: PARAMETER <acc>
    // Expect node: PARAMETER <val>
    // Expect node: CALL <concat-call>
    // Expect node: EXPRESSION <ternary-arg>
    // Expect node: CALL <isArray-call>
    // Expect node: CALL <recursive-flat>
    // Expect node: LITERAL <empty-array>
    // Expect edge: <if-polyfill> -[HAS_CONDITION]-> <!Array.prototype.flat>
    // Expect edge: <polyfill-flat> -[HAS_BODY]-> <depth>
    // Expect edge: <depth-ternary> -[HAS_CONSEQUENT]-> <1>
    // Expect edge: <Math.floor> -[PASSES_ARGUMENT]-> <depth>
    // Expect edge: <polyfill-flat> -[HAS_BODY]-> <early-return>
    // Expect edge: <early-return> -[HAS_CONSEQUENT]-> <slice-call>
    // Expect edge: <polyfill-flat> -[RETURNS]-> <reduce-call>
    // Expect edge: <reduce-call> -[PASSES_ARGUMENT]-> <reduce-callback>
    // Expect edge: <reduce-call> -[PASSES_ARGUMENT]-> <empty-array>
    // Expect edge: <reduce-callback> -[HAS_BODY]-> <acc>
    // Expect edge: <reduce-callback> -[HAS_BODY]-> <val>
    // Expect edge: <reduce-callback> -[RETURNS]-> <concat-call>
    // Expect edge: <concat-call> -[PASSES_ARGUMENT]-> <ternary-arg>
    // Expect edge: <ternary-arg> -[HAS_CONDITION]-> <isArray-call>
    // Expect edge: <ternary-arg> -[HAS_CONSEQUENT]-> <recursive-flat>
    // Expect edge: <isArray-call> -[PASSES_ARGUMENT]-> <val>
    void code;
  });

  test('modern-es::modern-array-at', () => {
    const code = "function arrayAt(arr) {\n  const first = arr.at(0);\n  const last = arr.at(-1);\n  const second = arr.at(1);\n  return { first, last, second };\n}";
    // Expect node: FUNCTION <arrayAt>
    // Expect node: PARAMETER <arr>
    // Expect node: VARIABLE <first>
    // Expect node: CALL <arr.at(0)>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <last>
    // Expect node: CALL <arr.at(-1)>
    // Expect node: LITERAL <-1>
    // Expect node: VARIABLE <second>
    // Expect node: CALL <arr.at(1)>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <{ first, last, second }>
    // Expect edge: <arrayAt> -[CONTAINS]-> <arr>
    // Expect edge: <arrayAt> -[CONTAINS]-> <first>
    // Expect edge: <arr.at(0)> -[PASSES_ARGUMENT]-> <0>
    // Expect edge: <arrayAt> -[CONTAINS]-> <last>
    // Expect edge: <arr.at(-1)> -[PASSES_ARGUMENT]-> <-1>
    // Expect edge: <arrayAt> -[CONTAINS]-> <second>
    // Expect edge: <arr.at(1)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <arrayAt> -[RETURNS]-> <{ first, last, second }>
    void code;
  });

  test('legacy-patterns::ts-compiled-spread', () => {
    const code = "var __spreadArray = function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};";
    // Expect node: VARIABLE <__spreadArray>
    // Expect node: FUNCTION <__spreadArray:fn>
    // Expect node: PARAMETER <to>
    // Expect node: PARAMETER <from>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <il>
    // Expect node: PROPERTY_ACCESS <from.length>
    // Expect node: VARIABLE <j>
    // Expect node: PROPERTY_ACCESS <to.length>
    // Expect node: EXPRESSION <i < il>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <j++>
    // Expect node: EXPRESSION <to[j] = from[i]>
    // Expect node: PROPERTY_ACCESS <to[j]>
    // Expect node: PROPERTY_ACCESS <from[i]>
    // Expect edge: <__spreadArray:fn> -[CONTAINS]-> <to>
    // Expect edge: <__spreadArray:fn> -[CONTAINS]-> <from>
    // Expect edge: <__spreadArray:fn> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[HAS_INIT]-> <i>
    // Expect edge: <for-loop> -[HAS_INIT]-> <il>
    // Expect edge: <for-loop> -[HAS_INIT]-> <j>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < il>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <j++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <to[j] = from[i]>
    // Expect edge: <__spreadArray:fn> -[RETURNS]-> <to>
    void code;
  });

  test('legacy-patterns::jquery-plugin-pattern', () => {
    const code = "// $.fn.highlight = function(color) {\n//   return this.each(function() {\n//     $(this).css('background-color', color || 'yellow');\n//   });\n// };\n// Usage: $('p').highlight('red');";
    // Expect node: PROPERTY_ACCESS <$.fn.highlight>
    // Expect node: FUNCTION <highlight:fn>
    // Expect node: PARAMETER <color>
    // Expect node: CALL <this.each(...)>
    // Expect node: FUNCTION <each-callback:fn>
    // Expect node: CALL <$(this)>
    // Expect node: CALL <$(this).css(...)>
    // Expect node: LITERAL <'background-color'>
    // Expect node: EXPRESSION <color || 'yellow'>
    // Expect node: LITERAL <'yellow'>
    // Expect node: CALL <$('p').highlight('red')>
    // Expect node: CALL <$('p')>
    // Expect node: LITERAL <'p'>
    // Expect node: LITERAL <'red'>
    // Expect edge: <highlight:fn> -[CONTAINS]-> <color>
    // Expect edge: <highlight:fn> -[RETURNS]-> <this.each(...)>
    // Expect edge: <this.each(...)> -[PASSES_ARGUMENT]-> <each-callback:fn>
    // Expect edge: <each-callback:fn> -[CONTAINS]-> <$(this)>
    // Expect edge: <$(this).css(...)> -[PASSES_ARGUMENT]-> <'background-color'>
    // Expect edge: <$(this).css(...)> -[PASSES_ARGUMENT]-> <color || 'yellow'>
    // Expect edge: <$('p')> -[PASSES_ARGUMENT]-> <'p'>
    // Expect edge: <$('p').highlight('red')> -[PASSES_ARGUMENT]-> <'red'>
    void code;
  });

  test('modern-es::modern-map-groupby', () => {
    const code = "function mapGroupBy(items) {\n  return Map.groupBy(items, item => item.category);\n}\n\n// --- Promise.withResolvers (ES2024) ---";
    // Expect node: FUNCTION <mapGroupBy>
    // Expect node: PARAMETER <items>
    // Expect node: CALL <Map.groupBy(items, item => item.category)>
    // Expect node: PROPERTY_ACCESS <Map.groupBy>
    // Expect node: FUNCTION <item => item.category>
    // Expect node: PARAMETER <item>
    // Expect node: PROPERTY_ACCESS <item.category>
    // Expect edge: <mapGroupBy> -[HAS_BODY]-> <items>
    // Expect edge: <mapGroupBy> -[RETURNS]-> <Map.groupBy(items, item => item.category)>
    // Expect edge: <Map.groupBy(items, item => item.category)> -[PASSES_ARGUMENT]-> <items>
    // Expect edge: <Map.groupBy(items, item => item.category)> -[PASSES_ARGUMENT]-> <item => item.category>
    // Expect edge: <item => item.category> -[HAS_BODY]-> <item>
    // Expect edge: <item => item.category> -[RETURNS]-> <item.category>
    void code;
  });

  test('modern-es::modern-object-hasown', () => {
    const code = "function hasOwnCheck(obj, key) {\n  return Object.hasOwn(obj, key);\n}\n\n// --- structuredClone (ES2022) ---";
    // Expect node: FUNCTION <hasOwnCheck>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <key>
    // Expect node: CALL <Object.hasOwn(obj, key)>
    // Expect node: PROPERTY_ACCESS <Object.hasOwn>
    // Expect edge: <hasOwnCheck> -[HAS_BODY]-> <obj>
    // Expect edge: <hasOwnCheck> -[HAS_BODY]-> <key>
    // Expect edge: <hasOwnCheck> -[RETURNS]-> <Object.hasOwn(obj, key)>
    // Expect edge: <Object.hasOwn(obj, key)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.hasOwn(obj, key)> -[PASSES_ARGUMENT]-> <key>
    void code;
  });

  test('legacy-patterns::jquery-deferred', () => {
    const code = "// var dfd = $.Deferred();\n// dfd.done(function(data) { ... });\n// dfd.fail(function(err) { ... });\n// dfd.resolve(result); // or dfd.reject(error);\n\n// --- Script Concatenation / Namespace Export ---";
    // Expect node: VARIABLE <dfd>
    // Expect node: CALL <$.Deferred()>
    // Expect node: PROPERTY_ACCESS <$.Deferred>
    // Expect node: VARIABLE <$>
    // Expect node: CALL <dfd.done(callback)>
    // Expect node: PROPERTY_ACCESS <dfd.done>
    // Expect node: FUNCTION <done-callback>
    // Expect node: PARAMETER <data>
    // Expect node: CALL <dfd.fail(callback)>
    // Expect node: PROPERTY_ACCESS <dfd.fail>
    // Expect node: FUNCTION <fail-callback>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <dfd.resolve(result)>
    // Expect node: PROPERTY_ACCESS <dfd.resolve>
    // Expect node: VARIABLE <result>
    // Expect node: CALL <dfd.reject(error)>
    // Expect node: PROPERTY_ACCESS <dfd.reject>
    // Expect node: VARIABLE <error>
    // Expect edge: <dfd.done(callback)> -[PASSES_ARGUMENT]-> <done-callback>
    // Expect edge: <done-callback> -[CONTAINS]-> <data>
    // Expect edge: <dfd.fail(callback)> -[PASSES_ARGUMENT]-> <fail-callback>
    // Expect edge: <fail-callback> -[CONTAINS]-> <err>
    // Expect edge: <dfd.resolve(result)> -[PASSES_ARGUMENT]-> <result>
    // Expect edge: <dfd.reject(error)> -[PASSES_ARGUMENT]-> <error>
    void code;
  });

  test('modern-es::modern-object-groupby', () => {
    const code = "function objectGroupBy(items) {\n  return Object.groupBy(items, item => item.category);\n}";
    // Expect node: FUNCTION <objectGroupBy>
    // Expect node: PARAMETER <items>
    // Expect node: CALL <Object.groupBy(items, item => item.category)>
    // Expect node: PROPERTY_ACCESS <Object.groupBy>
    // Expect node: FUNCTION <item => item.category>
    // Expect node: PARAMETER <item>
    // Expect node: PROPERTY_ACCESS <item.category>
    // Expect edge: <objectGroupBy> -[HAS_BODY]-> <items>
    // Expect edge: <objectGroupBy> -[RETURNS]-> <Object.groupBy(items, item => item.category)>
    // Expect edge: <Object.groupBy(items, item => item.category)> -[PASSES_ARGUMENT]-> <items>
    // Expect edge: <Object.groupBy(items, item => item.category)> -[PASSES_ARGUMENT]-> <item => item.category>
    // Expect edge: <item => item.category> -[HAS_BODY]-> <item>
    // Expect edge: <item => item.category> -[RETURNS]-> <item.category>
    void code;
  });

  test('modern-es::modern-array-findlast', () => {
    const code = "function arrayFindLast(arr) {\n  const last = arr.findLast(x => x > 3);\n  const lastIdx = arr.findLastIndex(x => x > 3);\n  return { last, lastIdx };\n}";
    // Expect node: FUNCTION <arrayFindLast>
    // Expect node: PARAMETER <arr>
    // Expect node: VARIABLE <last>
    // Expect node: CALL <arr.findLast(x => x > 3)>
    // Expect node: FUNCTION <findLast-callback>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x > 3>
    // Expect node: LITERAL <3>
    // Expect node: VARIABLE <lastIdx>
    // Expect node: CALL <arr.findLastIndex(x => x > 3)>
    // Expect node: FUNCTION <findLastIndex-callback>
    // Expect node: PARAMETER <x2>
    // Expect node: EXPRESSION <x2 > 3>
    // Expect node: LITERAL <3-2>
    // Expect node: EXPRESSION <{ last, lastIdx }>
    // Expect edge: <arrayFindLast> -[CONTAINS]-> <arr>
    // Expect edge: <arrayFindLast> -[CONTAINS]-> <last>
    // Expect edge: <arrayFindLast> -[CONTAINS]-> <lastIdx>
    // Expect edge: <arr.findLast(x => x > 3)> -[PASSES_ARGUMENT]-> <findLast-callback>
    // Expect edge: <findLast-callback> -[CONTAINS]-> <x>
    // Expect edge: <findLast-callback> -[RETURNS]-> <x > 3>
    // Expect edge: <arr.findLastIndex(x => x > 3)> -[PASSES_ARGUMENT]-> <findLastIndex-callback>
    // Expect edge: <findLastIndex-callback> -[CONTAINS]-> <x2>
    // Expect edge: <findLastIndex-callback> -[RETURNS]-> <x2 > 3>
    // Expect edge: <arrayFindLast> -[RETURNS]-> <{ last, lastIdx }>
    void code;
  });

  test('modern-es::modern-structured-clone', () => {
    const code = "function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Hashbang (ES2023) ---\n// Note: hashbang must be at very top of file, so this is just a reference\n// #!/usr/bin/env node — would be first line in a CLI script\n\n// --- RegExp: d flag / match indices (ES2022) ---";
    // Expect node: FUNCTION <deepClone>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <structuredClone(obj)>
    // Expect node: EXTERNAL <structuredClone>
    // Expect edge: <deepClone> -[HAS_BODY]-> <obj>
    // Expect edge: <deepClone> -[RETURNS]-> <structuredClone(obj)>
    // Expect edge: <structuredClone(obj)> -[PASSES_ARGUMENT]-> <obj>
    void code;
  });

  test('modern-es::modern-symbol-tostringtag', () => {
    const code = "class CustomCollection {\n  get [Symbol.toStringTag]() {\n    return 'CustomCollection';\n  }\n}";
    // Expect node: CLASS <CustomCollection>
    // Expect node: GETTER <CustomCollection.[Symbol.toStringTag]>
    // Expect node: PROPERTY_ACCESS <Symbol.toStringTag>
    // Expect node: LITERAL <'CustomCollection'>
    // Expect edge: <module> -[DECLARES]-> <CustomCollection>
    // Expect edge: <CustomCollection> -[CONTAINS]-> <CustomCollection.[Symbol.toStringTag]>
    // Expect edge: <CustomCollection.[Symbol.toStringTag]> -[HAS_PROPERTY]-> <Symbol.toStringTag>
    // Expect edge: <CustomCollection.[Symbol.toStringTag]> -[RETURNS]-> <'CustomCollection'>
    void code;
  });

  test('modern-es::modern-promise-with-resolvers', () => {
    const code = "function createDeferred() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  return { promise, resolve, reject };\n}\n\n// --- Error.cause usage ---";
    // Expect node: FUNCTION <createDeferred>
    // Expect node: CALL <Promise.withResolvers()>
    // Expect node: VARIABLE <promise>
    // Expect node: VARIABLE <resolve>
    // Expect node: VARIABLE <reject>
    // Expect node: EXPRESSION <return-object>
    // Expect node: PROPERTY_ACCESS <Promise.withResolvers>
    // Expect edge: <createDeferred> -[CONTAINS]-> <Promise.withResolvers()>
    // Expect edge: <createDeferred> -[CONTAINS]-> <promise>
    // Expect edge: <createDeferred> -[CONTAINS]-> <resolve>
    // Expect edge: <createDeferred> -[CONTAINS]-> <reject>
    // Expect edge: <createDeferred> -[RETURNS]-> <return-object>
    void code;
  });

  test('modern-es::modern-symbol-iterator', () => {
    const code = "class InfiniteOnes {\n  [Symbol.iterator]() {\n    return {\n      next() { return { value: 1, done: false }; },\n    };\n  }\n}";
    // Expect node: CLASS <InfiniteOnes>
    // Expect node: METHOD <InfiniteOnes[Symbol.iterator]>
    // Expect node: LITERAL <object-literal>
    // Expect node: METHOD <next>
    // Expect node: LITERAL <return-object>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <false>
    // Expect edge: <InfiniteOnes> -[CONTAINS]-> <InfiniteOnes[Symbol.iterator]>
    // Expect edge: <InfiniteOnes[Symbol.iterator]> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <next>
    // Expect edge: <next> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <1>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <false>
    void code;
  });

  test('modern-es::modern-error-cause', () => {
    const code = "function wrapError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    throw new Error('Wrapper failed', { cause: err });\n  }\n}\n\n// --- Object.hasOwn (ES2022) ---";
    // Expect node: FUNCTION <wrapError>
    // Expect node: PARAMETER <fn>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <fn()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <new Error()>
    // Expect node: LITERAL <'Wrapper failed'>
    // Expect node: EXPRESSION <{ cause: err }>
    // Expect edge: <wrapError> -[HAS_BODY]-> <fn>
    // Expect edge: <wrapError> -[HAS_BODY]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <fn()>
    // Expect edge: <wrapError> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <err>
    // Expect edge: <new Error()> -[PASSES_ARGUMENT]-> <'Wrapper failed'>
    // Expect edge: <new Error()> -[PASSES_ARGUMENT]-> <{ cause: err }>
    void code;
  });

  test('modern-es::modern-symbol-species', () => {
    const code = "class SpecialArray extends Array {\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n\n// --- AbortController ---";
    // Expect node: CLASS <SpecialArray>
    // Expect node: GETTER <SpecialArray[Symbol.species]>
    // Expect node: PROPERTY_ACCESS <Symbol.species>
    // Expect node: VARIABLE <Array>
    // Expect edge: <module> -[DECLARES]-> <SpecialArray>
    // Expect edge: <SpecialArray> -[CONTAINS]-> <SpecialArray[Symbol.species]>
    // Expect edge: <SpecialArray[Symbol.species]> -[USES]-> <Symbol.species>
    // Expect edge: <SpecialArray[Symbol.species]> -[RETURNS]-> <Array>
    void code;
  });

  test('modern-es::modern-using-sync', () => {
    const code = "function usingSyncExample() {\n  // Symbol.dispose — synchronous cleanup\n  const resource = {\n    data: 'important',\n    [Symbol.dispose]() {\n      this.data = null;\n    },\n  };\n  return resource;\n}";
    // Expect node: FUNCTION <usingSyncExample>
    // Expect node: VARIABLE <resource>
    // Expect node: LITERAL <resource-object>
    // Expect node: PROPERTY <data-property>
    // Expect node: LITERAL <'important'>
    // Expect node: METHOD <resource[Symbol.dispose]>
    // Expect node: PROPERTY_ACCESS <this.data>
    // Expect node: LITERAL <null>
    // Expect edge: <usingSyncExample> -[CONTAINS]-> <resource>
    // Expect edge: <resource-object> -[HAS_PROPERTY]-> <data-property>
    // Expect edge: <resource-object> -[HAS_PROPERTY]-> <resource[Symbol.dispose]>
    // Expect edge: <usingSyncExample> -[RETURNS]-> <resource>
    void code;
  });

  test('modern-es::reexport-namespace', () => {
    const code = "// export * as utils from './modules-helpers.js';\n// (commented — would conflict with existing exports; syntax reference only)";
    // Expect node: EXPORT <export-namespace>
    // Expect node: IMPORT <import-all>
    // Expect edge: <module> -[CONTAINS]-> <export-namespace>
    void code;
  });

  test('modern-es::modern-using-async', () => {
    const code = "async function usingAsyncExample() {\n  const resource = {\n    data: 'important',\n    async [Symbol.asyncDispose]() {\n      await new Promise(r => setTimeout(r, 10));\n      this.data = null;\n    },\n  };\n  return resource;\n}\n\n// --- Iterator helpers (ES2025) ---";
    // Expect node: FUNCTION <usingAsyncExample>
    // Expect node: VARIABLE <resource>
    // Expect node: LITERAL <'important'>
    // Expect node: METHOD <resource[Symbol.asyncDispose]>
    // Expect node: CALL <new Promise(r => setTimeout(r, 10))>
    // Expect node: FUNCTION <r => setTimeout(r, 10)>
    // Expect node: PARAMETER <r>
    // Expect node: CALL <setTimeout(r, 10)>
    // Expect node: LITERAL <10>
    // Expect node: PROPERTY_ACCESS <this.data>
    // Expect node: LITERAL <null>
    // Expect edge: <usingAsyncExample> -[CONTAINS]-> <resource>
    // Expect edge: <resource> -[HAS_PROPERTY]-> <'important'>
    // Expect edge: <resource> -[HAS_PROPERTY]-> <resource[Symbol.asyncDispose]>
    // Expect edge: <resource[Symbol.asyncDispose]> -[AWAITS]-> <new Promise(r => setTimeout(r, 10))>
    // Expect edge: <new Promise(r => setTimeout(r, 10))> -[PASSES_ARGUMENT]-> <r => setTimeout(r, 10)>
    // Expect edge: <r => setTimeout(r, 10)> -[CONTAINS]-> <r>
    // Expect edge: <r => setTimeout(r, 10)> -[RETURNS]-> <setTimeout(r, 10)>
    // Expect edge: <setTimeout(r, 10)> -[PASSES_ARGUMENT]-> <r>
    // Expect edge: <setTimeout(r, 10)> -[PASSES_ARGUMENT]-> <10>
    // Expect edge: <usingAsyncExample> -[RETURNS]-> <resource>
    void code;
  });

  test('modern-es::using-in-for', () => {
    const code = "function usingInFor(readers) {\n  for (using reader of readers) {\n    reader.process();\n  }\n}";
    // Expect node: FUNCTION <usingInFor>
    // Expect node: PARAMETER <readers>
    // Expect node: LOOP <for-of-using>
    // Expect node: VARIABLE <reader>
    // Expect node: CALL <reader.process()>
    // Expect node: PROPERTY_ACCESS <reader.process>
    // Expect edge: <usingInFor> -[CONTAINS]-> <readers>
    // Expect edge: <usingInFor> -[CONTAINS]-> <for-of-using>
    // Expect edge: <for-of-using> -[ITERATES_OVER]-> <readers>
    // Expect edge: <for-of-using> -[CONTAINS]-> <reader>
    // Expect edge: <for-of-using> -[HAS_BODY]-> <reader.process()>
    void code;
  });

  test('modern-es::modern-symbol-toprimitive', () => {
    const code = "class Money {\n  constructor(amount, currency) {\n    this.amount = amount;\n    this.currency = currency;\n  }\n\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return this.amount;\n    if (hint === 'string') return `${this.amount} ${this.currency}`;\n    return this.amount;\n  }\n}";
    // Expect node: CLASS <Money>
    // Expect node: METHOD <Money.constructor>
    // Expect node: PARAMETER <amount>
    // Expect node: PARAMETER <currency>
    // Expect node: PROPERTY_ACCESS <this.amount>
    // Expect node: PROPERTY_ACCESS <this.currency>
    // Expect node: METHOD <Money.[Symbol.toPrimitive]>
    // Expect node: PARAMETER <hint>
    // Expect node: BRANCH <hint === 'number'>
    // Expect node: BRANCH <hint === 'string'>
    // Expect node: LITERAL <'number'>
    // Expect node: LITERAL <'string'>
    // Expect node: EXPRESSION <`${this.amount} ${this.currency}`>
    // Expect edge: <Money> -[CONTAINS]-> <Money.constructor>
    // Expect edge: <Money> -[CONTAINS]-> <Money.[Symbol.toPrimitive]>
    // Expect edge: <Money.constructor> -[RECEIVES_ARGUMENT]-> <amount>
    // Expect edge: <Money.constructor> -[RECEIVES_ARGUMENT]-> <currency>
    // Expect edge: <Money.[Symbol.toPrimitive]> -[RECEIVES_ARGUMENT]-> <hint>
    // Expect edge: <Money.[Symbol.toPrimitive]> -[HAS_CONDITION]-> <hint === 'number'>
    // Expect edge: <Money.[Symbol.toPrimitive]> -[HAS_CONDITION]-> <hint === 'string'>
    // Expect edge: <hint === 'number'> -[HAS_CONSEQUENT]-> <this.amount>
    // Expect edge: <hint === 'string'> -[HAS_CONSEQUENT]-> <`${this.amount} ${this.currency}`>
    // Expect edge: <Money.[Symbol.toPrimitive]> -[RETURNS]-> <this.amount>
    void code;
  });

  test('modern-es::import-attributes-json', () => {
    const code = "// import config from './config.json' with { type: 'json' };";
    // Expect node: IMPORT <import-config>
    // Expect node: VARIABLE <config>
    // Expect node: EXTERNAL_MODULE <./config.json>

    void code;
  });

  test('modern-es::class-accessor-keyword', () => {
    const code = "class Reactive {\n  accessor count = 0;\n}\n\n// --- Import Attributes (ES2025) ---";
    // Expect node: CLASS <Reactive>
    // Expect node: PROPERTY <Reactive.count>
    // Expect node: LITERAL <0>
    // Expect edge: <module> -[DECLARES]-> <Reactive>
    // Expect edge: <Reactive> -[CONTAINS]-> <Reactive.count>
    void code;
  });

  test('modern-es::modern-iterator-helpers', () => {
    const code = "function iteratorHelpers(arr) {\n  // Iterator.from, .map, .filter, .take, .drop, .flatMap, .reduce, .toArray, .forEach, .some, .every, .find\n  const iter = arr.values();\n  const mapped = iter.map(x => x * 2);\n  const taken = mapped.take(3);\n  return [...taken];\n}\n\n// --- Set methods (ES2025) ---";
    // Expect node: FUNCTION <iteratorHelpers>
    // Expect node: PARAMETER <arr>
    // Expect node: VARIABLE <iter>
    // Expect node: CALL <arr.values()>
    // Expect node: VARIABLE <mapped>
    // Expect node: CALL <iter.map(x => x * 2)>
    // Expect node: FUNCTION <x => x * 2>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect node: VARIABLE <taken>
    // Expect node: CALL <mapped.take(3)>
    // Expect node: LITERAL <3>
    // Expect node: EXPRESSION <[...taken]>
    // Expect edge: <iteratorHelpers> -[CONTAINS]-> <arr>
    // Expect edge: <iteratorHelpers> -[CONTAINS]-> <iter>
    // Expect edge: <iteratorHelpers> -[CONTAINS]-> <mapped>
    // Expect edge: <iter.map(x => x * 2)> -[PASSES_ARGUMENT]-> <x => x * 2>
    // Expect edge: <x => x * 2> -[CONTAINS]-> <x>
    // Expect edge: <x => x * 2> -[RETURNS]-> <x * 2>
    // Expect edge: <iteratorHelpers> -[CONTAINS]-> <taken>
    // Expect edge: <mapped.take(3)> -[PASSES_ARGUMENT]-> <3>
    // Expect edge: <iteratorHelpers> -[RETURNS]-> <[...taken]>
    void code;
  });

  test('builtins::builtin-regex-named-groups', () => {
    const code = "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---";
    // Expect node: FUNCTION <regexNamedGroups>
    // Expect node: PARAMETER <dateStr>
    // Expect node: VARIABLE <pattern>
    // Expect node: LITERAL </(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/>
    // Expect node: VARIABLE <match>
    // Expect node: CALL <dateStr.match(pattern)>
    // Expect node: BRANCH <if (!match)>
    // Expect node: LITERAL <null>
    // Expect node: VARIABLE <year>
    // Expect node: VARIABLE <month>
    // Expect node: VARIABLE <day>
    // Expect node: PROPERTY_ACCESS <match.groups>
    // Expect node: EXPRESSION <{ year, month, day }>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <dateStr>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <pattern>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <match>
    // Expect edge: <dateStr.match(pattern)> -[PASSES_ARGUMENT]-> <pattern>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <if (!match)>
    // Expect edge: <if (!match)> -[HAS_CONDITION]-> <match>
    // Expect edge: <if (!match)> -[HAS_CONSEQUENT]-> <null>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <year>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <month>
    // Expect edge: <regexNamedGroups> -[CONTAINS]-> <day>
    // Expect edge: <regexNamedGroups> -[RETURNS]-> <{ year, month, day }>
    void code;
  });

  test('modern-es::modern-regex-indices', () => {
    const code = "function regexIndices(str) {\n  const regex = /(?<word>\\w+)/gd;\n  const match = regex.exec(str);\n  if (!match) return null;\n  const { indices } = match;\n  return { match: match[0], start: indices[0][0], end: indices[0][1], groups: indices.groups };\n}\n\n// --- Top-level await (ES2022) — already in async-generators.js, reference only ---\n\n// --- Logical assignment already in expressions.js (&&=, ||=, ??=) ---\n\n// --- Private class fields / methods already in classes.js ---\n\n// --- Class static block already in classes.js ---\n\n// --- Symbols: well-known symbols ---";
    // Expect node: FUNCTION <regexIndices>
    // Expect node: PARAMETER <str>
    // Expect node: VARIABLE <regex>
    // Expect node: LITERAL </(?<word>\w+)/gd>
    // Expect node: VARIABLE <match>
    // Expect node: CALL <regex.exec(str)>
    // Expect node: BRANCH <if (!match)>
    // Expect node: LITERAL <null>
    // Expect node: VARIABLE <indices>
    // Expect node: PROPERTY_ACCESS <match.indices>
    // Expect node: EXPRESSION <return-object>
    // Expect node: PROPERTY_ACCESS <match[0]>
    // Expect node: PROPERTY_ACCESS <indices[0][0]>
    // Expect node: PROPERTY_ACCESS <indices[0][1]>
    // Expect node: PROPERTY_ACCESS <indices.groups>
    // Expect edge: <regexIndices> -[CONTAINS]-> <str>
    // Expect edge: <regexIndices> -[CONTAINS]-> <regex>
    // Expect edge: <regexIndices> -[CONTAINS]-> <match>
    // Expect edge: <regex.exec(str)> -[PASSES_ARGUMENT]-> <str>
    // Expect edge: <regexIndices> -[CONTAINS]-> <if (!match)>
    // Expect edge: <if (!match)> -[HAS_CONSEQUENT]-> <null>
    // Expect edge: <regexIndices> -[CONTAINS]-> <indices>
    // Expect edge: <regexIndices> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <match[0]>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <indices[0][0]>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <indices[0][1]>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <indices.groups>
    void code;
  });

  test('modules-default-anon::export-default-anonymous-function', () => {
    const code = "export default function() {\n  return 'anonymous but hoisted';\n}\n\n// Only one `export default` per module — other forms as comments:";
    // Expect node: FUNCTION <anonymous-default-function>
    // Expect node: EXPORT <default-export>
    // Expect node: LITERAL <'anonymous but hoisted'>
    // Expect edge: <module> -[CONTAINS]-> <default-export>
    // Expect edge: <anonymous-default-function> -[RETURNS]-> <'anonymous but hoisted'>
    void code;
  });

  test('modern-es::import-attributes-reexport', () => {
    const code = "// export { default as schema } from './schema.json' with { type: 'json' };\n\n// --- import.meta.resolve() (ES2025) ---";
    // Expect node: EXPORT <export-schema>
    // Expect node: VARIABLE <schema>
    // Expect node: IMPORT <import-schema.json>
    // Expect node: EXTERNAL_MODULE <./schema.json>

    void code;
  });

  test('modern-es::import-attributes-css', () => {
    const code = "// import styles from './app.css' with { type: 'css' };";
    // Expect node: IMPORT <import-styles>
    // Expect node: VARIABLE <styles>
    // Expect node: LITERAL <type-css>
    // Expect edge: <module> -[CONTAINS]-> <import-styles>
    // Expect edge: <import-styles> -[HAS_PROPERTY]-> <type-css>
    void code;
  });

  test('modules-helpers::export-inline-function', () => {
    const code = "export function helperFunction() {\n  return 'help';\n}";
    // Expect node: FUNCTION <helperFunction>
    // Expect node: LITERAL <'help'>
    // Expect edge: <module> -[DECLARES]-> <helperFunction>
    // Expect edge: <helperFunction> -[RETURNS]-> <'help'>
    void code;
  });

  test('modern-es::modern-abort-controller', () => {
    const code = "async function fetchWithAbort(url, timeoutMs) {\n  const controller = new AbortController();\n  const { signal } = controller;\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal });\n    return await response.json();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// --- Disposable resources (ES2025) ---";
    // Expect node: FUNCTION <fetchWithAbort>
    // Expect node: PARAMETER <url>
    // Expect node: PARAMETER <timeoutMs>
    // Expect node: VARIABLE <controller>
    // Expect node: CALL <new AbortController()>
    // Expect node: VARIABLE <signal>
    // Expect node: PROPERTY_ACCESS <controller.signal>
    // Expect node: VARIABLE <timeoutId>
    // Expect node: CALL <setTimeout(...)>
    // Expect node: FUNCTION <timeout-callback>
    // Expect node: CALL <controller.abort()>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: VARIABLE <response>
    // Expect node: CALL <fetch(url, { signal })>
    // Expect node: LITERAL <{ signal }>
    // Expect node: CALL <response.json()>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: CALL <clearTimeout(timeoutId)>
    // Expect edge: <fetchWithAbort> -[CONTAINS]-> <url>
    // Expect edge: <fetchWithAbort> -[CONTAINS]-> <timeoutMs>
    // Expect edge: <fetchWithAbort> -[CONTAINS]-> <controller>
    // Expect edge: <fetchWithAbort> -[CONTAINS]-> <signal>
    // Expect edge: <fetchWithAbort> -[CONTAINS]-> <timeoutId>
    // Expect edge: <setTimeout(...)> -[PASSES_ARGUMENT]-> <timeout-callback>
    // Expect edge: <setTimeout(...)> -[PASSES_ARGUMENT]-> <timeoutMs>
    // Expect edge: <timeout-callback> -[CONTAINS]-> <controller.abort()>
    // Expect edge: <fetchWithAbort> -[CONTAINS]-> <try-block>
    // Expect edge: <try-block> -[CONTAINS]-> <response>
    // Expect edge: <fetch(url, { signal })> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <fetch(url, { signal })> -[PASSES_ARGUMENT]-> <{ signal }>
    // Expect edge: <try-block> -[RETURNS]-> <response.json()>
    // Expect edge: <fetchWithAbort> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <finally-block> -[CONTAINS]-> <clearTimeout(timeoutId)>
    // Expect edge: <clearTimeout(timeoutId)> -[PASSES_ARGUMENT]-> <timeoutId>
    void code;
  });

  test('modules-default-anon::export-default-anonymous-class', () => {
    const code = "// export default class { run() { return 'anonymous class'; } }";
    // Expect node: EXPORT <default-export>
    // Expect node: CLASS <anonymous-class>
    // Expect node: METHOD <anonymous-class.run>
    // Expect node: LITERAL <'anonymous class'>
    // Expect edge: <anonymous-class> -[CONTAINS]-> <anonymous-class.run>
    // Expect edge: <anonymous-class.run> -[RETURNS]-> <'anonymous class'>
    void code;
  });

  test('modern-es::using-declaration', () => {
    const code = "function usingDeclaration() {\n  function openFile(path) {\n    return {\n      path,\n      read() { return `contents of ${path}`; },\n      [Symbol.dispose]() { console.log(`closed ${path}`); },\n    };\n  }\n  using handle = openFile('/tmp/test');\n  return handle.read();\n}";
    // Expect node: FUNCTION <usingDeclaration>
    // Expect node: FUNCTION <openFile>
    // Expect node: PARAMETER <path>
    // Expect node: LITERAL <object-literal>
    // Expect node: PROPERTY <path-property>
    // Expect node: METHOD <read>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: METHOD <Symbol.dispose>
    // Expect node: CALL <console.log>
    // Expect node: EXPRESSION <dispose-template>
    // Expect node: VARIABLE <handle>
    // Expect node: CALL <openFile('/tmp/test')>
    // Expect node: LITERAL <'/tmp/test'>
    // Expect node: CALL <handle.read()>
    // Expect edge: <usingDeclaration> -[CONTAINS]-> <openFile>
    // Expect edge: <openFile> -[CONTAINS]-> <path>
    // Expect edge: <openFile> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <path-property>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <read>
    // Expect edge: <read> -[RETURNS]-> <template-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <Symbol.dispose>
    // Expect edge: <Symbol.dispose> -[CONTAINS]-> <console.log>
    // Expect edge: <console.log> -[PASSES_ARGUMENT]-> <dispose-template>
    // Expect edge: <usingDeclaration> -[DECLARES]-> <handle>
    // Expect edge: <openFile('/tmp/test')> -[PASSES_ARGUMENT]-> <'/tmp/test'>
    // Expect edge: <usingDeclaration> -[RETURNS]-> <handle.read()>
    void code;
  });

  test('modern-es::import-attributes-dynamic', () => {
    const code = "// const data = await import('./data.json', { with: { type: 'json' } });";
    // Expect node: VARIABLE <data>
    // Expect node: EXPRESSION <await import('./data.json', { with: { type: 'json' } })>
    // Expect node: CALL <import('./data.json', { with: { type: 'json' } })>
    // Expect node: LITERAL <'./data.json'>
    // Expect node: LITERAL <{ with: { type: 'json' } }>
    // Expect edge: <module> -[DECLARES]-> <data>
    // Expect edge: <await import('./data.json', { with: { type: 'json' } })> -[AWAITS]-> <import('./data.json', { with: { type: 'json' } })>
    // Expect edge: <import('./data.json', { with: { type: 'json' } })> -[USES]-> <{ with: { type: 'json' } }>
    void code;
  });

  test('modern-es::using-await-declaration', () => {
    const code = "async function usingAwaitDeclaration() {\n  function openStream(url) {\n    return {\n      url,\n      async readAll() { return 'data'; },\n      async [Symbol.asyncDispose]() { console.log(`closed ${url}`); },\n    };\n  }\n  await using stream = await openStream('http://example.com');\n  return stream.readAll();\n}";
    // Expect node: FUNCTION <usingAwaitDeclaration>
    // Expect node: FUNCTION <openStream>
    // Expect node: PARAMETER <url>
    // Expect node: LITERAL <'data'>
    // Expect node: LITERAL <'http://example.com'>
    // Expect node: LITERAL <'closed '>
    // Expect node: METHOD <readAll>
    // Expect node: METHOD <Symbol.asyncDispose>
    // Expect node: EXPRESSION <object-literal>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: VARIABLE <stream>
    // Expect node: CALL <openStream('http://example.com')>
    // Expect node: CALL <stream.readAll()>
    // Expect node: CALL <console.log(template)>
    // Expect edge: <usingAwaitDeclaration> -[CONTAINS]-> <openStream>
    // Expect edge: <openStream> -[CONTAINS]-> <url>
    // Expect edge: <openStream> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <url>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <readAll>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <Symbol.asyncDispose>
    // Expect edge: <readAll> -[RETURNS]-> <'data'>
    // Expect edge: <Symbol.asyncDispose> -[CONTAINS]-> <console.log(template)>
    // Expect edge: <template-literal> -[HAS_ELEMENT]-> <'closed '>
    // Expect edge: <template-literal> -[HAS_ELEMENT]-> <url>
    // Expect edge: <console.log(template)> -[PASSES_ARGUMENT]-> <template-literal>
    // Expect edge: <usingAwaitDeclaration> -[DECLARES]-> <stream>
    // Expect edge: <openStream('http://example.com')> -[PASSES_ARGUMENT]-> <'http://example.com'>
    // Expect edge: <usingAwaitDeclaration> -[RETURNS]-> <stream.readAll()>
    void code;
  });

  test('modules-helpers::export-inline-class', () => {
    const code = "export class HelperClass {\n  method() {\n    return true;\n  }\n}";
    // Expect node: CLASS <HelperClass>
    // Expect node: METHOD <HelperClass.method>
    // Expect node: LITERAL <true>
    // Expect edge: <module> -[DECLARES]-> <HelperClass>
    // Expect edge: <HelperClass> -[CONTAINS]-> <HelperClass.method>
    // Expect edge: <HelperClass.method> -[RETURNS]-> <true>
    void code;
  });

  test('modules-helpers::export-default-function', () => {
    const code = "export default function defaultHelper() {\n  return 'default';\n}";
    // Expect node: FUNCTION <defaultHelper>
    // Expect node: EXPORT <export-default>
    // Expect node: LITERAL <'default'>
    // Expect edge: <module> -[DECLARES]-> <defaultHelper>
    // Expect edge: <module> -[CONTAINS]-> <export-default>
    // Expect edge: <defaultHelper> -[RETURNS]-> <'default'>
    void code;
  });

  test('modules-helpers::export-inline-const', () => {
    const code = "export const HELPER_CONST = 42;";
    // Expect node: VARIABLE <HELPER_CONST>
    // Expect node: LITERAL <42>
    // Expect node: EXPORT <export-HELPER_CONST>
    // Expect edge: <module> -[DECLARES]-> <HELPER_CONST>
    // Expect edge: <module> -[CONTAINS]-> <export-HELPER_CONST>
    void code;
  });

  test('modules-helpers::export-default-class', () => {
    const code = "// export default class Router { navigate() { return '/'; } }\n// Also valid: export default class { anonymous() {} }\n// (Only one default export per module — shown above as function)";
    // Expect node: CLASS <Router>
    // Expect node: METHOD <Router.navigate>
    // Expect node: LITERAL <'/'>
    // Expect node: EXPORT <default-export>
    // Expect edge: <module> -[CONTAINS]-> <default-export>
    // Expect edge: <Router> -[CONTAINS]-> <Router.navigate>
    // Expect edge: <Router.navigate> -[RETURNS]-> <'/'>
    void code;
  });

  test('modules-helpers::export-as-default', () => {
    const code = "// Alternative syntax for default export:\n// export { someFunction as default };\n// Semantically equivalent to export default, but uses named export syntax";
    // Expect node: EXPORT <export-as-default>
    // Expect node: VARIABLE <someFunction>
    // Expect edge: <module> -[CONTAINS]-> <export-as-default>
    void code;
  });

  test('modules-default-anon::export-default-expression', () => {
    const code = "// export default [1, 2, 3];\n// export default { key: 'value' };\n// export default 42;";
    // Expect node: EXPORT <export-default-array>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: EXPORT <export-default-object>
    // Expect node: LITERAL <{ key: 'value' }>
    // Expect node: EXPORT <export-default-number>
    // Expect node: LITERAL <42>

    void code;
  });

  test('modern-es::import-meta-resolve', () => {
    const code = "const workerUrl = import.meta.resolve('./modules-helpers.js');\n\nasync function loadOptional(specifier) {\n  try {\n    const url = import.meta.resolve(specifier);\n    return await import(url);\n  } catch {\n    return null;\n  }\n}\n\n// --- WeakRef and FinalizationRegistry ---";
    // Expect node: VARIABLE <workerUrl>
    // Expect node: CALL <import.meta.resolve('./modules-helpers.js')>
    // Expect node: LITERAL <'./modules-helpers.js'>
    // Expect node: FUNCTION <loadOptional>
    // Expect node: PARAMETER <specifier>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: VARIABLE <url>
    // Expect node: CALL <import.meta.resolve(specifier)>
    // Expect node: CALL <import(url)>
    // Expect node: LITERAL <null>
    // Expect edge: <import.meta.resolve('./modules-helpers.js')> -[PASSES_ARGUMENT]-> <'./modules-helpers.js'>
    // Expect edge: <loadOptional> -[CONTAINS]-> <specifier>
    // Expect edge: <loadOptional> -[HAS_BODY]-> <try-block>
    // Expect edge: <loadOptional> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <import.meta.resolve(specifier)> -[PASSES_ARGUMENT]-> <specifier>
    // Expect edge: <try-block> -[RETURNS]-> <import(url)>
    // Expect edge: <import(url)> -[PASSES_ARGUMENT]-> <url>
    // Expect edge: <catch-block> -[RETURNS]-> <null>
    void code;
  });

  test('modules-helpers::export-default-expression', () => {
    const code = "// export default [1, 2, 3];\n// export default 42;\n// Any expression can be a default export";
    // Expect node: EXPORT <export-default-array>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: EXPORT <export-default-number>
    // Expect node: LITERAL <42>

    void code;
  });

  test('modules-reexport::reexport-named', () => {
    const code = "export { helperFunction } from './modules-helpers.js';";
    // Expect node: EXPORT <export-helperFunction>
    // Expect node: VARIABLE <helperFunction>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>
    // Expect node: MODULE <module>
    // Expect edge: <module> -[CONTAINS]-> <export-helperFunction>
    void code;
  });

  test('modules-reexport::reexport-aliased', () => {
    const code = "export { HELPER_CONST as RENAMED_CONST } from './modules-helpers.js';";
    // Expect node: EXPORT <reexport-aliased>
    // Expect node: VARIABLE <RENAMED_CONST>
    // Expect edge: <module> -[CONTAINS]-> <reexport-aliased>
    void code;
  });

  test('modern-es::finalization-registry', () => {
    const code = "const cleanupRegistry = new FinalizationRegistry((key) => {\n  console.log(`Object for key \"${key}\" was garbage collected`);\n});\n\nfunction trackObject(key, obj) {\n  cleanupRegistry.register(obj, key);\n}";
    // Expect node: VARIABLE <cleanupRegistry>
    // Expect node: CALL <new FinalizationRegistry>
    // Expect node: FUNCTION <cleanup-callback>
    // Expect node: PARAMETER <key>
    // Expect node: CALL <console.log>
    // Expect node: LITERAL <template-literal>
    // Expect node: FUNCTION <trackObject>
    // Expect node: PARAMETER <trackObject.key>
    // Expect node: PARAMETER <trackObject.obj>
    // Expect node: CALL <cleanupRegistry.register>
    // Expect edge: <new FinalizationRegistry> -[PASSES_ARGUMENT]-> <cleanup-callback>
    // Expect edge: <cleanup-callback> -[HAS_BODY]-> <key>
    // Expect edge: <cleanup-callback> -[HAS_BODY]-> <console.log>
    // Expect edge: <console.log> -[PASSES_ARGUMENT]-> <template-literal>
    // Expect edge: <trackObject> -[HAS_BODY]-> <trackObject.key>
    // Expect edge: <trackObject> -[HAS_BODY]-> <trackObject.obj>
    // Expect edge: <trackObject> -[HAS_BODY]-> <cleanupRegistry.register>
    // Expect edge: <cleanupRegistry.register> -[PASSES_ARGUMENT]-> <trackObject.obj>
    // Expect edge: <cleanupRegistry.register> -[PASSES_ARGUMENT]-> <trackObject.key>
    void code;
  });

  test('modules-reexport::reexport-default-as-named', () => {
    const code = "export { default as defaultFn } from './modules-helpers.js';";
    // Expect node: EXPORT <export-default-as-named>
    // Expect node: VARIABLE <defaultFn>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>
    // Expect node: EXTERNAL <./modules-helpers.js:default>

    void code;
  });

  test('modules-reexport::reexport-star', () => {
    const code = "export * from './declarations.js';";
    // Expect node: EXPORT <export-star>
    // Expect node: EXTERNAL_MODULE <./declarations.js>
    // Expect edge: <module> -[CONTAINS]-> <export-star>
    void code;
  });

  test('modules-helpers::export-multiple-names-same-binding', () => {
    const code = "const sharedValue = 'shared';\nexport { sharedValue, sharedValue as sharedAlias, sharedValue as sharedOther };";
    // Expect node: VARIABLE <sharedValue>
    // Expect node: LITERAL <'shared'>
    // Expect node: EXPORT <export-sharedValue>
    // Expect node: EXPORT <export-sharedAlias>
    // Expect node: EXPORT <export-sharedOther>

    void code;
  });

  test('modules-reexport::reexport-namespace', () => {
    const code = "export * as helpers from './modules-helpers.js';\n\n// --- Multi-file module patterns (construct references only) ---";
    // Expect node: EXPORT <export-namespace>
    // Expect node: IMPORT <import-all>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>

    void code;
  });

  test('modern-es::weakref-cache', () => {
    const code = "function createWeakCache() {\n  const cache = new Map();\n  return {\n    get(key, factory) {\n      const ref = cache.get(key);\n      const cached = ref?.deref();\n      if (cached) return cached;\n      const fresh = factory();\n      cache.set(key, new WeakRef(fresh));\n      return fresh;\n    },\n  };\n}";
    // Expect node: FUNCTION <createWeakCache>
    // Expect node: VARIABLE <cache>
    // Expect node: CALL <new Map()>
    // Expect node: LITERAL <object-literal>
    // Expect node: METHOD <get>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <factory>
    // Expect node: VARIABLE <ref>
    // Expect node: CALL <cache.get(key)>
    // Expect node: VARIABLE <cached>
    // Expect node: CALL <ref?.deref()>
    // Expect node: BRANCH <if-cached>
    // Expect node: VARIABLE <fresh>
    // Expect node: CALL <factory()>
    // Expect node: CALL <cache.set(key, new WeakRef(fresh))>
    // Expect node: CALL <new WeakRef(fresh)>
    // Expect edge: <createWeakCache> -[CONTAINS]-> <cache>
    // Expect edge: <createWeakCache> -[RETURNS]-> <object-literal>
    // Expect edge: <object-literal> -[HAS_PROPERTY]-> <get>
    // Expect edge: <get> -[CONTAINS]-> <key>
    // Expect edge: <get> -[CONTAINS]-> <factory>
    // Expect edge: <get> -[CONTAINS]-> <ref>
    // Expect edge: <cache.get(key)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <get> -[CONTAINS]-> <cached>
    // Expect edge: <get> -[CONTAINS]-> <if-cached>
    // Expect edge: <if-cached> -[HAS_CONDITION]-> <cached>
    // Expect edge: <if-cached> -[RETURNS]-> <cached>
    // Expect edge: <get> -[CONTAINS]-> <fresh>
    // Expect edge: <get> -[CONTAINS]-> <cache.set(key, new WeakRef(fresh))>
    // Expect edge: <cache.set(key, new WeakRef(fresh))> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <cache.set(key, new WeakRef(fresh))> -[PASSES_ARGUMENT]-> <new WeakRef(fresh)>
    // Expect edge: <new WeakRef(fresh)> -[PASSES_ARGUMENT]-> <fresh>
    // Expect edge: <get> -[RETURNS]-> <fresh>
    void code;
  });

  test('patterns::obj-destructuring-nested', () => {
    const code = "function objectDestructuringNested() {\n  const data = { outer: { inner: { deep: 42 } } };\n  const { outer: { inner: { deep } } } = data;\n  return deep;\n}";
    // Expect node: FUNCTION <objectDestructuringNested>
    // Expect node: VARIABLE <data>
    // Expect node: LITERAL <{ outer: { inner: { deep: 42 } } }>
    // Expect node: LITERAL <42>
    // Expect node: EXPRESSION <{ outer: { inner: { deep } } }>
    // Expect node: VARIABLE <deep>
    // Expect edge: <objectDestructuringNested> -[CONTAINS]-> <data>
    // Expect edge: <{ outer: { inner: { deep: 42 } } }> -[HAS_PROPERTY]-> <42>
    // Expect edge: <objectDestructuringNested> -[CONTAINS]-> <{ outer: { inner: { deep } } }>
    // Expect edge: <objectDestructuringNested> -[RETURNS]-> <deep>
    void code;
  });

  test('modules-reexport::star-import-namespace', () => {
    const code = "// import * as utils from './modules-helpers.js';\n// utils.helperFunction();          // method on namespace object\n// const { helperFunction } = utils; // destructured from namespace\n// const fn = utils['helperFunction']; // bracket access on namespace";
    // Expect node: IMPORT <import-utils>
    // Expect node: VARIABLE <utils>
    // Expect node: CALL <utils.helperFunction()>
    // Expect node: PROPERTY_ACCESS <utils.helperFunction>
    // Expect node: VARIABLE <helperFunction>
    // Expect node: VARIABLE <fn>
    // Expect node: PROPERTY_ACCESS <utils['helperFunction']>
    // Expect node: EXTERNAL_MODULE <./modules-helpers.js>

    void code;
  });

  test('patterns::param-destructuring-object', () => {
    const code = "function withObjectParam({ name, age, role = 'guest' }) {\n  return `${name} (${age}) - ${role}`;\n}";
    // Expect node: FUNCTION <withObjectParam>
    // Expect node: PARAMETER <destructured-param>
    // Expect node: VARIABLE <name>
    // Expect node: VARIABLE <age>
    // Expect node: VARIABLE <role>
    // Expect node: LITERAL <'guest'>
    // Expect node: EXPRESSION <template-literal>
    // Expect edge: <withObjectParam> -[CONTAINS]-> <destructured-param>
    // Expect edge: <role> -[DEFAULTS_TO]-> <'guest'>
    // Expect edge: <withObjectParam> -[RETURNS]-> <template-literal>
    void code;
  });

  test('patterns::array-destructuring-swap', () => {
    const code = "function arrayDestructuringSwap() {\n  let left = 'left';\n  let right = 'right';\n  [left, right] = [right, left];\n  return { left, right };\n}";
    // Expect node: FUNCTION <arrayDestructuringSwap>
    // Expect node: VARIABLE <left>
    // Expect node: LITERAL <'left'>
    // Expect node: VARIABLE <right>
    // Expect node: LITERAL <'right'>
    // Expect node: EXPRESSION <[left, right]>
    // Expect node: EXPRESSION <[right, left]>
    // Expect node: EXPRESSION <{ left, right }>
    // Expect edge: <arrayDestructuringSwap> -[CONTAINS]-> <left>
    // Expect edge: <arrayDestructuringSwap> -[CONTAINS]-> <right>
    // Expect edge: <arrayDestructuringSwap> -[RETURNS]-> <{ left, right }>
    void code;
  });

  test('modules-reexport::circular-import-live-binding', () => {
    const code = "// File A: export let count = 0; export function inc() { count++; }\n// File B: import { count, inc } from './a.js'; inc(); console.log(count); // 1 — live binding!\n// Graph impact: imported let is NOT a copy — mutations in source module visible to importers";
    // Expect node: MODULE <fileA>
    // Expect node: VARIABLE <count>
    // Expect node: LITERAL <0>
    // Expect node: FUNCTION <inc>
    // Expect node: EXPRESSION <count++>
    // Expect node: MODULE <fileB>
    // Expect node: IMPORT <import-a>
    // Expect node: VARIABLE <count:imported>
    // Expect node: VARIABLE <inc:imported>
    // Expect node: CALL <inc()>
    // Expect node: CALL <console.log(count)>
    // Expect edge: <fileA> -[DECLARES]-> <count>
    // Expect edge: <fileA> -[DECLARES]-> <inc>
    // Expect edge: <inc> -[CONTAINS]-> <count++>
    // Expect edge: <fileB> -[CONTAINS]-> <import-a>
    void code;
  });

  test('patterns::param-destructuring-array', () => {
    const code = "function withArrayParam([first, second, ...rest]) {\n  return { first, second, rest };\n}";
    // Expect node: FUNCTION <withArrayParam>
    // Expect node: PARAMETER <arrayParam>
    // Expect node: VARIABLE <first>
    // Expect node: VARIABLE <second>
    // Expect node: VARIABLE <rest>
    // Expect node: EXPRESSION <{ first, second, rest }>
    // Expect edge: <withArrayParam> -[CONTAINS]-> <arrayParam>
    // Expect edge: <withArrayParam> -[RETURNS]-> <{ first, second, rest }>
    void code;
  });

  test('modules-reexport::star-reexport-collision', () => {
    const code = "// a.js: export const x = 1;\n// b.js: export const x = 2;\n// barrel.js: export * from './a'; export * from './b'; // x is ambiguous!\n// Explicit re-export wins: export * from './a'; export { x } from './b';";
    // Expect node: MODULE <a.js>
    // Expect node: VARIABLE <a.js:x>
    // Expect node: LITERAL <1>
    // Expect node: MODULE <b.js>
    // Expect node: VARIABLE <b.js:x>
    // Expect node: LITERAL <2>
    // Expect node: MODULE <barrel.js>
    // Expect node: EXPORT <star-export-a>
    // Expect node: EXPORT <star-export-b>
    // Expect node: EXPORT <explicit-x-export>
    // Expect edge: <a.js> -[DECLARES]-> <a.js:x>
    // Expect edge: <b.js> -[DECLARES]-> <b.js:x>
    // Expect edge: <barrel.js> -[CONTAINS]-> <star-export-a>
    // Expect edge: <barrel.js> -[CONTAINS]-> <star-export-b>
    // Expect edge: <barrel.js> -[CONTAINS]-> <explicit-x-export>
    void code;
  });

  test('patterns::param-destructuring-nested', () => {
    const code = "function withNestedParam({ user: { name }, settings: { theme = 'light' } }) {\n  return { name, theme };\n}";
    // Expect node: FUNCTION <withNestedParam>
    // Expect node: PARAMETER <destructured-param>
    // Expect node: VARIABLE <name>
    // Expect node: VARIABLE <theme>
    // Expect node: LITERAL <'light'>
    // Expect node: EXPRESSION <{ name, theme }>
    // Expect edge: <withNestedParam> -[CONTAINS]-> <destructured-param>
    // Expect edge: <theme> -[DEFAULTS_TO]-> <'light'>
    // Expect edge: <withNestedParam> -[RETURNS]-> <{ name, theme }>
    void code;
  });

  test('modules-reexport::import-meta-url', () => {
    const code = "// const __filename = new URL(import.meta.url).pathname;\n// const __dirname = new URL('.', import.meta.url).pathname;\n// const workerUrl = new URL('./worker.js', import.meta.url); // implicit file dependency";
    // Expect node: VARIABLE <__filename>
    // Expect node: CALL <new URL(import.meta.url)>
    // Expect node: META_PROPERTY <import.meta.url>
    // Expect node: PROPERTY_ACCESS <new URL(import.meta.url).pathname>
    // Expect node: VARIABLE <__dirname>
    // Expect node: CALL <new URL('.', import.meta.url)>
    // Expect node: LITERAL <'.'>
    // Expect node: PROPERTY_ACCESS <new URL('.', import.meta.url).pathname>
    // Expect node: VARIABLE <workerUrl>
    // Expect node: CALL <new URL('./worker.js', import.meta.url)>
    // Expect node: LITERAL <'./worker.js'>
    // Expect node: FILE <./worker.js>
    // Expect edge: <new URL(import.meta.url)> -[PASSES_ARGUMENT]-> <import.meta.url>
    // Expect edge: <new URL('.', import.meta.url)> -[PASSES_ARGUMENT]-> <'.'>
    // Expect edge: <new URL('.', import.meta.url)> -[PASSES_ARGUMENT]-> <import.meta.url>
    // Expect edge: <new URL('./worker.js', import.meta.url)> -[PASSES_ARGUMENT]-> <'./worker.js'>
    // Expect edge: <new URL('./worker.js', import.meta.url)> -[PASSES_ARGUMENT]-> <import.meta.url>
    void code;
  });

  test('patterns::spread-calls', () => {
    const code = "function spreadInCalls() {\n  const args = [1, 2, 3];\n  const max = Math.max(...args);\n  return max;\n}";
    // Expect node: FUNCTION <spreadInCalls>
    // Expect node: VARIABLE <args>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: VARIABLE <max>
    // Expect node: CALL <Math.max(...args)>
    // Expect node: PROPERTY_ACCESS <Math.max>
    // Expect node: EXPRESSION <...args>
    // Expect edge: <spreadInCalls> -[CONTAINS]-> <args>
    // Expect edge: <spreadInCalls> -[CONTAINS]-> <max>
    // Expect edge: <Math.max(...args)> -[PASSES_ARGUMENT]-> <...args>
    // Expect edge: <...args> -[SPREADS_FROM]-> <args>
    // Expect edge: <spreadInCalls> -[RETURNS]-> <max>
    void code;
  });

  test('patterns::destructure-assign-nested-target', () => {
    const code = "function destructureAssignNestedTarget() {\n  const state = { user: { name: 'old' } };\n  let name;\n  ({ user: { name } } = state);\n  return name;\n}";
    // Expect node: FUNCTION <destructureAssignNestedTarget>
    // Expect node: VARIABLE <state>
    // Expect node: LITERAL <{ user: { name: 'old' } }>
    // Expect node: LITERAL <'old'>
    // Expect node: VARIABLE <name>
    // Expect node: EXPRESSION <{ user: { name } } = state>
    // Expect node: PROPERTY_ACCESS <state.user.name>
    // Expect edge: <destructureAssignNestedTarget> -[CONTAINS]-> <state>
    // Expect edge: <destructureAssignNestedTarget> -[CONTAINS]-> <name>
    // Expect edge: <{ user: { name: 'old' } }> -[CONTAINS]-> <'old'>
    // Expect edge: <destructureAssignNestedTarget> -[CONTAINS]-> <{ user: { name } } = state>
    // Expect edge: <destructureAssignNestedTarget> -[RETURNS]-> <name>
    void code;
  });

  test('patterns::spread-objects', () => {
    const code = "function spreadInObjects() {\n  const base = { a: 1, b: 2 };\n  const extended = { ...base, c: 3, b: 'overridden' };\n  const clone = { ...base };\n  return { extended, clone };\n}";
    // Expect node: FUNCTION <spreadInObjects>
    // Expect node: VARIABLE <base>
    // Expect node: LITERAL <{ a: 1, b: 2 }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: VARIABLE <extended>
    // Expect node: EXPRESSION <{ ...base, c: 3, b: 'overridden' }>
    // Expect node: LITERAL <3>
    // Expect node: LITERAL <'overridden'>
    // Expect node: VARIABLE <clone>
    // Expect node: EXPRESSION <{ ...base }>
    // Expect node: EXPRESSION <{ extended, clone }>
    // Expect edge: <spreadInObjects> -[CONTAINS]-> <base>
    // Expect edge: <spreadInObjects> -[CONTAINS]-> <extended>
    // Expect edge: <spreadInObjects> -[CONTAINS]-> <clone>
    // Expect edge: <{ a: 1, b: 2 }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ a: 1, b: 2 }> -[HAS_PROPERTY]-> <2>
    // Expect edge: <{ ...base, c: 3, b: 'overridden' }> -[SPREADS_FROM]-> <base>
    // Expect edge: <{ ...base, c: 3, b: 'overridden' }> -[HAS_PROPERTY]-> <3>
    // Expect edge: <{ ...base, c: 3, b: 'overridden' }> -[HAS_PROPERTY]-> <'overridden'>
    // Expect edge: <{ ...base }> -[SPREADS_FROM]-> <base>
    // Expect edge: <spreadInObjects> -[RETURNS]-> <{ extended, clone }>
    void code;
  });

  test('patterns::destructure-empty', () => {
    const code = "function destructureEmpty(obj, iter) {\n  const {} = obj;        // valid — no vars, triggers toString/valueOf\n  const [] = iter;       // valid — consumes iterator, creates nothing\n}";
    // Expect node: FUNCTION <destructureEmpty>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <iter>
    // Expect node: EXPRESSION <{} = obj>
    // Expect node: EXPRESSION <[] = iter>
    // Expect edge: <module> -[DECLARES]-> <destructureEmpty>
    // Expect edge: <destructureEmpty> -[CONTAINS]-> <obj>
    // Expect edge: <destructureEmpty> -[CONTAINS]-> <iter>
    // Expect edge: <destructureEmpty> -[CONTAINS]-> <{} = obj>
    // Expect edge: <destructureEmpty> -[CONTAINS]-> <[] = iter>
    void code;
  });

  test('patterns::spread-arrays', () => {
    const code = "function spreadInArrays() {\n  const source = [1, 2, 3];\n  const extended = [0, ...source, 4, 5];\n  const clone = [...source];\n  return { extended, clone };\n}";
    // Expect node: FUNCTION <spreadInArrays>
    // Expect node: VARIABLE <source>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect node: VARIABLE <extended>
    // Expect node: LITERAL <[0, ...source, 4, 5]>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <...source>
    // Expect node: LITERAL <4>
    // Expect node: LITERAL <5>
    // Expect node: VARIABLE <clone>
    // Expect node: LITERAL <[...source]>
    // Expect node: EXPRESSION <...source:clone>
    // Expect node: LITERAL <{ extended, clone }>
    // Expect edge: <spreadInArrays> -[CONTAINS]-> <source>
    // Expect edge: <spreadInArrays> -[CONTAINS]-> <extended>
    // Expect edge: <spreadInArrays> -[CONTAINS]-> <clone>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <1>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <2>
    // Expect edge: <[1, 2, 3]> -[HAS_ELEMENT]-> <3>
    // Expect edge: <[0, ...source, 4, 5]> -[HAS_ELEMENT]-> <0>
    // Expect edge: <[0, ...source, 4, 5]> -[HAS_ELEMENT]-> <...source>
    // Expect edge: <[0, ...source, 4, 5]> -[HAS_ELEMENT]-> <4>
    // Expect edge: <[0, ...source, 4, 5]> -[HAS_ELEMENT]-> <5>
    // Expect edge: <...source> -[SPREADS_FROM]-> <source>
    // Expect edge: <[...source]> -[HAS_ELEMENT]-> <...source:clone>
    // Expect edge: <...source:clone> -[SPREADS_FROM]-> <source>
    // Expect edge: <spreadInArrays> -[RETURNS]-> <{ extended, clone }>
    // Expect edge: <{ extended, clone }> -[HAS_PROPERTY]-> <extended>
    // Expect edge: <{ extended, clone }> -[HAS_PROPERTY]-> <clone>
    void code;
  });

  test('patterns::destructure-computed-key', () => {
    const code = "function destructureComputedKey() {\n  const key = 'name';\n  const { [key]: value } = { name: 'Alice' };\n  return value;\n}";
    // Expect node: FUNCTION <destructureComputedKey>
    // Expect node: VARIABLE <key>
    // Expect node: LITERAL <'name'>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <{ [key]: value }>
    // Expect node: LITERAL <{ name: 'Alice' }>
    // Expect node: LITERAL <'Alice'>
    // Expect edge: <destructureComputedKey> -[CONTAINS]-> <key>
    // Expect edge: <destructureComputedKey> -[CONTAINS]-> <value>
    // Expect edge: <destructureComputedKey> -[CONTAINS]-> <{ [key]: value }>
    // Expect edge: <{ name: 'Alice' }> -[HAS_PROPERTY]-> <'Alice'>
    // Expect edge: <destructureComputedKey> -[RETURNS]-> <value>
    void code;
  });

  test('patterns::destructure-nested-defaults-combined', () => {
    const code = "function destructureNestedDefaults() {\n  const { a: { b = 10 } = {} } = {};\n  return b; // 10 — default for inner AND outer\n}";
    // Expect node: FUNCTION <destructureNestedDefaults>
    // Expect node: VARIABLE <destructuring>
    // Expect node: VARIABLE <b>
    // Expect node: LITERAL <10>
    // Expect node: LITERAL <{}>
    // Expect node: LITERAL <{}:source>
    // Expect node: EXPRESSION <return b>
    // Expect edge: <destructureNestedDefaults> -[CONTAINS]-> <destructuring>
    // Expect edge: <b> -[DEFAULTS_TO]-> <10>
    // Expect edge: <destructuring> -[DEFAULTS_TO]-> <{}>
    // Expect edge: <destructureNestedDefaults> -[CONTAINS]-> <return b>
    // Expect edge: <destructureNestedDefaults> -[RETURNS]-> <return b>
    void code;
  });

  test('patterns::destructure-assign-to-properties', () => {
    const code = "function destructureAssignToProperties() {\n  const obj = {};\n  ({ a: obj.x, b: obj.y } = { a: 1, b: 2 });\n  return obj; // { x: 1, y: 2 }\n}";
    // Expect node: FUNCTION <destructureAssignToProperties>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{}>
    // Expect node: EXPRESSION <destructure-assign>
    // Expect node: PROPERTY_ACCESS <obj.x>
    // Expect node: PROPERTY_ACCESS <obj.y>
    // Expect node: LITERAL <{ a: 1, b: 2 }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect edge: <destructureAssignToProperties> -[DECLARES]-> <obj>
    // Expect edge: <destructureAssignToProperties> -[CONTAINS]-> <destructure-assign>
    // Expect edge: <{ a: 1, b: 2 }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ a: 1, b: 2 }> -[HAS_PROPERTY]-> <2>
    // Expect edge: <destructureAssignToProperties> -[RETURNS]-> <obj>
    void code;
  });

  test('patterns::spread-duplicate-key-override', () => {
    const code = "function spreadDuplicateKeyOverride(overrides) {\n  // Key 'debug' at positions (1) and (3) with spread between — (3) always wins\n  const config = {\n    debug: false,       // (1) explicit default\n    ...overrides,       // (2) user overrides — may set debug\n    debug: true,        // (3) THIS ALWAYS WINS — overrides the override\n    timestamp: Date.now(),\n  };\n  return config;\n}";
    // Expect node: FUNCTION <spreadDuplicateKeyOverride>
    // Expect node: PARAMETER <overrides>
    // Expect node: VARIABLE <config>
    // Expect node: EXPRESSION <config-object>
    // Expect node: PROPERTY <debug-1>
    // Expect node: LITERAL <false>
    // Expect node: EXPRESSION <...overrides>
    // Expect node: PROPERTY <debug-3>
    // Expect node: LITERAL <true>
    // Expect node: PROPERTY <timestamp>
    // Expect node: CALL <Date.now()>
    // Expect node: PROPERTY_ACCESS <Date.now>
    // Expect edge: <spreadDuplicateKeyOverride> -[CONTAINS]-> <overrides>
    // Expect edge: <spreadDuplicateKeyOverride> -[CONTAINS]-> <config>
    // Expect edge: <config-object> -[HAS_PROPERTY]-> <debug-1>
    // Expect edge: <config-object> -[HAS_ELEMENT]-> <...overrides>
    // Expect edge: <...overrides> -[SPREADS_FROM]-> <overrides>
    // Expect edge: <config-object> -[HAS_PROPERTY]-> <debug-3>
    // Expect edge: <debug-3> -[SHADOWS]-> <debug-1>
    // Expect edge: <config-object> -[HAS_PROPERTY]-> <timestamp>
    // Expect edge: <spreadDuplicateKeyOverride> -[RETURNS]-> <config>
    void code;
  });

  test('patterns::destructure-computed-default-rename', () => {
    const code = "function destructureComputedDefaultRename() {\n  const key = 'name';\n  const { [key]: renamed = 'anonymous' } = { name: 'Alice' };\n  const { [key]: missing = 'anonymous' } = {};\n  return { renamed, missing };\n}";
    // Expect node: FUNCTION <destructureComputedDefaultRename>
    // Expect node: VARIABLE <key>
    // Expect node: LITERAL <'name'>
    // Expect node: VARIABLE <renamed>
    // Expect node: LITERAL <'anonymous'>
    // Expect node: EXPRESSION <destructure1>
    // Expect node: LITERAL <{ name: 'Alice' }>
    // Expect node: LITERAL <'Alice'>
    // Expect node: VARIABLE <missing>
    // Expect node: EXPRESSION <destructure2>
    // Expect node: LITERAL <{}>
    // Expect node: EXPRESSION <{ renamed, missing }>
    // Expect edge: <destructureComputedDefaultRename> -[CONTAINS]-> <key>
    // Expect edge: <destructureComputedDefaultRename> -[CONTAINS]-> <renamed>
    // Expect edge: <destructureComputedDefaultRename> -[CONTAINS]-> <destructure1>
    // Expect edge: <renamed> -[DEFAULTS_TO]-> <'anonymous'>
    // Expect edge: <{ name: 'Alice' }> -[HAS_PROPERTY]-> <'Alice'>
    // Expect edge: <destructureComputedDefaultRename> -[CONTAINS]-> <missing>
    // Expect edge: <destructureComputedDefaultRename> -[CONTAINS]-> <destructure2>
    // Expect edge: <missing> -[DEFAULTS_TO]-> <'anonymous'>
    // Expect edge: <destructureComputedDefaultRename> -[RETURNS]-> <{ renamed, missing }>
    void code;
  });

  test('patterns::destructure-nested-rest', () => {
    const code = "function destructureNestedRest() {\n  const [first, ...[second, ...deep]] = [1, 2, 3, 4, 5];\n  // first=1, second=2, deep=[3,4,5]\n  return { first, second, deep };\n}";
    // Expect node: FUNCTION <destructureNestedRest>
    // Expect node: EXPRESSION <[first, ...[second, ...deep]]>
    // Expect node: VARIABLE <first>
    // Expect node: VARIABLE <second>
    // Expect node: VARIABLE <deep>
    // Expect node: LITERAL <[1, 2, 3, 4, 5]>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect node: LITERAL <4>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <{ first, second, deep }>
    // Expect edge: <destructureNestedRest> -[CONTAINS]-> <[first, ...[second, ...deep]]>
    // Expect edge: <[1, 2, 3, 4, 5]> -[HAS_ELEMENT]-> <1>
    // Expect edge: <[1, 2, 3, 4, 5]> -[HAS_ELEMENT]-> <2>
    // Expect edge: <[1, 2, 3, 4, 5]> -[HAS_ELEMENT]-> <3>
    // Expect edge: <[1, 2, 3, 4, 5]> -[HAS_ELEMENT]-> <4>
    // Expect edge: <[1, 2, 3, 4, 5]> -[HAS_ELEMENT]-> <5>
    // Expect edge: <destructureNestedRest> -[RETURNS]-> <{ first, second, deep }>
    void code;
  });

  test('property-access::prop-dot-notation', () => {
    const code = "function dotAccess(obj) {\n  const a = obj.name;\n  const b = obj.nested.deep.value;\n  return { a, b };\n}";
    // Expect node: FUNCTION <dotAccess>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <a>
    // Expect node: PROPERTY_ACCESS <obj.name>
    // Expect node: VARIABLE <b>
    // Expect node: PROPERTY_ACCESS <obj.nested>
    // Expect node: PROPERTY_ACCESS <obj.nested.deep>
    // Expect node: PROPERTY_ACCESS <obj.nested.deep.value>
    // Expect node: EXPRESSION <{ a, b }>
    // Expect edge: <dotAccess> -[CONTAINS]-> <obj>
    // Expect edge: <dotAccess> -[DECLARES]-> <a>
    // Expect edge: <dotAccess> -[DECLARES]-> <b>
    // Expect edge: <dotAccess> -[RETURNS]-> <{ a, b }>
    void code;
  });

  test('property-access::prop-deep-chain', () => {
    const code = "function deepChain(root) {\n  return root.level1.level2.level3.value;\n}";
    // Expect node: FUNCTION <deepChain>
    // Expect node: PARAMETER <root>
    // Expect node: PROPERTY_ACCESS <root.level1>
    // Expect node: PROPERTY_ACCESS <root.level1.level2>
    // Expect node: PROPERTY_ACCESS <root.level1.level2.level3>
    // Expect node: PROPERTY_ACCESS <root.level1.level2.level3.value>
    // Expect edge: <deepChain> -[CONTAINS]-> <root>
    // Expect edge: <deepChain> -[RETURNS]-> <root.level1.level2.level3.value>
    // Expect edge: <root.level1.level2> -[CHAINS_FROM]-> <root.level1>
    // Expect edge: <root.level1.level2.level3> -[CHAINS_FROM]-> <root.level1.level2>
    // Expect edge: <root.level1.level2.level3.value> -[CHAINS_FROM]-> <root.level1.level2.level3>
    void code;
  });

  test('property-access::prop-dynamic-access', () => {
    const code = "function dynamicAccess(obj, keys) {\n  const results = {};\n  for (const key of keys) {\n    results[key] = obj[key];\n  }\n  return results;\n}\n\n// --- Property chain ---";
    // Expect node: FUNCTION <dynamicAccess>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <keys>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <{}>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <key>
    // Expect node: PROPERTY_ACCESS <results[key]>
    // Expect node: PROPERTY_ACCESS <obj[key]>
    // Expect edge: <dynamicAccess> -[CONTAINS]-> <obj>
    // Expect edge: <dynamicAccess> -[CONTAINS]-> <keys>
    // Expect edge: <dynamicAccess> -[CONTAINS]-> <results>
    // Expect edge: <dynamicAccess> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <keys>
    // Expect edge: <for-of> -[CONTAINS]-> <key>
    // Expect edge: <dynamicAccess> -[RETURNS]-> <results>
    void code;
  });

  test('property-access::prop-bracket-notation', () => {
    const code = "function bracketAccess(obj, key) {\n  const a = obj['name'];\n  const b = obj[key];\n  const c = obj['complex-key'];\n  return { a, b, c };\n}";
    // Expect node: FUNCTION <bracketAccess>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <key>
    // Expect node: VARIABLE <a>
    // Expect node: PROPERTY_ACCESS <obj['name']>
    // Expect node: LITERAL <'name'>
    // Expect node: VARIABLE <b>
    // Expect node: PROPERTY_ACCESS <obj[key]>
    // Expect node: VARIABLE <c>
    // Expect node: PROPERTY_ACCESS <obj['complex-key']>
    // Expect node: LITERAL <'complex-key'>
    // Expect node: EXPRESSION <{ a, b, c }>
    // Expect edge: <bracketAccess> -[CONTAINS]-> <obj>
    // Expect edge: <bracketAccess> -[CONTAINS]-> <key>
    // Expect edge: <bracketAccess> -[CONTAINS]-> <a>
    // Expect edge: <bracketAccess> -[CONTAINS]-> <b>
    // Expect edge: <bracketAccess> -[CONTAINS]-> <c>
    // Expect edge: <obj['name']> -[USES]-> <'name'>
    // Expect edge: <obj[key]> -[USES]-> <key>
    // Expect edge: <obj['complex-key']> -[USES]-> <'complex-key'>
    // Expect edge: <bracketAccess> -[RETURNS]-> <{ a, b, c }>
    void code;
  });

  test('property-access::prop-dot-assign', () => {
    const code = "function dotAssign(obj) {\n  obj.name = 'new';\n  obj.nested = {};\n  obj.nested.deep = 42;\n  return obj;\n}";
    // Expect node: FUNCTION <dotAssign>
    // Expect node: PARAMETER <obj>
    // Expect node: PROPERTY_ACCESS <obj.name>
    // Expect node: LITERAL <'new'>
    // Expect node: PROPERTY_ACCESS <obj.nested>
    // Expect node: LITERAL <{}>
    // Expect node: PROPERTY_ACCESS <obj.nested.deep>
    // Expect node: LITERAL <42>
    // Expect edge: <dotAssign> -[CONTAINS]-> <obj>
    // Expect edge: <dotAssign> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::prop-object-from-entries', () => {
    const code = "function fromEntries(entries) {\n  return Object.fromEntries(entries);\n}\n\n// --- Object.assign ---";
    // Expect node: FUNCTION <fromEntries>
    // Expect node: PARAMETER <entries>
    // Expect node: CALL <Object.fromEntries(entries)>
    // Expect node: PROPERTY_ACCESS <Object.fromEntries>
    // Expect node: EXTERNAL <Object>
    // Expect edge: <fromEntries> -[HAS_BODY]-> <entries>
    // Expect edge: <fromEntries> -[RETURNS]-> <Object.fromEntries(entries)>
    // Expect edge: <Object.fromEntries(entries)> -[PASSES_ARGUMENT]-> <entries>
    void code;
  });

  test('property-access::prop-bracket-assign', () => {
    const code = "function bracketAssign(obj, key, value) {\n  obj[key] = value;\n  obj['fixed-key'] = 'fixed';\n  return obj;\n}";
    // Expect node: FUNCTION <bracketAssign>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <key>
    // Expect node: PARAMETER <value>
    // Expect node: PROPERTY_ACCESS <obj[key]>
    // Expect node: PROPERTY_ACCESS <obj['fixed-key']>
    // Expect node: LITERAL <'fixed'>
    // Expect edge: <bracketAssign> -[CONTAINS]-> <obj>
    // Expect edge: <bracketAssign> -[CONTAINS]-> <key>
    // Expect edge: <bracketAssign> -[CONTAINS]-> <value>
    // Expect edge: <bracketAssign> -[RETURNS]-> <obj>
    void code;
  });

  test('patterns::destructure-rest-own-only', () => {
    const code = "function destructureRestOwnOnly() {\n  const proto = { inherited: 1 };\n  const child = Object.create(proto);\n  child.own = 2;\n  child.also = 3;\n\n  const { own, ...rest } = child;\n  // rest === { also: 3 } — inherited NOT included in rest\n  // But:\n  const { inherited } = child; // 1 — named destructuring DOES access prototype\n  return { own, rest, inherited };\n}";
    // Expect node: FUNCTION <destructureRestOwnOnly>
    // Expect node: VARIABLE <proto>
    // Expect node: LITERAL <{ inherited: 1 }>
    // Expect node: VARIABLE <child>
    // Expect node: CALL <Object.create(proto)>
    // Expect node: PROPERTY_ACCESS <child.own>
    // Expect node: LITERAL <2>
    // Expect node: PROPERTY_ACCESS <child.also>
    // Expect node: LITERAL <3>
    // Expect node: EXPRESSION <{ own, ...rest }>
    // Expect node: VARIABLE <own>
    // Expect node: VARIABLE <rest>
    // Expect node: EXPRESSION <{ inherited }>
    // Expect node: VARIABLE <inherited>
    // Expect node: LITERAL <{ own, rest, inherited }>
    // Expect edge: <destructureRestOwnOnly> -[CONTAINS]-> <proto>
    // Expect edge: <destructureRestOwnOnly> -[CONTAINS]-> <child>
    // Expect edge: <Object.create(proto)> -[PASSES_ARGUMENT]-> <proto>
    // Expect edge: <destructureRestOwnOnly> -[CONTAINS]-> <{ own, ...rest }>
    // Expect edge: <destructureRestOwnOnly> -[CONTAINS]-> <{ inherited }>
    // Expect edge: <destructureRestOwnOnly> -[RETURNS]-> <{ own, rest, inherited }>
    void code;
  });

  test('property-access::prop-object-keys', () => {
    const code = "function objectEnumeration(obj) {\n  const keys = Object.keys(obj);\n  const values = Object.values(obj);\n  const entries = Object.entries(obj);\n  return { keys, values, entries };\n}";
    // Expect node: FUNCTION <objectEnumeration>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <keys>
    // Expect node: CALL <Object.keys(obj)>
    // Expect node: PROPERTY_ACCESS <Object.keys>
    // Expect node: VARIABLE <values>
    // Expect node: CALL <Object.values(obj)>
    // Expect node: PROPERTY_ACCESS <Object.values>
    // Expect node: VARIABLE <entries>
    // Expect node: CALL <Object.entries(obj)>
    // Expect node: PROPERTY_ACCESS <Object.entries>
    // Expect node: EXPRESSION <{ keys, values, entries }>
    // Expect edge: <objectEnumeration> -[CONTAINS]-> <obj>
    // Expect edge: <objectEnumeration> -[DECLARES]-> <keys>
    // Expect edge: <Object.keys(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <objectEnumeration> -[DECLARES]-> <values>
    // Expect edge: <Object.values(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <objectEnumeration> -[DECLARES]-> <entries>
    // Expect edge: <Object.entries(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <objectEnumeration> -[RETURNS]-> <{ keys, values, entries }>
    void code;
  });

  test('property-access::prop-freeze', () => {
    const code = "function frozen() {\n  const obj = { a: 1, b: { c: 2 } };\n  Object.freeze(obj);\n  obj.a = 999;       // silently fails (or throws in strict)\n  obj.b.c = 999;     // succeeds — shallow freeze\n  return obj;\n}";
    // Expect node: FUNCTION <frozen>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ a: 1, b: { c: 2 } }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <{ c: 2 }>
    // Expect node: LITERAL <2>
    // Expect node: CALL <Object.freeze(obj)>
    // Expect node: PROPERTY_ACCESS <obj.a>
    // Expect node: LITERAL <999>
    // Expect node: PROPERTY_ACCESS <obj.b.c>
    // Expect node: LITERAL <999-2>
    // Expect edge: <frozen> -[CONTAINS]-> <obj>
    // Expect edge: <{ a: 1, b: { c: 2 } }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ a: 1, b: { c: 2 } }> -[HAS_PROPERTY]-> <{ c: 2 }>
    // Expect edge: <{ c: 2 }> -[HAS_PROPERTY]-> <2>
    // Expect edge: <frozen> -[CONTAINS]-> <Object.freeze(obj)>
    // Expect edge: <Object.freeze(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <frozen> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::prop-structured-clone', () => {
    const code = "function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Getter/setter side effects ---";
    // Expect node: FUNCTION <deepClone>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <structuredClone(obj)>
    // Expect node: EXTERNAL <structuredClone>
    // Expect edge: <deepClone> -[CONTAINS]-> <obj>
    // Expect edge: <deepClone> -[RETURNS]-> <structuredClone(obj)>
    // Expect edge: <structuredClone(obj)> -[PASSES_ARGUMENT]-> <obj>
    void code;
  });

  test('property-access::prop-optional-chain-mixed', () => {
    const code = "function optionalChainMixed(obj) {\n  const a = obj?.level1?.level2;\n  const b = obj?.['dynamic-key']?.value;\n  const c = obj?.method?.();\n  const d = obj?.arr?.[0]?.name;\n  return { a, b, c, d };\n}\n\n// --- Property assignment patterns ---";
    // Expect node: FUNCTION <optionalChainMixed>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <a>
    // Expect node: PROPERTY_ACCESS <obj?.level1?.level2>
    // Expect node: VARIABLE <b>
    // Expect node: PROPERTY_ACCESS <obj?.['dynamic-key']?.value>
    // Expect node: LITERAL <'dynamic-key'>
    // Expect node: VARIABLE <c>
    // Expect node: CALL <obj?.method?.()>
    // Expect node: VARIABLE <d>
    // Expect node: PROPERTY_ACCESS <obj?.arr?.[0]?.name>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <{ a, b, c, d }>
    // Expect edge: <optionalChainMixed> -[CONTAINS]-> <obj>
    // Expect edge: <optionalChainMixed> -[CONTAINS]-> <a>
    // Expect edge: <optionalChainMixed> -[CONTAINS]-> <b>
    // Expect edge: <obj?.['dynamic-key']?.value> -[USES]-> <'dynamic-key'>
    // Expect edge: <optionalChainMixed> -[CONTAINS]-> <c>
    // Expect edge: <optionalChainMixed> -[CONTAINS]-> <d>
    // Expect edge: <obj?.arr?.[0]?.name> -[USES]-> <0>
    // Expect edge: <optionalChainMixed> -[RETURNS]-> <{ a, b, c, d }>
    void code;
  });

  test('property-access::prop-seal', () => {
    const code = "function sealed() {\n  const obj = { a: 1 };\n  Object.seal(obj);\n  obj.a = 2;         // allowed — existing property\n  obj.b = 3;         // silently fails — no new properties\n  delete obj.a;      // silently fails — cannot delete\n  return obj;\n}";
    // Expect node: FUNCTION <sealed>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ a: 1 }>
    // Expect node: LITERAL <1>
    // Expect node: CALL <Object.seal(obj)>
    // Expect node: PROPERTY_ACCESS <obj.a>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect node: PROPERTY_ACCESS <obj.b>
    // Expect node: EXPRESSION <delete obj.a>
    // Expect edge: <sealed> -[CONTAINS]-> <obj>
    // Expect edge: <{ a: 1 }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <Object.seal(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <sealed> -[CONTAINS]-> <Object.seal(obj)>
    // Expect edge: <sealed> -[CONTAINS]-> <delete obj.a>
    // Expect edge: <sealed> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::prop-delete', () => {
    const code = "function propertyDeletion(obj) {\n  const hadKey = 'key' in obj;\n  delete obj.key;\n  const hasKey = 'key' in obj;\n  return { hadKey, hasKey };\n}\n\n// --- Property enumeration order ---";
    // Expect node: FUNCTION <propertyDeletion>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <hadKey>
    // Expect node: EXPRESSION <'key' in obj>
    // Expect node: LITERAL <'key'>
    // Expect node: EXPRESSION <delete obj.key>
    // Expect node: PROPERTY_ACCESS <obj.key>
    // Expect node: VARIABLE <hasKey>
    // Expect node: EXPRESSION <'key' in obj_2>
    // Expect node: LITERAL <'key'_2>
    // Expect node: EXPRESSION <{ hadKey, hasKey }>
    // Expect edge: <propertyDeletion> -[CONTAINS]-> <obj>
    // Expect edge: <propertyDeletion> -[CONTAINS]-> <hadKey>
    // Expect edge: <delete obj.key> -[DELETES]-> <obj.key>
    // Expect edge: <propertyDeletion> -[CONTAINS]-> <hasKey>
    // Expect edge: <propertyDeletion> -[RETURNS]-> <{ hadKey, hasKey }>
    void code;
  });

  test('property-access::prop-prevent-extensions', () => {
    const code = "function preventExtensions() {\n  const obj = { a: 1 };\n  Object.preventExtensions(obj);\n  obj.b = 2;         // silently fails\n  obj.a = 99;        // allowed\n  delete obj.a;      // allowed\n  return obj;\n}\n\n// --- Property existence checks ---";
    // Expect node: FUNCTION <preventExtensions>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ a: 1 }>
    // Expect node: PROPERTY <a>
    // Expect node: LITERAL <1>
    // Expect node: CALL <Object.preventExtensions(obj)>
    // Expect node: PROPERTY_ACCESS <Object.preventExtensions>
    // Expect node: PROPERTY_ACCESS <obj.b>
    // Expect node: LITERAL <2>
    // Expect node: PROPERTY_ACCESS <obj.a>
    // Expect node: LITERAL <99>
    // Expect node: EXPRESSION <delete obj.a>
    // Expect edge: <preventExtensions> -[CONTAINS]-> <obj>
    // Expect edge: <{ a: 1 }> -[HAS_PROPERTY]-> <a>
    // Expect edge: <Object.preventExtensions(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <preventExtensions> -[CONTAINS]-> <Object.preventExtensions(obj)>
    // Expect edge: <preventExtensions> -[CONTAINS]-> <delete obj.a>
    // Expect edge: <preventExtensions> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::prop-compound-assign', () => {
    const code = "function compoundPropertyAssign(obj) {\n  obj.count += 1;\n  obj.total -= 5;\n  obj.name += ' suffix';\n  obj.flags |= 0x04;\n  obj.mask &= 0xff;\n  return obj;\n}\n\n// --- Object.keys / values / entries ---";
    // Expect node: FUNCTION <compoundPropertyAssign>
    // Expect node: PARAMETER <obj>
    // Expect node: PROPERTY_ACCESS <obj.count>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <obj.count += 1>
    // Expect node: PROPERTY_ACCESS <obj.total>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <obj.total -= 5>
    // Expect node: PROPERTY_ACCESS <obj.name>
    // Expect node: LITERAL <' suffix'>
    // Expect node: EXPRESSION <obj.name += ' suffix'>
    // Expect node: PROPERTY_ACCESS <obj.flags>
    // Expect node: LITERAL <0x04>
    // Expect node: EXPRESSION <obj.flags |= 0x04>
    // Expect node: PROPERTY_ACCESS <obj.mask>
    // Expect node: LITERAL <0xff>
    // Expect node: EXPRESSION <obj.mask &= 0xff>
    // Expect edge: <compoundPropertyAssign> -[CONTAINS]-> <obj>
    // Expect edge: <compoundPropertyAssign> -[CONTAINS]-> <obj.count += 1>
    // Expect edge: <compoundPropertyAssign> -[CONTAINS]-> <obj.total -= 5>
    // Expect edge: <compoundPropertyAssign> -[CONTAINS]-> <obj.name += ' suffix'>
    // Expect edge: <compoundPropertyAssign> -[CONTAINS]-> <obj.flags |= 0x04>
    // Expect edge: <compoundPropertyAssign> -[CONTAINS]-> <obj.mask &= 0xff>
    // Expect edge: <compoundPropertyAssign> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::prop-circular-object', () => {
    const code = "function circularObject() {\n  const a = {};\n  const b = { ref: a };\n  a.ref = b;\n  return a;\n}";
    // Expect node: FUNCTION <circularObject>
    // Expect node: VARIABLE <a>
    // Expect node: LITERAL <{}>
    // Expect node: VARIABLE <b>
    // Expect node: LITERAL <{ ref: a }>
    // Expect node: PROPERTY_ACCESS <a.ref>
    // Expect edge: <circularObject> -[CONTAINS]-> <a>
    // Expect edge: <circularObject> -[CONTAINS]-> <b>
    // Expect edge: <circularObject> -[RETURNS]-> <a>
    void code;
  });

  test('property-access::prop-object-assign', () => {
    const code = "function objectAssign() {\n  const target = { a: 1 };\n  const source1 = { b: 2 };\n  const source2 = { c: 3, a: 'overridden' };\n  return Object.assign(target, source1, source2);\n}\n\n// --- Object.freeze / seal / preventExtensions ---";
    // Expect node: FUNCTION <objectAssign>
    // Expect node: VARIABLE <target>
    // Expect node: LITERAL <{ a: 1 }>
    // Expect node: PROPERTY <target.a>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <source1>
    // Expect node: LITERAL <{ b: 2 }>
    // Expect node: PROPERTY <source1.b>
    // Expect node: LITERAL <2>
    // Expect node: VARIABLE <source2>
    // Expect node: LITERAL <{ c: 3, a: 'overridden' }>
    // Expect node: PROPERTY <source2.c>
    // Expect node: LITERAL <3>
    // Expect node: PROPERTY <source2.a>
    // Expect node: LITERAL <'overridden'>
    // Expect node: CALL <Object.assign(target, source1, source2)>
    // Expect node: PROPERTY_ACCESS <Object.assign>
    // Expect edge: <objectAssign> -[CONTAINS]-> <target>
    // Expect edge: <objectAssign> -[CONTAINS]-> <source1>
    // Expect edge: <objectAssign> -[CONTAINS]-> <source2>
    // Expect edge: <{ a: 1 }> -[HAS_PROPERTY]-> <target.a>
    // Expect edge: <{ b: 2 }> -[HAS_PROPERTY]-> <source1.b>
    // Expect edge: <{ c: 3, a: 'overridden' }> -[HAS_PROPERTY]-> <source2.c>
    // Expect edge: <{ c: 3, a: 'overridden' }> -[HAS_PROPERTY]-> <source2.a>
    // Expect edge: <Object.assign(target, source1, source2)> -[PASSES_ARGUMENT]-> <target>
    // Expect edge: <Object.assign(target, source1, source2)> -[PASSES_ARGUMENT]-> <source1>
    // Expect edge: <Object.assign(target, source1, source2)> -[PASSES_ARGUMENT]-> <source2>
    // Expect edge: <objectAssign> -[RETURNS]-> <Object.assign(target, source1, source2)>
    void code;
  });

  test('property-access::prop-proto-direct', () => {
    const code = "function protoDirectAssign() {\n  const obj = {};\n  obj.__proto__ = { inherited: true };\n  return obj.inherited;\n}\n\n// --- Null-prototype dictionary ---";
    // Expect node: FUNCTION <protoDirectAssign>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{}>
    // Expect node: PROPERTY_ACCESS <obj.__proto__>
    // Expect node: LITERAL <{ inherited: true }>
    // Expect node: PROPERTY_ACCESS <obj.inherited>
    // Expect edge: <protoDirectAssign> -[CONTAINS]-> <obj>
    // Expect edge: <protoDirectAssign> -[RETURNS]-> <obj.inherited>
    void code;
  });

  test('builtins::builtin-globalthis', () => {
    const code = "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---";
    // Expect node: FUNCTION <globalThisAccess>
    // Expect node: VARIABLE <g>
    // Expect node: EXTERNAL <globalThis>
    // Expect node: VARIABLE <hasConsole>
    // Expect node: EXPRESSION <'console' in globalThis>
    // Expect node: LITERAL <'console'>
    // Expect node: EXPRESSION <{ g, hasConsole }>
    // Expect edge: <globalThisAccess> -[CONTAINS]-> <g>
    // Expect edge: <globalThisAccess> -[CONTAINS]-> <hasConsole>
    // Expect edge: <globalThisAccess> -[RETURNS]-> <{ g, hasConsole }>
    void code;
  });

  test('property-access::prop-enumeration-order', () => {
    const code = "function enumerationOrder() {\n  const obj = {};\n  obj.b = 1;\n  obj.a = 2;\n  obj[1] = 3;\n  obj[0] = 4;\n  obj.c = 5;\n  // Integer keys first (sorted), then string keys (insertion order)\n  return Object.keys(obj); // ['0', '1', 'b', 'a', 'c']\n}\n\n// --- Getter/setter via Object.defineProperty ---";
    // Expect node: FUNCTION <enumerationOrder>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{}>
    // Expect node: PROPERTY_ACCESS <obj.b>
    // Expect node: LITERAL <1>
    // Expect node: PROPERTY_ACCESS <obj.a>
    // Expect node: LITERAL <2>
    // Expect node: PROPERTY_ACCESS <obj[1]>
    // Expect node: LITERAL <3>
    // Expect node: PROPERTY_ACCESS <obj[0]>
    // Expect node: LITERAL <4>
    // Expect node: PROPERTY_ACCESS <obj.c>
    // Expect node: LITERAL <5>
    // Expect node: CALL <Object.keys(obj)>
    // Expect node: PROPERTY_ACCESS <Object.keys>
    // Expect edge: <enumerationOrder> -[CONTAINS]-> <obj>
    // Expect edge: <Object.keys(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <enumerationOrder> -[RETURNS]-> <Object.keys(obj)>
    void code;
  });

  test('property-access::prop-symbol-key', () => {
    const code = "function symbolKey() {\n  const sym = Symbol('myKey');\n  const obj = { [sym]: 'symbol value' };\n  return obj[sym];\n}\n\n// --- __proto__ direct assignment ---";
    // Expect node: FUNCTION <symbolKey>
    // Expect node: VARIABLE <sym>
    // Expect node: CALL <Symbol('myKey')>
    // Expect node: LITERAL <'myKey'>
    // Expect node: VARIABLE <obj>
    // Expect node: EXPRESSION <{ [sym]: 'symbol value' }>
    // Expect node: PROPERTY <[sym]>
    // Expect node: LITERAL <'symbol value'>
    // Expect node: PROPERTY_ACCESS <obj[sym]>
    // Expect edge: <symbolKey> -[CONTAINS]-> <sym>
    // Expect edge: <symbolKey> -[CONTAINS]-> <obj>
    // Expect edge: <Symbol('myKey')> -[PASSES_ARGUMENT]-> <'myKey'>
    // Expect edge: <{ [sym]: 'symbol value' }> -[HAS_PROPERTY]-> <[sym]>
    // Expect edge: <symbolKey> -[RETURNS]-> <obj[sym]>
    void code;
  });

  test('property-access::prop-define-accessor', () => {
    const code = "function defineAccessor() {\n  const obj = { _value: 0 };\n  Object.defineProperty(obj, 'value', {\n    get() { return this._value; },\n    set(v) { this._value = Math.max(0, v); },\n    enumerable: true,\n  });\n  return obj;\n}\n\n// --- Object.is ---";
    // Expect node: FUNCTION <defineAccessor>
    // Expect node: VARIABLE <obj>
    // Expect node: LITERAL <{ _value: 0 }>
    // Expect node: LITERAL <0>
    // Expect node: CALL <Object.defineProperty(obj, 'value', {...})>
    // Expect node: EXTERNAL <Object.defineProperty>
    // Expect node: LITERAL <'value'>
    // Expect node: LITERAL <descriptor>
    // Expect node: GETTER <get>
    // Expect node: PROPERTY_ACCESS <this._value>
    // Expect node: SETTER <set>
    // Expect node: PARAMETER <v>
    // Expect node: PROPERTY_ACCESS <this._value_assign>
    // Expect node: CALL <Math.max(0, v)>
    // Expect node: EXTERNAL <Math.max>
    // Expect node: LITERAL <true>
    // Expect edge: <defineAccessor> -[CONTAINS]-> <obj>
    // Expect edge: <{ _value: 0 }> -[HAS_PROPERTY]-> <0>
    // Expect edge: <defineAccessor> -[CONTAINS]-> <Object.defineProperty(obj, 'value', {...})>
    // Expect edge: <Object.defineProperty(obj, 'value', {...})> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.defineProperty(obj, 'value', {...})> -[PASSES_ARGUMENT]-> <'value'>
    // Expect edge: <Object.defineProperty(obj, 'value', {...})> -[PASSES_ARGUMENT]-> <descriptor>
    // Expect edge: <descriptor> -[HAS_PROPERTY]-> <get>
    // Expect edge: <descriptor> -[HAS_PROPERTY]-> <set>
    // Expect edge: <descriptor> -[HAS_PROPERTY]-> <true>
    // Expect edge: <get> -[RETURNS]-> <this._value>
    // Expect edge: <set> -[CONTAINS]-> <v>
    // Expect edge: <Math.max(0, v)> -[PASSES_ARGUMENT]-> <0>
    // Expect edge: <Math.max(0, v)> -[PASSES_ARGUMENT]-> <v>
    // Expect edge: <defineAccessor> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::prop-object-is', () => {
    const code = "function objectIsComparison() {\n  const a = Object.is(NaN, NaN);       // true (unlike ===)\n  const b = Object.is(0, -0);          // false (unlike ===)\n  const c = Object.is(1, 1);           // true\n  return { a, b, c };\n}\n\n// --- structuredClone ---";
    // Expect node: FUNCTION <objectIsComparison>
    // Expect node: VARIABLE <a>
    // Expect node: CALL <Object.is(NaN, NaN)>
    // Expect node: PROPERTY_ACCESS <Object.is>
    // Expect node: LITERAL <NaN>
    // Expect node: VARIABLE <b>
    // Expect node: CALL <Object.is(0, -0)>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <-0>
    // Expect node: VARIABLE <c>
    // Expect node: CALL <Object.is(1, 1)>
    // Expect node: LITERAL <1>
    // Expect node: EXPRESSION <{ a, b, c }>
    // Expect edge: <objectIsComparison> -[CONTAINS]-> <a>
    // Expect edge: <objectIsComparison> -[CONTAINS]-> <b>
    // Expect edge: <objectIsComparison> -[CONTAINS]-> <c>
    // Expect edge: <Object.is(NaN, NaN)> -[PASSES_ARGUMENT]-> <NaN>
    // Expect edge: <Object.is(NaN, NaN)> -[PASSES_ARGUMENT]-> <NaN>
    // Expect edge: <Object.is(0, -0)> -[PASSES_ARGUMENT]-> <0>
    // Expect edge: <Object.is(0, -0)> -[PASSES_ARGUMENT]-> <-0>
    // Expect edge: <Object.is(1, 1)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <Object.is(1, 1)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <objectIsComparison> -[RETURNS]-> <{ a, b, c }>
    void code;
  });

  test('property-access::optional-chaining-delete', () => {
    const code = "function optionalChainingDelete(obj) {\n  const result = delete obj?.prop; // true if obj is nullish (no-op), normal delete otherwise\n  return result;\n}\n\n// --- Getter side effects in destructuring and spread ---";
    // Expect node: FUNCTION <optionalChainingDelete>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <result>
    // Expect node: EXPRESSION <delete obj?.prop>
    // Expect node: PROPERTY_ACCESS <obj?.prop>
    // Expect edge: <optionalChainingDelete> -[CONTAINS]-> <obj>
    // Expect edge: <optionalChainingDelete> -[CONTAINS]-> <result>
    // Expect edge: <delete obj?.prop> -[DELETES]-> <obj?.prop>
    // Expect edge: <optionalChainingDelete> -[RETURNS]-> <result>
    void code;
  });

  test('property-access::prop-circular-class', () => {
    const code = "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n}\n\n// --- Symbol as property key ---";
    // Expect node: CLASS <TreeNode>
    // Expect node: METHOD <TreeNode.constructor>
    // Expect node: PARAMETER <value>
    // Expect node: PROPERTY_ACCESS <this.value>
    // Expect node: PROPERTY_ACCESS <this.parent>
    // Expect node: LITERAL <null>
    // Expect node: PROPERTY_ACCESS <this.children>
    // Expect node: LITERAL <[]>
    // Expect node: METHOD <TreeNode.addChild>
    // Expect node: PARAMETER <child>
    // Expect node: PROPERTY_ACCESS <child.parent>
    // Expect node: CALL <this.children.push(child)>
    // Expect node: PROPERTY_ACCESS <this.children.push>
    // Expect edge: <TreeNode> -[CONTAINS]-> <TreeNode.constructor>
    // Expect edge: <TreeNode> -[CONTAINS]-> <TreeNode.addChild>
    // Expect edge: <TreeNode.constructor> -[CONTAINS]-> <value>
    // Expect edge: <TreeNode.addChild> -[CONTAINS]-> <child>
    // Expect edge: <TreeNode.addChild> -[CONTAINS]-> <this.children.push(child)>
    // Expect edge: <this.children.push(child)> -[PASSES_ARGUMENT]-> <child>
    void code;
  });

  test('property-access::prop-null-proto-dict', () => {
    const code = "function nullPrototypeDict() {\n  const dict = Object.create(null);\n  dict['key with spaces'] = 1;\n  dict['another-key'] = 2;\n  return dict;\n}\n\n// --- Proxy handler traps (full set) ---";
    // Expect node: FUNCTION <nullPrototypeDict>
    // Expect node: VARIABLE <dict>
    // Expect node: CALL <Object.create(null)>
    // Expect node: PROPERTY_ACCESS <Object.create>
    // Expect node: LITERAL <null>
    // Expect node: PROPERTY_ACCESS <dict['key with spaces']>
    // Expect node: LITERAL <'key with spaces'>
    // Expect node: LITERAL <1>
    // Expect node: PROPERTY_ACCESS <dict['another-key']>
    // Expect node: LITERAL <'another-key'>
    // Expect node: LITERAL <2>
    // Expect edge: <nullPrototypeDict> -[CONTAINS]-> <dict>
    // Expect edge: <Object.create(null)> -[PASSES_ARGUMENT]-> <null>
    // Expect edge: <nullPrototypeDict> -[RETURNS]-> <dict>
    void code;
  });

  test('property-access::prop-getter-only-no-setter', () => {
    const code = "function getterOnlyNoSetter() {\n  const obj = {\n    get value() { return 42; },\n  };\n  obj.value = 99; // silently fails in sloppy, throws in strict\n  return obj.value; // still 42\n}";
    // Expect node: FUNCTION <getterOnlyNoSetter>
    // Expect node: VARIABLE <obj>
    // Expect node: EXPRESSION <obj-literal>
    // Expect node: GETTER <value-getter>
    // Expect node: LITERAL <42>
    // Expect node: PROPERTY_ACCESS <obj.value-write>
    // Expect node: LITERAL <99>
    // Expect node: PROPERTY_ACCESS <obj.value-read>
    // Expect edge: <getterOnlyNoSetter> -[CONTAINS]-> <obj>
    // Expect edge: <obj-literal> -[HAS_PROPERTY]-> <value-getter>
    // Expect edge: <value-getter> -[RETURNS]-> <42>
    // Expect edge: <getterOnlyNoSetter> -[RETURNS]-> <obj.value-read>
    void code;
  });

  test('property-access::delete-array-hole', () => {
    const code = "function deleteArrayHole(arr) {\n  delete arr[1];                 // creates a HOLE — arr.length unchanged\n  return arr;                    // [1, empty, 3] if arr was [1, 2, 3]\n}";
    // Expect node: FUNCTION <deleteArrayHole>
    // Expect node: PARAMETER <arr>
    // Expect node: SIDE_EFFECT <delete arr[1]>
    // Expect node: PROPERTY_ACCESS <arr[1]>
    // Expect node: LITERAL <1>
    // Expect edge: <deleteArrayHole> -[DECLARES]-> <arr>
    // Expect edge: <deleteArrayHole> -[CONTAINS]-> <delete arr[1]>
    // Expect edge: <delete arr[1]> -[DELETES]-> <arr[1]>
    // Expect edge: <arr[1]> -[USES]-> <1>
    // Expect edge: <deleteArrayHole> -[RETURNS]-> <arr>
    void code;
  });

  test('property-access::prop-getter-side-effect', () => {
    const code = "function getterSideEffect() {\n  let callCount = 0;\n  const obj = {\n    get value() {\n      callCount++;\n      return 42;\n    },\n    set value(v) {\n      console.log('set to', v);\n    },\n  };\n  const x = obj.value;   // triggers getter — side effect\n  obj.value = 10;         // triggers setter — side effect\n  return { x, callCount };\n}\n\n// --- Circular references ---";
    // Expect node: FUNCTION <getterSideEffect>
    // Expect node: VARIABLE <callCount>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <obj>
    // Expect node: EXPRESSION <obj:object>
    // Expect node: GETTER <obj.value:getter>
    // Expect node: SETTER <obj.value:setter>
    // Expect node: PARAMETER <v>
    // Expect node: EXPRESSION <callCount++>
    // Expect node: LITERAL <42>
    // Expect node: CALL <console.log('set to', v)>
    // Expect node: LITERAL <'set to'>
    // Expect node: VARIABLE <x>
    // Expect node: PROPERTY_ACCESS <obj.value:read>
    // Expect node: PROPERTY_ACCESS <obj.value:write>
    // Expect node: LITERAL <10>
    // Expect node: EXPRESSION <return-object>
    // Expect edge: <getterSideEffect> -[CONTAINS]-> <callCount>
    // Expect edge: <getterSideEffect> -[CONTAINS]-> <obj>
    // Expect edge: <obj:object> -[HAS_PROPERTY]-> <obj.value:getter>
    // Expect edge: <obj:object> -[HAS_PROPERTY]-> <obj.value:setter>
    // Expect edge: <obj.value:getter> -[CONTAINS]-> <callCount++>
    // Expect edge: <obj.value:getter> -[RETURNS]-> <42>
    // Expect edge: <obj.value:setter> -[CONTAINS]-> <v>
    // Expect edge: <obj.value:setter> -[CONTAINS]-> <console.log('set to', v)>
    // Expect edge: <console.log('set to', v)> -[PASSES_ARGUMENT]-> <'set to'>
    // Expect edge: <console.log('set to', v)> -[PASSES_ARGUMENT]-> <v>
    // Expect edge: <getterSideEffect> -[CONTAINS]-> <x>
    // Expect edge: <getterSideEffect> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <x>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <callCount>
    void code;
  });

  test('prototypes::proto-static-method', () => {
    const code = "Person.create = function (name, age) {\n  return new Person(name, age);\n};\n\n// --- Prototypal inheritance ---";
    // Expect node: PROPERTY_ACCESS <Person.create>
    // Expect node: FUNCTION <Person.create:fn>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <age>
    // Expect node: CALL <new Person(name, age)>
    // Expect edge: <Person.create:fn> -[CONTAINS]-> <name>
    // Expect edge: <Person.create:fn> -[CONTAINS]-> <age>
    // Expect edge: <Person.create:fn> -[RETURNS]-> <new Person(name, age)>
    // Expect edge: <new Person(name, age)> -[PASSES_ARGUMENT]-> <name>
    // Expect edge: <new Person(name, age)> -[PASSES_ARGUMENT]-> <age>
    void code;
  });

  test('property-access::delete-computed-property', () => {
    const code = "function deleteComputed(obj, key) {\n  delete obj[key];               // computed delete — property name unknown at parse time\n  delete obj[key.toUpperCase()]; // delete with expression in key\n}";
    // Expect node: FUNCTION <deleteComputed>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <key>
    // Expect node: SIDE_EFFECT <delete obj[key]>
    // Expect node: PROPERTY_ACCESS <obj[key]>
    // Expect node: SIDE_EFFECT <delete obj[key.toUpperCase()]>
    // Expect node: PROPERTY_ACCESS <obj[key.toUpperCase()]>
    // Expect node: CALL <key.toUpperCase()>
    // Expect node: PROPERTY_ACCESS <key.toUpperCase>
    // Expect edge: <deleteComputed> -[CONTAINS]-> <obj>
    // Expect edge: <deleteComputed> -[CONTAINS]-> <key>
    // Expect edge: <deleteComputed> -[CONTAINS]-> <delete obj[key]>
    // Expect edge: <deleteComputed> -[CONTAINS]-> <delete obj[key.toUpperCase()]>
    // Expect edge: <delete obj[key]> -[DELETES]-> <obj[key]>
    // Expect edge: <delete obj[key.toUpperCase()]> -[DELETES]-> <obj[key.toUpperCase()]>
    void code;
  });

  test('prototypes::proto-object-create-null', () => {
    const code = "const nullProto = Object.create(null);\nnullProto.key = 'value';\n\n// --- Prototype chain inspection ---";
    // Expect node: VARIABLE <nullProto>
    // Expect node: CALL <Object.create(null)>
    // Expect node: PROPERTY_ACCESS <Object.create>
    // Expect node: LITERAL <null>
    // Expect node: PROPERTY_ACCESS <nullProto.key>
    // Expect node: LITERAL <'value'>
    // Expect edge: <MODULE> -[DECLARES]-> <nullProto>
    // Expect edge: <Object.create(null)> -[PASSES_ARGUMENT]-> <null>
    void code;
  });

  test('prototypes::proto-constructor-function', () => {
    const code = "function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function () {\n  return `Hi, I'm ${this.name}`;\n};\n\nPerson.prototype.toString = function () {\n  return `Person(${this.name}, ${this.age})`;\n};";
    // Expect node: FUNCTION <Person>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <age>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: PROPERTY_ACCESS <this.age>
    // Expect node: PROPERTY_ACCESS <Person.prototype>
    // Expect node: PROPERTY_ACCESS <Person.prototype.greet>
    // Expect node: FUNCTION <greet:fn>
    // Expect node: EXPRESSION <`Hi, I'm ${this.name}`>
    // Expect node: PROPERTY_ACCESS <Person.prototype.toString>
    // Expect node: FUNCTION <toString:fn>
    // Expect node: EXPRESSION <`Person(${this.name}, ${this.age})`>
    // Expect edge: <Person> -[HAS_BODY]-> <name>
    // Expect edge: <Person> -[HAS_BODY]-> <age>
    // Expect edge: <greet:fn> -[RETURNS]-> <`Hi, I'm ${this.name}`>
    // Expect edge: <toString:fn> -[RETURNS]-> <`Person(${this.name}, ${this.age})`>
    void code;
  });

  test('property-access::getter-throws-in-destructuring', () => {
    const code = "function getterThrowsInDestructuring() {\n  const dangerous = {\n    get boom() { throw new Error('trap!'); },\n    safe: 1,\n  };\n  try {\n    const { boom } = dangerous; // throws during destructuring\n  } catch (e) {\n    return e.message;\n  }\n}\n\n// --- Proxy wrapping a class constructor ---";
    // Expect node: FUNCTION <getterThrowsInDestructuring>
    // Expect node: VARIABLE <dangerous>
    // Expect node: EXPRESSION <dangerous:object>
    // Expect node: GETTER <boom:getter>
    // Expect node: EXPRESSION <throw new Error('trap!')>
    // Expect node: CALL <new Error('trap!')>
    // Expect node: LITERAL <'trap!'>
    // Expect node: PROPERTY <safe:property>
    // Expect node: LITERAL <1>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: EXPRESSION <{ boom } = dangerous>
    // Expect node: VARIABLE <boom>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <e>
    // Expect node: PROPERTY_ACCESS <e.message>
    // Expect edge: <getterThrowsInDestructuring> -[CONTAINS]-> <dangerous>
    // Expect edge: <dangerous:object> -[HAS_PROPERTY]-> <boom:getter>
    // Expect edge: <dangerous:object> -[HAS_PROPERTY]-> <safe:property>
    // Expect edge: <boom:getter> -[HAS_BODY]-> <throw new Error('trap!')>
    // Expect edge: <new Error('trap!')> -[PASSES_ARGUMENT]-> <'trap!'>
    // Expect edge: <getterThrowsInDestructuring> -[CONTAINS]-> <try-block>
    // Expect edge: <try-block> -[HAS_BODY]-> <{ boom } = dangerous>
    // Expect edge: <{ boom } = dangerous> -[DECLARES]-> <boom>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <e>
    // Expect edge: <getterThrowsInDestructuring> -[RETURNS]-> <e.message>
    void code;
  });

  test('property-access::getter-destructuring-side-effect', () => {
    const code = "function getterInDestructuring() {\n  let callCount = 0;\n  const sneaky = {\n    get value() { callCount++; return callCount; },\n  };\n  const { value } = sneaky;        // getter fires — callCount incremented\n  const copy = { ...sneaky };      // spread triggers ALL getters\n  return { value, copy, callCount };\n}";
    // Expect node: FUNCTION <getterInDestructuring>
    // Expect node: VARIABLE <callCount>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <sneaky>
    // Expect node: EXPRESSION <sneaky:obj>
    // Expect node: GETTER <sneaky.value>
    // Expect node: EXPRESSION <callCount++>
    // Expect node: VARIABLE <value>
    // Expect node: EXPRESSION <{ value }>
    // Expect node: VARIABLE <copy>
    // Expect node: EXPRESSION <...sneaky>
    // Expect node: EXPRESSION <copy:obj>
    // Expect node: EXPRESSION <return:obj>
    // Expect edge: <getterInDestructuring> -[CONTAINS]-> <callCount>
    // Expect edge: <getterInDestructuring> -[CONTAINS]-> <sneaky>
    // Expect edge: <sneaky:obj> -[HAS_PROPERTY]-> <sneaky.value>
    // Expect edge: <sneaky.value> -[RETURNS]-> <callCount++>
    // Expect edge: <getterInDestructuring> -[CONTAINS]-> <value>
    // Expect edge: <getterInDestructuring> -[CONTAINS]-> <copy>
    // Expect edge: <copy:obj> -[CONTAINS]-> <...sneaky>
    // Expect edge: <...sneaky> -[SPREADS_FROM]-> <sneaky>
    // Expect edge: <getterInDestructuring> -[RETURNS]-> <return:obj>
    // Expect edge: <return:obj> -[CONTAINS]-> <value>
    // Expect edge: <return:obj> -[CONTAINS]-> <copy>
    // Expect edge: <return:obj> -[CONTAINS]-> <callCount>
    void code;
  });

  test('property-access::prop-proxy-revocable', () => {
    const code = "function proxyRevocable() {\n  const { proxy, revoke } = Proxy.revocable({}, {\n    get(t, prop) { return prop in t ? t[prop] : 'default'; },\n  });\n  proxy.x = 1;\n  const val = proxy.x;\n  revoke();\n  return val;\n}";
    // Expect node: FUNCTION <proxyRevocable>
    // Expect node: VARIABLE <proxy>
    // Expect node: VARIABLE <revoke>
    // Expect node: CALL <Proxy.revocable({}, handler)>
    // Expect node: LITERAL <{}>
    // Expect node: FUNCTION <handler>
    // Expect node: METHOD <handler.get>
    // Expect node: PARAMETER <t>
    // Expect node: PARAMETER <prop>
    // Expect node: EXPRESSION <prop in t>
    // Expect node: PROPERTY_ACCESS <t[prop]>
    // Expect node: LITERAL <'default'>
    // Expect node: PROPERTY_ACCESS <proxy.x>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <val>
    // Expect node: PROPERTY_ACCESS <proxy.x:read>
    // Expect node: CALL <revoke()>
    // Expect edge: <proxyRevocable> -[CONTAINS]-> <proxy>
    // Expect edge: <proxyRevocable> -[CONTAINS]-> <revoke>
    // Expect edge: <Proxy.revocable({}, handler)> -[PASSES_ARGUMENT]-> <{}>
    // Expect edge: <Proxy.revocable({}, handler)> -[PASSES_ARGUMENT]-> <handler>
    // Expect edge: <handler> -[CONTAINS]-> <handler.get>
    // Expect edge: <handler.get> -[CONTAINS]-> <t>
    // Expect edge: <handler.get> -[CONTAINS]-> <prop>
    // Expect edge: <handler.get> -[CONTAINS]-> <prop in t>
    // Expect edge: <handler.get> -[RETURNS]-> <t[prop]>
    // Expect edge: <handler.get> -[RETURNS]-> <'default'>
    // Expect edge: <proxyRevocable> -[RETURNS]-> <val>
    void code;
  });

  test('prototypes::proto-set-prototype', () => {
    const code = "function reparent(obj, newParent) {\n  Object.setPrototypeOf(obj, newParent);\n  return obj;\n}\n\n// --- Mixin pattern ---";
    // Expect node: FUNCTION <reparent>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <newParent>
    // Expect node: CALL <Object.setPrototypeOf(obj, newParent)>
    // Expect node: PROPERTY_ACCESS <Object.setPrototypeOf>
    // Expect edge: <reparent> -[HAS_BODY]-> <obj>
    // Expect edge: <reparent> -[HAS_BODY]-> <newParent>
    // Expect edge: <reparent> -[CONTAINS]-> <Object.setPrototypeOf(obj, newParent)>
    // Expect edge: <Object.setPrototypeOf(obj, newParent)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.setPrototypeOf(obj, newParent)> -[PASSES_ARGUMENT]-> <newParent>
    // Expect edge: <reparent> -[RETURNS]-> <obj>
    void code;
  });

  test('property-access::getter-computed-destructuring', () => {
    const code = "function getterComputedDestructuring() {\n  let fired = false;\n  const obj = {\n    get secret() { fired = true; return 42; },\n  };\n  const key = 'secret';\n  const { [key]: extracted } = obj; // getter via computed key\n  return { extracted, fired };\n}";
    // Expect node: FUNCTION <getterComputedDestructuring>
    // Expect node: VARIABLE <fired>
    // Expect node: LITERAL <false>
    // Expect node: VARIABLE <obj>
    // Expect node: EXPRESSION <obj-literal>
    // Expect node: GETTER <obj.secret>
    // Expect node: LITERAL <true>
    // Expect node: LITERAL <42>
    // Expect node: VARIABLE <key>
    // Expect node: LITERAL <'secret'>
    // Expect node: VARIABLE <extracted>
    // Expect node: EXPRESSION <destructure-obj>
    // Expect node: PROPERTY_ACCESS <obj[key]>
    // Expect node: EXPRESSION <return-object>
    // Expect node: EXPRESSION <return-expression>
    // Expect edge: <getterComputedDestructuring> -[CONTAINS]-> <fired>
    // Expect edge: <getterComputedDestructuring> -[CONTAINS]-> <obj>
    // Expect edge: <obj-literal> -[HAS_PROPERTY]-> <obj.secret>
    // Expect edge: <obj.secret> -[RETURNS]-> <42>
    // Expect edge: <getterComputedDestructuring> -[CONTAINS]-> <key>
    // Expect edge: <getterComputedDestructuring> -[CONTAINS]-> <extracted>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <extracted>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <fired>
    // Expect edge: <return-expression> -[RETURNS]-> <return-object>
    // Expect edge: <getterComputedDestructuring> -[RETURNS]-> <return-expression>
    void code;
  });

  test('prototypes::proto-mixin-applied', () => {
    const code = "function Widget(name) {\n  this.name = name;\n}\napplyMixins(Widget, Serializable, EventEmitterMixin);\n\n// --- Property descriptors ---";
    // Expect node: FUNCTION <Widget>
    // Expect node: PARAMETER <name>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: CALL <applyMixins(Widget, Serializable, EventEmitterMixin)>
    // Expect node: EXTERNAL <applyMixins>
    // Expect node: EXTERNAL <Serializable>
    // Expect node: EXTERNAL <EventEmitterMixin>
    // Expect edge: <Widget> -[CONTAINS]-> <name>
    // Expect edge: <applyMixins(Widget, Serializable, EventEmitterMixin)> -[PASSES_ARGUMENT]-> <Widget>
    // Expect edge: <applyMixins(Widget, Serializable, EventEmitterMixin)> -[PASSES_ARGUMENT]-> <Serializable>
    // Expect edge: <applyMixins(Widget, Serializable, EventEmitterMixin)> -[PASSES_ARGUMENT]-> <EventEmitterMixin>
    void code;
  });

  test('builtins::regex-lookahead', () => {
    const code = "const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;";
    // Expect node: VARIABLE <posLookahead>
    // Expect node: LITERAL </\d+(?=px)/>
    // Expect node: VARIABLE <negLookahead>
    // Expect node: LITERAL </\d+(?!px)/>
    // Expect edge: <module> -[DECLARES]-> <posLookahead>
    // Expect edge: <module> -[DECLARES]-> <negLookahead>
    void code;
  });

  test('property-access::proxy-class-constructor', () => {
    const code = "class OriginalClass {\n  constructor(name) { this.name = name; }\n  greet() { return `Hi, ${this.name}`; }\n}\n\nconst TrackedClass = new Proxy(OriginalClass, {\n  construct(target, args, newTarget) {\n    return Reflect.construct(target, args, newTarget);\n  },\n});\n\nconst trackedInstance = new TrackedClass('Alice');\n\n// --- delete on computed properties ---";
    // Expect node: CLASS <OriginalClass>
    // Expect node: METHOD <OriginalClass.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: METHOD <OriginalClass.greet>
    // Expect node: EXPRESSION <`Hi, ${this.name}`>
    // Expect node: VARIABLE <TrackedClass>
    // Expect node: CALL <new Proxy(OriginalClass, {...})>
    // Expect node: LITERAL <proxy-handler>
    // Expect node: METHOD <construct>
    // Expect node: PARAMETER <target>
    // Expect node: PARAMETER <args>
    // Expect node: PARAMETER <newTarget>
    // Expect node: CALL <Reflect.construct(target, args, newTarget)>
    // Expect node: VARIABLE <trackedInstance>
    // Expect node: CALL <new TrackedClass('Alice')>
    // Expect node: LITERAL <'Alice'>
    // Expect edge: <OriginalClass> -[CONTAINS]-> <OriginalClass.constructor>
    // Expect edge: <OriginalClass> -[CONTAINS]-> <OriginalClass.greet>
    // Expect edge: <OriginalClass.constructor> -[CONTAINS]-> <name>
    // Expect edge: <OriginalClass.greet> -[RETURNS]-> <`Hi, ${this.name}`>
    // Expect edge: <new Proxy(OriginalClass, {...})> -[PASSES_ARGUMENT]-> <OriginalClass>
    // Expect edge: <new Proxy(OriginalClass, {...})> -[PASSES_ARGUMENT]-> <proxy-handler>
    // Expect edge: <proxy-handler> -[HAS_PROPERTY]-> <construct>
    // Expect edge: <construct> -[CONTAINS]-> <target>
    // Expect edge: <construct> -[CONTAINS]-> <args>
    // Expect edge: <construct> -[CONTAINS]-> <newTarget>
    // Expect edge: <construct> -[RETURNS]-> <Reflect.construct(target, args, newTarget)>
    // Expect edge: <Reflect.construct(target, args, newTarget)> -[PASSES_ARGUMENT]-> <target>
    // Expect edge: <Reflect.construct(target, args, newTarget)> -[PASSES_ARGUMENT]-> <args>
    // Expect edge: <Reflect.construct(target, args, newTarget)> -[PASSES_ARGUMENT]-> <newTarget>
    // Expect edge: <new TrackedClass('Alice')> -[PASSES_ARGUMENT]-> <'Alice'>
    void code;
  });

  test('prototypes::proto-define-property', () => {
    const code = "function createReadonly(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  });\n  return obj;\n}";
    // Expect node: FUNCTION <createReadonly>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <prop>
    // Expect node: PARAMETER <value>
    // Expect node: CALL <Object.defineProperty(obj, prop, {...})>
    // Expect node: PROPERTY_ACCESS <Object.defineProperty>
    // Expect node: EXPRESSION <descriptor>
    // Expect node: LITERAL <false>
    // Expect node: LITERAL <true>
    // Expect edge: <createReadonly> -[CONTAINS]-> <obj>
    // Expect edge: <createReadonly> -[CONTAINS]-> <prop>
    // Expect edge: <createReadonly> -[CONTAINS]-> <value>
    // Expect edge: <createReadonly> -[CONTAINS]-> <Object.defineProperty(obj, prop, {...})>
    // Expect edge: <Object.defineProperty(obj, prop, {...})> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.defineProperty(obj, prop, {...})> -[PASSES_ARGUMENT]-> <prop>
    // Expect edge: <Object.defineProperty(obj, prop, {...})> -[PASSES_ARGUMENT]-> <descriptor>
    // Expect edge: <descriptor> -[HAS_PROPERTY]-> <value>
    // Expect edge: <descriptor> -[HAS_PROPERTY]-> <false>
    // Expect edge: <descriptor> -[HAS_PROPERTY]-> <true>
    // Expect edge: <createReadonly> -[RETURNS]-> <obj>
    void code;
  });

  test('prototypes::proto-property-descriptor-read', () => {
    const code = "function getDescriptor(obj, prop) {\n  return Object.getOwnPropertyDescriptor(obj, prop);\n}\n\nfunction getAllDescriptors(obj) {\n  return Object.getOwnPropertyDescriptors(obj);\n}\n\n// --- instanceof with Symbol.hasInstance ---";
    // Expect node: FUNCTION <getDescriptor>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <prop>
    // Expect node: CALL <Object.getOwnPropertyDescriptor(obj, prop)>
    // Expect node: PROPERTY_ACCESS <Object.getOwnPropertyDescriptor>
    // Expect node: FUNCTION <getAllDescriptors>
    // Expect node: PARAMETER <obj2>
    // Expect node: CALL <Object.getOwnPropertyDescriptors(obj)>
    // Expect node: PROPERTY_ACCESS <Object.getOwnPropertyDescriptors>
    // Expect edge: <getDescriptor> -[HAS_BODY]-> <obj>
    // Expect edge: <getDescriptor> -[HAS_BODY]-> <prop>
    // Expect edge: <getDescriptor> -[RETURNS]-> <Object.getOwnPropertyDescriptor(obj, prop)>
    // Expect edge: <Object.getOwnPropertyDescriptor(obj, prop)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.getOwnPropertyDescriptor(obj, prop)> -[PASSES_ARGUMENT]-> <prop>
    // Expect edge: <getAllDescriptors> -[HAS_BODY]-> <obj2>
    // Expect edge: <getAllDescriptors> -[RETURNS]-> <Object.getOwnPropertyDescriptors(obj)>
    // Expect edge: <Object.getOwnPropertyDescriptors(obj)> -[PASSES_ARGUMENT]-> <obj2>
    void code;
  });

  test('prototypes::proto-object-create', () => {
    const code = "const baseProto = {\n  type: 'base',\n  identify() {\n    return this.type;\n  },\n};\n\nconst derived = Object.create(baseProto);\nderived.type = 'derived';\nderived.extra = function () {\n  return 'extra';\n};";
    // Expect node: VARIABLE <baseProto>
    // Expect node: LITERAL <baseProto:object>
    // Expect node: PROPERTY <baseProto.type>
    // Expect node: LITERAL <'base'>
    // Expect node: METHOD <baseProto.identify>
    // Expect node: PROPERTY_ACCESS <this.type>
    // Expect node: VARIABLE <derived>
    // Expect node: CALL <Object.create(baseProto)>
    // Expect node: PROPERTY <derived.type>
    // Expect node: LITERAL <'derived'>
    // Expect node: PROPERTY <derived.extra>
    // Expect node: FUNCTION <derived.extra:fn>
    // Expect node: LITERAL <'extra'>
    // Expect edge: <baseProto:object> -[HAS_PROPERTY]-> <baseProto.type>
    // Expect edge: <baseProto:object> -[HAS_PROPERTY]-> <baseProto.identify>
    // Expect edge: <baseProto.identify> -[RETURNS]-> <this.type>
    // Expect edge: <Object.create(baseProto)> -[PASSES_ARGUMENT]-> <baseProto>
    // Expect edge: <derived.extra:fn> -[RETURNS]-> <'extra'>
    void code;
  });

  test('prototypes::monkey-patch-builtin', () => {
    const code = "Array.prototype.last = function () {\n  return this[this.length - 1];\n};\n[1, 2, 3].last();";
    // Expect node: PROPERTY_ACCESS <Array.prototype.last>
    // Expect node: FUNCTION <last:fn>
    // Expect node: PROPERTY_ACCESS <this[this.length - 1]>
    // Expect node: EXPRESSION <this.length - 1>
    // Expect node: PROPERTY_ACCESS <this.length>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <[1, 2, 3]>
    // Expect node: CALL <[1, 2, 3].last()>
    // Expect edge: <last:fn> -[RETURNS]-> <this[this.length - 1]>
    void code;
  });

  test('builtins::regex-lookbehind', () => {
    const code = "const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;";
    // Expect node: VARIABLE <posLookbehind>
    // Expect node: LITERAL </(?<=\$)\d+/>
    // Expect node: VARIABLE <negLookbehind>
    // Expect node: LITERAL </(?<!\$)\d+/>
    // Expect edge: <module> -[DECLARES]-> <posLookbehind>
    // Expect edge: <module> -[DECLARES]-> <negLookbehind>
    void code;
  });

  test('prototypes::proto-inheritance-chain', () => {
    const code = "function Employee(name, age, role) {\n  Person.call(this, name, age);\n  this.role = role;\n}\n\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\nEmployee.prototype.describe = function () {\n  return `${this.greet()}, I'm a ${this.role}`;\n};\n\n// --- Object.create ---";
    // Expect node: FUNCTION <Employee>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <age>
    // Expect node: PARAMETER <role>
    // Expect node: CALL <Person.call(this, name, age)>
    // Expect node: PROPERTY_ACCESS <this.role>
    // Expect node: PROPERTY_ACCESS <Employee.prototype>
    // Expect node: CALL <Object.create(Person.prototype)>
    // Expect node: PROPERTY_ACCESS <Person.prototype>
    // Expect node: PROPERTY_ACCESS <Employee.prototype.constructor>
    // Expect node: METHOD <Employee.prototype.describe>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: CALL <this.greet()>
    // Expect edge: <Employee> -[CONTAINS]-> <name>
    // Expect edge: <Employee> -[CONTAINS]-> <age>
    // Expect edge: <Employee> -[CONTAINS]-> <role>
    // Expect edge: <Employee> -[CONTAINS]-> <Person.call(this, name, age)>
    // Expect edge: <Person.call(this, name, age)> -[PASSES_ARGUMENT]-> <name>
    // Expect edge: <Person.call(this, name, age)> -[PASSES_ARGUMENT]-> <age>
    // Expect edge: <Object.create(Person.prototype)> -[PASSES_ARGUMENT]-> <Person.prototype>
    // Expect edge: <Employee.prototype> -[HAS_PROPERTY]-> <Employee.prototype.describe>
    // Expect edge: <Employee.prototype.describe> -[RETURNS]-> <template-literal>
    void code;
  });

  test('prototypes::proto-symbol-hasinstance', () => {
    const code = "class EvenNumber {\n  static [Symbol.hasInstance](instance) {\n    return typeof instance === 'number' && instance % 2 === 0;\n  }\n}\n\n// --- Monkey-patching ---";
    // Expect node: CLASS <EvenNumber>
    // Expect node: METHOD <EvenNumber[Symbol.hasInstance]>
    // Expect node: PARAMETER <instance>
    // Expect node: EXPRESSION <typeof instance === 'number' && instance % 2 === 0>
    // Expect node: LITERAL <'number'>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <0>
    // Expect edge: <EvenNumber> -[CONTAINS]-> <EvenNumber[Symbol.hasInstance]>
    // Expect edge: <EvenNumber[Symbol.hasInstance]> -[CONTAINS]-> <instance>
    // Expect edge: <EvenNumber[Symbol.hasInstance]> -[RETURNS]-> <typeof instance === 'number' && instance % 2 === 0>
    void code;
  });

  test('prototypes::proto-define-getter-setter', () => {
    const code = "function withComputedProp(obj) {\n  let _internal = 0;\n  Object.defineProperty(obj, 'computed', {\n    get() { return _internal * 2; },\n    set(v) { _internal = v; },\n    enumerable: true,\n    configurable: true,\n  });\n  return obj;\n}";
    // Expect node: FUNCTION <withComputedProp>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <_internal>
    // Expect node: LITERAL <0>
    // Expect node: CALL <Object.defineProperty>
    // Expect node: LITERAL <'computed'>
    // Expect node: EXPRESSION <computed-descriptor>
    // Expect node: GETTER <computed-getter>
    // Expect node: SETTER <computed-setter>
    // Expect node: PARAMETER <v>
    // Expect node: EXPRESSION <_internal * 2>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <true-enumerable>
    // Expect node: LITERAL <true-configurable>
    // Expect edge: <withComputedProp> -[CONTAINS]-> <obj>
    // Expect edge: <withComputedProp> -[CONTAINS]-> <_internal>
    // Expect edge: <withComputedProp> -[CONTAINS]-> <Object.defineProperty>
    // Expect edge: <Object.defineProperty> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.defineProperty> -[PASSES_ARGUMENT]-> <'computed'>
    // Expect edge: <Object.defineProperty> -[PASSES_ARGUMENT]-> <computed-descriptor>
    // Expect edge: <computed-descriptor> -[HAS_PROPERTY]-> <computed-getter>
    // Expect edge: <computed-descriptor> -[HAS_PROPERTY]-> <computed-setter>
    // Expect edge: <computed-descriptor> -[HAS_PROPERTY]-> <true-enumerable>
    // Expect edge: <computed-descriptor> -[HAS_PROPERTY]-> <true-configurable>
    // Expect edge: <computed-getter> -[RETURNS]-> <_internal * 2>
    // Expect edge: <computed-setter> -[CONTAINS]-> <v>
    // Expect edge: <withComputedProp> -[RETURNS]-> <obj>
    void code;
  });

  test('prototypes::proto-chain-inspection', () => {
    const code = "function inspectPrototype(obj) {\n  const proto = Object.getPrototypeOf(obj);\n  const hasOwn = obj.hasOwnProperty('name');\n  const hasOwn2 = Object.hasOwn(obj, 'name');\n  const inChain = 'toString' in obj;\n  return { proto, hasOwn, hasOwn2, inChain };\n}\n\n// --- Object.setPrototypeOf ---";
    // Expect node: FUNCTION <inspectPrototype>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <proto>
    // Expect node: CALL <Object.getPrototypeOf(obj)>
    // Expect node: PROPERTY_ACCESS <Object.getPrototypeOf>
    // Expect node: VARIABLE <hasOwn>
    // Expect node: CALL <obj.hasOwnProperty('name')>
    // Expect node: PROPERTY_ACCESS <obj.hasOwnProperty>
    // Expect node: LITERAL <'name'>
    // Expect node: VARIABLE <hasOwn2>
    // Expect node: CALL <Object.hasOwn(obj, 'name')>
    // Expect node: PROPERTY_ACCESS <Object.hasOwn>
    // Expect node: LITERAL <'name'2>
    // Expect node: VARIABLE <inChain>
    // Expect node: EXPRESSION <'toString' in obj>
    // Expect node: LITERAL <'toString'>
    // Expect node: EXPRESSION <{ proto, hasOwn, hasOwn2, inChain }>
    // Expect edge: <inspectPrototype> -[CONTAINS]-> <obj>
    // Expect edge: <inspectPrototype> -[CONTAINS]-> <proto>
    // Expect edge: <Object.getPrototypeOf(obj)> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <inspectPrototype> -[CONTAINS]-> <hasOwn>
    // Expect edge: <obj.hasOwnProperty('name')> -[PASSES_ARGUMENT]-> <'name'>
    // Expect edge: <inspectPrototype> -[CONTAINS]-> <hasOwn2>
    // Expect edge: <Object.hasOwn(obj, 'name')> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.hasOwn(obj, 'name')> -[PASSES_ARGUMENT]-> <'name'2>
    // Expect edge: <inspectPrototype> -[CONTAINS]-> <inChain>
    // Expect edge: <inspectPrototype> -[RETURNS]-> <{ proto, hasOwn, hasOwn2, inChain }>
    void code;
  });

  test('prototypes::monkey-patch-third-party', () => {
    const code = "function patchRouter(router) {\n  const originalGet = router.get;\n  router.get = function (path, handler) {\n    console.log(`GET ${path}`);\n    return originalGet.call(this, path, handler);\n  };\n}";
    // Expect node: FUNCTION <patchRouter>
    // Expect node: PARAMETER <router>
    // Expect node: VARIABLE <originalGet>
    // Expect node: PROPERTY_ACCESS <router.get>
    // Expect node: FUNCTION <router.get:replacement>
    // Expect node: PARAMETER <path>
    // Expect node: PARAMETER <handler>
    // Expect node: CALL <console.log>
    // Expect node: LITERAL <'GET '>
    // Expect node: EXPRESSION <`GET ${path}`>
    // Expect node: CALL <originalGet.call>
    // Expect node: LITERAL <this>
    // Expect edge: <patchRouter> -[CONTAINS]-> <router>
    // Expect edge: <patchRouter> -[DECLARES]-> <originalGet>
    // Expect edge: <router.get:replacement> -[CONTAINS]-> <path>
    // Expect edge: <router.get:replacement> -[CONTAINS]-> <handler>
    // Expect edge: <router.get:replacement> -[CONTAINS]-> <console.log>
    // Expect edge: <console.log> -[PASSES_ARGUMENT]-> <`GET ${path}`>
    // Expect edge: <router.get:replacement> -[RETURNS]-> <originalGet.call>
    // Expect edge: <originalGet.call> -[PASSES_ARGUMENT]-> <this>
    // Expect edge: <originalGet.call> -[PASSES_ARGUMENT]-> <path>
    // Expect edge: <originalGet.call> -[PASSES_ARGUMENT]-> <handler>
    void code;
  });

  test('prototypes::super-in-object-literal', () => {
    const code = "const parentObj = {\n  greet() { return 'hello from parent'; },\n};\n\nconst childObj = {\n  __proto__: parentObj,\n  greet() {\n    return super.greet() + ' and child';\n  },\n};";
    // Expect node: VARIABLE <parentObj>
    // Expect node: EXPRESSION <parentObj:obj>
    // Expect node: METHOD <parentObj.greet>
    // Expect node: LITERAL <'hello from parent'>
    // Expect node: VARIABLE <childObj>
    // Expect node: EXPRESSION <childObj:obj>
    // Expect node: PROPERTY_ACCESS <__proto__>
    // Expect node: METHOD <childObj.greet>
    // Expect node: CALL <super.greet()>
    // Expect node: EXPRESSION <super.greet() + ' and child'>
    // Expect node: LITERAL <' and child'>
    // Expect edge: <parentObj:obj> -[CONTAINS]-> <parentObj.greet>
    // Expect edge: <parentObj.greet> -[RETURNS]-> <'hello from parent'>
    // Expect edge: <childObj:obj> -[CONTAINS]-> <__proto__>
    // Expect edge: <childObj:obj> -[CONTAINS]-> <childObj.greet>
    // Expect edge: <childObj.greet> -[RETURNS]-> <super.greet() + ' and child'>
    void code;
  });

  test('prototypes::monkey-patch-global', () => {
    const code = "const originalFetch = globalThis.fetch;\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n  apply(target, thisArg, args) {\n    console.log('intercepted:', args[0]);\n    return Reflect.apply(target, thisArg, args);\n  },\n});";
    // Expect node: VARIABLE <originalFetch>
    // Expect node: PROPERTY_ACCESS <globalThis.fetch>
    // Expect node: CALL <fetch-proxy>
    // Expect node: METHOD <apply-handler>
    // Expect node: PARAMETER <target>
    // Expect node: PARAMETER <thisArg>
    // Expect node: PARAMETER <args>
    // Expect node: CALL <console.log>
    // Expect node: PROPERTY_ACCESS <args[0]>
    // Expect node: CALL <Reflect.apply>
    // Expect edge: <fetch-proxy> -[PASSES_ARGUMENT]-> <globalThis.fetch>
    // Expect edge: <fetch-proxy> -[HAS_PROPERTY]-> <apply-handler>
    // Expect edge: <apply-handler> -[RECEIVES_ARGUMENT]-> <target>
    // Expect edge: <apply-handler> -[RECEIVES_ARGUMENT]-> <thisArg>
    // Expect edge: <apply-handler> -[RECEIVES_ARGUMENT]-> <args>
    // Expect edge: <apply-handler> -[CONTAINS]-> <console.log>
    // Expect edge: <apply-handler> -[RETURNS]-> <Reflect.apply>
    // Expect edge: <console.log> -[PASSES_ARGUMENT]-> <args[0]>
    // Expect edge: <Reflect.apply> -[PASSES_ARGUMENT]-> <target>
    // Expect edge: <Reflect.apply> -[PASSES_ARGUMENT]-> <thisArg>
    // Expect edge: <Reflect.apply> -[PASSES_ARGUMENT]-> <args>
    void code;
  });

  test('runtime-apis::runtime-message-channel', () => {
    const code = "function messageChannelPattern() {\n  const { port1, port2 } = new MessageChannel();\n  port1.onmessage = (e) => console.log(e.data);\n  port2.postMessage('hello');\n}";
    // Expect node: FUNCTION <messageChannelPattern>
    // Expect node: VARIABLE <port1>
    // Expect node: VARIABLE <port2>
    // Expect node: CALL <new MessageChannel()>
    // Expect node: PROPERTY_ACCESS <port1.onmessage>
    // Expect node: FUNCTION <onmessage-handler>
    // Expect node: PARAMETER <e>
    // Expect node: CALL <console.log(e.data)>
    // Expect node: PROPERTY_ACCESS <e.data>
    // Expect node: CALL <port2.postMessage('hello')>
    // Expect node: LITERAL <'hello'>
    // Expect edge: <messageChannelPattern> -[CONTAINS]-> <port1>
    // Expect edge: <messageChannelPattern> -[CONTAINS]-> <port2>
    // Expect edge: <onmessage-handler> -[CONTAINS]-> <e>
    // Expect edge: <onmessage-handler> -[CONTAINS]-> <console.log(e.data)>
    // Expect edge: <console.log(e.data)> -[PASSES_ARGUMENT]-> <e.data>
    // Expect edge: <messageChannelPattern> -[CONTAINS]-> <port2.postMessage('hello')>
    // Expect edge: <port2.postMessage('hello')> -[PASSES_ARGUMENT]-> <'hello'>
    void code;
  });

  test('runtime-apis::runtime-atomics-wait-notify', () => {
    const code = "function atomicsSynchronization(view) {\n  // Atomics.wait(view, 0, 0);     // blocks thread (worker only)\n  Atomics.notify(view, 0, 1);      // wake one waiting thread\n  Atomics.waitAsync(view, 0, 0);   // non-blocking, returns Promise\n}\n\n// --- Worker Communication (Plugin: workers) ---";
    // Expect node: FUNCTION <atomicsSynchronization>
    // Expect node: PARAMETER <view>
    // Expect node: CALL <Atomics.notify(view, 0, 1)>
    // Expect node: PROPERTY_ACCESS <Atomics.notify>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <1>
    // Expect node: CALL <Atomics.waitAsync(view, 0, 0)>
    // Expect node: PROPERTY_ACCESS <Atomics.waitAsync>
    // Expect node: LITERAL <0_2>
    // Expect node: LITERAL <0_3>
    // Expect edge: <atomicsSynchronization> -[HAS_BODY]-> <view>
    // Expect edge: <atomicsSynchronization> -[HAS_BODY]-> <Atomics.notify(view, 0, 1)>
    // Expect edge: <atomicsSynchronization> -[HAS_BODY]-> <Atomics.waitAsync(view, 0, 0)>
    // Expect edge: <Atomics.notify(view, 0, 1)> -[PASSES_ARGUMENT]-> <view>
    // Expect edge: <Atomics.notify(view, 0, 1)> -[PASSES_ARGUMENT]-> <0>
    // Expect edge: <Atomics.notify(view, 0, 1)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <Atomics.waitAsync(view, 0, 0)> -[PASSES_ARGUMENT]-> <view>
    // Expect edge: <Atomics.waitAsync(view, 0, 0)> -[PASSES_ARGUMENT]-> <0_2>
    // Expect edge: <Atomics.waitAsync(view, 0, 0)> -[PASSES_ARGUMENT]-> <0_3>
    void code;
  });

  test('runtime-apis::runtime-transfer-ownership', () => {
    const code = "function transferOwnership(worker) {\n  const buffer = new ArrayBuffer(1024);\n  worker.postMessage(buffer, [buffer]); // buffer neutered in sender\n}\n\n// --- import.meta Extensions (Plugin: node-modules) ---";
    // Expect node: FUNCTION <transferOwnership>
    // Expect node: PARAMETER <worker>
    // Expect node: VARIABLE <buffer>
    // Expect node: CALL <new ArrayBuffer(1024)>
    // Expect node: LITERAL <1024>
    // Expect node: CALL <worker.postMessage(buffer, [buffer])>
    // Expect node: PROPERTY_ACCESS <worker.postMessage>
    // Expect node: EXPRESSION <[buffer]>
    // Expect edge: <transferOwnership> -[HAS_BODY]-> <worker>
    // Expect edge: <transferOwnership> -[HAS_BODY]-> <buffer>
    // Expect edge: <new ArrayBuffer(1024)> -[PASSES_ARGUMENT]-> <1024>
    // Expect edge: <transferOwnership> -[HAS_BODY]-> <worker.postMessage(buffer, [buffer])>
    // Expect edge: <worker.postMessage(buffer, [buffer])> -[PASSES_ARGUMENT]-> <buffer>
    // Expect edge: <worker.postMessage(buffer, [buffer])> -[PASSES_ARGUMENT]-> <[buffer]>
    // Expect edge: <[buffer]> -[HAS_ELEMENT]-> <buffer>
    void code;
  });

  test('prototypes::proto-define-properties', () => {
    const code = "function defineMultiple(obj) {\n  Object.defineProperties(obj, {\n    x: { value: 10, writable: true, enumerable: true },\n    y: { value: 20, writable: true, enumerable: true },\n    sum: {\n      get() { return this.x + this.y; },\n      enumerable: true,\n    },\n  });\n  return obj;\n}";
    // Expect node: FUNCTION <defineMultiple>
    // Expect node: PARAMETER <obj>
    // Expect node: CALL <Object.defineProperties>
    // Expect node: EXPRESSION <x-descriptor>
    // Expect node: LITERAL <10>
    // Expect node: LITERAL <true-writable-x>
    // Expect node: LITERAL <true-enumerable-x>
    // Expect node: EXPRESSION <y-descriptor>
    // Expect node: LITERAL <20>
    // Expect node: LITERAL <true-writable-y>
    // Expect node: LITERAL <true-enumerable-y>
    // Expect node: EXPRESSION <sum-descriptor>
    // Expect node: GETTER <sum-getter>
    // Expect node: EXPRESSION <this.x + this.y>
    // Expect node: PROPERTY_ACCESS <this.x>
    // Expect node: PROPERTY_ACCESS <this.y>
    // Expect node: LITERAL <true-enumerable-sum>
    // Expect edge: <defineMultiple> -[CONTAINS]-> <obj>
    // Expect edge: <defineMultiple> -[CONTAINS]-> <Object.defineProperties>
    // Expect edge: <Object.defineProperties> -[PASSES_ARGUMENT]-> <obj>
    // Expect edge: <Object.defineProperties> -[PASSES_ARGUMENT]-> <x-descriptor>
    // Expect edge: <Object.defineProperties> -[PASSES_ARGUMENT]-> <y-descriptor>
    // Expect edge: <Object.defineProperties> -[PASSES_ARGUMENT]-> <sum-descriptor>
    // Expect edge: <x-descriptor> -[HAS_PROPERTY]-> <10>
    // Expect edge: <x-descriptor> -[HAS_PROPERTY]-> <true-writable-x>
    // Expect edge: <x-descriptor> -[HAS_PROPERTY]-> <true-enumerable-x>
    // Expect edge: <y-descriptor> -[HAS_PROPERTY]-> <20>
    // Expect edge: <y-descriptor> -[HAS_PROPERTY]-> <true-writable-y>
    // Expect edge: <y-descriptor> -[HAS_PROPERTY]-> <true-enumerable-y>
    // Expect edge: <sum-descriptor> -[HAS_PROPERTY]-> <sum-getter>
    // Expect edge: <sum-descriptor> -[HAS_PROPERTY]-> <true-enumerable-sum>
    // Expect edge: <sum-getter> -[RETURNS]-> <this.x + this.y>
    // Expect edge: <defineMultiple> -[RETURNS]-> <obj>
    void code;
  });

  test('prototypes::method-vs-function-property-super', () => {
    const code = "const superParent = {\n  greet() { return 'parent'; },\n};\n\nconst superChild = {\n  __proto__: superParent,\n\n  // Method shorthand — HAS [[HomeObject]], super works\n  shorthand() {\n    return super.greet(); // 'parent' ✓\n  },\n\n  // Function property — NO [[HomeObject]], super is SyntaxError\n  funcProp: function() {\n    // super.greet(); // Would be SyntaxError: 'super' keyword unexpected here\n    return 'no super access';\n  },\n\n  // Arrow property — NO own [[HomeObject]], inherits from defining scope\n  arrowProp: () => {\n    // super.greet(); // Would use enclosing scope's super, not this object's\n    return 'arrow has no own super';\n  },\n};";
    // Expect node: VARIABLE <superParent>
    // Expect node: EXPRESSION <superParent:obj>
    // Expect node: METHOD <superParent.greet>
    // Expect node: LITERAL <'parent'>
    // Expect node: VARIABLE <superChild>
    // Expect node: EXPRESSION <superChild:obj>
    // Expect node: PROPERTY <__proto__:superParent>
    // Expect node: METHOD <superChild.shorthand>
    // Expect node: CALL <super.greet()>
    // Expect node: PROPERTY <superChild.funcProp>
    // Expect node: FUNCTION <superChild.funcProp:fn>
    // Expect node: LITERAL <'no super access'>
    // Expect node: PROPERTY <superChild.arrowProp>
    // Expect node: FUNCTION <superChild.arrowProp:fn>
    // Expect node: LITERAL <'arrow has no own super'>
    // Expect edge: <superParent:obj> -[HAS_PROPERTY]-> <superParent.greet>
    // Expect edge: <superParent.greet> -[RETURNS]-> <'parent'>
    // Expect edge: <superChild:obj> -[HAS_PROPERTY]-> <__proto__:superParent>
    // Expect edge: <superChild:obj> -[HAS_PROPERTY]-> <superChild.shorthand>
    // Expect edge: <superChild.shorthand> -[CONTAINS]-> <super.greet()>
    // Expect edge: <superChild.shorthand> -[RETURNS]-> <super.greet()>
    // Expect edge: <superChild:obj> -[HAS_PROPERTY]-> <superChild.funcProp>
    // Expect edge: <superChild.funcProp:fn> -[RETURNS]-> <'no super access'>
    // Expect edge: <superChild:obj> -[HAS_PROPERTY]-> <superChild.arrowProp>
    // Expect edge: <superChild.arrowProp:fn> -[RETURNS]-> <'arrow has no own super'>
    void code;
  });

  test('builtins::regex-unicode-props', () => {
    const code = "const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;";
    // Expect node: VARIABLE <emoji>
    // Expect node: LITERAL </\p{Emoji}/u>
    // Expect node: VARIABLE <greek>
    // Expect node: LITERAL </\p{Script=Greek}/u>
    // Expect node: VARIABLE <letter>
    // Expect node: LITERAL </\p{Letter}/u>
    // Expect edge: <MODULE> -[DECLARES]-> <emoji>
    // Expect edge: <MODULE> -[DECLARES]-> <greek>
    // Expect edge: <MODULE> -[DECLARES]-> <letter>
    void code;
  });

  test('prototypes::export-named-list', () => {
    const code = "export {\n  Person,\n  Employee,\n  baseProto,\n  derived,\n  nullProto,\n  inspectPrototype,\n  reparent,\n  Serializable,\n  EventEmitterMixin,\n  applyMixins,\n  Widget,\n  createReadonly,\n  withComputedProp,\n  defineMultiple,\n  getDescriptor,\n  getAllDescriptors,\n  EvenNumber,\n  patchRouter,\n  originalFetch,\n  parentObj,\n  childObj,\n  superParent,\n  superChild,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <Person>
    // Expect node: VARIABLE <Employee>
    // Expect node: VARIABLE <baseProto>
    // Expect node: VARIABLE <derived>
    // Expect node: VARIABLE <nullProto>
    // Expect node: VARIABLE <inspectPrototype>
    // Expect node: VARIABLE <reparent>
    // Expect node: VARIABLE <Serializable>
    // Expect node: VARIABLE <EventEmitterMixin>
    // Expect node: VARIABLE <applyMixins>
    // Expect node: VARIABLE <Widget>
    // Expect node: VARIABLE <createReadonly>
    // Expect node: VARIABLE <withComputedProp>
    // Expect node: VARIABLE <defineMultiple>
    // Expect node: VARIABLE <getDescriptor>
    // Expect node: VARIABLE <getAllDescriptors>
    // Expect node: VARIABLE <EvenNumber>
    // Expect node: VARIABLE <patchRouter>
    // Expect node: VARIABLE <originalFetch>
    // Expect node: VARIABLE <parentObj>
    // Expect node: VARIABLE <childObj>
    // Expect node: VARIABLE <superParent>
    // Expect node: VARIABLE <superChild>

    void code;
  });

  test('runtime-apis::runtime-broadcast-channel', () => {
    const code = "function broadcastChannelPattern() {\n  const bc = new BroadcastChannel('updates');\n  bc.postMessage({ type: 'refresh' });\n  bc.onmessage = (e) => console.log(e.data);\n  bc.close();\n}";
    // Expect node: FUNCTION <broadcastChannelPattern>
    // Expect node: VARIABLE <bc>
    // Expect node: CALL <new BroadcastChannel('updates')>
    // Expect node: LITERAL <'updates'>
    // Expect node: CALL <bc.postMessage({ type: 'refresh' })>
    // Expect node: LITERAL <{ type: 'refresh' }>
    // Expect node: PROPERTY_ACCESS <bc.onmessage>
    // Expect node: FUNCTION <(e) => console.log(e.data)>
    // Expect node: PARAMETER <e>
    // Expect node: CALL <console.log(e.data)>
    // Expect node: PROPERTY_ACCESS <e.data>
    // Expect node: CALL <bc.close()>
    // Expect edge: <broadcastChannelPattern> -[CONTAINS]-> <bc>
    // Expect edge: <new BroadcastChannel('updates')> -[PASSES_ARGUMENT]-> <'updates'>
    // Expect edge: <bc.postMessage({ type: 'refresh' })> -[PASSES_ARGUMENT]-> <{ type: 'refresh' }>
    // Expect edge: <(e) => console.log(e.data)> -[CONTAINS]-> <e>
    // Expect edge: <(e) => console.log(e.data)> -[CONTAINS]-> <console.log(e.data)>
    // Expect edge: <console.log(e.data)> -[PASSES_ARGUMENT]-> <e.data>
    // Expect edge: <broadcastChannelPattern> -[CONTAINS]-> <bc.postMessage({ type: 'refresh' })>
    // Expect edge: <broadcastChannelPattern> -[CONTAINS]-> <bc.onmessage>
    // Expect edge: <broadcastChannelPattern> -[CONTAINS]-> <bc.close()>
    void code;
  });

  test('runtime-apis::export-named-list', () => {
    const code = "export {\n  sharedMemory,\n  atomicsSynchronization,\n  workerCommunication,\n  messageChannelPattern,\n  broadcastChannelPattern,\n  transferOwnership,\n  importMetaExtensions,\n  deferredPromise,\n};";
    // Expect node: EXPORT <export-named-list>
    // Expect node: VARIABLE <sharedMemory>
    // Expect node: VARIABLE <atomicsSynchronization>
    // Expect node: VARIABLE <workerCommunication>
    // Expect node: VARIABLE <messageChannelPattern>
    // Expect node: VARIABLE <broadcastChannelPattern>
    // Expect node: VARIABLE <transferOwnership>
    // Expect node: VARIABLE <importMetaExtensions>
    // Expect node: VARIABLE <deferredPromise>

    void code;
  });

  test('statements::if-else', () => {
    const code = "function ifElseStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  } else {\n    return 'non-positive';\n  }\n}";
    // Expect node: FUNCTION <ifElseStatement>
    // Expect node: PARAMETER <x>
    // Expect node: BRANCH <if-else>
    // Expect node: EXPRESSION <x > 0>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <'positive'>
    // Expect node: LITERAL <'non-positive'>
    // Expect edge: <ifElseStatement> -[CONTAINS]-> <x>
    // Expect edge: <ifElseStatement> -[CONTAINS]-> <if-else>
    // Expect edge: <if-else> -[HAS_CONDITION]-> <x > 0>
    // Expect edge: <if-else> -[HAS_CONSEQUENT]-> <'positive'>
    // Expect edge: <ifElseStatement> -[RETURNS]-> <'positive'>
    // Expect edge: <ifElseStatement> -[RETURNS]-> <'non-positive'>
    void code;
  });

  test('runtime-apis::runtime-import-meta-resolve', () => {
    const code = "function importMetaExtensions() {\n  const depPath = import.meta.resolve('lodash');\n  const localPath = import.meta.resolve('./utils.js');\n  // Node.js 21+:\n  // const dir = import.meta.dirname;   // replaces __dirname\n  // const file = import.meta.filename; // replaces __filename\n  return { depPath, localPath };\n}\n\n// --- Global Error Sinks (Plugin: error-flow) ---\n// These create implicit edges from ANY uncaught throw/reject to handler.";
    // Expect node: FUNCTION <importMetaExtensions>
    // Expect node: VARIABLE <depPath>
    // Expect node: CALL <import.meta.resolve('lodash')>
    // Expect node: META_PROPERTY <import.meta.resolve>
    // Expect node: LITERAL <'lodash'>
    // Expect node: VARIABLE <localPath>
    // Expect node: CALL <import.meta.resolve('./utils.js')>
    // Expect node: META_PROPERTY <import.meta.resolve2>
    // Expect node: LITERAL <'./utils.js'>
    // Expect node: EXPRESSION <{ depPath, localPath }>
    // Expect edge: <importMetaExtensions> -[CONTAINS]-> <depPath>
    // Expect edge: <importMetaExtensions> -[CONTAINS]-> <localPath>
    // Expect edge: <import.meta.resolve('lodash')> -[PASSES_ARGUMENT]-> <'lodash'>
    // Expect edge: <import.meta.resolve('./utils.js')> -[PASSES_ARGUMENT]-> <'./utils.js'>
    // Expect edge: <importMetaExtensions> -[RETURNS]-> <{ depPath, localPath }>
    void code;
  });

  test('builtins::string-raw-template', () => {
    const code = "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file' — no escape processing";
    // Expect node: VARIABLE <windowsPath>
    // Expect node: CALL <String.raw`C:\Users\name\file`>
    // Expect node: PROPERTY_ACCESS <String.raw>
    // Expect node: LITERAL <String>
    // Expect node: LITERAL <template-literal>
    // Expect edge: <module> -[DECLARES]-> <windowsPath>
    // Expect edge: <String.raw`C:\Users\name\file`> -[PASSES_ARGUMENT]-> <template-literal>
    void code;
  });

  test('statements::if-basic', () => {
    const code = "function ifStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  }\n  return 'non-positive';\n}";
    // Expect node: FUNCTION <ifStatement>
    // Expect node: PARAMETER <x>
    // Expect node: BRANCH <if-branch>
    // Expect node: EXPRESSION <x > 0>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <'positive'>
    // Expect node: LITERAL <'non-positive'>
    // Expect edge: <ifStatement> -[CONTAINS]-> <x>
    // Expect edge: <ifStatement> -[CONTAINS]-> <if-branch>
    // Expect edge: <if-branch> -[HAS_CONDITION]-> <x > 0>
    // Expect edge: <if-branch> -[HAS_CONSEQUENT]-> <'positive'>
    // Expect edge: <ifStatement> -[RETURNS]-> <'positive'>
    // Expect edge: <ifStatement> -[RETURNS]-> <'non-positive'>
    void code;
  });

  test('runtime-apis::runtime-promise-try', () => {
    const code = "// const result = await Promise.try(() => {\n//   if (cached) return cachedValue;    // sync return → wrapped in Promise\n//   return fetchFromNetwork();          // async return\n// });";
    // Expect node: VARIABLE <result>
    // Expect node: CALL <Promise.try(...)>
    // Expect node: FUNCTION <Promise.try:callback>
    // Expect node: BRANCH <if-cached>
    // Expect node: VARIABLE <cached>
    // Expect node: VARIABLE <cachedValue>
    // Expect node: CALL <fetchFromNetwork()>
    // Expect edge: <Promise.try(...)> -[PASSES_ARGUMENT]-> <Promise.try:callback>
    // Expect edge: <Promise.try:callback> -[CONTAINS]-> <if-cached>
    // Expect edge: <if-cached> -[HAS_CONDITION]-> <cached>
    // Expect edge: <if-cached> -[HAS_CONSEQUENT]-> <cachedValue>
    void code;
  });

  test('runtime-apis::runtime-global-error-handlers', () => {
    const code = "// Node.js:\n// process.on('unhandledRejection', (reason, promise) => { ... });\n// process.on('uncaughtException', (error) => { process.exit(1); });\n//\n// Browser:\n// window.addEventListener('unhandledrejection', (event) => { ... });\n// window.addEventListener('error', (event) => { ... });\n\n// --- ES2025+ API Methods (Plugin: es-builtins) ---";
    // Expect node: FUNCTION <process.unhandledRejection>
    // Expect node: PARAMETER <reason>
    // Expect node: PARAMETER <promise>
    // Expect node: FUNCTION <process.uncaughtException>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <process.exit(1)>
    // Expect node: LITERAL <1>
    // Expect node: FUNCTION <window.unhandledrejection>
    // Expect node: PARAMETER <event1>
    // Expect node: FUNCTION <window.error>
    // Expect node: PARAMETER <event2>
    // Expect node: EXTERNAL <process>
    // Expect node: EXTERNAL <window>
    // Expect edge: <process> -[LISTENS_TO]-> <process.unhandledRejection>
    // Expect edge: <process.unhandledRejection> -[RECEIVES_ARGUMENT]-> <reason>
    // Expect edge: <process.unhandledRejection> -[RECEIVES_ARGUMENT]-> <promise>
    // Expect edge: <process> -[LISTENS_TO]-> <process.uncaughtException>
    // Expect edge: <process.uncaughtException> -[RECEIVES_ARGUMENT]-> <error>
    // Expect edge: <process.uncaughtException> -[CONTAINS]-> <process.exit(1)>
    // Expect edge: <process.exit(1)> -[PASSES_ARGUMENT]-> <1>
    // Expect edge: <window> -[LISTENS_TO]-> <window.unhandledrejection>
    // Expect edge: <window.unhandledrejection> -[RECEIVES_ARGUMENT]-> <event1>
    // Expect edge: <window> -[LISTENS_TO]-> <window.error>
    // Expect edge: <window.error> -[RECEIVES_ARGUMENT]-> <event2>
    void code;
  });

  test('statements::for-in', () => {
    const code = "function forIn(obj) {\n  const keys = [];\n  for (const key in obj) {\n    keys.push(key);\n  }\n  return keys;\n}";
    // Expect node: FUNCTION <forIn>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <keys>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-in>
    // Expect node: VARIABLE <key>
    // Expect node: CALL <keys.push(key)>
    // Expect edge: <forIn> -[CONTAINS]-> <obj>
    // Expect edge: <forIn> -[CONTAINS]-> <keys>
    // Expect edge: <forIn> -[CONTAINS]-> <for-in>
    // Expect edge: <for-in> -[ITERATES_OVER]-> <obj>
    // Expect edge: <for-in> -[CONTAINS]-> <key>
    // Expect edge: <forIn> -[CONTAINS]-> <keys.push(key)>
    // Expect edge: <keys.push(key)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <forIn> -[RETURNS]-> <keys>
    void code;
  });

  test('runtime-apis::runtime-worker-postmessage', () => {
    const code = "function workerCommunication() {\n  const worker = new Worker('./task.js');\n  worker.postMessage({ type: 'start', payload: 'data' });\n  worker.onmessage = (e) => console.log(e.data);\n  worker.onerror = (err) => console.error(err);\n  worker.terminate();\n}";
    // Expect node: FUNCTION <workerCommunication>
    // Expect node: VARIABLE <worker>
    // Expect node: CALL <new Worker('./task.js')>
    // Expect node: LITERAL <'./task.js'>
    // Expect node: CALL <worker.postMessage>
    // Expect node: LITERAL <{ type: 'start', payload: 'data' }>
    // Expect node: PROPERTY_ACCESS <worker.onmessage>
    // Expect node: FUNCTION <onmessage-handler>
    // Expect node: PARAMETER <e>
    // Expect node: CALL <console.log(e.data)>
    // Expect node: PROPERTY_ACCESS <e.data>
    // Expect node: PROPERTY_ACCESS <worker.onerror>
    // Expect node: FUNCTION <onerror-handler>
    // Expect node: PARAMETER <err>
    // Expect node: CALL <console.error(err)>
    // Expect node: CALL <worker.terminate>
    // Expect edge: <workerCommunication> -[CONTAINS]-> <worker>
    // Expect edge: <new Worker('./task.js')> -[PASSES_ARGUMENT]-> <'./task.js'>
    // Expect edge: <workerCommunication> -[CONTAINS]-> <worker.postMessage>
    // Expect edge: <worker.postMessage> -[PASSES_ARGUMENT]-> <{ type: 'start', payload: 'data' }>
    // Expect edge: <onmessage-handler> -[CONTAINS]-> <e>
    // Expect edge: <onmessage-handler> -[CONTAINS]-> <console.log(e.data)>
    // Expect edge: <console.log(e.data)> -[PASSES_ARGUMENT]-> <e.data>
    // Expect edge: <onerror-handler> -[CONTAINS]-> <err>
    // Expect edge: <onerror-handler> -[CONTAINS]-> <console.error(err)>
    // Expect edge: <console.error(err)> -[PASSES_ARGUMENT]-> <err>
    // Expect edge: <workerCommunication> -[CONTAINS]-> <worker.terminate>
    void code;
  });

  test('statements::do-while', () => {
    const code = "function doWhileLoop() {\n  let attempts = 0;\n  do {\n    attempts++;\n  } while (attempts < 3);\n  return attempts;\n}";
    // Expect node: FUNCTION <doWhileLoop>
    // Expect node: VARIABLE <attempts>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <do-while>
    // Expect node: EXPRESSION <attempts++>
    // Expect node: EXPRESSION <attempts < 3>
    // Expect node: LITERAL <3>
    // Expect edge: <doWhileLoop> -[CONTAINS]-> <attempts>
    // Expect edge: <doWhileLoop> -[CONTAINS]-> <do-while>
    // Expect edge: <do-while> -[HAS_BODY]-> <attempts++>
    // Expect edge: <do-while> -[HAS_CONDITION]-> <attempts < 3>
    // Expect edge: <doWhileLoop> -[RETURNS]-> <attempts>
    void code;
  });

  test('statements::while', () => {
    const code = "function whileLoop() {\n  let count = 0;\n  while (count < 5) {\n    count++;\n  }\n  return count;\n}";
    // Expect node: FUNCTION <whileLoop>
    // Expect node: VARIABLE <count>
    // Expect node: LITERAL <0>
    // Expect node: LOOP <while>
    // Expect node: EXPRESSION <count < 5>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <count++>
    // Expect edge: <whileLoop> -[DECLARES]-> <count>
    // Expect edge: <whileLoop> -[CONTAINS]-> <while>
    // Expect edge: <while> -[HAS_CONDITION]-> <count < 5>
    // Expect edge: <while> -[HAS_BODY]-> <count++>
    // Expect edge: <whileLoop> -[RETURNS]-> <count>
    void code;
  });

  test('statements::for-classic', () => {
    const code = "function classicFor() {\n  const results = [];\n  for (let i = 0; i < 10; i++) {\n    results.push(i);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <classicFor>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-classic>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <i < 10>
    // Expect node: LITERAL <10>
    // Expect node: EXPRESSION <i++>
    // Expect node: CALL <results.push(i)>
    // Expect node: PROPERTY_ACCESS <results.push>
    // Expect edge: <classicFor> -[CONTAINS]-> <results>
    // Expect edge: <classicFor> -[CONTAINS]-> <for-classic>
    // Expect edge: <for-classic> -[HAS_INIT]-> <i>
    // Expect edge: <for-classic> -[HAS_CONDITION]-> <i < 10>
    // Expect edge: <for-classic> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-classic> -[HAS_BODY]-> <results.push(i)>
    // Expect edge: <results.push(i)> -[PASSES_ARGUMENT]-> <i>
    // Expect edge: <classicFor> -[RETURNS]-> <results>
    void code;
  });

  test('statements::switch-break', () => {
    const code = "function switchWithBreak(action) {\n  let result;\n  switch (action) {\n    case 'start':\n      result = 'starting';\n      break;\n    case 'stop':\n      result = 'stopping';\n      break;\n    default:\n      result = 'unknown';\n  }\n  return result;\n}";
    // Expect node: FUNCTION <switchWithBreak>
    // Expect node: PARAMETER <action>
    // Expect node: VARIABLE <result>
    // Expect node: BRANCH <switch>
    // Expect node: CASE <case-start>
    // Expect node: LITERAL <'start'>
    // Expect node: LITERAL <'starting'>
    // Expect node: CASE <case-stop>
    // Expect node: LITERAL <'stop'>
    // Expect node: LITERAL <'stopping'>
    // Expect node: CASE <default-case>
    // Expect node: LITERAL <'unknown'>
    // Expect edge: <switchWithBreak> -[CONTAINS]-> <action>
    // Expect edge: <switchWithBreak> -[CONTAINS]-> <result>
    // Expect edge: <switchWithBreak> -[CONTAINS]-> <switch>
    // Expect edge: <switch> -[HAS_CONDITION]-> <action>
    // Expect edge: <switch> -[HAS_CASE]-> <case-start>
    // Expect edge: <switch> -[HAS_CASE]-> <case-stop>
    // Expect edge: <switch> -[HAS_DEFAULT]-> <default-case>
    // Expect edge: <case-start> -[HAS_CONDITION]-> <'start'>
    // Expect edge: <case-stop> -[HAS_CONDITION]-> <'stop'>
    // Expect edge: <switchWithBreak> -[RETURNS]-> <result>
    void code;
  });

  test('statements::for-of', () => {
    const code = "function forOf(iterable) {\n  const values = [];\n  for (const item of iterable) {\n    values.push(item);\n  }\n  return values;\n}";
    // Expect node: FUNCTION <forOf>
    // Expect node: PARAMETER <iterable>
    // Expect node: VARIABLE <values>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <item>
    // Expect node: CALL <values.push(item)>
    // Expect node: PROPERTY_ACCESS <values.push>
    // Expect edge: <forOf> -[CONTAINS]-> <iterable>
    // Expect edge: <forOf> -[DECLARES]-> <values>
    // Expect edge: <forOf> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <iterable>
    // Expect edge: <for-of> -[CONTAINS]-> <item>
    // Expect edge: <for-of> -[CONTAINS]-> <values.push(item)>
    // Expect edge: <values.push(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <forOf> -[RETURNS]-> <values>
    void code;
  });

  test('statements::if-else-if-chain', () => {
    const code = "function ifElseIfChain(x) {\n  if (x > 0) {\n    return 'positive';\n  } else if (x < 0) {\n    return 'negative';\n  } else {\n    return 'zero';\n  }\n}";
    // Expect node: FUNCTION <ifElseIfChain>
    // Expect node: PARAMETER <x>
    // Expect node: BRANCH <if-x>0>
    // Expect node: EXPRESSION <x > 0>
    // Expect node: LITERAL <0-first>
    // Expect node: LITERAL <'positive'>
    // Expect node: BRANCH <else-if-x<0>
    // Expect node: EXPRESSION <x < 0>
    // Expect node: LITERAL <0-second>
    // Expect node: LITERAL <'negative'>
    // Expect node: BRANCH <else>
    // Expect node: LITERAL <'zero'>
    // Expect edge: <ifElseIfChain> -[CONTAINS]-> <x>
    // Expect edge: <ifElseIfChain> -[CONTAINS]-> <if-x>0>
    // Expect edge: <if-x>0> -[HAS_CONDITION]-> <x > 0>
    // Expect edge: <if-x>0> -[HAS_CONSEQUENT]-> <'positive'>
    // Expect edge: <ifElseIfChain> -[RETURNS]-> <'positive'>
    // Expect edge: <else-if-x<0> -[HAS_CONDITION]-> <x < 0>
    // Expect edge: <else-if-x<0> -[HAS_CONSEQUENT]-> <'negative'>
    // Expect edge: <ifElseIfChain> -[RETURNS]-> <'negative'>
    // Expect edge: <else> -[HAS_CONSEQUENT]-> <'zero'>
    // Expect edge: <ifElseIfChain> -[RETURNS]-> <'zero'>
    void code;
  });

  test('runtime-apis::runtime-promise-withresolvers-deferred', () => {
    const code = "function deferredPromise() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  // resolve/reject passed to different scopes as callbacks\n  setTimeout(() => reject(new Error('timeout')), 5000);\n  return { promise, resolve, reject };\n}";
    // Expect node: FUNCTION <deferredPromise>
    // Expect node: CALL <Promise.withResolvers()>
    // Expect node: VARIABLE <promise>
    // Expect node: VARIABLE <resolve>
    // Expect node: VARIABLE <reject>
    // Expect node: CALL <setTimeout(...)>
    // Expect node: FUNCTION <timeout-callback>
    // Expect node: CALL <reject(new Error('timeout'))>
    // Expect node: CALL <new Error('timeout')>
    // Expect node: LITERAL <'timeout'>
    // Expect node: LITERAL <5000>
    // Expect node: EXPRESSION <return-object>
    // Expect edge: <deferredPromise> -[CONTAINS]-> <Promise.withResolvers()>
    // Expect edge: <deferredPromise> -[CONTAINS]-> <setTimeout(...)>
    // Expect edge: <setTimeout(...)> -[PASSES_ARGUMENT]-> <timeout-callback>
    // Expect edge: <setTimeout(...)> -[PASSES_ARGUMENT]-> <5000>
    // Expect edge: <timeout-callback> -[CONTAINS]-> <reject(new Error('timeout'))>
    // Expect edge: <reject(new Error('timeout'))> -[PASSES_ARGUMENT]-> <new Error('timeout')>
    // Expect edge: <new Error('timeout')> -[PASSES_ARGUMENT]-> <'timeout'>
    // Expect edge: <deferredPromise> -[RETURNS]-> <return-object>
    void code;
  });

  test('statements::for-of-destructuring', () => {
    const code = "function forOfDestructuring(entries) {\n  const result = {};\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}";
    // Expect node: FUNCTION <forOfDestructuring>
    // Expect node: PARAMETER <entries>
    // Expect node: VARIABLE <result>
    // Expect node: LITERAL <{}>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <key>
    // Expect node: VARIABLE <value>
    // Expect node: PROPERTY_ACCESS <result[key]>
    // Expect node: EXPRESSION <result[key] = value>
    // Expect edge: <forOfDestructuring> -[CONTAINS]-> <entries>
    // Expect edge: <forOfDestructuring> -[CONTAINS]-> <result>
    // Expect edge: <forOfDestructuring> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <entries>
    // Expect edge: <for-of> -[CONTAINS]-> <key>
    // Expect edge: <for-of> -[CONTAINS]-> <value>
    // Expect edge: <for-of> -[CONTAINS]-> <result[key] = value>
    // Expect edge: <forOfDestructuring> -[RETURNS]-> <result>
    void code;
  });

  test('statements::try-finally', () => {
    const code = "function tryFinally() {\n  try {\n    doSomething();\n  } finally {\n    alwaysRun();\n  }\n}";
    // Expect node: FUNCTION <tryFinally>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: CALL <doSomething()>
    // Expect node: CALL <alwaysRun()>
    // Expect edge: <module> -[DECLARES]-> <tryFinally>
    // Expect edge: <tryFinally> -[CONTAINS]-> <try-block>
    // Expect edge: <tryFinally> -[CONTAINS]-> <finally-block>
    // Expect edge: <try-block> -[HAS_BODY]-> <doSomething()>
    // Expect edge: <finally-block> -[HAS_BODY]-> <alwaysRun()>
    void code;
  });

  test('statements::debugger', () => {
    const code = "function debuggerStatement() {\n  debugger;\n  return 'after debugger';\n}";
    // Expect node: FUNCTION <debuggerStatement>
    // Expect node: SIDE_EFFECT <debugger>
    // Expect node: LITERAL <'after debugger'>
    // Expect edge: <module> -[DECLARES]-> <debuggerStatement>
    // Expect edge: <debuggerStatement> -[CONTAINS]-> <debugger>
    // Expect edge: <debuggerStatement> -[RETURNS]-> <'after debugger'>
    void code;
  });

  test('statements::switch-return-fallthrough', () => {
    const code = "function switchWithReturn(action) {\n  switch (action) {\n    case 'start':\n      return 'starting';\n    case 'stop':\n      return 'stopping';\n    case 'pause':\n    case 'suspend':\n      return 'pausing';\n    default:\n      return 'unknown';\n  }\n}";
    // Expect node: FUNCTION <switchWithReturn>
    // Expect node: PARAMETER <action>
    // Expect node: BRANCH <switch>
    // Expect node: CASE <case-start>
    // Expect node: LITERAL <'start'>
    // Expect node: LITERAL <'starting'>
    // Expect node: CASE <case-stop>
    // Expect node: LITERAL <'stop'>
    // Expect node: LITERAL <'stopping'>
    // Expect node: CASE <case-pause>
    // Expect node: LITERAL <'pause'>
    // Expect node: CASE <case-suspend>
    // Expect node: LITERAL <'suspend'>
    // Expect node: LITERAL <'pausing'>
    // Expect node: CASE <default>
    // Expect node: LITERAL <'unknown'>
    // Expect edge: <switchWithReturn> -[CONTAINS]-> <action>
    // Expect edge: <switchWithReturn> -[CONTAINS]-> <switch>
    // Expect edge: <switch> -[HAS_CONDITION]-> <action>
    // Expect edge: <switch> -[HAS_CASE]-> <case-start>
    // Expect edge: <switch> -[HAS_CASE]-> <case-stop>
    // Expect edge: <switch> -[HAS_CASE]-> <case-pause>
    // Expect edge: <switch> -[HAS_CASE]-> <case-suspend>
    // Expect edge: <switch> -[HAS_DEFAULT]-> <default>
    // Expect edge: <case-start> -[HAS_CONDITION]-> <'start'>
    // Expect edge: <case-start> -[RETURNS]-> <'starting'>
    // Expect edge: <case-stop> -[HAS_CONDITION]-> <'stop'>
    // Expect edge: <case-stop> -[RETURNS]-> <'stopping'>
    // Expect edge: <case-pause> -[HAS_CONDITION]-> <'pause'>
    // Expect edge: <case-suspend> -[HAS_CONDITION]-> <'suspend'>
    // Expect edge: <case-suspend> -[RETURNS]-> <'pausing'>
    // Expect edge: <default> -[RETURNS]-> <'unknown'>
    void code;
  });

  test('statements::labeled-function', () => {
    const code = "myLabel: function labeledFn() { return 1; }";
    // Expect node: LABEL <myLabel>
    // Expect node: FUNCTION <labeledFn>
    // Expect node: LITERAL <1>
    // Expect edge: <module> -[CONTAINS]-> <myLabel>
    // Expect edge: <myLabel> -[CONTAINS]-> <labeledFn>
    // Expect edge: <module> -[DECLARES]-> <labeledFn>
    // Expect edge: <labeledFn> -[RETURNS]-> <1>
    void code;
  });

  test('statements::try-catch', () => {
    const code = "function tryCatch() {\n  try {\n    JSON.parse('invalid');\n  } catch (error) {\n    console.error(error.message);\n  }\n}";
    // Expect node: FUNCTION <tryCatch>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <JSON.parse('invalid')>
    // Expect node: LITERAL <'invalid'>
    // Expect node: CALL <console.error(error.message)>
    // Expect node: PROPERTY_ACCESS <error.message>
    // Expect node: EXTERNAL <JSON.parse>
    // Expect node: EXTERNAL <console.error>
    // Expect edge: <tryCatch> -[CONTAINS]-> <try-block>
    // Expect edge: <tryCatch> -[CONTAINS]-> <catch-block>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <error>
    // Expect edge: <try-block> -[CONTAINS]-> <JSON.parse('invalid')>
    // Expect edge: <JSON.parse('invalid')> -[PASSES_ARGUMENT]-> <'invalid'>
    // Expect edge: <catch-block> -[CONTAINS]-> <console.error(error.message)>
    // Expect edge: <console.error(error.message)> -[PASSES_ARGUMENT]-> <error.message>
    void code;
  });

  test('statements::finally-return-override', () => {
    const code = "function finallyReturnOverride() {\n  try {\n    return 1;\n  } finally {\n    return 2; // swallows try return — returns 2\n  }\n}";
    // Expect node: FUNCTION <finallyReturnOverride>
    // Expect node: TRY_BLOCK <try>
    // Expect node: FINALLY_BLOCK <finally>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect edge: <finallyReturnOverride> -[CONTAINS]-> <try>
    // Expect edge: <finallyReturnOverride> -[HAS_FINALLY]-> <finally>
    // Expect edge: <try> -[RETURNS]-> <1>
    // Expect edge: <finally> -[RETURNS]-> <2>
    // Expect edge: <finallyReturnOverride> -[RETURNS]-> <2>
    void code;
  });

  test('statements::catch-no-binding', () => {
    const code = "function catchWithoutBinding() {\n  try {\n    JSON.parse('{}');\n  } catch {\n    console.error('parse failed');\n  }\n}";
    // Expect node: FUNCTION <catchWithoutBinding>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: CALL <JSON.parse('{}')>
    // Expect node: PROPERTY_ACCESS <JSON.parse>
    // Expect node: LITERAL <'{}'>
    // Expect node: CALL <console.error('parse failed')>
    // Expect node: PROPERTY_ACCESS <console.error>
    // Expect node: LITERAL <'parse failed'>
    // Expect edge: <catchWithoutBinding> -[CONTAINS]-> <try-block>
    // Expect edge: <catchWithoutBinding> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <try-block> -[CONTAINS]-> <JSON.parse('{}')>
    // Expect edge: <JSON.parse('{}')> -[PASSES_ARGUMENT]-> <'{}'>
    // Expect edge: <catch-block> -[CONTAINS]-> <console.error('parse failed')>
    // Expect edge: <console.error('parse failed')> -[PASSES_ARGUMENT]-> <'parse failed'>
    void code;
  });

  test('statements::labeled-block', () => {
    const code = "function labeledBlock() {\n  block: {\n    if (true) break block;\n    unreachable();\n  }\n}";
    // Expect node: FUNCTION <labeledBlock>
    // Expect node: LABEL <block>
    // Expect node: SCOPE <block-scope>
    // Expect node: BRANCH <if-true>
    // Expect node: LITERAL <true>
    // Expect node: CALL <unreachable()>
    // Expect edge: <labeledBlock> -[CONTAINS]-> <block>
    // Expect edge: <block> -[HAS_SCOPE]-> <block-scope>
    // Expect edge: <block-scope> -[CONTAINS]-> <if-true>
    // Expect edge: <if-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <block-scope> -[CONTAINS]-> <unreachable()>
    void code;
  });

  test('statements::try-catch-finally', () => {
    const code = "function tryCatchFinally() {\n  let resource;\n  try {\n    resource = openResource();\n  } catch (error) {\n    handleError(error);\n  } finally {\n    cleanup(resource);\n  }\n}";
    // Expect node: FUNCTION <tryCatchFinally>
    // Expect node: VARIABLE <resource>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CALL <openResource()>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: PARAMETER <error>
    // Expect node: CALL <handleError(error)>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: CALL <cleanup(resource)>
    // Expect edge: <tryCatchFinally> -[CONTAINS]-> <resource>
    // Expect edge: <tryCatchFinally> -[CONTAINS]-> <try-block>
    // Expect edge: <tryCatchFinally> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <tryCatchFinally> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <try-block> -[CONTAINS]-> <openResource()>
    // Expect edge: <catch-block> -[CONTAINS]-> <error>
    // Expect edge: <catch-block> -[CONTAINS]-> <handleError(error)>
    // Expect edge: <handleError(error)> -[PASSES_ARGUMENT]-> <error>
    // Expect edge: <finally-block> -[CONTAINS]-> <cleanup(resource)>
    // Expect edge: <cleanup(resource)> -[PASSES_ARGUMENT]-> <resource>
    void code;
  });

  test('statements::empty-statement', () => {
    const code = "function emptyStatements() {\n  ;\n  for (let i = 0; i < 0; i++);\n}";
    // Expect node: FUNCTION <emptyStatements>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0-init>
    // Expect node: EXPRESSION <i < 0>
    // Expect node: LITERAL <0-condition>
    // Expect node: EXPRESSION <i++>
    // Expect edge: <emptyStatements> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[DECLARES]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 0>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    void code;
  });

  test('statements::try-nested', () => {
    const code = "function nestedTryCatch() {\n  try {\n    try {\n      riskyOperation();\n    } catch (innerError) {\n      fallback(innerError);\n    }\n  } catch (outerError) {\n    lastResort(outerError);\n  }\n}";
    // Expect node: FUNCTION <nestedTryCatch>
    // Expect node: TRY_BLOCK <outer-try>
    // Expect node: CATCH_BLOCK <outer-catch>
    // Expect node: PARAMETER <outerError>
    // Expect node: TRY_BLOCK <inner-try>
    // Expect node: CATCH_BLOCK <inner-catch>
    // Expect node: PARAMETER <innerError>
    // Expect node: CALL <riskyOperation()>
    // Expect node: CALL <fallback(innerError)>
    // Expect node: CALL <lastResort(outerError)>
    // Expect node: EXTERNAL <riskyOperation>
    // Expect node: EXTERNAL <fallback>
    // Expect node: EXTERNAL <lastResort>
    // Expect edge: <nestedTryCatch> -[HAS_BODY]-> <outer-try>
    // Expect edge: <outer-try> -[HAS_CATCH]-> <outer-catch>
    // Expect edge: <outer-catch> -[RECEIVES_ARGUMENT]-> <outerError>
    // Expect edge: <outer-try> -[CONTAINS]-> <inner-try>
    // Expect edge: <inner-try> -[HAS_CATCH]-> <inner-catch>
    // Expect edge: <inner-catch> -[RECEIVES_ARGUMENT]-> <innerError>
    // Expect edge: <inner-try> -[CONTAINS]-> <riskyOperation()>
    // Expect edge: <inner-catch> -[CONTAINS]-> <fallback(innerError)>
    // Expect edge: <outer-catch> -[CONTAINS]-> <lastResort(outerError)>
    // Expect edge: <fallback(innerError)> -[PASSES_ARGUMENT]-> <innerError>
    // Expect edge: <lastResort(outerError)> -[PASSES_ARGUMENT]-> <outerError>
    // Expect edge: <riskyOperation()> -[CATCHES_FROM]-> <inner-catch>
    // Expect edge: <fallback(innerError)> -[CATCHES_FROM]-> <outer-catch>
    void code;
  });

  test('builtins::array-from-mapfn', () => {
    const code = "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---";
    // Expect node: FUNCTION <arrayFromMapFn>
    // Expect node: VARIABLE <indices>
    // Expect node: CALL <Array.from({ length: 5 }, (_, i) => i)>
    // Expect node: LITERAL <{ length: 5 }>
    // Expect node: FUNCTION <(_, i) => i>
    // Expect node: PARAMETER <_>
    // Expect node: PARAMETER <i>
    // Expect edge: <arrayFromMapFn> -[CONTAINS]-> <indices>
    // Expect edge: <Array.from({ length: 5 }, (_, i) => i)> -[PASSES_ARGUMENT]-> <{ length: 5 }>
    // Expect edge: <Array.from({ length: 5 }, (_, i) => i)> -[PASSES_ARGUMENT]-> <(_, i) => i>
    // Expect edge: <(_, i) => i> -[CONTAINS]-> <_>
    // Expect edge: <(_, i) => i> -[CONTAINS]-> <i>
    // Expect edge: <(_, i) => i> -[RETURNS]-> <i>
    // Expect edge: <arrayFromMapFn> -[RETURNS]-> <indices>
    void code;
  });

  test('statements::finally-throw-override', () => {
    const code = "function finallyThrowOverride() {\n  try {\n    throw new Error('original');\n  } catch (e) {\n    throw new Error('from catch');\n  } finally {\n    throw new Error('from finally'); // swallows catch throw\n  }\n}";
    // Expect node: FUNCTION <finallyThrowOverride>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: FINALLY_BLOCK <finally-block>
    // Expect node: PARAMETER <e>
    // Expect node: CALL <new Error('original')>
    // Expect node: LITERAL <'original'>
    // Expect node: CALL <new Error('from catch')>
    // Expect node: LITERAL <'from catch'>
    // Expect node: CALL <new Error('from finally')>
    // Expect node: LITERAL <'from finally'>
    // Expect edge: <finallyThrowOverride> -[CONTAINS]-> <try-block>
    // Expect edge: <finallyThrowOverride> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <finallyThrowOverride> -[HAS_FINALLY]-> <finally-block>
    // Expect edge: <catch-block> -[CONTAINS]-> <e>
    // Expect edge: <new Error('original')> -[PASSES_ARGUMENT]-> <'original'>
    // Expect edge: <new Error('from catch')> -[PASSES_ARGUMENT]-> <'from catch'>
    // Expect edge: <new Error('from finally')> -[PASSES_ARGUMENT]-> <'from finally'>
    // Expect edge: <catch-block> -[CATCHES_FROM]-> <new Error('original')>
    void code;
  });

  test('statements::tdz-switch-fallthrough', () => {
    const code = "function tdzSwitch(x) {\n  switch (x) {\n    case 1:\n      let y = 1; // y scoped to ENTIRE switch block\n      break;\n    case 2:\n      // console.log(y); // ReferenceError — TDZ\n      break;\n  }\n}";
    // Expect node: FUNCTION <tdzSwitch>
    // Expect node: PARAMETER <x>
    // Expect node: BRANCH <switch>
    // Expect node: SCOPE <switch-block-scope>
    // Expect node: CASE <case-1>
    // Expect node: LITERAL <1>
    // Expect node: VARIABLE <y>
    // Expect node: LITERAL <1-init>
    // Expect node: CASE <case-2>
    // Expect node: LITERAL <2>
    // Expect edge: <tdzSwitch> -[CONTAINS]-> <x>
    // Expect edge: <tdzSwitch> -[CONTAINS]-> <switch>
    // Expect edge: <switch> -[HAS_CONDITION]-> <x>
    // Expect edge: <switch> -[HAS_SCOPE]-> <switch-block-scope>
    // Expect edge: <switch-block-scope> -[DECLARES]-> <y>
    // Expect edge: <switch> -[HAS_CASE]-> <case-1>
    // Expect edge: <case-1> -[HAS_CONDITION]-> <1>
    // Expect edge: <case-1> -[CONTAINS]-> <y>
    // Expect edge: <switch> -[HAS_CASE]-> <case-2>
    // Expect edge: <case-2> -[HAS_CONDITION]-> <2>
    void code;
  });

  test('statements::for-of-no-declaration', () => {
    const code = "function forOfNoDeclaration(items) {\n  let item;\n  for (item of items) {           // REASSIGNS existing var, not declaration\n    console.log(item);\n  }\n  return item; // last item — outer var mutated\n}";
    // Expect node: FUNCTION <forOfNoDeclaration>
    // Expect node: PARAMETER <items>
    // Expect node: VARIABLE <item>
    // Expect node: LOOP <for-of>
    // Expect node: CALL <console.log(item)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect edge: <forOfNoDeclaration> -[CONTAINS]-> <items>
    // Expect edge: <forOfNoDeclaration> -[CONTAINS]-> <item>
    // Expect edge: <forOfNoDeclaration> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <items>
    // Expect edge: <for-of> -[CONTAINS]-> <console.log(item)>
    // Expect edge: <console.log(item)> -[PASSES_ARGUMENT]-> <item>
    // Expect edge: <forOfNoDeclaration> -[RETURNS]-> <item>
    void code;
  });

  test('statements::destructure-catch-clause', () => {
    const code = "function destructureCatchClause() {\n  try {\n    throw { code: 'ENOENT', message: 'not found' };\n  } catch ({ code, message }) {\n    return { code, message };\n  }\n}";
    // Expect node: FUNCTION <destructureCatchClause>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: LITERAL <{ code: 'ENOENT', message: 'not found' }>
    // Expect node: LITERAL <'ENOENT'>
    // Expect node: LITERAL <'not found'>
    // Expect node: VARIABLE <code>
    // Expect node: VARIABLE <message>
    // Expect node: LITERAL <{ code, message }>
    // Expect edge: <destructureCatchClause> -[CONTAINS]-> <try-block>
    // Expect edge: <destructureCatchClause> -[CONTAINS]-> <catch-block>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <{ code: 'ENOENT', message: 'not found' }> -[HAS_PROPERTY]-> <'ENOENT'>
    // Expect edge: <{ code: 'ENOENT', message: 'not found' }> -[HAS_PROPERTY]-> <'not found'>
    // Expect edge: <catch-block> -[DECLARES]-> <code>
    // Expect edge: <catch-block> -[DECLARES]-> <message>
    // Expect edge: <destructureCatchClause> -[RETURNS]-> <{ code, message }>
    void code;
  });

  test('statements::throw', () => {
    const code = "function throwError(type) {\n  if (type === 'error') {\n    throw new Error('Something went wrong');\n  }\n  if (type === 'custom') {\n    throw { code: 'CUSTOM', message: 'Custom error' };\n  }\n  if (type === 'string') {\n    throw 'simple string error';\n  }\n}";
    // Expect node: FUNCTION <throwError>
    // Expect node: PARAMETER <type>
    // Expect node: BRANCH <if-error>
    // Expect node: EXPRESSION <type === 'error'>
    // Expect node: LITERAL <'error'>
    // Expect node: EXPRESSION <throw-error>
    // Expect node: CALL <new Error('Something went wrong')>
    // Expect node: LITERAL <'Something went wrong'>
    // Expect node: BRANCH <if-custom>
    // Expect node: EXPRESSION <type === 'custom'>
    // Expect node: LITERAL <'custom'>
    // Expect node: EXPRESSION <throw-custom>
    // Expect node: LITERAL <custom-object>
    // Expect node: LITERAL <'CUSTOM'>
    // Expect node: LITERAL <'Custom error'>
    // Expect node: BRANCH <if-string>
    // Expect node: EXPRESSION <type === 'string'>
    // Expect node: LITERAL <'string'>
    // Expect node: EXPRESSION <throw-string>
    // Expect node: LITERAL <'simple string error'>
    // Expect edge: <throwError> -[CONTAINS]-> <type>
    // Expect edge: <throwError> -[CONTAINS]-> <if-error>
    // Expect edge: <throwError> -[CONTAINS]-> <if-custom>
    // Expect edge: <throwError> -[CONTAINS]-> <if-string>
    // Expect edge: <if-error> -[HAS_CONDITION]-> <type === 'error'>
    // Expect edge: <if-error> -[HAS_CONSEQUENT]-> <throw-error>
    // Expect edge: <new Error('Something went wrong')> -[PASSES_ARGUMENT]-> <'Something went wrong'>
    // Expect edge: <if-custom> -[HAS_CONDITION]-> <type === 'custom'>
    // Expect edge: <if-custom> -[HAS_CONSEQUENT]-> <throw-custom>
    // Expect edge: <custom-object> -[HAS_PROPERTY]-> <'CUSTOM'>
    // Expect edge: <custom-object> -[HAS_PROPERTY]-> <'Custom error'>
    // Expect edge: <if-string> -[HAS_CONDITION]-> <type === 'string'>
    // Expect edge: <if-string> -[HAS_CONSEQUENT]-> <throw-string>
    void code;
  });

  test('statements::labeled-continue', () => {
    const code = "function labeledContinue() {\n  const results = [];\n  loop: for (let i = 0; i < 5; i++) {\n    if (i === 3) continue loop;\n    results.push(i);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <labeledContinue>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LABEL <loop>
    // Expect node: LOOP <for-loop>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0>
    // Expect node: EXPRESSION <i < 5>
    // Expect node: LITERAL <5>
    // Expect node: EXPRESSION <i++>
    // Expect node: BRANCH <if-i===3>
    // Expect node: EXPRESSION <i === 3>
    // Expect node: LITERAL <3>
    // Expect node: EXPRESSION <continue-loop>
    // Expect node: CALL <results.push(i)>
    // Expect node: PROPERTY_ACCESS <results.push>
    // Expect edge: <labeledContinue> -[CONTAINS]-> <results>
    // Expect edge: <labeledContinue> -[CONTAINS]-> <loop>
    // Expect edge: <labeledContinue> -[CONTAINS]-> <for-loop>
    // Expect edge: <for-loop> -[CONTAINS]-> <i>
    // Expect edge: <for-loop> -[HAS_CONDITION]-> <i < 5>
    // Expect edge: <for-loop> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-loop> -[HAS_BODY]-> <if-i===3>
    // Expect edge: <if-i===3> -[HAS_CONDITION]-> <i === 3>
    // Expect edge: <if-i===3> -[HAS_CONSEQUENT]-> <continue-loop>
    // Expect edge: <for-loop> -[HAS_BODY]-> <results.push(i)>
    // Expect edge: <results.push(i)> -[PASSES_ARGUMENT]-> <i>
    // Expect edge: <labeledContinue> -[RETURNS]-> <results>
    void code;
  });

  test('statements::for-in-no-declaration', () => {
    const code = "function forInNoDeclaration(obj) {\n  let key;\n  for (key in obj) {              // REASSIGNS existing var\n    console.log(key);\n  }\n  return key; // last key — outer var mutated\n}";
    // Expect node: FUNCTION <forInNoDeclaration>
    // Expect node: PARAMETER <obj>
    // Expect node: VARIABLE <key>
    // Expect node: LOOP <for-in>
    // Expect node: CALL <console.log(key)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect edge: <forInNoDeclaration> -[CONTAINS]-> <obj>
    // Expect edge: <forInNoDeclaration> -[CONTAINS]-> <key>
    // Expect edge: <forInNoDeclaration> -[CONTAINS]-> <for-in>
    // Expect edge: <for-in> -[ITERATES_OVER]-> <obj>
    // Expect edge: <for-in> -[HAS_BODY]-> <console.log(key)>
    // Expect edge: <console.log(key)> -[PASSES_ARGUMENT]-> <key>
    // Expect edge: <forInNoDeclaration> -[RETURNS]-> <key>
    void code;
  });

  test('builtins::sparse-array', () => {
    const code = "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false — hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}";
    // Expect node: FUNCTION <sparseArrayOps>
    // Expect node: VARIABLE <sparse>
    // Expect node: LITERAL <sparse-array>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <3>
    // Expect node: LITERAL <5>
    // Expect node: VARIABLE <length>
    // Expect node: PROPERTY_ACCESS <sparse.length>
    // Expect node: VARIABLE <hasIndex1>
    // Expect node: EXPRESSION <1 in sparse>
    // Expect node: LITERAL <1-key>
    // Expect node: VARIABLE <mapped>
    // Expect node: CALL <sparse.map(x => x * 2)>
    // Expect node: FUNCTION <map-callback>
    // Expect node: PARAMETER <x>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect node: EXPRESSION <return-object>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <sparse>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <length>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <hasIndex1>
    // Expect edge: <sparseArrayOps> -[CONTAINS]-> <mapped>
    // Expect edge: <sparse-array> -[HAS_ELEMENT]-> <1>
    // Expect edge: <sparse-array> -[HAS_ELEMENT]-> <3>
    // Expect edge: <sparse-array> -[HAS_ELEMENT]-> <5>
    // Expect edge: <sparse.map(x => x * 2)> -[PASSES_ARGUMENT]-> <map-callback>
    // Expect edge: <map-callback> -[CONTAINS]-> <x>
    // Expect edge: <map-callback> -[RETURNS]-> <x * 2>
    // Expect edge: <sparseArrayOps> -[RETURNS]-> <return-object>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <length>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <hasIndex1>
    // Expect edge: <return-object> -[HAS_PROPERTY]-> <mapped>
    void code;
  });

  test('statements::switch-true-pattern', () => {
    const code = "function switchTruePattern(x) {\n  switch (true) {\n    case x > 100: return 'high';\n    case x > 50:  return 'medium';\n    case x > 0:   return 'low';\n    default:       return 'none';\n  }\n}";
    // Expect node: FUNCTION <switchTruePattern>
    // Expect node: PARAMETER <x>
    // Expect node: BRANCH <switch-true>
    // Expect node: LITERAL <true>
    // Expect node: CASE <case-x>100>
    // Expect node: EXPRESSION <x > 100>
    // Expect node: LITERAL <100>
    // Expect node: LITERAL <'high'>
    // Expect node: CASE <case-x>50>
    // Expect node: EXPRESSION <x > 50>
    // Expect node: LITERAL <50>
    // Expect node: LITERAL <'medium'>
    // Expect node: CASE <case-x>0>
    // Expect node: EXPRESSION <x > 0>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <'low'>
    // Expect node: CASE <default-case>
    // Expect node: LITERAL <'none'>
    // Expect edge: <switchTruePattern> -[CONTAINS]-> <x>
    // Expect edge: <switchTruePattern> -[CONTAINS]-> <switch-true>
    // Expect edge: <switch-true> -[HAS_CONDITION]-> <true>
    // Expect edge: <switch-true> -[HAS_CASE]-> <case-x>100>
    // Expect edge: <switch-true> -[HAS_CASE]-> <case-x>50>
    // Expect edge: <switch-true> -[HAS_CASE]-> <case-x>0>
    // Expect edge: <switch-true> -[HAS_DEFAULT]-> <default-case>
    // Expect edge: <case-x>100> -[HAS_CONDITION]-> <x > 100>
    // Expect edge: <case-x>100> -[RETURNS]-> <'high'>
    // Expect edge: <case-x>50> -[HAS_CONDITION]-> <x > 50>
    // Expect edge: <case-x>50> -[RETURNS]-> <'medium'>
    // Expect edge: <case-x>0> -[HAS_CONDITION]-> <x > 0>
    // Expect edge: <case-x>0> -[RETURNS]-> <'low'>
    // Expect edge: <default-case> -[RETURNS]-> <'none'>
    void code;
  });

  test('statements::for-of-destructure-assign', () => {
    const code = "function forOfDestructureAssign(pairs) {\n  let a, b;\n  for ([a, b] of pairs) {        // destructuring assignment in for-of head\n    console.log(a, b);\n  }\n  return { a, b }; // last pair values\n}";
    // Expect node: FUNCTION <forOfDestructureAssign>
    // Expect node: PARAMETER <pairs>
    // Expect node: VARIABLE <a>
    // Expect node: VARIABLE <b>
    // Expect node: LOOP <for-of>
    // Expect node: EXPRESSION <[a, b]>
    // Expect node: CALL <console.log(a, b)>
    // Expect node: PROPERTY_ACCESS <console.log>
    // Expect node: EXPRESSION <{ a, b }>
    // Expect edge: <forOfDestructureAssign> -[CONTAINS]-> <pairs>
    // Expect edge: <forOfDestructureAssign> -[CONTAINS]-> <a>
    // Expect edge: <forOfDestructureAssign> -[CONTAINS]-> <b>
    // Expect edge: <forOfDestructureAssign> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <pairs>
    // Expect edge: <for-of> -[CONTAINS]-> <console.log(a, b)>
    // Expect edge: <console.log(a, b)> -[PASSES_ARGUMENT]-> <a>
    // Expect edge: <console.log(a, b)> -[PASSES_ARGUMENT]-> <b>
    // Expect edge: <forOfDestructureAssign> -[RETURNS]-> <{ a, b }>
    void code;
  });

  test('ts-specific::interface-basic', () => {
    const code = "interface User {\n  name: string;\n  age: number;\n  email?: string;\n  readonly id: number;\n}";
    // Expect node: INTERFACE <User>
    // Expect node: PROPERTY <User.name>
    // Expect node: PROPERTY <User.age>
    // Expect node: PROPERTY <User.email>
    // Expect node: PROPERTY <User.id>
    // Expect edge: <module> -[DECLARES]-> <User>
    // Expect edge: <User> -[CONTAINS]-> <User.name>
    // Expect edge: <User> -[CONTAINS]-> <User.age>
    // Expect edge: <User> -[CONTAINS]-> <User.email>
    // Expect edge: <User> -[CONTAINS]-> <User.id>
    void code;
  });

  test('statements::for-of-destructuring-object', () => {
    const code = "function forOfDestructuringObject() {\n  const points = [{ x: 1, y: 2 }, { x: 3, y: 4 }];\n  const results = [];\n  for (const { x, y } of points) {\n    results.push(x + y);\n  }\n  return results;\n}";
    // Expect node: FUNCTION <forOfDestructuringObject>
    // Expect node: VARIABLE <points>
    // Expect node: LITERAL <[{ x: 1, y: 2 }, { x: 3, y: 4 }]>
    // Expect node: LITERAL <{ x: 1, y: 2 }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <{ x: 3, y: 4 }>
    // Expect node: LITERAL <3>
    // Expect node: LITERAL <4>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-of>
    // Expect node: VARIABLE <x>
    // Expect node: VARIABLE <y>
    // Expect node: CALL <results.push(x + y)>
    // Expect node: EXPRESSION <x + y>
    // Expect edge: <forOfDestructuringObject> -[CONTAINS]-> <points>
    // Expect edge: <[{ x: 1, y: 2 }, { x: 3, y: 4 }]> -[HAS_ELEMENT]-> <{ x: 1, y: 2 }>
    // Expect edge: <[{ x: 1, y: 2 }, { x: 3, y: 4 }]> -[HAS_ELEMENT]-> <{ x: 3, y: 4 }>
    // Expect edge: <{ x: 1, y: 2 }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ x: 1, y: 2 }> -[HAS_PROPERTY]-> <2>
    // Expect edge: <{ x: 3, y: 4 }> -[HAS_PROPERTY]-> <3>
    // Expect edge: <{ x: 3, y: 4 }> -[HAS_PROPERTY]-> <4>
    // Expect edge: <forOfDestructuringObject> -[CONTAINS]-> <results>
    // Expect edge: <forOfDestructuringObject> -[CONTAINS]-> <for-of>
    // Expect edge: <for-of> -[ITERATES_OVER]-> <points>
    // Expect edge: <for-of> -[CONTAINS]-> <x>
    // Expect edge: <for-of> -[CONTAINS]-> <y>
    // Expect edge: <for-of> -[HAS_BODY]-> <results.push(x + y)>
    // Expect edge: <results.push(x + y)> -[PASSES_ARGUMENT]-> <x + y>
    // Expect edge: <forOfDestructuringObject> -[RETURNS]-> <results>
    void code;
  });

  test('statements::for-in-destructuring', () => {
    const code = "function forInDestructuring() {\n  const results = [];\n  for (const { length } in { abc: 1, de: 2, f: 3 }) {\n    results.push(length); // 3, 2, 1 — destructures the string KEY, not value\n  }\n  return results;\n}";
    // Expect node: FUNCTION <forInDestructuring>
    // Expect node: VARIABLE <results>
    // Expect node: LITERAL <[]>
    // Expect node: LOOP <for-in>
    // Expect node: VARIABLE <length>
    // Expect node: LITERAL <{ abc: 1, de: 2, f: 3 }>
    // Expect node: CALL <results.push(length)>
    // Expect node: PROPERTY_ACCESS <results.push>
    // Expect edge: <forInDestructuring> -[CONTAINS]-> <results>
    // Expect edge: <forInDestructuring> -[CONTAINS]-> <for-in>
    // Expect edge: <for-in> -[ITERATES_OVER]-> <{ abc: 1, de: 2, f: 3 }>
    // Expect edge: <for-in> -[CONTAINS]-> <length>
    // Expect edge: <for-in> -[HAS_BODY]-> <results.push(length)>
    // Expect edge: <results.push(length)> -[PASSES_ARGUMENT]-> <length>
    // Expect edge: <forInDestructuring> -[RETURNS]-> <results>
    void code;
  });

  test('ts-specific::ts-typed-function', () => {
    const code = "function typedFunction(name: string, age: number): string {\n  return `${name} is ${age}`;\n}";
    // Expect node: FUNCTION <typedFunction>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <age>
    // Expect node: TYPE_REFERENCE <string:return>
    // Expect node: EXPRESSION <`${name} is ${age}`>
    // Expect node: EXPRESSION <${name}>
    // Expect node: EXPRESSION <${age}>
    // Expect edge: <module> -[DECLARES]-> <typedFunction>
    // Expect edge: <typedFunction> -[CONTAINS]-> <name>
    // Expect edge: <typedFunction> -[CONTAINS]-> <age>
    // Expect edge: <typedFunction> -[RETURNS_TYPE]-> <string:return>
    // Expect edge: <typedFunction> -[RETURNS]-> <`${name} is ${age}`>
    // Expect edge: <`${name} is ${age}`> -[CONTAINS]-> <${name}>
    // Expect edge: <`${name} is ${age}`> -[CONTAINS]-> <${age}>
    void code;
  });

  test('ts-specific::interface-method', () => {
    const code = "interface Printable {\n  print(): void;\n}";
    // Expect node: INTERFACE <Printable>
    // Expect node: METHOD <Printable.print>
    // Expect edge: <module> -[DECLARES]-> <Printable>
    // Expect edge: <Printable> -[CONTAINS]-> <Printable.print>
    void code;
  });

  test('statements::destructure-catch-nested', () => {
    const code = "function destructureCatchNested() {\n  try {\n    throw { errors: [{ code: 'E1', path: '/api' }], status: 500 };\n  } catch ({ errors: [{ code, path }], status }) {\n    return { code, path, status };\n  }\n}";
    // Expect node: FUNCTION <destructureCatchNested>
    // Expect node: TRY_BLOCK <try-block>
    // Expect node: CATCH_BLOCK <catch-block>
    // Expect node: LITERAL <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>
    // Expect node: LITERAL <'E1'>
    // Expect node: LITERAL <'/api'>
    // Expect node: LITERAL <500>
    // Expect node: VARIABLE <code>
    // Expect node: VARIABLE <path>
    // Expect node: VARIABLE <status>
    // Expect node: EXPRESSION <{ code, path, status }>
    // Expect edge: <destructureCatchNested> -[CONTAINS]-> <try-block>
    // Expect edge: <destructureCatchNested> -[CONTAINS]-> <catch-block>
    // Expect edge: <try-block> -[HAS_CATCH]-> <catch-block>
    // Expect edge: <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }> -[CONTAINS]-> <'E1'>
    // Expect edge: <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }> -[CONTAINS]-> <'/api'>
    // Expect edge: <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }> -[CONTAINS]-> <500>
    // Expect edge: <catch-block> -[DECLARES]-> <code>
    // Expect edge: <catch-block> -[DECLARES]-> <path>
    // Expect edge: <catch-block> -[DECLARES]-> <status>
    // Expect edge: <destructureCatchNested> -[RETURNS]-> <{ code, path, status }>
    void code;
  });

  test('ts-specific::interface-extends', () => {
    const code = "interface Admin extends User, Printable {\n  role: string;\n  permissions: string[];\n}";
    // Expect node: INTERFACE <Admin>
    // Expect node: PROPERTY <Admin.role>
    // Expect node: PROPERTY <Admin.permissions>
    // Expect edge: <module> -[DECLARES]-> <Admin>
    // Expect edge: <Admin> -[CONTAINS]-> <Admin.role>
    // Expect edge: <Admin> -[CONTAINS]-> <Admin.permissions>
    void code;
  });

  test('ts-specific::interface-index-signature', () => {
    const code = "interface StringMap {\n  [key: string]: string;\n}";
    // Expect node: INTERFACE <StringMap>
    // Expect node: PROPERTY <StringMap[key: string]>
    // Expect node: PARAMETER <key>
    // Expect edge: <module> -[DECLARES]-> <StringMap>
    // Expect edge: <StringMap> -[HAS_PROPERTY]-> <StringMap[key: string]>
    // Expect edge: <StringMap[key: string]> -[CONTAINS]-> <key>
    void code;
  });

  test('ts-specific::type-alias-union', () => {
    const code = "type ID = string | number;";
    // Expect node: TYPE_ALIAS <ID>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <number>
    // Expect edge: <module> -[DECLARES]-> <ID>
    // Expect edge: <ID> -[UNION_MEMBER]-> <string>
    // Expect edge: <ID> -[UNION_MEMBER]-> <number>
    void code;
  });

  test('ts-specific::ts-typed-arrow', () => {
    const code = "const typedArrow = (x: number): number => x * 2;";
    // Expect node: VARIABLE <typedArrow>
    // Expect node: FUNCTION <typedArrow:fn>
    // Expect node: PARAMETER <x>
    // Expect node: TYPE_REFERENCE <number:param>
    // Expect node: TYPE_REFERENCE <number:return>
    // Expect node: EXPRESSION <x * 2>
    // Expect node: LITERAL <2>
    // Expect edge: <module> -[DECLARES]-> <typedArrow>
    // Expect edge: <typedArrow:fn> -[CONTAINS]-> <x>
    // Expect edge: <typedArrow:fn> -[RETURNS_TYPE]-> <number:return>
    // Expect edge: <typedArrow:fn> -[RETURNS]-> <x * 2>
    void code;
  });

  test('ts-specific::interface-construct-signature', () => {
    const code = "interface Constructor {\n  new (name: string): User;\n}";
    // Expect node: INTERFACE <Constructor>
    // Expect node: METHOD <Constructor.new>
    // Expect node: PARAMETER <name>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <User>
    // Expect edge: <Constructor> -[CONTAINS]-> <Constructor.new>
    // Expect edge: <Constructor.new> -[RECEIVES_ARGUMENT]-> <name>
    // Expect edge: <Constructor.new> -[RETURNS_TYPE]-> <User>
    void code;
  });

  test('ts-specific::interface-call-signature', () => {
    const code = "interface Logger {\n  (message: string): void;\n  level: string;\n}";
    // Expect node: INTERFACE <Logger>
    // Expect node: METHOD <Logger:call>
    // Expect node: PARAMETER <message>
    // Expect node: PROPERTY <Logger.level>
    // Expect edge: <module> -[DECLARES]-> <Logger>
    // Expect edge: <Logger> -[CONTAINS]-> <Logger:call>
    // Expect edge: <Logger> -[CONTAINS]-> <Logger.level>
    // Expect edge: <Logger:call> -[RECEIVES_ARGUMENT]-> <message>
    void code;
  });

  test('ts-specific::type-alias-tuple', () => {
    const code = "type Pair<A, B> = [A, B];";
    // Expect node: TYPE_ALIAS <Pair>
    // Expect node: TYPE_PARAMETER <A>
    // Expect node: TYPE_PARAMETER <B>
    // Expect node: TYPE_REFERENCE <[A, B]>
    // Expect edge: <module> -[DECLARES]-> <Pair>
    // Expect edge: <Pair> -[HAS_TYPE_PARAMETER]-> <A>
    // Expect edge: <Pair> -[HAS_TYPE_PARAMETER]-> <B>
    // Expect edge: <[A, B]> -[HAS_ELEMENT]-> <A>
    // Expect edge: <[A, B]> -[HAS_ELEMENT]-> <B>
    void code;
  });

  test('ts-specific::enum-numeric', () => {
    const code = "enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}";
    // Expect node: ENUM <Direction>
    // Expect node: ENUM_MEMBER <Direction.Up>
    // Expect node: ENUM_MEMBER <Direction.Down>
    // Expect node: ENUM_MEMBER <Direction.Left>
    // Expect node: ENUM_MEMBER <Direction.Right>
    // Expect edge: <module> -[DECLARES]-> <Direction>
    // Expect edge: <Direction> -[CONTAINS]-> <Direction.Up>
    // Expect edge: <Direction> -[CONTAINS]-> <Direction.Down>
    // Expect edge: <Direction> -[CONTAINS]-> <Direction.Left>
    // Expect edge: <Direction> -[CONTAINS]-> <Direction.Right>
    void code;
  });

  test('ts-specific::enum-heterogeneous', () => {
    const code = "enum Mixed {\n  No = 0,\n  Yes = 'YES',\n}";
    // Expect node: ENUM <Mixed>
    // Expect node: ENUM_MEMBER <Mixed.No>
    // Expect node: LITERAL <0>
    // Expect node: ENUM_MEMBER <Mixed.Yes>
    // Expect node: LITERAL <'YES'>
    // Expect edge: <module> -[DECLARES]-> <Mixed>
    // Expect edge: <Mixed> -[CONTAINS]-> <Mixed.No>
    // Expect edge: <Mixed> -[CONTAINS]-> <Mixed.Yes>
    void code;
  });

  test('ts-specific::type-alias-generic', () => {
    const code = "type Nullable<T> = T | null;";
    // Expect node: TYPE_ALIAS <Nullable>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_REFERENCE <T:ref>
    // Expect node: LITERAL_TYPE <null>
    // Expect edge: <Nullable> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <Nullable> -[UNION_MEMBER]-> <T:ref>
    // Expect edge: <Nullable> -[UNION_MEMBER]-> <null>
    void code;
  });

  test('ts-specific::type-alias-function', () => {
    const code = "type Callback = (error: Error | null, result?: unknown) => void;";
    // Expect node: TYPE_ALIAS <Callback>
    // Expect node: PARAMETER <error>
    // Expect node: PARAMETER <result>
    // Expect node: TYPE_REFERENCE <Error | null>
    // Expect node: TYPE_REFERENCE <Error>
    // Expect node: LITERAL_TYPE <null>
    // Expect node: TYPE_REFERENCE <unknown>
    // Expect node: TYPE_REFERENCE <void>
    // Expect edge: <module> -[DECLARES]-> <Callback>
    // Expect edge: <Callback> -[CONTAINS]-> <error>
    // Expect edge: <Callback> -[CONTAINS]-> <result>
    // Expect edge: <Callback> -[RETURNS_TYPE]-> <void>
    // Expect edge: <Error | null> -[UNION_MEMBER]-> <Error>
    // Expect edge: <Error | null> -[UNION_MEMBER]-> <null>
    void code;
  });

  test('statements::for-comma-update', () => {
    const code = "function forCommaUpdate() {\n  const arr = [1, 2, 3, 4, 5];\n\n  // Two-pointer technique — comma in both init and update\n  for (let lo = 0, hi = arr.length - 1; lo < hi; lo++, hi--) {\n    [arr[lo], arr[hi]] = [arr[hi], arr[lo]]; // swap\n  }\n\n  // Side effect in update clause\n  let processed = 0;\n  for (let i = 0; i < 3; i++, processed++) {\n    // comma separates two update expressions\n  }\n\n  return { arr, processed };\n}";
    // Expect node: FUNCTION <forCommaUpdate>
    // Expect node: VARIABLE <arr>
    // Expect node: LITERAL <[1, 2, 3, 4, 5]>
    // Expect node: LOOP <for-two-pointer>
    // Expect node: VARIABLE <lo>
    // Expect node: LITERAL <0>
    // Expect node: VARIABLE <hi>
    // Expect node: EXPRESSION <arr.length - 1>
    // Expect node: EXPRESSION <lo < hi>
    // Expect node: EXPRESSION <lo++>
    // Expect node: EXPRESSION <hi-->
    // Expect node: EXPRESSION <[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>
    // Expect node: VARIABLE <processed>
    // Expect node: LITERAL <0-2>
    // Expect node: LOOP <for-side-effect>
    // Expect node: VARIABLE <i>
    // Expect node: LITERAL <0-3>
    // Expect node: EXPRESSION <i < 3>
    // Expect node: LITERAL <3>
    // Expect node: EXPRESSION <i++>
    // Expect node: EXPRESSION <processed++>
    // Expect node: EXPRESSION <{ arr, processed }>
    // Expect edge: <module> -[DECLARES]-> <forCommaUpdate>
    // Expect edge: <forCommaUpdate> -[CONTAINS]-> <arr>
    // Expect edge: <forCommaUpdate> -[CONTAINS]-> <for-two-pointer>
    // Expect edge: <for-two-pointer> -[HAS_INIT]-> <lo>
    // Expect edge: <for-two-pointer> -[HAS_INIT]-> <hi>
    // Expect edge: <for-two-pointer> -[HAS_CONDITION]-> <lo < hi>
    // Expect edge: <for-two-pointer> -[HAS_UPDATE]-> <lo++>
    // Expect edge: <for-two-pointer> -[HAS_UPDATE]-> <hi-->
    // Expect edge: <for-two-pointer> -[HAS_BODY]-> <[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>
    // Expect edge: <forCommaUpdate> -[CONTAINS]-> <processed>
    // Expect edge: <forCommaUpdate> -[CONTAINS]-> <for-side-effect>
    // Expect edge: <for-side-effect> -[HAS_INIT]-> <i>
    // Expect edge: <for-side-effect> -[HAS_CONDITION]-> <i < 3>
    // Expect edge: <for-side-effect> -[HAS_UPDATE]-> <i++>
    // Expect edge: <for-side-effect> -[HAS_UPDATE]-> <processed++>
    // Expect edge: <forCommaUpdate> -[RETURNS]-> <{ arr, processed }>
    void code;
  });

  test('statements::in-operator-type-guard', () => {
    const code = "function inOperatorTypeGuard(input) {\n  // 'prop' in obj as conditional guard — narrows type inside branch\n  if ('name' in input) {\n    return input.name.toUpperCase(); // safe — guarded by 'in' check\n  }\n\n  // Compound in-check — multiple property guards\n  if ('items' in input && 'count' in input) {\n    return input.items.slice(0, input.count);\n  }\n\n  // Negated in-check\n  if (!('error' in input)) {\n    return input;\n  }\n\n  return null;\n}";
    // Expect node: FUNCTION <inOperatorTypeGuard>
    // Expect node: PARAMETER <input>
    // Expect node: BRANCH <if-name-in-input>
    // Expect node: EXPRESSION <'name' in input>
    // Expect node: LITERAL <'name'>
    // Expect node: PROPERTY_ACCESS <input.name>
    // Expect node: CALL <input.name.toUpperCase()>
    // Expect node: BRANCH <if-items-and-count>
    // Expect node: EXPRESSION <'items' in input && 'count' in input>
    // Expect node: EXPRESSION <'items' in input>
    // Expect node: LITERAL <'items'>
    // Expect node: EXPRESSION <'count' in input>
    // Expect node: LITERAL <'count'>
    // Expect node: PROPERTY_ACCESS <input.items>
    // Expect node: CALL <input.items.slice(0, input.count)>
    // Expect node: LITERAL <0>
    // Expect node: PROPERTY_ACCESS <input.count>
    // Expect node: BRANCH <if-not-error>
    // Expect node: EXPRESSION <!('error' in input)>
    // Expect node: EXPRESSION <'error' in input>
    // Expect node: LITERAL <'error'>
    // Expect node: LITERAL <null>
    // Expect edge: <module> -[DECLARES]-> <inOperatorTypeGuard>
    // Expect edge: <inOperatorTypeGuard> -[CONTAINS]-> <input>
    // Expect edge: <inOperatorTypeGuard> -[CONTAINS]-> <if-name-in-input>
    // Expect edge: <if-name-in-input> -[HAS_CONDITION]-> <'name' in input>
    // Expect edge: <if-name-in-input> -[HAS_CONSEQUENT]-> <input.name.toUpperCase()>
    // Expect edge: <inOperatorTypeGuard> -[CONTAINS]-> <if-items-and-count>
    // Expect edge: <if-items-and-count> -[HAS_CONDITION]-> <'items' in input && 'count' in input>
    // Expect edge: <if-items-and-count> -[HAS_CONSEQUENT]-> <input.items.slice(0, input.count)>
    // Expect edge: <input.items.slice(0, input.count)> -[PASSES_ARGUMENT]-> <0>
    // Expect edge: <input.items.slice(0, input.count)> -[PASSES_ARGUMENT]-> <input.count>
    // Expect edge: <inOperatorTypeGuard> -[CONTAINS]-> <if-not-error>
    // Expect edge: <if-not-error> -[HAS_CONDITION]-> <!('error' in input)>
    // Expect edge: <if-not-error> -[HAS_CONSEQUENT]-> <input>
    // Expect edge: <inOperatorTypeGuard> -[RETURNS]-> <null>
    // Expect edge: <if-name-in-input> -[RETURNS]-> <input.name.toUpperCase()>
    // Expect edge: <if-items-and-count> -[RETURNS]-> <input.items.slice(0, input.count)>
    // Expect edge: <if-not-error> -[RETURNS]-> <input>
    void code;
  });

  test('ts-specific::enum-const', () => {
    const code = "const enum Flags {\n  Read = 1,\n  Write = 2,\n  Execute = 4,\n}";
    // Expect node: ENUM <Flags>
    // Expect node: ENUM_MEMBER <Flags.Read>
    // Expect node: LITERAL <1>
    // Expect node: ENUM_MEMBER <Flags.Write>
    // Expect node: LITERAL <2>
    // Expect node: ENUM_MEMBER <Flags.Execute>
    // Expect node: LITERAL <4>
    // Expect edge: <module> -[DECLARES]-> <Flags>
    // Expect edge: <Flags> -[CONTAINS]-> <Flags.Read>
    // Expect edge: <Flags> -[CONTAINS]-> <Flags.Write>
    // Expect edge: <Flags> -[CONTAINS]-> <Flags.Execute>
    void code;
  });

  test('ts-specific::enum-string', () => {
    const code = "enum Status {\n  Active = 'ACTIVE',\n  Inactive = 'INACTIVE',\n  Pending = 'PENDING',\n}";
    // Expect node: ENUM <Status>
    // Expect node: ENUM_MEMBER <Status.Active>
    // Expect node: LITERAL <'ACTIVE'>
    // Expect node: ENUM_MEMBER <Status.Inactive>
    // Expect node: LITERAL <'INACTIVE'>
    // Expect node: ENUM_MEMBER <Status.Pending>
    // Expect node: LITERAL <'PENDING'>
    // Expect edge: <module> -[DECLARES]-> <Status>
    // Expect edge: <Status> -[CONTAINS]-> <Status.Active>
    // Expect edge: <Status> -[CONTAINS]-> <Status.Inactive>
    // Expect edge: <Status> -[CONTAINS]-> <Status.Pending>
    void code;
  });

  test('ts-specific::generic-function', () => {
    const code = "function identity<T>(value: T): T {\n  return value;\n}";
    // Expect node: FUNCTION <identity>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: PARAMETER <value>
    // Expect node: TYPE_REFERENCE <T:param>
    // Expect node: TYPE_REFERENCE <T:return>
    // Expect edge: <module> -[DECLARES]-> <identity>
    // Expect edge: <identity> -[CONTAINS]-> <T>
    // Expect edge: <identity> -[CONTAINS]-> <value>
    // Expect edge: <identity> -[RETURNS_TYPE]-> <T:return>
    // Expect edge: <identity> -[RETURNS]-> <value>
    void code;
  });

  test('ts-specific::generic-function-multi', () => {
    const code = "function merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}";
    // Expect node: FUNCTION <merge>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_PARAMETER <U>
    // Expect node: PARAMETER <obj1>
    // Expect node: PARAMETER <obj2>
    // Expect node: TYPE_REFERENCE <T & U>
    // Expect node: EXPRESSION <{ ...obj1, ...obj2 }>
    // Expect edge: <module> -[DECLARES]-> <merge>
    // Expect edge: <merge> -[CONTAINS]-> <T>
    // Expect edge: <merge> -[CONTAINS]-> <U>
    // Expect edge: <merge> -[CONTAINS]-> <obj1>
    // Expect edge: <merge> -[CONTAINS]-> <obj2>
    // Expect edge: <merge> -[RETURNS_TYPE]-> <T & U>
    // Expect edge: <T & U> -[INTERSECTS_WITH]-> <T>
    // Expect edge: <T & U> -[INTERSECTS_WITH]-> <U>
    // Expect edge: <merge> -[RETURNS]-> <{ ...obj1, ...obj2 }>
    // Expect edge: <{ ...obj1, ...obj2 }> -[SPREADS_FROM]-> <obj1>
    // Expect edge: <{ ...obj1, ...obj2 }> -[SPREADS_FROM]-> <obj2>
    void code;
  });

  test('ts-specific::generic-constraint', () => {
    const code = "function getLength<T extends { length: number }>(item: T): number {\n  return item.length;\n}";
    // Expect node: FUNCTION <getLength>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_REFERENCE <{ length: number }>
    // Expect node: PARAMETER <item>
    // Expect node: TYPE_REFERENCE <T:param>
    // Expect node: TYPE_REFERENCE <number:return>
    // Expect node: PROPERTY_ACCESS <item.length>
    // Expect edge: <module> -[DECLARES]-> <getLength>
    // Expect edge: <getLength> -[CONTAINS]-> <T>
    // Expect edge: <T> -[CONSTRAINED_BY]-> <{ length: number }>
    // Expect edge: <getLength> -[CONTAINS]-> <item>
    // Expect edge: <getLength> -[RETURNS_TYPE]-> <number:return>
    // Expect edge: <getLength> -[RETURNS]-> <item.length>
    void code;
  });

  test('ts-specific::generic-default', () => {
    const code = "function createArray<T = string>(length: number, fill: T): T[] {\n  return Array(length).fill(fill);\n}";
    // Expect node: FUNCTION <createArray>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: PARAMETER <length>
    // Expect node: PARAMETER <fill>
    // Expect node: CALL <Array(length)>
    // Expect node: CALL <Array(length).fill(fill)>
    // Expect edge: <module> -[DECLARES]-> <createArray>
    // Expect edge: <createArray> -[CONTAINS]-> <T>
    // Expect edge: <createArray> -[CONTAINS]-> <length>
    // Expect edge: <createArray> -[CONTAINS]-> <fill>
    // Expect edge: <createArray> -[RETURNS]-> <Array(length).fill(fill)>
    // Expect edge: <Array(length)> -[PASSES_ARGUMENT]-> <length>
    // Expect edge: <Array(length).fill(fill)> -[PASSES_ARGUMENT]-> <fill>
    void code;
  });

  test('ts-specific::generic-interface', () => {
    const code = "interface Repository<T> {\n  find(id: string): Promise<T>;\n  save(item: T): Promise<void>;\n  delete(id: string): Promise<boolean>;\n}";
    // Expect node: INTERFACE <Repository>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: METHOD <Repository.find>
    // Expect node: PARAMETER <id>
    // Expect node: TYPE_REFERENCE <Promise<T>>
    // Expect node: METHOD <Repository.save>
    // Expect node: PARAMETER <item>
    // Expect node: TYPE_REFERENCE <Promise<void>>
    // Expect node: METHOD <Repository.delete>
    // Expect node: PARAMETER <id2>
    // Expect node: TYPE_REFERENCE <Promise<boolean>>
    // Expect edge: <module> -[DECLARES]-> <Repository>
    // Expect edge: <Repository> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <Repository> -[CONTAINS]-> <Repository.find>
    // Expect edge: <Repository> -[CONTAINS]-> <Repository.save>
    // Expect edge: <Repository> -[CONTAINS]-> <Repository.delete>
    // Expect edge: <Repository.find> -[CONTAINS]-> <id>
    // Expect edge: <Repository.find> -[RETURNS]-> <Promise<T>>
    // Expect edge: <Promise<T>> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <Repository.save> -[CONTAINS]-> <item>
    // Expect edge: <Repository.save> -[RETURNS]-> <Promise<void>>
    // Expect edge: <Repository.delete> -[CONTAINS]-> <id2>
    // Expect edge: <Repository.delete> -[RETURNS]-> <Promise<boolean>>
    void code;
  });

  test('ts-specific::satisfies', () => {
    const code = "const theme = {\n  primary: '#007bff',\n  secondary: '#6c757d',\n} satisfies Record<string, string>;";
    // Expect node: VARIABLE <theme>
    // Expect node: LITERAL <{primary: '#007bff', secondary: '#6c757d'}>
    // Expect node: LITERAL <'#007bff'>
    // Expect node: LITERAL <'#6c757d'>
    // Expect node: TYPE_REFERENCE <Record<string, string>>
    // Expect edge: <module> -[DECLARES]-> <theme>
    // Expect edge: <{primary: '#007bff', secondary: '#6c757d'}> -[HAS_PROPERTY]-> <'#007bff'>
    // Expect edge: <{primary: '#007bff', secondary: '#6c757d'}> -[HAS_PROPERTY]-> <'#6c757d'>
    void code;
  });

  test('ts-specific::type-assertion-as', () => {
    const code = "function typeAssertions(value: unknown) {\n  const asString = value as string;\n  const angleBracket = <number>value;\n  return { asString, angleBracket };\n}";
    // Expect node: FUNCTION <typeAssertions>
    // Expect node: PARAMETER <value>
    // Expect node: VARIABLE <asString>
    // Expect node: EXPRESSION <value as string>
    // Expect node: VARIABLE <angleBracket>
    // Expect node: EXPRESSION <<number>value>
    // Expect node: EXPRESSION <{ asString, angleBracket }>
    // Expect edge: <module> -[DECLARES]-> <typeAssertions>
    // Expect edge: <typeAssertions> -[CONTAINS]-> <value>
    // Expect edge: <typeAssertions> -[DECLARES]-> <asString>
    // Expect edge: <typeAssertions> -[DECLARES]-> <angleBracket>
    // Expect edge: <typeAssertions> -[RETURNS]-> <{ asString, angleBracket }>
    void code;
  });

  test('ts-specific::non-null-assertion', () => {
    const code = "function nonNullAssertion(map: Map<string, string>) {\n  const value = map.get('key')!;\n  return value.toUpperCase();\n}";
    // Expect node: FUNCTION <nonNullAssertion>
    // Expect node: PARAMETER <map>
    // Expect node: VARIABLE <value>
    // Expect node: CALL <map.get('key')>
    // Expect node: LITERAL <'key'>
    // Expect node: EXPRESSION <map.get('key')!>
    // Expect node: CALL <value.toUpperCase()>
    // Expect edge: <module> -[DECLARES]-> <nonNullAssertion>
    // Expect edge: <nonNullAssertion> -[CONTAINS]-> <map>
    // Expect edge: <nonNullAssertion> -[DECLARES]-> <value>
    // Expect edge: <map.get('key')> -[PASSES_ARGUMENT]-> <'key'>
    // Expect edge: <nonNullAssertion> -[RETURNS]-> <value.toUpperCase()>
    void code;
  });

  test('ts-specific::access-modifiers', () => {
    const code = "class Service {\n  public name: string;\n  protected config: Record<string, unknown>;\n  private secret: string;\n\n  constructor(name: string, secret: string) {\n    this.name = name;\n    this.config = {};\n    this.secret = secret;\n  }\n}";
    // Expect node: CLASS <Service>
    // Expect node: PROPERTY <Service.name>
    // Expect node: PROPERTY <Service.config>
    // Expect node: PROPERTY <Service.secret>
    // Expect node: METHOD <Service.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <secret>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect node: PROPERTY_ACCESS <this.config>
    // Expect node: PROPERTY_ACCESS <this.secret>
    // Expect node: LITERAL <{}>
    // Expect edge: <module> -[DECLARES]-> <Service>
    // Expect edge: <Service> -[CONTAINS]-> <Service.name>
    // Expect edge: <Service> -[CONTAINS]-> <Service.config>
    // Expect edge: <Service> -[CONTAINS]-> <Service.secret>
    // Expect edge: <Service> -[CONTAINS]-> <Service.constructor>
    // Expect edge: <Service.constructor> -[CONTAINS]-> <name>
    // Expect edge: <Service.constructor> -[CONTAINS]-> <secret>
    void code;
  });

  test('ts-specific::generic-class', () => {
    const code = "class Container<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n\n  map<U>(fn: (value: T) => U): Container<U> {\n    return new Container(fn(this.value));\n  }\n}";
    // Expect node: CLASS <Container>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: PROPERTY <Container.value>
    // Expect node: METHOD <Container.constructor>
    // Expect node: PARAMETER <constructor.value>
    // Expect node: PROPERTY_ACCESS <this.value>
    // Expect node: METHOD <Container.getValue>
    // Expect node: METHOD <Container.map>
    // Expect node: TYPE_PARAMETER <U>
    // Expect node: PARAMETER <map.fn>
    // Expect node: CALL <new Container(fn(this.value))>
    // Expect node: CALL <fn(this.value)>
    // Expect edge: <module> -[DECLARES]-> <Container>
    // Expect edge: <Container> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <Container> -[CONTAINS]-> <Container.value>
    // Expect edge: <Container> -[CONTAINS]-> <Container.constructor>
    // Expect edge: <Container> -[CONTAINS]-> <Container.getValue>
    // Expect edge: <Container> -[CONTAINS]-> <Container.map>
    // Expect edge: <Container.constructor> -[CONTAINS]-> <constructor.value>
    // Expect edge: <Container.getValue> -[RETURNS_TYPE]-> <T>
    // Expect edge: <Container.getValue> -[RETURNS]-> <this.value>
    // Expect edge: <Container.map> -[HAS_TYPE_PARAMETER]-> <U>
    // Expect edge: <Container.map> -[CONTAINS]-> <map.fn>
    // Expect edge: <map.fn> -[RETURNS_TYPE]-> <U>
    // Expect edge: <Container.map> -[RETURNS_TYPE]-> <Container>
    // Expect edge: <Container.map> -[RETURNS_TYPE]-> <U>
    // Expect edge: <Container.map> -[RETURNS]-> <new Container(fn(this.value))>
    // Expect edge: <new Container(fn(this.value))> -[PASSES_ARGUMENT]-> <fn(this.value)>
    // Expect edge: <fn(this.value)> -[PASSES_ARGUMENT]-> <this.value>
    void code;
  });

  test('ts-specific::decorator-class', () => {
    const code = "function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}";
    // Expect node: FUNCTION <sealed>
    // Expect node: PARAMETER <constructor>
    // Expect node: CALL <Object.seal(constructor)>
    // Expect node: PROPERTY_ACCESS <constructor.prototype>
    // Expect node: CALL <Object.seal(constructor.prototype)>
    // Expect edge: <module> -[DECLARES]-> <sealed>
    // Expect edge: <sealed> -[CONTAINS]-> <constructor>
    // Expect edge: <sealed> -[CONTAINS]-> <Object.seal(constructor)>
    // Expect edge: <sealed> -[CONTAINS]-> <Object.seal(constructor.prototype)>
    // Expect edge: <Object.seal(constructor)> -[PASSES_ARGUMENT]-> <constructor>
    // Expect edge: <Object.seal(constructor.prototype)> -[PASSES_ARGUMENT]-> <constructor.prototype>
    void code;
  });

  test('ts-specific::as-const', () => {
    const code = "const config = {\n  api: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n} as const;\n\nconst directions = ['up', 'down', 'left', 'right'] as const;";
    // Expect node: VARIABLE <config>
    // Expect node: LITERAL <config:object>
    // Expect node: PROPERTY <config:object.api>
    // Expect node: LITERAL <'https://api.example.com'>
    // Expect node: PROPERTY <config:object.timeout>
    // Expect node: LITERAL <5000>
    // Expect node: PROPERTY <config:object.retries>
    // Expect node: LITERAL <3>
    // Expect node: EXPRESSION <config:as-const>
    // Expect node: VARIABLE <directions>
    // Expect node: LITERAL <directions:array>
    // Expect node: LITERAL <'up'>
    // Expect node: LITERAL <'down'>
    // Expect node: LITERAL <'left'>
    // Expect node: LITERAL <'right'>
    // Expect node: EXPRESSION <directions:as-const>
    // Expect edge: <module> -[DECLARES]-> <config>
    // Expect edge: <config:object> -[HAS_PROPERTY]-> <config:object.api>
    // Expect edge: <config:object> -[HAS_PROPERTY]-> <config:object.timeout>
    // Expect edge: <config:object> -[HAS_PROPERTY]-> <config:object.retries>
    // Expect edge: <module> -[DECLARES]-> <directions>
    // Expect edge: <directions:array> -[HAS_ELEMENT]-> <'up'>
    // Expect edge: <directions:array> -[HAS_ELEMENT]-> <'down'>
    // Expect edge: <directions:array> -[HAS_ELEMENT]-> <'left'>
    // Expect edge: <directions:array> -[HAS_ELEMENT]-> <'right'>
    void code;
  });

  test('ts-specific::decorator-usage', () => {
    const code = "@sealed\nclass DecoratedClass {\n  @log\n  method() {\n    return 42;\n  }\n}";
    // Expect node: DECORATOR <@sealed>
    // Expect node: CLASS <DecoratedClass>
    // Expect node: DECORATOR <@log>
    // Expect node: METHOD <DecoratedClass.method>
    // Expect node: LITERAL <42>
    // Expect edge: <module> -[DECLARES]-> <DecoratedClass>
    // Expect edge: <@sealed> -[DECORATED_BY]-> <DecoratedClass>
    // Expect edge: <DecoratedClass> -[CONTAINS]-> <DecoratedClass.method>
    // Expect edge: <@log> -[DECORATED_BY]-> <DecoratedClass.method>
    // Expect edge: <DecoratedClass.method> -[RETURNS]-> <42>
    void code;
  });

  test('ts-specific::parameter-properties', () => {
    const code = "class ServiceWithParamProps {\n  constructor(\n    public name: string,\n    protected config: Record<string, unknown>,\n    private secret: string,\n    readonly id: number,\n  ) {}\n}";
    // Expect node: CLASS <ServiceWithParamProps>
    // Expect node: METHOD <ServiceWithParamProps.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <config>
    // Expect node: PARAMETER <secret>
    // Expect node: PARAMETER <id>
    // Expect node: PROPERTY <ServiceWithParamProps.name>
    // Expect node: PROPERTY <ServiceWithParamProps.config>
    // Expect node: PROPERTY <ServiceWithParamProps.secret>
    // Expect node: PROPERTY <ServiceWithParamProps.id>
    // Expect edge: <module> -[DECLARES]-> <ServiceWithParamProps>
    // Expect edge: <ServiceWithParamProps> -[CONTAINS]-> <ServiceWithParamProps.constructor>
    // Expect edge: <ServiceWithParamProps.constructor> -[CONTAINS]-> <name>
    // Expect edge: <ServiceWithParamProps.constructor> -[CONTAINS]-> <config>
    // Expect edge: <ServiceWithParamProps.constructor> -[CONTAINS]-> <secret>
    // Expect edge: <ServiceWithParamProps.constructor> -[CONTAINS]-> <id>
    // Expect edge: <ServiceWithParamProps> -[CONTAINS]-> <ServiceWithParamProps.name>
    // Expect edge: <ServiceWithParamProps> -[CONTAINS]-> <ServiceWithParamProps.config>
    // Expect edge: <ServiceWithParamProps> -[CONTAINS]-> <ServiceWithParamProps.secret>
    // Expect edge: <ServiceWithParamProps> -[CONTAINS]-> <ServiceWithParamProps.id>
    // Expect edge: <name> -[DECLARES]-> <ServiceWithParamProps.name>
    // Expect edge: <config> -[DECLARES]-> <ServiceWithParamProps.config>
    // Expect edge: <secret> -[DECLARES]-> <ServiceWithParamProps.secret>
    // Expect edge: <id> -[DECLARES]-> <ServiceWithParamProps.id>
    void code;
  });

  test('ts-specific::conditional-type', () => {
    const code = "type IsString<T> = T extends string ? true : false;";
    // Expect node: TYPE_ALIAS <IsString>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: CONDITIONAL_TYPE <T extends string ? true : false>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: LITERAL_TYPE <true>
    // Expect node: LITERAL_TYPE <false>
    // Expect edge: <module> -[DECLARES]-> <IsString>
    // Expect edge: <IsString> -[CONTAINS]-> <T>
    // Expect edge: <T extends string ? true : false> -[HAS_CONDITION]-> <T>
    // Expect edge: <T extends string ? true : false> -[HAS_CONSEQUENT]-> <true>
    void code;
  });

  test('ts-specific::decorator-method', () => {
    const code = "function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey}`);\n    return original.apply(this, args);\n  };\n}";
    // Expect node: FUNCTION <log>
    // Expect node: PARAMETER <target>
    // Expect node: PARAMETER <propertyKey>
    // Expect node: PARAMETER <descriptor>
    // Expect node: VARIABLE <original>
    // Expect node: PROPERTY_ACCESS <descriptor.value>
    // Expect node: FUNCTION <wrapper:fn>
    // Expect node: PARAMETER <args>
    // Expect node: CALL <console.log>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: CALL <original.apply>
    // Expect node: LITERAL <this>
    // Expect edge: <module> -[DECLARES]-> <log>
    // Expect edge: <log> -[CONTAINS]-> <target>
    // Expect edge: <log> -[CONTAINS]-> <propertyKey>
    // Expect edge: <log> -[CONTAINS]-> <descriptor>
    // Expect edge: <log> -[DECLARES]-> <original>
    // Expect edge: <wrapper:fn> -[CONTAINS]-> <args>
    // Expect edge: <wrapper:fn> -[CONTAINS]-> <console.log>
    // Expect edge: <console.log> -[PASSES_ARGUMENT]-> <template-literal>
    // Expect edge: <wrapper:fn> -[RETURNS]-> <original.apply>
    // Expect edge: <original.apply> -[PASSES_ARGUMENT]-> <this>
    // Expect edge: <original.apply> -[PASSES_ARGUMENT]-> <args>
    void code;
  });

  test('ts-specific::conditional-type-infer', () => {
    const code = "type UnpackPromise<T> = T extends Promise<infer U> ? U : T;";
    // Expect node: TYPE_ALIAS <UnpackPromise>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: CONDITIONAL_TYPE <T extends Promise<infer U> ? U : T>
    // Expect node: TYPE_REFERENCE <T extends Promise<infer U>>
    // Expect node: TYPE_REFERENCE <Promise<infer U>>
    // Expect node: INFER_TYPE <infer U>
    // Expect node: TYPE_PARAMETER <U>
    // Expect node: TYPE_REFERENCE <U:true-branch>
    // Expect node: TYPE_REFERENCE <T:false-branch>
    // Expect edge: <module> -[DECLARES]-> <UnpackPromise>
    // Expect edge: <UnpackPromise> -[CONTAINS]-> <T>
    // Expect edge: <T extends Promise<infer U> ? U : T> -[HAS_CONDITION]-> <T extends Promise<infer U>>
    // Expect edge: <T extends Promise<infer U>> -[HAS_CONDITION]-> <T>
    // Expect edge: <infer U> -[INFERS]-> <U>
    // Expect edge: <T extends Promise<infer U> ? U : T> -[HAS_CONSEQUENT]-> <U:true-branch>
    void code;
  });

  test('ts-specific::conditional-type-exclude', () => {
    const code = "type StrictNonNull<T> = T extends null | undefined ? never : T;";
    // Expect node: TYPE_ALIAS <StrictNonNull>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: CONDITIONAL_TYPE <T extends null | undefined ? never : T>
    // Expect node: TYPE_ALIAS <null | undefined>
    // Expect node: LITERAL_TYPE <null>
    // Expect node: LITERAL_TYPE <undefined>
    // Expect node: LITERAL_TYPE <never>
    // Expect edge: <module> -[DECLARES]-> <StrictNonNull>
    // Expect edge: <StrictNonNull> -[CONTAINS]-> <T>
    // Expect edge: <T extends null | undefined ? never : T> -[HAS_CONDITION]-> <T>
    // Expect edge: <T extends null | undefined ? never : T> -[HAS_CONDITION]-> <null | undefined>
    // Expect edge: <null | undefined> -[CONTAINS]-> <null>
    // Expect edge: <null | undefined> -[CONTAINS]-> <undefined>
    // Expect edge: <T extends null | undefined ? never : T> -[HAS_CONSEQUENT]-> <never>
    void code;
  });

  test('ts-specific::mapped-type-readonly', () => {
    const code = "type ReadonlyAll<T> = { readonly [K in keyof T]: T[K] };";
    // Expect node: TYPE_ALIAS <ReadonlyAll>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_ALIAS <ReadonlyAll:mapped>
    // Expect node: TYPE_PARAMETER <K>
    // Expect node: TYPE_REFERENCE <keyof T>
    // Expect node: TYPE_REFERENCE <T[K]>
    // Expect edge: <module> -[DECLARES]-> <ReadonlyAll>
    // Expect edge: <ReadonlyAll> -[CONTAINS]-> <T>
    // Expect edge: <ReadonlyAll:mapped> -[CONTAINS]-> <K>
    // Expect edge: <K> -[CONSTRAINED_BY]-> <keyof T>
    void code;
  });

  test('ts-specific::abstract-class', () => {
    const code = "abstract class Shape {\n  abstract area(): number;\n  abstract perimeter(): number;\n\n  describe(): string {\n    return `Area: ${this.area()}, Perimeter: ${this.perimeter()}`;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(private radius: number) {\n    super();\n  }\n\n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n\n  perimeter(): number {\n    return 2 * Math.PI * this.radius;\n  }\n}";
    // Expect node: CLASS <Shape>
    // Expect node: METHOD <Shape.area>
    // Expect node: METHOD <Shape.perimeter>
    // Expect node: METHOD <Shape.describe>
    // Expect node: EXPRESSION <template-literal>
    // Expect node: CALL <this.area()>
    // Expect node: CALL <this.perimeter()>
    // Expect node: CLASS <Circle>
    // Expect node: METHOD <Circle.constructor>
    // Expect node: PARAMETER <radius>
    // Expect node: CALL <super()>
    // Expect node: METHOD <Circle.area>
    // Expect node: EXPRESSION <Math.PI * this.radius ** 2>
    // Expect node: PROPERTY_ACCESS <Math.PI>
    // Expect node: PROPERTY_ACCESS <this.radius>
    // Expect node: METHOD <Circle.perimeter>
    // Expect node: EXPRESSION <2 * Math.PI * this.radius>
    // Expect node: LITERAL <2>
    // Expect edge: <module> -[DECLARES]-> <Shape>
    // Expect edge: <Shape> -[CONTAINS]-> <Shape.area>
    // Expect edge: <Shape> -[CONTAINS]-> <Shape.perimeter>
    // Expect edge: <Shape> -[CONTAINS]-> <Shape.describe>
    // Expect edge: <Shape.describe> -[RETURNS]-> <template-literal>
    // Expect edge: <template-literal> -[CONTAINS]-> <this.area()>
    // Expect edge: <template-literal> -[CONTAINS]-> <this.perimeter()>
    // Expect edge: <module> -[DECLARES]-> <Circle>
    // Expect edge: <Circle> -[CONTAINS]-> <Circle.constructor>
    // Expect edge: <Circle.constructor> -[CONTAINS]-> <radius>
    // Expect edge: <Circle.constructor> -[CONTAINS]-> <super()>
    // Expect edge: <Circle> -[CONTAINS]-> <Circle.area>
    // Expect edge: <Circle.area> -[RETURNS]-> <Math.PI * this.radius ** 2>
    // Expect edge: <Circle> -[CONTAINS]-> <Circle.perimeter>
    // Expect edge: <Circle.perimeter> -[RETURNS]-> <2 * Math.PI * this.radius>
    void code;
  });

  test('ts-specific::mapped-type-mutable', () => {
    const code = "type Mutable<T> = { -readonly [K in keyof T]: T[K] };";
    // Expect node: TYPE_ALIAS <Mutable>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_ALIAS <Mutable:mapped>
    // Expect node: TYPE_PARAMETER <K>
    // Expect node: TYPE_REFERENCE <keyof T>
    // Expect node: PROPERTY_ACCESS <T[K]>
    // Expect edge: <module> -[DECLARES]-> <Mutable>
    // Expect edge: <Mutable> -[CONTAINS]-> <T>
    // Expect edge: <Mutable:mapped> -[CONTAINS]-> <K>
    // Expect edge: <K> -[ITERATES_OVER]-> <keyof T>
    void code;
  });

  test('ts-specific::mapped-type-optional', () => {
    const code = "type Optional<T> = { [K in keyof T]?: T[K] };";
    // Expect node: TYPE_ALIAS <Optional>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_ALIAS <Optional:mapped>
    // Expect node: TYPE_PARAMETER <K>
    // Expect node: TYPE_REFERENCE <keyof T>
    // Expect node: PROPERTY_ACCESS <T[K]>
    // Expect edge: <module> -[DECLARES]-> <Optional>
    // Expect edge: <Optional> -[CONTAINS]-> <T>
    // Expect edge: <Optional:mapped> -[CONTAINS]-> <K>
    // Expect edge: <K> -[ITERATES_OVER]-> <keyof T>
    void code;
  });

  test('ts-specific::template-literal-type', () => {
    const code = "type EventName = 'click' | 'focus' | 'blur';\ntype OnEvent = `on${Capitalize<EventName>}`;\ntype CSSProperty = `${string}-${string}`;";
    // Expect node: TYPE_ALIAS <EventName>
    // Expect node: LITERAL_TYPE <'click'>
    // Expect node: LITERAL_TYPE <'focus'>
    // Expect node: LITERAL_TYPE <'blur'>
    // Expect node: TYPE_ALIAS <OnEvent>
    // Expect node: TYPE_REFERENCE <`on${Capitalize<EventName>}`>
    // Expect node: TYPE_REFERENCE <Capitalize<EventName>>
    // Expect node: TYPE_ALIAS <CSSProperty>
    // Expect node: TYPE_REFERENCE <`${string}-${string}`>
    // Expect node: TYPE_REFERENCE <string>
    // Expect edge: <module> -[DECLARES]-> <EventName>
    // Expect edge: <EventName> -[UNION_MEMBER]-> <'click'>
    // Expect edge: <EventName> -[UNION_MEMBER]-> <'focus'>
    // Expect edge: <EventName> -[UNION_MEMBER]-> <'blur'>
    // Expect edge: <module> -[DECLARES]-> <OnEvent>
    // Expect edge: <`on${Capitalize<EventName>}`> -[CONTAINS]-> <Capitalize<EventName>>
    // Expect edge: <module> -[DECLARES]-> <CSSProperty>
    // Expect edge: <`${string}-${string}`> -[CONTAINS]-> <string>
    void code;
  });

  test('ts-specific::union-intersection', () => {
    const code = "type StringOrNumber = string | number;\ntype ObjA = { a: string };\ntype ObjB = { b: number };\ntype Combined = ObjA & ObjB;";
    // Expect node: TYPE_ALIAS <StringOrNumber>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <number>
    // Expect node: TYPE_ALIAS <string | number>
    // Expect node: TYPE_ALIAS <ObjA>
    // Expect node: TYPE_REFERENCE <{ a: string }>
    // Expect node: TYPE_REFERENCE <a: string>
    // Expect node: TYPE_ALIAS <ObjB>
    // Expect node: TYPE_REFERENCE <{ b: number }>
    // Expect node: TYPE_REFERENCE <b: number>
    // Expect node: TYPE_ALIAS <Combined>
    // Expect node: TYPE_REFERENCE <ObjA & ObjB>
    // Expect edge: <module> -[DECLARES]-> <StringOrNumber>
    // Expect edge: <string | number> -[UNION_MEMBER]-> <string>
    // Expect edge: <string | number> -[UNION_MEMBER]-> <number>
    // Expect edge: <module> -[DECLARES]-> <ObjA>
    // Expect edge: <{ a: string }> -[CONTAINS]-> <a: string>
    // Expect edge: <module> -[DECLARES]-> <ObjB>
    // Expect edge: <{ b: number }> -[CONTAINS]-> <b: number>
    // Expect edge: <module> -[DECLARES]-> <Combined>
    // Expect edge: <ObjA & ObjB> -[INTERSECTS_WITH]-> <ObjA>
    // Expect edge: <ObjA & ObjB> -[INTERSECTS_WITH]-> <ObjB>
    void code;
  });

  test('ts-specific::type-guard-is', () => {
    const code = "function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}";
    // Expect node: FUNCTION <isString>
    // Expect node: PARAMETER <value>
    // Expect node: TYPE_REFERENCE <value is string>
    // Expect node: EXPRESSION <typeof value === 'string'>
    // Expect node: EXPRESSION <typeof value>
    // Expect node: LITERAL <'string'>
    // Expect edge: <module> -[DECLARES]-> <isString>
    // Expect edge: <isString> -[CONTAINS]-> <value>
    // Expect edge: <isString> -[RETURNS]-> <typeof value === 'string'>
    void code;
  });

  test('ts-specific::discriminated-union', () => {
    const code = "type Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: Error };";
    // Expect node: TYPE_ALIAS <Result>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_ALIAS <Result:union>
    // Expect node: TYPE_REFERENCE <success-case>
    // Expect node: TYPE_REFERENCE <success-case.success>
    // Expect node: LITERAL_TYPE <true>
    // Expect node: TYPE_REFERENCE <success-case.data>
    // Expect node: TYPE_REFERENCE <error-case>
    // Expect node: TYPE_REFERENCE <error-case.success>
    // Expect node: LITERAL_TYPE <false>
    // Expect node: TYPE_REFERENCE <error-case.error>
    // Expect node: TYPE_REFERENCE <Error>
    // Expect edge: <module> -[DECLARES]-> <Result>
    // Expect edge: <Result> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <Result:union> -[UNION_MEMBER]-> <success-case>
    // Expect edge: <Result:union> -[UNION_MEMBER]-> <error-case>
    // Expect edge: <success-case> -[HAS_PROPERTY]-> <success-case.success>
    // Expect edge: <success-case> -[HAS_PROPERTY]-> <success-case.data>
    // Expect edge: <error-case> -[HAS_PROPERTY]-> <error-case.success>
    // Expect edge: <error-case> -[HAS_PROPERTY]-> <error-case.error>
    void code;
  });

  test('ts-specific::keyof-typeof', () => {
    const code = "type UserKeys = keyof User;\nconst sampleUser = { name: 'Alice', age: 30 };\ntype InferredUser = typeof sampleUser;";
    // Expect node: TYPE_ALIAS <UserKeys>
    // Expect node: TYPE_REFERENCE <keyof User>
    // Expect node: TYPE_REFERENCE <User>
    // Expect node: VARIABLE <sampleUser>
    // Expect node: LITERAL <{ name: 'Alice', age: 30 }>
    // Expect node: LITERAL <'Alice'>
    // Expect node: LITERAL <30>
    // Expect node: TYPE_ALIAS <InferredUser>
    // Expect node: TYPE_REFERENCE <typeof sampleUser>
    // Expect edge: <module> -[DECLARES]-> <UserKeys>
    // Expect edge: <module> -[DECLARES]-> <sampleUser>
    // Expect edge: <{ name: 'Alice', age: 30 }> -[HAS_PROPERTY]-> <'Alice'>
    // Expect edge: <{ name: 'Alice', age: 30 }> -[HAS_PROPERTY]-> <30>
    // Expect edge: <module> -[DECLARES]-> <InferredUser>
    void code;
  });

  test('ts-specific::index-access-type', () => {
    const code = "type UserName = User['name'];\ntype UserNameOrAge = User['name' | 'age'];";
    // Expect node: TYPE_ALIAS <UserName>
    // Expect node: TYPE_REFERENCE <User['name']>
    // Expect node: TYPE_ALIAS <UserNameOrAge>
    // Expect node: TYPE_REFERENCE <User['name' | 'age']>
    // Expect node: TYPE_ALIAS <'name' | 'age'>
    // Expect node: LITERAL_TYPE <'name'>
    // Expect node: LITERAL_TYPE <'age'>
    // Expect edge: <module> -[DECLARES]-> <UserName>
    // Expect edge: <module> -[DECLARES]-> <UserNameOrAge>
    // Expect edge: <'name' | 'age'> -[CONTAINS]-> <'name'>
    // Expect edge: <'name' | 'age'> -[CONTAINS]-> <'age'>
    void code;
  });

  test('ts-specific::namespace', () => {
    const code = "namespace Validation {\n  export interface Schema {\n    validate(data: unknown): boolean;\n  }\n\n  export function createSchema(): Schema {\n    return { validate: () => true };\n  }\n}";
    // Expect node: NAMESPACE <Validation>
    // Expect node: INTERFACE <Validation.Schema>
    // Expect node: METHOD <Validation.Schema.validate>
    // Expect node: PARAMETER <data>
    // Expect node: FUNCTION <Validation.createSchema>
    // Expect node: LITERAL <{ validate: () => true }>
    // Expect node: FUNCTION <() => true>
    // Expect node: LITERAL <true>
    // Expect edge: <module> -[DECLARES]-> <Validation>
    // Expect edge: <Validation> -[CONTAINS]-> <Validation.Schema>
    // Expect edge: <Validation> -[CONTAINS]-> <Validation.createSchema>
    // Expect edge: <Validation.Schema> -[CONTAINS]-> <Validation.Schema.validate>
    // Expect edge: <Validation.Schema.validate> -[CONTAINS]-> <data>
    // Expect edge: <Validation.createSchema> -[RETURNS]-> <{ validate: () => true }>
    // Expect edge: <{ validate: () => true }> -[HAS_PROPERTY]-> <() => true>
    // Expect edge: <() => true> -[RETURNS]-> <true>
    // Expect edge: <Validation.createSchema> -[RETURNS_TYPE]-> <Validation.Schema>
    void code;
  });

  test('ts-specific::ts-import-type', () => {
    const code = "// import type { User } from './types';\n// import { type Role, Permission } from './auth';\n// (commented out — no actual modules to import from, but syntax is valid)\ntype ImportedType = User;";
    // Expect node: TYPE_ALIAS <ImportedType>
    // Expect node: TYPE_REFERENCE <User>
    // Expect edge: <module> -[DECLARES]-> <ImportedType>
    void code;
  });

  test('ts-specific::type-guard-assertion', () => {
    const code = "function hasName(obj: unknown): obj is { name: string } {\n  return typeof obj === 'object' && obj !== null && 'name' in obj;\n}";
    // Expect node: FUNCTION <hasName>
    // Expect node: PARAMETER <obj>
    // Expect node: TYPE_REFERENCE <obj is { name: string }>
    // Expect node: EXPRESSION <typeof obj === 'object'>
    // Expect node: EXPRESSION <obj !== null>
    // Expect node: EXPRESSION <'name' in obj>
    // Expect node: EXPRESSION <guard-conjunction>
    // Expect node: LITERAL <'object'>
    // Expect node: LITERAL <null>
    // Expect node: LITERAL <'name'>
    // Expect edge: <module> -[DECLARES]-> <hasName>
    // Expect edge: <hasName> -[CONTAINS]-> <obj>
    // Expect edge: <hasName> -[RETURNS]-> <guard-conjunction>
    // Expect edge: <guard-conjunction> -[CONTAINS]-> <typeof obj === 'object'>
    // Expect edge: <guard-conjunction> -[CONTAINS]-> <obj !== null>
    // Expect edge: <guard-conjunction> -[CONTAINS]-> <'name' in obj>
    void code;
  });

  test('ts-specific::function-overloads', () => {
    const code = "function processInput(input: string): string;\nfunction processInput(input: number): number;\nfunction processInput(input: string | number): string | number {\n  return input;\n}";
    // Expect node: METHOD <processInput:overload1>
    // Expect node: METHOD <processInput:overload2>
    // Expect node: FUNCTION <processInput>
    // Expect node: PARAMETER <input>
    // Expect edge: <module> -[DECLARES]-> <processInput:overload1>
    // Expect edge: <module> -[DECLARES]-> <processInput:overload2>
    // Expect edge: <module> -[DECLARES]-> <processInput>
    // Expect edge: <processInput> -[CONTAINS]-> <input>
    // Expect edge: <processInput> -[RETURNS]-> <input>
    void code;
  });

  test('ts-specific::ts-export-type', () => {
    const code = "export type { Admin };\n// export { type Status }; — inline type export (already exported as value above)";
    // Expect node: EXPORT <export-type-Admin>
    // Expect node: TYPE_REFERENCE <Admin>
    // Expect edge: <module> -[CONTAINS]-> <export-type-Admin>
    void code;
  });

  test('ts-specific::ts-declare-const', () => {
    const code = "declare const __VERSION__: string;";
    // Expect node: VARIABLE <__VERSION__>
    // Expect edge: <module> -[DECLARES]-> <__VERSION__>
    void code;
  });

  test('ts-specific::tuple-types', () => {
    const code = "type Point2D = [number, number];\ntype Point3D = [number, number, number];\ntype NamedTuple = [name: string, age: number];\ntype RestTuple = [string, ...number[]];";
    // Expect node: TYPE_ALIAS <Point2D>
    // Expect node: TYPE_ALIAS <Point2D:tuple>
    // Expect node: TYPE_REFERENCE <number:0>
    // Expect node: TYPE_REFERENCE <number:1>
    // Expect node: TYPE_ALIAS <Point3D>
    // Expect node: TYPE_ALIAS <Point3D:tuple>
    // Expect node: TYPE_REFERENCE <number:0:3d>
    // Expect node: TYPE_REFERENCE <number:1:3d>
    // Expect node: TYPE_REFERENCE <number:2:3d>
    // Expect node: TYPE_ALIAS <NamedTuple>
    // Expect node: TYPE_ALIAS <NamedTuple:tuple>
    // Expect node: TYPE_REFERENCE <name>
    // Expect node: TYPE_REFERENCE <string:named>
    // Expect node: TYPE_REFERENCE <age>
    // Expect node: TYPE_REFERENCE <number:named>
    // Expect node: TYPE_ALIAS <RestTuple>
    // Expect node: TYPE_ALIAS <RestTuple:tuple>
    // Expect node: TYPE_REFERENCE <string:rest>
    // Expect node: PARAMETER <...number[]>
    // Expect node: TYPE_REFERENCE <number[]>
    // Expect node: TYPE_REFERENCE <number:array>
    // Expect edge: <module> -[DECLARES]-> <Point2D>
    // Expect edge: <Point2D> -[DECLARES]-> <Point2D:tuple>
    // Expect edge: <Point2D:tuple> -[HAS_ELEMENT]-> <number:0>
    // Expect edge: <Point2D:tuple> -[HAS_ELEMENT]-> <number:1>
    // Expect edge: <module> -[DECLARES]-> <Point3D>
    // Expect edge: <Point3D> -[DECLARES]-> <Point3D:tuple>
    // Expect edge: <Point3D:tuple> -[HAS_ELEMENT]-> <number:0:3d>
    // Expect edge: <Point3D:tuple> -[HAS_ELEMENT]-> <number:1:3d>
    // Expect edge: <Point3D:tuple> -[HAS_ELEMENT]-> <number:2:3d>
    // Expect edge: <module> -[DECLARES]-> <NamedTuple>
    // Expect edge: <NamedTuple> -[DECLARES]-> <NamedTuple:tuple>
    // Expect edge: <NamedTuple:tuple> -[HAS_ELEMENT]-> <name>
    // Expect edge: <NamedTuple:tuple> -[HAS_ELEMENT]-> <age>
    // Expect edge: <module> -[DECLARES]-> <RestTuple>
    // Expect edge: <RestTuple> -[DECLARES]-> <RestTuple:tuple>
    // Expect edge: <RestTuple:tuple> -[HAS_ELEMENT]-> <string:rest>
    // Expect edge: <RestTuple:tuple> -[CONTAINS]-> <...number[]>
    // Expect edge: <...number[]> -[SPREADS_FROM]-> <number[]>
    // Expect edge: <number[]> -[CONTAINS]-> <number:array>
    void code;
  });

  test('ts-specific::ts-declare-function', () => {
    const code = "declare function require(id: string): any;";
    // Expect node: FUNCTION <require>
    // Expect node: PARAMETER <id>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <any>
    // Expect edge: <module> -[DECLARES]-> <require>
    // Expect edge: <require> -[CONTAINS]-> <id>
    // Expect edge: <require> -[RETURNS_TYPE]-> <any>
    void code;
  });

  test('ts-specific::class-implements', () => {
    const code = "class UserImpl implements User, Printable {\n  constructor(\n    public name: string,\n    public age: number,\n    public readonly id: number,\n  ) {}\n\n  print(): void {\n    console.log(this.name);\n  }\n}";
    // Expect node: CLASS <UserImpl>
    // Expect node: INTERFACE <User>
    // Expect node: INTERFACE <Printable>
    // Expect node: METHOD <UserImpl.constructor>
    // Expect node: PARAMETER <name>
    // Expect node: PARAMETER <age>
    // Expect node: PARAMETER <id>
    // Expect node: METHOD <UserImpl.print>
    // Expect node: CALL <console.log(this.name)>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect edge: <module> -[DECLARES]-> <UserImpl>
    // Expect edge: <UserImpl> -[CONTAINS]-> <UserImpl.constructor>
    // Expect edge: <UserImpl> -[CONTAINS]-> <UserImpl.print>
    // Expect edge: <UserImpl.constructor> -[CONTAINS]-> <name>
    // Expect edge: <UserImpl.constructor> -[CONTAINS]-> <age>
    // Expect edge: <UserImpl.constructor> -[CONTAINS]-> <id>
    // Expect edge: <UserImpl.print> -[CONTAINS]-> <console.log(this.name)>
    // Expect edge: <console.log(this.name)> -[PASSES_ARGUMENT]-> <this.name>
    void code;
  });

  test('ts-specific::ts-declare-module', () => {
    const code = "declare module '*.css' {\n  const content: Record<string, string>;\n  export default content;\n}";
    // Expect node: NAMESPACE <declare-*.css>
    // Expect node: VARIABLE <content>
    // Expect node: TYPE_REFERENCE <Record<string, string>>
    // Expect node: EXPORT <default-export>
    // Expect edge: <module> -[DECLARES]-> <declare-*.css>
    // Expect edge: <declare-*.css> -[CONTAINS]-> <content>
    // Expect edge: <declare-*.css> -[CONTAINS]-> <default-export>
    void code;
  });

  test('ts-specific::ts-declare-namespace', () => {
    const code = "declare namespace NodeJS {\n  interface ProcessEnv {\n    NODE_ENV: 'development' | 'production';\n  }\n}";
    // Expect node: NAMESPACE <NodeJS>
    // Expect node: INTERFACE <ProcessEnv>
    // Expect node: PROPERTY <NODE_ENV>
    // Expect node: TYPE_ALIAS <'development' | 'production'>
    // Expect node: LITERAL_TYPE <'development'>
    // Expect node: LITERAL_TYPE <'production'>
    // Expect edge: <module> -[DECLARES]-> <NodeJS>
    // Expect edge: <NodeJS> -[CONTAINS]-> <ProcessEnv>
    // Expect edge: <ProcessEnv> -[CONTAINS]-> <NODE_ENV>
    // Expect edge: <'development' | 'production'> -[CONTAINS]-> <'development'>
    // Expect edge: <'development' | 'production'> -[CONTAINS]-> <'production'>
    void code;
  });

  test('ts-specific::ts-declare-global', () => {
    const code = "declare global {\n  interface Window {\n    __APP_STATE__: unknown;\n  }\n}";
    // Expect node: EXPRESSION <global-declaration>
    // Expect node: INTERFACE <Window>
    // Expect node: PROPERTY <__APP_STATE__>
    // Expect edge: <module> -[CONTAINS]-> <global-declaration>
    // Expect edge: <global-declaration> -[DECLARES]-> <Window>
    // Expect edge: <Window> -[HAS_PROPERTY]-> <__APP_STATE__>
    void code;
  });

  test('ts-specific::ts-override', () => {
    const code = "class BaseWithMethod {\n  greet() { return 'hello'; }\n}\nclass DerivedWithOverride extends BaseWithMethod {\n  override greet() { return 'hi'; }\n}";
    // Expect node: CLASS <BaseWithMethod>
    // Expect node: METHOD <BaseWithMethod.greet>
    // Expect node: LITERAL <'hello'>
    // Expect node: CLASS <DerivedWithOverride>
    // Expect node: METHOD <DerivedWithOverride.greet>
    // Expect node: LITERAL <'hi'>
    // Expect edge: <module> -[DECLARES]-> <BaseWithMethod>
    // Expect edge: <BaseWithMethod> -[CONTAINS]-> <BaseWithMethod.greet>
    // Expect edge: <BaseWithMethod.greet> -[RETURNS]-> <'hello'>
    // Expect edge: <module> -[DECLARES]-> <DerivedWithOverride>
    // Expect edge: <DerivedWithOverride> -[CONTAINS]-> <DerivedWithOverride.greet>
    // Expect edge: <DerivedWithOverride.greet> -[RETURNS]-> <'hi'>
    void code;
  });

  test('ts-specific::utility-types', () => {
    const code = "type PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype PickedUser = Pick<User, 'name' | 'age'>;\ntype OmittedUser = Omit<User, 'email'>;\ntype UserRecord = Record<string, User>;\ntype ExtractedType = Extract<string | number | boolean, string | boolean>;\ntype ExcludedType = Exclude<string | number | boolean, boolean>;";
    // Expect node: TYPE_ALIAS <PartialUser>
    // Expect node: TYPE_REFERENCE <Partial<User>>
    // Expect node: TYPE_ALIAS <RequiredUser>
    // Expect node: TYPE_REFERENCE <Required<User>>
    // Expect node: TYPE_ALIAS <PickedUser>
    // Expect node: TYPE_REFERENCE <Pick<User, 'name' | 'age'>>
    // Expect node: LITERAL <'name'>
    // Expect node: LITERAL <'age'>
    // Expect node: TYPE_ALIAS <OmittedUser>
    // Expect node: TYPE_REFERENCE <Omit<User, 'email'>>
    // Expect node: LITERAL <'email'>
    // Expect node: TYPE_ALIAS <UserRecord>
    // Expect node: TYPE_REFERENCE <Record<string, User>>
    // Expect node: TYPE_ALIAS <ExtractedType>
    // Expect node: TYPE_REFERENCE <Extract<string | number | boolean, string | boolean>>
    // Expect node: TYPE_ALIAS <string | number | boolean>
    // Expect node: TYPE_ALIAS <string | boolean>
    // Expect node: TYPE_ALIAS <ExcludedType>
    // Expect node: TYPE_REFERENCE <Exclude<string | number | boolean, boolean>>
    // Expect edge: <module> -[DECLARES]-> <PartialUser>
    // Expect edge: <module> -[DECLARES]-> <RequiredUser>
    // Expect edge: <module> -[DECLARES]-> <PickedUser>
    // Expect edge: <module> -[DECLARES]-> <OmittedUser>
    // Expect edge: <Omit<User, 'email'>> -[CONTAINS]-> <'email'>
    // Expect edge: <module> -[DECLARES]-> <UserRecord>
    // Expect edge: <module> -[DECLARES]-> <ExtractedType>
    // Expect edge: <Extract<string | number | boolean, string | boolean>> -[HAS_CONDITION]-> <string | boolean>
    // Expect edge: <module> -[DECLARES]-> <ExcludedType>
    // Expect edge: <Exclude<string | number | boolean, boolean>> -[CONTAINS]-> <string | number | boolean>
    void code;
  });

  test('ts-specific::ts-module-augmentation', () => {
    const code = "declare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}";
    // Expect node: NAMESPACE <express-augmentation>
    // Expect node: INTERFACE <Request-augmentation>
    // Expect node: PROPERTY <user>
    // Expect node: TYPE_REFERENCE <user-type>
    // Expect node: PROPERTY <id>
    // Expect node: PROPERTY <role>
    // Expect edge: <module> -[DECLARES]-> <express-augmentation>
    // Expect edge: <express-augmentation> -[CONTAINS]-> <Request-augmentation>
    // Expect edge: <Request-augmentation> -[CONTAINS]-> <user>
    // Expect edge: <user-type> -[CONTAINS]-> <id>
    // Expect edge: <user-type> -[CONTAINS]-> <role>
    void code;
  });

  test('ts-specific::ts-recursive-type', () => {
    const code = "type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };";
    // Expect node: TYPE_ALIAS <JSONValue>
    // Expect node: TYPE_ALIAS <JSONValue:union>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <number>
    // Expect node: TYPE_REFERENCE <boolean>
    // Expect node: LITERAL_TYPE <null>
    // Expect node: TYPE_REFERENCE <JSONValue[]>
    // Expect node: TYPE_REFERENCE <JSONValue:object>
    // Expect node: PROPERTY <[key: string]: JSONValue>
    // Expect edge: <module> -[DECLARES]-> <JSONValue>
    // Expect edge: <JSONValue:union> -[CONTAINS]-> <string>
    // Expect edge: <JSONValue:union> -[CONTAINS]-> <number>
    // Expect edge: <JSONValue:union> -[CONTAINS]-> <boolean>
    // Expect edge: <JSONValue:union> -[CONTAINS]-> <null>
    // Expect edge: <JSONValue:union> -[CONTAINS]-> <JSONValue[]>
    // Expect edge: <JSONValue:union> -[CONTAINS]-> <JSONValue:object>
    // Expect edge: <JSONValue[]> -[CONTAINS]-> <JSONValue>
    // Expect edge: <JSONValue:object> -[CONTAINS]-> <[key: string]: JSONValue>
    void code;
  });

  test('ts-specific::ts-const-type-param', () => {
    const code = "function literal<const T>(value: T): T {\n  return value;\n}\nconst literalResult = literal({ x: 1, y: [2, 3] } as const);";
    // Expect node: FUNCTION <literal>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: PARAMETER <value>
    // Expect node: VARIABLE <literalResult>
    // Expect node: CALL <literal({ x: 1, y: [2, 3] } as const)>
    // Expect node: LITERAL <{ x: 1, y: [2, 3] }>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <[2, 3]>
    // Expect node: LITERAL <2>
    // Expect node: LITERAL <3>
    // Expect edge: <module> -[DECLARES]-> <literal>
    // Expect edge: <literal> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <literal> -[CONTAINS]-> <value>
    // Expect edge: <literal> -[RETURNS_TYPE]-> <T>
    // Expect edge: <literal> -[RETURNS]-> <value>
    // Expect edge: <module> -[DECLARES]-> <literalResult>
    // Expect edge: <literal({ x: 1, y: [2, 3] } as const)> -[PASSES_ARGUMENT]-> <{ x: 1, y: [2, 3] }>
    // Expect edge: <{ x: 1, y: [2, 3] }> -[HAS_PROPERTY]-> <1>
    // Expect edge: <{ x: 1, y: [2, 3] }> -[HAS_PROPERTY]-> <[2, 3]>
    // Expect edge: <[2, 3]> -[HAS_ELEMENT]-> <2>
    // Expect edge: <[2, 3]> -[HAS_ELEMENT]-> <3>
    void code;
  });

  test('ts-specific::ts-variance-in-out', () => {
    const code = "interface Producer<out T> {\n  produce(): T;\n}\ninterface Consumer<in T> {\n  consume(value: T): void;\n}\ninterface Transformer<in T, out U> {\n  transform(input: T): U;\n}";
    // Expect node: INTERFACE <Producer>
    // Expect node: TYPE_PARAMETER <Producer.T>
    // Expect node: METHOD <Producer.produce>
    // Expect node: INTERFACE <Consumer>
    // Expect node: TYPE_PARAMETER <Consumer.T>
    // Expect node: METHOD <Consumer.consume>
    // Expect node: PARAMETER <Consumer.consume.value>
    // Expect node: INTERFACE <Transformer>
    // Expect node: TYPE_PARAMETER <Transformer.T>
    // Expect node: TYPE_PARAMETER <Transformer.U>
    // Expect node: METHOD <Transformer.transform>
    // Expect node: PARAMETER <Transformer.transform.input>
    // Expect edge: <module> -[DECLARES]-> <Producer>
    // Expect edge: <Producer> -[HAS_TYPE_PARAMETER]-> <Producer.T>
    // Expect edge: <Producer> -[CONTAINS]-> <Producer.produce>
    // Expect edge: <Producer.produce> -[RETURNS_TYPE]-> <Producer.T>
    // Expect edge: <module> -[DECLARES]-> <Consumer>
    // Expect edge: <Consumer> -[HAS_TYPE_PARAMETER]-> <Consumer.T>
    // Expect edge: <Consumer> -[CONTAINS]-> <Consumer.consume>
    // Expect edge: <Consumer.consume> -[CONTAINS]-> <Consumer.consume.value>
    // Expect edge: <module> -[DECLARES]-> <Transformer>
    // Expect edge: <Transformer> -[HAS_TYPE_PARAMETER]-> <Transformer.T>
    // Expect edge: <Transformer> -[HAS_TYPE_PARAMETER]-> <Transformer.U>
    // Expect edge: <Transformer> -[CONTAINS]-> <Transformer.transform>
    // Expect edge: <Transformer.transform> -[CONTAINS]-> <Transformer.transform.input>
    // Expect edge: <Transformer.transform> -[RETURNS_TYPE]-> <Transformer.U>
    void code;
  });

  test('ts-specific::ts-asserts-guard', () => {
    const code = "function assertDefined<T>(val: T | undefined): asserts val is T {\n  if (val === undefined) throw new Error('undefined');\n}";
    // Expect node: FUNCTION <assertDefined>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: PARAMETER <val>
    // Expect node: TYPE_REFERENCE <T | undefined>
    // Expect node: EXPRESSION <asserts val is T>
    // Expect node: BRANCH <if-undefined-check>
    // Expect node: EXPRESSION <val === undefined>
    // Expect node: LITERAL <undefined>
    // Expect node: EXPRESSION <throw-error>
    // Expect node: CALL <new Error('undefined')>
    // Expect node: LITERAL <'undefined'>
    // Expect edge: <module> -[DECLARES]-> <assertDefined>
    // Expect edge: <assertDefined> -[CONTAINS]-> <T>
    // Expect edge: <assertDefined> -[CONTAINS]-> <val>
    // Expect edge: <assertDefined> -[RETURNS]-> <asserts val is T>
    // Expect edge: <assertDefined> -[CONTAINS]-> <if-undefined-check>
    // Expect edge: <if-undefined-check> -[HAS_CONDITION]-> <val === undefined>
    // Expect edge: <if-undefined-check> -[HAS_CONSEQUENT]-> <throw-error>
    // Expect edge: <new Error('undefined')> -[PASSES_ARGUMENT]-> <'undefined'>
    void code;
  });

  test('ts-specific::ts-recursive-type-tree', () => {
    const code = "type TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};";
    // Expect node: TYPE_ALIAS <TreeNode>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_REFERENCE <TreeNode:objectType>
    // Expect node: PROPERTY <value>
    // Expect node: PROPERTY <children>
    // Expect node: TYPE_REFERENCE <TreeNode<T>[]>
    // Expect node: TYPE_REFERENCE <TreeNode<T>:ref>
    // Expect edge: <module> -[DECLARES]-> <TreeNode>
    // Expect edge: <TreeNode> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <TreeNode:objectType> -[HAS_PROPERTY]-> <value>
    // Expect edge: <TreeNode:objectType> -[HAS_PROPERTY]-> <children>
    // Expect edge: <TreeNode<T>[]> -[CONTAINS]-> <TreeNode<T>:ref>
    void code;
  });

  test('ts-specific::ts-import-assertions', () => {
    const code = "// import data from './data.json' with { type: 'json' };\n// (commented out — import attributes syntax, requires runtime support)\ntype ImportedJSON = Record<string, unknown>;";
    // Expect node: TYPE_ALIAS <ImportedJSON>
    // Expect node: TYPE_REFERENCE <Record<string, unknown>>
    // Expect edge: <module> -[DECLARES]-> <ImportedJSON>
    void code;
  });

  test('ts-specific::ts-import-type-star', () => {
    const code = "// import type * as AllTypes from './modules-helpers.js';\n// (commented out — no actual modules to import from, but syntax is valid)\ntype AllTypesPlaceholder = Record<string, unknown>;";
    // Expect node: TYPE_ALIAS <AllTypesPlaceholder>
    // Expect node: TYPE_REFERENCE <Record<string, unknown>>
    // Expect edge: <module> -[DECLARES]-> <AllTypesPlaceholder>
    void code;
  });

  test('ts-specific::ts-noinfer', () => {
    const code = "function createFSM<S extends string>(config: {\n  initial: NoInfer<S>;\n  states: Record<S, object>;\n}) {\n  return config;\n}";
    // Expect node: FUNCTION <createFSM>
    // Expect node: TYPE_PARAMETER <S>
    // Expect node: PARAMETER <config>
    // Expect node: TYPE_REFERENCE <config:type>
    // Expect node: PROPERTY <initial>
    // Expect node: TYPE_REFERENCE <NoInfer<S>>
    // Expect node: PROPERTY <states>
    // Expect node: TYPE_REFERENCE <Record<S, object>>
    // Expect edge: <module> -[DECLARES]-> <createFSM>
    // Expect edge: <createFSM> -[HAS_TYPE_PARAMETER]-> <S>
    // Expect edge: <createFSM> -[CONTAINS]-> <config>
    // Expect edge: <config:type> -[HAS_PROPERTY]-> <initial>
    // Expect edge: <config:type> -[HAS_PROPERTY]-> <states>
    // Expect edge: <NoInfer<S>> -[CONTAINS]-> <S>
    // Expect edge: <createFSM> -[RETURNS]-> <config>
    void code;
  });

  test('ts-specific::ts-template-literal-infer', () => {
    const code = "type ParseRoute<T extends string> =\n  T extends `/${infer Segment}/${infer Rest}`\n    ? [Segment, ...ParseRoute<`/${Rest}`>]\n    : T extends `/${infer Segment}`\n      ? [Segment]\n      : [];";
    // Expect node: TYPE_ALIAS <ParseRoute>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: CONDITIONAL_TYPE <ParseRoute-conditional>
    // Expect node: TYPE_REFERENCE <`/${infer Segment}/${infer Rest}`>
    // Expect node: INFER_TYPE <infer Segment>
    // Expect node: INFER_TYPE <infer Rest>
    // Expect node: TYPE_ALIAS <[Segment, ...ParseRoute<`/${Rest}`>]>
    // Expect node: TYPE_REFERENCE <ParseRoute<`/${Rest}`>>
    // Expect node: TYPE_REFERENCE <`/${Rest}`>
    // Expect node: TYPE_REFERENCE <`/${infer Segment}`>
    // Expect node: INFER_TYPE <infer Segment-2>
    // Expect node: TYPE_ALIAS <[Segment]>
    // Expect node: TYPE_ALIAS <[]>
    // Expect edge: <module> -[DECLARES]-> <ParseRoute>
    // Expect edge: <ParseRoute> -[CONTAINS]-> <T>
    // Expect edge: <ParseRoute-conditional> -[HAS_CONDITION]-> <T>
    // Expect edge: <ParseRoute-conditional> -[HAS_CONDITION]-> <`/${infer Segment}/${infer Rest}`>
    // Expect edge: <`/${infer Segment}/${infer Rest}`> -[INFERS]-> <infer Segment>
    // Expect edge: <`/${infer Segment}/${infer Rest}`> -[INFERS]-> <infer Rest>
    // Expect edge: <ParseRoute-conditional> -[HAS_CONSEQUENT]-> <[Segment, ...ParseRoute<`/${Rest}`>]>
    // Expect edge: <[Segment, ...ParseRoute<`/${Rest}`>]> -[SPREADS_FROM]-> <ParseRoute<`/${Rest}`>>
    // Expect edge: <ParseRoute<`/${Rest}`>> -[PASSES_ARGUMENT]-> <`/${Rest}`>
    // Expect edge: <ParseRoute-conditional> -[HAS_CONDITION]-> <`/${infer Segment}`>
    // Expect edge: <`/${infer Segment}`> -[INFERS]-> <infer Segment-2>
    void code;
  });

  test('ts-specific::ts-explicit-this-param', () => {
    const code = "function onActivate(this: { name: string }, greeting: string): string {\n  return `${greeting}, ${this.name}`;\n}";
    // Expect node: FUNCTION <onActivate>
    // Expect node: PARAMETER <this>
    // Expect node: PARAMETER <greeting>
    // Expect node: LITERAL <template-literal>
    // Expect node: PROPERTY_ACCESS <this.name>
    // Expect edge: <module> -[DECLARES]-> <onActivate>
    // Expect edge: <onActivate> -[CONTAINS]-> <this>
    // Expect edge: <onActivate> -[CONTAINS]-> <greeting>
    // Expect edge: <onActivate> -[RETURNS]-> <template-literal>
    void code;
  });

  test('ts-specific::ts-exhaustive-never', () => {
    const code = "type ShapeUnion = { kind: 'circle'; radius: number } | { kind: 'square'; side: number };\n\nfunction shapeArea(shape: ShapeUnion): number {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n    default: {\n      const _exhaustive: never = shape;\n      throw new Error(`Unknown shape: ${_exhaustive}`);\n    }\n  }\n}";
    // Expect node: TYPE_ALIAS <ShapeUnion>
    // Expect node: TYPE_REFERENCE <circle-type>
    // Expect node: TYPE_REFERENCE <square-type>
    // Expect node: FUNCTION <shapeArea>
    // Expect node: PARAMETER <shape>
    // Expect node: BRANCH <switch-shape.kind>
    // Expect node: CASE <case-circle>
    // Expect node: CASE <case-square>
    // Expect node: CASE <case-default>
    // Expect node: EXPRESSION <Math.PI * shape.radius ** 2>
    // Expect node: EXPRESSION <shape.side ** 2>
    // Expect node: VARIABLE <_exhaustive>
    // Expect node: CALL <throw new Error>
    // Expect node: LITERAL <'Unknown shape: '>
    // Expect edge: <module> -[DECLARES]-> <ShapeUnion>
    // Expect edge: <ShapeUnion> -[CONTAINS]-> <circle-type>
    // Expect edge: <ShapeUnion> -[CONTAINS]-> <square-type>
    // Expect edge: <module> -[DECLARES]-> <shapeArea>
    // Expect edge: <shapeArea> -[CONTAINS]-> <shape>
    // Expect edge: <shapeArea> -[CONTAINS]-> <switch-shape.kind>
    // Expect edge: <switch-shape.kind> -[HAS_CASE]-> <case-circle>
    // Expect edge: <switch-shape.kind> -[HAS_CASE]-> <case-square>
    // Expect edge: <switch-shape.kind> -[HAS_DEFAULT]-> <case-default>
    // Expect edge: <case-circle> -[RETURNS]-> <Math.PI * shape.radius ** 2>
    // Expect edge: <case-square> -[RETURNS]-> <shape.side ** 2>
    // Expect edge: <case-default> -[DECLARES]-> <_exhaustive>
    // Expect edge: <case-default> -[CONTAINS]-> <throw new Error>
    // Expect edge: <throw new Error> -[PASSES_ARGUMENT]-> <'Unknown shape: '>
    void code;
  });

  test('ts-specific::ts-this-type', () => {
    const code = "class Builder {\n  private builderValue = 0;\n\n  add(n: number): this {\n    this.builderValue += n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.builderValue *= n;\n    return this;\n  }\n}\n\nclass AdvancedBuilder extends Builder {\n  negate(): this {\n    return this;\n  }\n}";
    // Expect node: CLASS <Builder>
    // Expect node: PROPERTY <Builder.builderValue>
    // Expect node: LITERAL <0>
    // Expect node: METHOD <Builder.add>
    // Expect node: PARAMETER <n>
    // Expect node: TYPE_REFERENCE <this-return-type>
    // Expect node: EXPRESSION <this.builderValue += n>
    // Expect node: PROPERTY_ACCESS <this.builderValue>
    // Expect node: METHOD <Builder.multiply>
    // Expect node: PARAMETER <n2>
    // Expect node: TYPE_REFERENCE <this-return-type2>
    // Expect node: EXPRESSION <this.builderValue *= n>
    // Expect node: PROPERTY_ACCESS <this.builderValue2>
    // Expect node: CLASS <AdvancedBuilder>
    // Expect node: METHOD <AdvancedBuilder.negate>
    // Expect node: TYPE_REFERENCE <this-return-type3>
    // Expect edge: <module> -[DECLARES]-> <Builder>
    // Expect edge: <Builder> -[CONTAINS]-> <Builder.builderValue>
    // Expect edge: <Builder> -[CONTAINS]-> <Builder.add>
    // Expect edge: <Builder.add> -[CONTAINS]-> <n>
    // Expect edge: <Builder.add> -[RETURNS_TYPE]-> <this-return-type>
    // Expect edge: <Builder.add> -[CONTAINS]-> <this.builderValue += n>
    // Expect edge: <Builder.add> -[RETURNS]-> <this>
    // Expect edge: <Builder> -[CONTAINS]-> <Builder.multiply>
    // Expect edge: <Builder.multiply> -[CONTAINS]-> <n2>
    // Expect edge: <Builder.multiply> -[RETURNS_TYPE]-> <this-return-type2>
    // Expect edge: <Builder.multiply> -[CONTAINS]-> <this.builderValue *= n>
    // Expect edge: <Builder.multiply> -[RETURNS]-> <this>
    // Expect edge: <module> -[DECLARES]-> <AdvancedBuilder>
    // Expect edge: <AdvancedBuilder> -[CONTAINS]-> <AdvancedBuilder.negate>
    // Expect edge: <AdvancedBuilder.negate> -[RETURNS_TYPE]-> <this-return-type3>
    // Expect edge: <AdvancedBuilder.negate> -[RETURNS]-> <this>
    void code;
  });

  test('ts-specific::ts-branded-type', () => {
    const code = "type UserId = string & { readonly __brand: unique symbol };\ntype OrderId = string & { readonly __brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction createOrderId(id: string): OrderId {\n  return id as OrderId;\n}";
    // Expect node: TYPE_ALIAS <UserId>
    // Expect node: TYPE_REFERENCE <string & { readonly __brand: unique symbol }>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <{ readonly __brand: unique symbol }>
    // Expect node: PROPERTY <__brand>
    // Expect node: TYPE_REFERENCE <unique symbol>
    // Expect node: TYPE_ALIAS <OrderId>
    // Expect node: TYPE_REFERENCE <string & { readonly __brand: unique symbol }#2>
    // Expect node: TYPE_REFERENCE <{ readonly __brand: unique symbol }#2>
    // Expect node: PROPERTY <__brand#2>
    // Expect node: TYPE_REFERENCE <unique symbol#2>
    // Expect node: FUNCTION <createUserId>
    // Expect node: PARAMETER <id>
    // Expect node: EXPRESSION <id as UserId>
    // Expect node: FUNCTION <createOrderId>
    // Expect node: PARAMETER <id#2>
    // Expect node: EXPRESSION <id as OrderId>
    // Expect edge: <module> -[DECLARES]-> <UserId>
    // Expect edge: <string & { readonly __brand: unique symbol }> -[INTERSECTS_WITH]-> <string>
    // Expect edge: <string & { readonly __brand: unique symbol }> -[INTERSECTS_WITH]-> <{ readonly __brand: unique symbol }>
    // Expect edge: <{ readonly __brand: unique symbol }> -[CONTAINS]-> <__brand>
    // Expect edge: <module> -[DECLARES]-> <OrderId>
    // Expect edge: <string & { readonly __brand: unique symbol }#2> -[INTERSECTS_WITH]-> <string>
    // Expect edge: <string & { readonly __brand: unique symbol }#2> -[INTERSECTS_WITH]-> <{ readonly __brand: unique symbol }#2>
    // Expect edge: <{ readonly __brand: unique symbol }#2> -[CONTAINS]-> <__brand#2>
    // Expect edge: <module> -[DECLARES]-> <createUserId>
    // Expect edge: <createUserId> -[CONTAINS]-> <id>
    // Expect edge: <createUserId> -[RETURNS]-> <UserId>
    // Expect edge: <createUserId> -[RETURNS]-> <id as UserId>
    // Expect edge: <module> -[DECLARES]-> <createOrderId>
    // Expect edge: <createOrderId> -[CONTAINS]-> <id#2>
    // Expect edge: <createOrderId> -[RETURNS]-> <OrderId>
    // Expect edge: <createOrderId> -[RETURNS]-> <id as OrderId>
    void code;
  });

  test('ts-specific::ts-abstract-construct', () => {
    const code = "type AbstractConstructor<T> = abstract new (...args: any[]) => T;\n\nfunction withMixin<T extends AbstractConstructor<{}>>(Base: T) {\n  abstract class Mixed extends Base {\n    abstract doThing(): void;\n  }\n  return Mixed;\n}";
    // Expect node: TYPE_ALIAS <AbstractConstructor>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_REFERENCE <abstract new (...args: any[]) => T>
    // Expect node: FUNCTION <withMixin>
    // Expect node: TYPE_PARAMETER <T:withMixin>
    // Expect node: PARAMETER <Base>
    // Expect node: CLASS <Mixed>
    // Expect node: METHOD <Mixed.doThing>
    // Expect edge: <module> -[DECLARES]-> <AbstractConstructor>
    // Expect edge: <AbstractConstructor> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <abstract new (...args: any[]) => T> -[RETURNS]-> <T>
    // Expect edge: <module> -[DECLARES]-> <withMixin>
    // Expect edge: <withMixin> -[HAS_TYPE_PARAMETER]-> <T:withMixin>
    // Expect edge: <T:withMixin> -[CONSTRAINED_BY]-> <AbstractConstructor>
    // Expect edge: <withMixin> -[CONTAINS]-> <Base>
    // Expect edge: <withMixin> -[CONTAINS]-> <Mixed>
    // Expect edge: <Mixed> -[CONTAINS]-> <Mixed.doThing>
    // Expect edge: <withMixin> -[RETURNS]-> <Mixed>
    void code;
  });

  test('ts-specific::ts-declaration-merging', () => {
    const code = "class Box { x = 0; }\ninterface Box { y: number; }\n// Box now has both x (from class) and y (from interface)";
    // Expect node: CLASS <Box>
    // Expect node: PROPERTY <Box.x>
    // Expect node: LITERAL <0>
    // Expect node: INTERFACE <Box:interface>
    // Expect node: PROPERTY <Box.y>
    // Expect node: TYPE_REFERENCE <number>
    // Expect edge: <module> -[DECLARES]-> <Box>
    // Expect edge: <module> -[DECLARES]-> <Box:interface>
    // Expect edge: <Box> -[CONTAINS]-> <Box.x>
    // Expect edge: <Box:interface> -[CONTAINS]-> <Box.y>
    void code;
  });

  test('ts-specific::ts-const-enum-computed', () => {
    const code = "const enum BitFlags {\n  Read = 1 << 0,\n  Write = 1 << 1,\n  Execute = 1 << 2,\n  ReadWrite = Read | Write,\n}";
    // Expect node: ENUM <BitFlags>
    // Expect node: ENUM_MEMBER <BitFlags.Read>
    // Expect node: EXPRESSION <1 << 0>
    // Expect node: LITERAL <1>
    // Expect node: LITERAL <0>
    // Expect node: ENUM_MEMBER <BitFlags.Write>
    // Expect node: EXPRESSION <1 << 1>
    // Expect node: LITERAL <1_2>
    // Expect node: LITERAL <1_literal>
    // Expect node: ENUM_MEMBER <BitFlags.Execute>
    // Expect node: EXPRESSION <1 << 2>
    // Expect node: LITERAL <1_3>
    // Expect node: LITERAL <2>
    // Expect node: ENUM_MEMBER <BitFlags.ReadWrite>
    // Expect node: EXPRESSION <Read | Write>
    // Expect edge: <module> -[DECLARES]-> <BitFlags>
    // Expect edge: <BitFlags> -[CONTAINS]-> <BitFlags.Read>
    // Expect edge: <BitFlags> -[CONTAINS]-> <BitFlags.Write>
    // Expect edge: <BitFlags> -[CONTAINS]-> <BitFlags.Execute>
    // Expect edge: <BitFlags> -[CONTAINS]-> <BitFlags.ReadWrite>
    void code;
  });

  test('ts-specific::ts-class-method-overloads', () => {
    const code = "class Parser {\n  parse(input: string): string;\n  parse(input: number): number;\n  parse(input: string | number): string | number {\n    return input;\n  }\n}";
    // Expect node: CLASS <Parser>
    // Expect node: METHOD <Parser.parse>
    // Expect node: METHOD <Parser.parse:overload1>
    // Expect node: METHOD <Parser.parse:overload2>
    // Expect node: METHOD <Parser.parse:implementation>
    // Expect node: PARAMETER <input:overload1>
    // Expect node: PARAMETER <input:overload2>
    // Expect node: PARAMETER <input:implementation>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <number>
    // Expect node: TYPE_REFERENCE <string | number>
    // Expect edge: <module> -[DECLARES]-> <Parser>
    // Expect edge: <Parser> -[CONTAINS]-> <Parser.parse>
    // Expect edge: <Parser.parse:overload1> -[CONTAINS]-> <input:overload1>
    // Expect edge: <Parser.parse:overload2> -[CONTAINS]-> <input:overload2>
    // Expect edge: <Parser.parse:implementation> -[CONTAINS]-> <input:implementation>
    // Expect edge: <Parser.parse:overload1> -[RETURNS_TYPE]-> <string>
    // Expect edge: <Parser.parse:overload2> -[RETURNS_TYPE]-> <number>
    // Expect edge: <Parser.parse:implementation> -[RETURNS_TYPE]-> <string | number>
    // Expect edge: <Parser.parse:implementation> -[RETURNS]-> <input:implementation>
    void code;
  });

  test('ts-specific::ts-ambient-class-enum', () => {
    const code = "declare class ExternalLib {\n  constructor(config: object);\n  process(): Promise<void>;\n}\ndeclare enum Platform { Web, Mobile, Desktop }\n\n// --- Decorator metadata (Stage 3 + TS experimental) ---";
    // Expect node: CLASS <ExternalLib>
    // Expect node: METHOD <ExternalLib.constructor>
    // Expect node: PARAMETER <config>
    // Expect node: METHOD <ExternalLib.process>
    // Expect node: ENUM <Platform>
    // Expect node: ENUM_MEMBER <Platform.Web>
    // Expect node: ENUM_MEMBER <Platform.Mobile>
    // Expect node: ENUM_MEMBER <Platform.Desktop>
    // Expect edge: <module> -[DECLARES]-> <ExternalLib>
    // Expect edge: <ExternalLib> -[CONTAINS]-> <ExternalLib.constructor>
    // Expect edge: <ExternalLib> -[CONTAINS]-> <ExternalLib.process>
    // Expect edge: <ExternalLib.constructor> -[CONTAINS]-> <config>
    // Expect edge: <module> -[DECLARES]-> <Platform>
    // Expect edge: <Platform> -[CONTAINS]-> <Platform.Web>
    // Expect edge: <Platform> -[CONTAINS]-> <Platform.Mobile>
    // Expect edge: <Platform> -[CONTAINS]-> <Platform.Desktop>
    void code;
  });

  test('ts-specific::ts-unique-symbol', () => {
    const code = "declare const uniqueSym: unique symbol;\ntype WithSymKey = { [uniqueSym]: string };";
    // Expect node: VARIABLE <uniqueSym>
    // Expect node: TYPE_REFERENCE <unique symbol>
    // Expect node: TYPE_REFERENCE <WithSymKey>
    // Expect node: TYPE_REFERENCE <WithSymKey:object>
    // Expect node: PROPERTY <WithSymKey:[uniqueSym]>
    // Expect edge: <module> -[DECLARES]-> <uniqueSym>
    // Expect edge: <module> -[DECLARES]-> <WithSymKey>
    // Expect edge: <WithSymKey:object> -[CONTAINS]-> <WithSymKey:[uniqueSym]>
    void code;
  });

  test('ts-specific::ts-enum-namespace-merge', () => {
    const code = "enum Color { Red, Green, Blue }\nnamespace Color {\n  export function parse(s: string): Color { return Color[s as keyof typeof Color]; }\n}";
    // Expect node: ENUM <Color>
    // Expect node: ENUM_MEMBER <Color.Red>
    // Expect node: ENUM_MEMBER <Color.Green>
    // Expect node: ENUM_MEMBER <Color.Blue>
    // Expect node: NAMESPACE <Color:namespace>
    // Expect node: FUNCTION <Color.parse>
    // Expect node: PARAMETER <s>
    // Expect node: PROPERTY_ACCESS <Color[s]>
    // Expect node: EXPRESSION <s as keyof typeof Color>
    // Expect edge: <module> -[DECLARES]-> <Color>
    // Expect edge: <Color> -[CONTAINS]-> <Color.Red>
    // Expect edge: <Color> -[CONTAINS]-> <Color.Green>
    // Expect edge: <Color> -[CONTAINS]-> <Color.Blue>
    // Expect edge: <module> -[DECLARES]-> <Color:namespace>
    // Expect edge: <Color:namespace> -[CONTAINS]-> <Color.parse>
    // Expect edge: <Color.parse> -[CONTAINS]-> <s>
    // Expect edge: <Color.parse> -[RETURNS]-> <Color[s]>
    void code;
  });

  test('ts-specific::ts-parameter-decorators', () => {
    const code = "// Common in NestJS/Angular — parameter decorators\nfunction Inject(token: string) {\n  return function(target: any, propertyKey: string | symbol, parameterIndex: number) {};\n}\n\nclass AppController {\n  constructor(@Inject('DB') private db: any) {}\n}";
    // Expect node: FUNCTION <Inject>
    // Expect node: PARAMETER <token>
    // Expect node: FUNCTION <Inject:decorator>
    // Expect node: PARAMETER <target>
    // Expect node: PARAMETER <propertyKey>
    // Expect node: PARAMETER <parameterIndex>
    // Expect node: CLASS <AppController>
    // Expect node: METHOD <AppController.constructor>
    // Expect node: PARAMETER <db>
    // Expect node: DECORATOR <@Inject('DB')>
    // Expect node: LITERAL <'DB'>
    // Expect edge: <module> -[DECLARES]-> <Inject>
    // Expect edge: <Inject> -[CONTAINS]-> <token>
    // Expect edge: <Inject> -[RETURNS]-> <Inject:decorator>
    // Expect edge: <Inject:decorator> -[CONTAINS]-> <target>
    // Expect edge: <Inject:decorator> -[CONTAINS]-> <propertyKey>
    // Expect edge: <Inject:decorator> -[CONTAINS]-> <parameterIndex>
    // Expect edge: <module> -[DECLARES]-> <AppController>
    // Expect edge: <AppController> -[CONTAINS]-> <AppController.constructor>
    // Expect edge: <AppController.constructor> -[CONTAINS]-> <db>
    // Expect edge: <@Inject('DB')> -[PASSES_ARGUMENT]-> <'DB'>
    // Expect edge: <db> -[DECORATED_BY]-> <@Inject('DB')>
    // Expect edge: <@Inject('DB')> -[RETURNS]-> <Inject:decorator>
    void code;
  });

  test('ts-specific::ts-decorator-metadata', () => {
    const code = "function track(constructor: Function, context: ClassDecoratorContext) {\n  context.metadata.tracked = true;\n}\n\nfunction log(target: Function, context: ClassMethodDecoratorContext) {\n  context.addInitializer(function() {\n    console.log(`${String(context.name)} initialized`);\n  });\n}\n\n@track\nclass TrackedService {\n  @log\n  process(data: string) { return data; }\n}\n// const meta = TrackedService[Symbol.metadata]; // { tracked: true }";
    // Expect node: FUNCTION <track>
    // Expect node: PARAMETER <constructor>
    // Expect node: PARAMETER <context>
    // Expect node: PROPERTY_ACCESS <context.metadata.tracked>
    // Expect node: LITERAL <true>
    // Expect node: FUNCTION <log>
    // Expect node: PARAMETER <target>
    // Expect node: PARAMETER <context2>
    // Expect node: CALL <context.addInitializer(...)>
    // Expect node: FUNCTION <addInitializer-callback>
    // Expect node: CALL <console.log(...)>
    // Expect node: EXPRESSION <String(context.name)>
    // Expect node: CLASS <TrackedService>
    // Expect node: DECORATOR <@track>
    // Expect node: METHOD <TrackedService.process>
    // Expect node: DECORATOR <@log>
    // Expect node: PARAMETER <data>
    // Expect edge: <module> -[DECLARES]-> <track>
    // Expect edge: <track> -[CONTAINS]-> <constructor>
    // Expect edge: <track> -[CONTAINS]-> <context>
    // Expect edge: <module> -[DECLARES]-> <log>
    // Expect edge: <log> -[CONTAINS]-> <target>
    // Expect edge: <log> -[CONTAINS]-> <context2>
    // Expect edge: <log> -[CONTAINS]-> <context.addInitializer(...)>
    // Expect edge: <context.addInitializer(...)> -[PASSES_ARGUMENT]-> <addInitializer-callback>
    // Expect edge: <addInitializer-callback> -[CONTAINS]-> <console.log(...)>
    // Expect edge: <console.log(...)> -[PASSES_ARGUMENT]-> <String(context.name)>
    // Expect edge: <module> -[DECLARES]-> <TrackedService>
    // Expect edge: <@track> -[DECORATED_BY]-> <track>
    // Expect edge: <TrackedService> -[DECORATED_BY]-> <@track>
    // Expect edge: <TrackedService> -[CONTAINS]-> <TrackedService.process>
    // Expect edge: <@log> -[DECORATED_BY]-> <log>
    // Expect edge: <TrackedService.process> -[DECORATED_BY]-> <@log>
    // Expect edge: <TrackedService.process> -[CONTAINS]-> <data>
    // Expect edge: <TrackedService.process> -[RETURNS]-> <data>
    void code;
  });

  test('ts-specific::ts-constructor-overloads', () => {
    const code = "class Point {\n  x: number;\n  y: number;\n  constructor(x: number, y: number);\n  constructor(coords: [number, number]);\n  constructor(xOrCoords: number | [number, number], y?: number) {\n    if (Array.isArray(xOrCoords)) {\n      this.x = xOrCoords[0];\n      this.y = xOrCoords[1];\n    } else {\n      this.x = xOrCoords;\n      this.y = y!;\n    }\n  }\n}";
    // Expect node: CLASS <Point>
    // Expect node: PROPERTY <Point.x>
    // Expect node: PROPERTY <Point.y>
    // Expect node: METHOD <Point.constructor:overload1>
    // Expect node: PARAMETER <x:overload1>
    // Expect node: PARAMETER <y:overload1>
    // Expect node: METHOD <Point.constructor:overload2>
    // Expect node: PARAMETER <coords:overload2>
    // Expect node: METHOD <Point.constructor>
    // Expect node: PARAMETER <xOrCoords>
    // Expect node: PARAMETER <y>
    // Expect node: BRANCH <Array.isArray(xOrCoords)>
    // Expect node: PROPERTY_ACCESS <this.x:branch1>
    // Expect node: PROPERTY_ACCESS <xOrCoords[0]>
    // Expect node: PROPERTY_ACCESS <this.y:branch1>
    // Expect node: PROPERTY_ACCESS <xOrCoords[1]>
    // Expect node: PROPERTY_ACCESS <this.x:branch2>
    // Expect node: PROPERTY_ACCESS <this.y:branch2>
    // Expect node: EXPRESSION <y!>
    // Expect edge: <module> -[DECLARES]-> <Point>
    // Expect edge: <Point> -[CONTAINS]-> <Point.x>
    // Expect edge: <Point> -[CONTAINS]-> <Point.y>
    // Expect edge: <Point> -[CONTAINS]-> <Point.constructor:overload1>
    // Expect edge: <Point> -[CONTAINS]-> <Point.constructor:overload2>
    // Expect edge: <Point> -[CONTAINS]-> <Point.constructor>
    // Expect edge: <Point.constructor:overload1> -[CONTAINS]-> <x:overload1>
    // Expect edge: <Point.constructor:overload1> -[CONTAINS]-> <y:overload1>
    // Expect edge: <Point.constructor:overload2> -[CONTAINS]-> <coords:overload2>
    // Expect edge: <Point.constructor> -[CONTAINS]-> <xOrCoords>
    // Expect edge: <Point.constructor> -[CONTAINS]-> <y>
    // Expect edge: <Point.constructor> -[CONTAINS]-> <Array.isArray(xOrCoords)>
    // Expect edge: <Array.isArray(xOrCoords)> -[HAS_CONSEQUENT]-> <this.x:branch1>
    // Expect edge: <Array.isArray(xOrCoords)> -[HAS_CONSEQUENT]-> <this.y:branch1>
    void code;
  });

  test('ts-specific::ts-mapped-type-as-clause', () => {
    const code = "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\ntype RemoveKind<T> = {\n  [K in keyof T as Exclude<K, 'kind'>]: T[K]\n};";
    // Expect node: TYPE_ALIAS <Getters>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_ALIAS <Getters:mapped>
    // Expect node: TYPE_PARAMETER <K>
    // Expect node: TYPE_REFERENCE <get${Capitalize<string & K>}>
    // Expect node: TYPE_REFERENCE <() => T[K]>
    // Expect node: TYPE_ALIAS <RemoveKind>
    // Expect node: TYPE_PARAMETER <T2>
    // Expect node: TYPE_ALIAS <RemoveKind:mapped>
    // Expect node: TYPE_PARAMETER <K2>
    // Expect node: TYPE_REFERENCE <Exclude<K, 'kind'>>
    // Expect node: LITERAL <'kind'>
    // Expect edge: <module> -[DECLARES]-> <Getters>
    // Expect edge: <Getters> -[CONTAINS]-> <T>
    // Expect edge: <Getters:mapped> -[ITERATES_OVER]-> <K>
    // Expect edge: <module> -[DECLARES]-> <RemoveKind>
    // Expect edge: <RemoveKind> -[CONTAINS]-> <T2>
    // Expect edge: <RemoveKind:mapped> -[ITERATES_OVER]-> <K2>
    void code;
  });

  test('ts-specific::ts-this-type-guard', () => {
    const code = "class FSNode {\n  isFile(): this is FSFileNode { return this instanceof FSFileNode; }\n  isDir(): this is FSDirNode { return this instanceof FSDirNode; }\n}\n\nclass FSFileNode extends FSNode {\n  content: string = '';\n}\n\nclass FSDirNode extends FSNode {\n  children: FSNode[] = [];\n}";
    // Expect node: CLASS <FSNode>
    // Expect node: METHOD <FSNode.isFile>
    // Expect node: METHOD <FSNode.isDir>
    // Expect node: EXPRESSION <this instanceof FSFileNode>
    // Expect node: EXPRESSION <this instanceof FSDirNode>
    // Expect node: CLASS <FSFileNode>
    // Expect node: PROPERTY <FSFileNode.content>
    // Expect node: LITERAL <''>
    // Expect node: CLASS <FSDirNode>
    // Expect node: PROPERTY <FSDirNode.children>
    // Expect node: LITERAL <[]>
    // Expect edge: <module> -[DECLARES]-> <FSNode>
    // Expect edge: <FSNode> -[CONTAINS]-> <FSNode.isFile>
    // Expect edge: <FSNode> -[CONTAINS]-> <FSNode.isDir>
    // Expect edge: <FSNode.isFile> -[RETURNS]-> <this instanceof FSFileNode>
    // Expect edge: <FSNode.isDir> -[RETURNS]-> <this instanceof FSDirNode>
    // Expect edge: <module> -[DECLARES]-> <FSFileNode>
    // Expect edge: <FSFileNode> -[CONTAINS]-> <FSFileNode.content>
    // Expect edge: <module> -[DECLARES]-> <FSDirNode>
    // Expect edge: <FSDirNode> -[CONTAINS]-> <FSDirNode.children>
    void code;
  });

  test('ts-specific::ts-distributive-conditional', () => {
    const code = "type ToArray<T> = T extends any ? T[] : never;\ntype DistResult = ToArray<string | number>; // string[] | number[]\n\ntype ToArrayND<T> = [T] extends [any] ? T[] : never;\ntype NonDistResult = ToArrayND<string | number>; // (string | number)[]";
    // Expect node: TYPE_ALIAS <ToArray>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: CONDITIONAL_TYPE <T extends any ? T[] : never>
    // Expect node: TYPE_REFERENCE <T extends any>
    // Expect node: TYPE_REFERENCE <T[]>
    // Expect node: LITERAL_TYPE <never>
    // Expect node: TYPE_ALIAS <DistResult>
    // Expect node: TYPE_REFERENCE <ToArray<string | number>>
    // Expect node: TYPE_ALIAS <string | number>
    // Expect node: TYPE_REFERENCE <string>
    // Expect node: TYPE_REFERENCE <number>
    // Expect node: TYPE_ALIAS <ToArrayND>
    // Expect node: TYPE_PARAMETER <T_nd>
    // Expect node: CONDITIONAL_TYPE <[T] extends [any] ? T[] : never>
    // Expect node: TYPE_REFERENCE <[T] extends [any]>
    // Expect node: TYPE_ALIAS <[T]>
    // Expect node: TYPE_ALIAS <[any]>
    // Expect node: TYPE_REFERENCE <T[]_nd>
    // Expect node: LITERAL_TYPE <never_nd>
    // Expect node: TYPE_ALIAS <NonDistResult>
    // Expect node: TYPE_REFERENCE <ToArrayND<string | number>>
    // Expect node: TYPE_ALIAS <string | number_nd>
    // Expect edge: <module> -[DECLARES]-> <ToArray>
    // Expect edge: <ToArray> -[CONTAINS]-> <T>
    // Expect edge: <T extends any ? T[] : never> -[HAS_CONDITION]-> <T extends any>
    // Expect edge: <T extends any ? T[] : never> -[HAS_CONSEQUENT]-> <T[]>
    // Expect edge: <T extends any> -[CONSTRAINED_BY]-> <T>
    // Expect edge: <T[]> -[CONTAINS]-> <T>
    // Expect edge: <module> -[DECLARES]-> <DistResult>
    // Expect edge: <string | number> -[UNION_MEMBER]-> <string>
    // Expect edge: <string | number> -[UNION_MEMBER]-> <number>
    // Expect edge: <module> -[DECLARES]-> <ToArrayND>
    // Expect edge: <ToArrayND> -[CONTAINS]-> <T_nd>
    // Expect edge: <[T] extends [any] ? T[] : never> -[HAS_CONDITION]-> <[T] extends [any]>
    // Expect edge: <[T] extends [any] ? T[] : never> -[HAS_CONSEQUENT]-> <T[]_nd>
    // Expect edge: <[T] extends [any]> -[CONSTRAINED_BY]-> <[T]>
    // Expect edge: <[T] extends [any]> -[CONSTRAINED_BY]-> <[any]>
    // Expect edge: <[T]> -[CONTAINS]-> <T_nd>
    // Expect edge: <T[]_nd> -[CONTAINS]-> <T_nd>
    // Expect edge: <module> -[DECLARES]-> <NonDistResult>
    // Expect edge: <string | number_nd> -[UNION_MEMBER]-> <string>
    // Expect edge: <string | number_nd> -[UNION_MEMBER]-> <number>
    void code;
  });

  test('ts-specific::ts-function-type-intersection', () => {
    const code = "type StringHandler = (input: string) => string;\ntype NumberHandler = (input: number) => number;\ntype BothHandler = StringHandler & NumberHandler;";
    // Expect node: TYPE_ALIAS <StringHandler>
    // Expect node: TYPE_REFERENCE <StringHandler:fn-type>
    // Expect node: TYPE_REFERENCE <StringHandler:input>
    // Expect node: TYPE_REFERENCE <string1>
    // Expect node: TYPE_REFERENCE <string2>
    // Expect node: TYPE_ALIAS <NumberHandler>
    // Expect node: TYPE_REFERENCE <NumberHandler:fn-type>
    // Expect node: TYPE_REFERENCE <NumberHandler:input>
    // Expect node: TYPE_REFERENCE <number1>
    // Expect node: TYPE_REFERENCE <number2>
    // Expect node: TYPE_ALIAS <BothHandler>
    // Expect node: TYPE_REFERENCE <StringHandler & NumberHandler>
    // Expect edge: <module> -[DECLARES]-> <StringHandler>
    // Expect edge: <StringHandler:fn-type> -[CONTAINS]-> <StringHandler:input>
    // Expect edge: <StringHandler:fn-type> -[RETURNS]-> <string2>
    // Expect edge: <module> -[DECLARES]-> <NumberHandler>
    // Expect edge: <NumberHandler:fn-type> -[CONTAINS]-> <NumberHandler:input>
    // Expect edge: <NumberHandler:fn-type> -[RETURNS]-> <number2>
    // Expect edge: <module> -[DECLARES]-> <BothHandler>
    // Expect edge: <StringHandler & NumberHandler> -[INTERSECTS_WITH]-> <StringHandler>
    // Expect edge: <StringHandler & NumberHandler> -[INTERSECTS_WITH]-> <NumberHandler>
    void code;
  });

  test('ts-specific::ts-variadic-tuple', () => {
    const code = "type Concat<A extends unknown[], B extends unknown[]> = [...A, ...B];\ntype HeadOf<T extends unknown[]> = T extends [infer H, ...unknown[]] ? H : never;\ntype TailOf<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;\ntype LastOf<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;";
    // Expect node: TYPE_ALIAS <Concat>
    // Expect node: TYPE_PARAMETER <A>
    // Expect node: TYPE_PARAMETER <B>
    // Expect node: TYPE_ALIAS <[...A, ...B]>
    // Expect node: EXPRESSION <...A>
    // Expect node: EXPRESSION <...B>
    // Expect node: TYPE_ALIAS <HeadOf>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: CONDITIONAL_TYPE <T extends [infer H, ...unknown[]] ? H : never>
    // Expect node: INFER_TYPE <H>
    // Expect node: LITERAL_TYPE <never>
    // Expect node: TYPE_ALIAS <TailOf>
    // Expect node: TYPE_PARAMETER <T:TailOf>
    // Expect node: CONDITIONAL_TYPE <T extends [unknown, ...infer R] ? R : never>
    // Expect node: INFER_TYPE <R>
    // Expect node: LITERAL_TYPE <never:TailOf>
    // Expect node: TYPE_ALIAS <LastOf>
    // Expect node: TYPE_PARAMETER <T:LastOf>
    // Expect node: CONDITIONAL_TYPE <T extends [...unknown[], infer L] ? L : never>
    // Expect node: INFER_TYPE <L>
    // Expect node: LITERAL_TYPE <never:LastOf>
    // Expect edge: <module> -[DECLARES]-> <Concat>
    // Expect edge: <Concat> -[CONTAINS]-> <A>
    // Expect edge: <Concat> -[CONTAINS]-> <B>
    // Expect edge: <[...A, ...B]> -[CONTAINS]-> <...A>
    // Expect edge: <[...A, ...B]> -[CONTAINS]-> <...B>
    // Expect edge: <...A> -[SPREADS_FROM]-> <A>
    // Expect edge: <...B> -[SPREADS_FROM]-> <B>
    // Expect edge: <module> -[DECLARES]-> <HeadOf>
    // Expect edge: <HeadOf> -[CONTAINS]-> <T>
    // Expect edge: <T extends [infer H, ...unknown[]] ? H : never> -[HAS_CONDITION]-> <T>
    // Expect edge: <T extends [infer H, ...unknown[]] ? H : never> -[INFERS]-> <H>
    // Expect edge: <T extends [infer H, ...unknown[]] ? H : never> -[RETURNS]-> <H>
    // Expect edge: <T extends [infer H, ...unknown[]] ? H : never> -[RETURNS]-> <never>
    // Expect edge: <module> -[DECLARES]-> <TailOf>
    // Expect edge: <TailOf> -[CONTAINS]-> <T:TailOf>
    // Expect edge: <T extends [unknown, ...infer R] ? R : never> -[HAS_CONDITION]-> <T:TailOf>
    // Expect edge: <T extends [unknown, ...infer R] ? R : never> -[INFERS]-> <R>
    // Expect edge: <T extends [unknown, ...infer R] ? R : never> -[RETURNS]-> <R>
    // Expect edge: <T extends [unknown, ...infer R] ? R : never> -[RETURNS]-> <never:TailOf>
    // Expect edge: <module> -[DECLARES]-> <LastOf>
    // Expect edge: <LastOf> -[CONTAINS]-> <T:LastOf>
    // Expect edge: <T extends [...unknown[], infer L] ? L : never> -[HAS_CONDITION]-> <T:LastOf>
    // Expect edge: <T extends [...unknown[], infer L] ? L : never> -[INFERS]-> <L>
    // Expect edge: <T extends [...unknown[], infer L] ? L : never> -[RETURNS]-> <L>
    // Expect edge: <T extends [...unknown[], infer L] ? L : never> -[RETURNS]-> <never:LastOf>
    void code;
  });

  test('ts-specific::ts-import-type-inline', () => {
    const code = "// Type-level import() — resolves types without runtime import\ntype InlineImported = import('./modules-helpers.js').default;\n// In function signatures: function handle(req: import('express').Request): void {}\n\n// --- TypeScript using with type annotations ---";
    // Expect node: TYPE_ALIAS <InlineImported>
    // Expect node: IMPORT <import('./modules-helpers.js')>
    // Expect node: PROPERTY_ACCESS <import('./modules-helpers.js').default>
    // Expect edge: <module> -[DECLARES]-> <InlineImported>
    void code;
  });

  test('ts-specific::ts-typeof-class', () => {
    const code = "class ExampleForTypeof {\n  static create() { return new ExampleForTypeof(); }\n  method() { return 1; }\n}\n\ntype ExampleInstance = ExampleForTypeof;            // instance type — has method()\ntype ExampleConstructor = typeof ExampleForTypeof;  // constructor type — has create()\n\nfunction classFactory(Cls: typeof ExampleForTypeof): ExampleForTypeof {\n  return Cls.create();\n}";
    // Expect node: CLASS <ExampleForTypeof>
    // Expect node: METHOD <ExampleForTypeof.create>
    // Expect node: EXPRESSION <new ExampleForTypeof()>
    // Expect node: METHOD <ExampleForTypeof.method>
    // Expect node: LITERAL <1>
    // Expect node: TYPE_ALIAS <ExampleInstance>
    // Expect node: TYPE_REFERENCE <ExampleForTypeof:instance-type>
    // Expect node: TYPE_ALIAS <ExampleConstructor>
    // Expect node: TYPE_REFERENCE <typeof ExampleForTypeof>
    // Expect node: FUNCTION <classFactory>
    // Expect node: PARAMETER <Cls>
    // Expect node: TYPE_REFERENCE <typeof ExampleForTypeof:param-type>
    // Expect node: TYPE_REFERENCE <ExampleForTypeof:return-type>
    // Expect node: CALL <Cls.create()>
    // Expect edge: <module> -[DECLARES]-> <ExampleForTypeof>
    // Expect edge: <ExampleForTypeof> -[CONTAINS]-> <ExampleForTypeof.create>
    // Expect edge: <ExampleForTypeof> -[CONTAINS]-> <ExampleForTypeof.method>
    // Expect edge: <ExampleForTypeof.create> -[RETURNS]-> <new ExampleForTypeof()>
    // Expect edge: <ExampleForTypeof.method> -[RETURNS]-> <1>
    // Expect edge: <module> -[DECLARES]-> <ExampleInstance>
    // Expect edge: <module> -[DECLARES]-> <ExampleConstructor>
    // Expect edge: <module> -[DECLARES]-> <classFactory>
    // Expect edge: <classFactory> -[CONTAINS]-> <Cls>
    // Expect edge: <classFactory> -[RETURNS_TYPE]-> <ExampleForTypeof:return-type>
    // Expect edge: <classFactory> -[RETURNS]-> <Cls.create()>
    void code;
  });

  test('ts-specific::ts-enum-reverse-mapping', () => {
    const code = "enum HttpStatus {\n  OK = 200,\n  NotFound = 404,\n  ServerError = 500,\n}\nconst statusName = HttpStatus[200];           // 'OK' — reverse mapping\nconst statusCode = HttpStatus.OK;             // 200 — forward mapping\n// String enums do NOT have reverse mapping";
    // Expect node: ENUM <HttpStatus>
    // Expect node: ENUM_MEMBER <HttpStatus.OK>
    // Expect node: ENUM_MEMBER <HttpStatus.NotFound>
    // Expect node: ENUM_MEMBER <HttpStatus.ServerError>
    // Expect node: LITERAL <200>
    // Expect node: LITERAL <404>
    // Expect node: LITERAL <500>
    // Expect node: VARIABLE <statusName>
    // Expect node: PROPERTY_ACCESS <HttpStatus[200]>
    // Expect node: VARIABLE <statusCode>
    // Expect node: PROPERTY_ACCESS <HttpStatus.OK>
    // Expect edge: <module> -[DECLARES]-> <HttpStatus>
    // Expect edge: <HttpStatus> -[CONTAINS]-> <HttpStatus.OK>
    // Expect edge: <HttpStatus> -[CONTAINS]-> <HttpStatus.NotFound>
    // Expect edge: <HttpStatus> -[CONTAINS]-> <HttpStatus.ServerError>
    // Expect edge: <module> -[DECLARES]-> <statusName>
    // Expect edge: <module> -[DECLARES]-> <statusCode>
    void code;
  });

  test('ts-specific::ts-generic-keyof-constraint', () => {
    const code = "function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nfunction pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {\n  return items.map(item => item[key]);\n}";
    // Expect node: FUNCTION <getProperty>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_PARAMETER <K>
    // Expect node: TYPE_REFERENCE <keyof T>
    // Expect node: PARAMETER <obj>
    // Expect node: PARAMETER <key>
    // Expect node: TYPE_REFERENCE <T[K]>
    // Expect node: PROPERTY_ACCESS <obj[key]>
    // Expect node: FUNCTION <pluck>
    // Expect node: TYPE_PARAMETER <T2>
    // Expect node: TYPE_PARAMETER <K2>
    // Expect node: TYPE_REFERENCE <keyof T2>
    // Expect node: PARAMETER <items>
    // Expect node: PARAMETER <key2>
    // Expect node: TYPE_REFERENCE <T[K][]>
    // Expect node: CALL <items.map(...)>
    // Expect node: FUNCTION <arrow-fn>
    // Expect node: PARAMETER <item>
    // Expect node: PROPERTY_ACCESS <item[key]>
    // Expect edge: <module> -[DECLARES]-> <getProperty>
    // Expect edge: <getProperty> -[CONTAINS]-> <T>
    // Expect edge: <getProperty> -[CONTAINS]-> <K>
    // Expect edge: <K> -[CONSTRAINED_BY]-> <keyof T>
    // Expect edge: <getProperty> -[CONTAINS]-> <obj>
    // Expect edge: <getProperty> -[CONTAINS]-> <key>
    // Expect edge: <getProperty> -[RETURNS]-> <T[K]>
    // Expect edge: <getProperty> -[RETURNS]-> <obj[key]>
    // Expect edge: <module> -[DECLARES]-> <pluck>
    // Expect edge: <pluck> -[CONTAINS]-> <T2>
    // Expect edge: <pluck> -[CONTAINS]-> <K2>
    // Expect edge: <K2> -[CONSTRAINED_BY]-> <keyof T2>
    // Expect edge: <pluck> -[CONTAINS]-> <items>
    // Expect edge: <pluck> -[CONTAINS]-> <key2>
    // Expect edge: <pluck> -[RETURNS]-> <T[K][]>
    // Expect edge: <pluck> -[RETURNS]-> <items.map(...)>
    // Expect edge: <items.map(...)> -[PASSES_ARGUMENT]-> <arrow-fn>
    // Expect edge: <arrow-fn> -[CONTAINS]-> <item>
    // Expect edge: <arrow-fn> -[RETURNS]-> <item[key]>
    void code;
  });

  test('ts-specific::ts-import-equals-require', () => {
    const code = "// CJS-style import — emits: const CjsLib = require('./module')\n// import CjsLib = require('./module');\n// const instance = new CjsLib();\n// (commented out: requires actual CJS module; syntax is ExportAssignment / ImportEqualsDeclaration)\n\n// --- Getter and setter with different types (TS 4.3+) ---";
    // Expect node: IMPORT <import-equals>
    // Expect node: VARIABLE <CjsLib>
    // Expect node: CALL <new CjsLib()>
    // Expect node: VARIABLE <instance>
    // Expect edge: <module> -[CONTAINS]-> <import-equals>
    // Expect edge: <module> -[DECLARES]-> <instance>
    void code;
  });

  test('ts-specific::ts-export-equals', () => {
    const code = "// CJS-style export assignment — emits: module.exports = CjsLibrary\nclass CjsLibrary {\n  static VERSION = '1.0';\n  process(data: string): string { return data.toUpperCase(); }\n}\n// export = CjsLibrary;\n// (commented out: only one module export mode per file; shown for AST coverage)";
    // Expect node: CLASS <CjsLibrary>
    // Expect node: PROPERTY <CjsLibrary.VERSION>
    // Expect node: LITERAL <'1.0'>
    // Expect node: METHOD <CjsLibrary.process>
    // Expect node: PARAMETER <data>
    // Expect node: CALL <data.toUpperCase()>
    // Expect node: EXPORT <export=CjsLibrary>
    // Expect edge: <module> -[DECLARES]-> <CjsLibrary>
    // Expect edge: <CjsLibrary> -[CONTAINS]-> <CjsLibrary.VERSION>
    // Expect edge: <CjsLibrary> -[CONTAINS]-> <CjsLibrary.process>
    // Expect edge: <CjsLibrary.process> -[CONTAINS]-> <data>
    // Expect edge: <CjsLibrary.process> -[RETURNS]-> <data.toUpperCase()>
    void code;
  });

  test('ts-specific::ts-generic-default-prior-ref', () => {
    const code = "function createGenericStore<\n  S extends object,\n  A extends object = {},\n  G extends Record<string, (state: S) => unknown> = {},\n>(config: { state: S; actions?: A; getters?: G }) {\n  return config;\n}\n\nfunction wrapInArray<T, R = T[]>(value: T): R {\n  return [value] as unknown as R;         // R defaults to T[]\n}\n\n// --- infer with constraints (TS 4.7+) ---";
    // Expect node: FUNCTION <createGenericStore>
    // Expect node: TYPE_PARAMETER <S>
    // Expect node: TYPE_PARAMETER <A>
    // Expect node: TYPE_PARAMETER <G>
    // Expect node: LITERAL <{}>
    // Expect node: LITERAL <{}>
    // Expect node: PARAMETER <config>
    // Expect node: FUNCTION <wrapInArray>
    // Expect node: TYPE_PARAMETER <T>
    // Expect node: TYPE_PARAMETER <R>
    // Expect node: PARAMETER <value>
    // Expect node: EXPRESSION <[value] as unknown as R>
    // Expect node: EXPRESSION <[value]>
    // Expect edge: <module> -[DECLARES]-> <createGenericStore>
    // Expect edge: <createGenericStore> -[HAS_TYPE_PARAMETER]-> <S>
    // Expect edge: <createGenericStore> -[HAS_TYPE_PARAMETER]-> <A>
    // Expect edge: <createGenericStore> -[HAS_TYPE_PARAMETER]-> <G>
    // Expect edge: <A> -[DEFAULTS_TO]-> <{}>
    // Expect edge: <G> -[DEFAULTS_TO]-> <{}>
    // Expect edge: <createGenericStore> -[CONTAINS]-> <config>
    // Expect edge: <createGenericStore> -[RETURNS]-> <config>
    // Expect edge: <module> -[DECLARES]-> <wrapInArray>
    // Expect edge: <wrapInArray> -[HAS_TYPE_PARAMETER]-> <T>
    // Expect edge: <wrapInArray> -[HAS_TYPE_PARAMETER]-> <R>
    // Expect edge: <wrapInArray> -[CONTAINS]-> <value>
    // Expect edge: <wrapInArray> -[RETURNS]-> <[value] as unknown as R>
    void code;
  });

  test('ts-specific::ts-getter-setter-different-types', () => {
    const code = "class SmartField {\n  #raw: string = '';\n\n  get value(): string {\n    return this.#raw;\n  }\n\n  // Setter accepts wider type than getter returns\n  set value(input: string | number) {\n    this.#raw = String(input);\n  }\n}\n\n// --- Inline type modifier on import/export specifiers (TS 4.5+) ---";
    // Expect node: CLASS <SmartField>
    // Expect node: PROPERTY <SmartField.#raw>
    // Expect node: LITERAL <''>
    // Expect node: METHOD <SmartField.value:getter>
    // Expect node: METHOD <SmartField.value:setter>
    // Expect node: PARAMETER <input>
    // Expect node: CALL <String(input)>
    // Expect edge: <module> -[DECLARES]-> <SmartField>
    // Expect edge: <SmartField> -[CONTAINS]-> <SmartField.#raw>
    // Expect edge: <SmartField> -[CONTAINS]-> <SmartField.value:getter>
    // Expect edge: <SmartField> -[CONTAINS]-> <SmartField.value:setter>
    // Expect edge: <SmartField.value:getter> -[RETURNS]-> <SmartField.#raw>
    // Expect edge: <SmartField.value:setter> -[CONTAINS]-> <input>
    // Expect edge: <String(input)> -[PASSES_ARGUMENT]-> <input>
    void code;
  });

  test('ts-specific::ts-using-typed', () => {
    const code = "// using with type annotations (TS extension of ES2025 Explicit Resource Management)\n// using handle: FileHandle = openFile('/tmp/data');\n// await using conn: DBConnection = await pool.connect();\n// for (using reader: Reader of getReaders()) { reader.process(); }\n\n// --- satisfies + as const combo ---";
    // Expect node: VARIABLE <handle>
    // Expect node: TYPE_REFERENCE <FileHandle>
    // Expect node: CALL <openFile('/tmp/data')>
    // Expect node: LITERAL <'/tmp/data'>
    // Expect node: VARIABLE <conn>
    // Expect node: TYPE_REFERENCE <DBConnection>
    // Expect node: EXPRESSION <await pool.connect()>
    // Expect node: CALL <pool.connect()>
    // Expect node: LOOP <for-using>
    // Expect node: VARIABLE <reader>
    // Expect node: TYPE_REFERENCE <Reader>
    // Expect node: CALL <getReaders()>
    // Expect node: CALL <reader.process()>
    // Expect edge: <module> -[DECLARES]-> <handle>
    // Expect edge: <openFile('/tmp/data')> -[PASSES_ARGUMENT]-> <'/tmp/data'>
    // Expect edge: <module> -[DECLARES]-> <conn>
    // Expect edge: <await pool.connect()> -[AWAITS]-> <pool.connect()>
    // Expect edge: <for-using> -[ITERATES_OVER]-> <getReaders()>
    // Expect edge: <for-using> -[CONTAINS]-> <reader>
    void code;
  });

  test('ts-specific::ts-inline-type-modifier', () => {
    const code = "// Mixed value + type in single import:\n// import { Component, type Props, type State } from './ui';\n// Component → runtime import (IMPORTS_FROM edge)\n// Props, State → type-only (erased, NO runtime dependency)\n\n// Mixed value + type in single re-export:\n// export { handler, type HandlerConfig } from './handlers';\n\n// Contrast with import type (entire statement is type-only):\n// import type { OnlyTypes } from './types';\n\n// --- this parameter combined with destructuring ---";
    // Expect node: IMPORT <import-ui>
    // Expect node: VARIABLE <Component>
    // Expect node: TYPE_ALIAS <Props>
    // Expect node: TYPE_ALIAS <State>
    // Expect node: EXPORT <export-handlers>
    // Expect node: VARIABLE <handler>
    // Expect node: TYPE_ALIAS <HandlerConfig>
    // Expect node: IMPORT <import-types>
    // Expect node: TYPE_ALIAS <OnlyTypes>
    // Expect edge: <module> -[CONTAINS]-> <import-ui>
    // Expect edge: <module> -[CONTAINS]-> <export-handlers>
    // Expect edge: <module> -[CONTAINS]-> <import-types>
    void code;
  });

  test('ts-specific::ts-satisfies-as-const', () => {
    const code = "const routes = {\n  home: '/',\n  about: '/about',\n  user: '/user/:id',\n} as const satisfies Record<string, string>;\n\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n} satisfies Record<string, string | number[]>;\n\n// --- TS CJS interop: export = / import = require() ---";
    // Expect node: VARIABLE <routes>
    // Expect node: LITERAL <routes:obj>
    // Expect node: PROPERTY <routes:obj.home>
    // Expect node: LITERAL <'/'>
    // Expect node: PROPERTY <routes:obj.about>
    // Expect node: LITERAL <'/about'>
    // Expect node: PROPERTY <routes:obj.user>
    // Expect node: LITERAL <'/user/:id'>
    // Expect node: TYPE_REFERENCE <Record<string, string>>
    // Expect node: VARIABLE <palette>
    // Expect node: LITERAL <palette:obj>
    // Expect node: PROPERTY <palette:obj.red>
    // Expect node: LITERAL <[255, 0, 0]>
    // Expect node: LITERAL <255>
    // Expect node: LITERAL <0>
    // Expect node: LITERAL <0_2>
    // Expect node: PROPERTY <palette:obj.green>
    // Expect node: LITERAL <'#00ff00'>
    // Expect node: TYPE_REFERENCE <Record<string, string | number[]>>
    // Expect edge: <module> -[DECLARES]-> <routes>
    // Expect edge: <routes:obj> -[HAS_PROPERTY]-> <routes:obj.home>
    // Expect edge: <routes:obj> -[HAS_PROPERTY]-> <routes:obj.about>
    // Expect edge: <routes:obj> -[HAS_PROPERTY]-> <routes:obj.user>
    // Expect edge: <module> -[DECLARES]-> <palette>
    // Expect edge: <palette:obj> -[HAS_PROPERTY]-> <palette:obj.red>
    // Expect edge: <[255, 0, 0]> -[HAS_ELEMENT]-> <255>
    // Expect edge: <[255, 0, 0]> -[HAS_ELEMENT]-> <0>
    // Expect edge: <[255, 0, 0]> -[HAS_ELEMENT]-> <0_2>
    // Expect edge: <palette:obj> -[HAS_PROPERTY]-> <palette:obj.green>
    void code;
  });

  test('ts-specific::ts-infer-constrained', () => {
    const code = "type FirstString<T> = T extends [infer S extends string, ...unknown[]] ? S : never;\ntype NumericKeys<T> = { [K in keyof T as K extends `${infer N extends number}` ? K : never]: T[K] };\ntype ParsePair<T> = T extends `${infer A extends number},${infer B extends number}` ? [A, B] : never;\n\n// --- Inline import() type expressions ---";
    // Expect node: TYPE_ALIAS <FirstString>
    // Expect node: TYPE_PARAMETER <T1>
    // Expect node: CONDITIONAL_TYPE <FirstString:conditional>
    // Expect node: INFER_TYPE <S>
    // Expect node: TYPE_ALIAS <[infer S extends string, ...unknown[]]>
    // Expect node: LITERAL_TYPE <never1>
    // Expect node: TYPE_ALIAS <NumericKeys>
    // Expect node: TYPE_PARAMETER <T2>
    // Expect node: TYPE_ALIAS <NumericKeys:mapped>
    // Expect node: TYPE_REFERENCE <NumericKeys:remapping>
    // Expect node: INFER_TYPE <N>
    // Expect node: TYPE_REFERENCE <${infer N extends number}>
    // Expect node: LITERAL_TYPE <never2>
    // Expect node: TYPE_ALIAS <ParsePair>
    // Expect node: TYPE_PARAMETER <T3>
    // Expect node: CONDITIONAL_TYPE <ParsePair:conditional>
    // Expect node: TYPE_REFERENCE <${infer A extends number},${infer B extends number}>
    // Expect node: INFER_TYPE <A>
    // Expect node: INFER_TYPE <B>
    // Expect node: TYPE_ALIAS <[A, B]>
    // Expect node: LITERAL_TYPE <never3>
    // Expect edge: <module> -[DECLARES]-> <FirstString>
    // Expect edge: <FirstString> -[CONTAINS]-> <T1>
    // Expect edge: <FirstString:conditional> -[HAS_CONDITION]-> <T1>
    // Expect edge: <[infer S extends string, ...unknown[]]> -[INFERS]-> <S>
    // Expect edge: <S> -[CONSTRAINED_BY]-> string
    // Expect edge: <FirstString:conditional> -[HAS_CONSEQUENT]-> <S>
    // Expect edge: <module> -[DECLARES]-> <NumericKeys>
    // Expect edge: <NumericKeys> -[CONTAINS]-> <T2>
    // Expect edge: <NumericKeys:mapped> -[ITERATES_OVER]-> <T2>
    // Expect edge: <${infer N extends number}> -[INFERS]-> <N>
    // Expect edge: <N> -[CONSTRAINED_BY]-> number
    // Expect edge: <module> -[DECLARES]-> <ParsePair>
    // Expect edge: <ParsePair> -[CONTAINS]-> <T3>
    // Expect edge: <ParsePair:conditional> -[HAS_CONDITION]-> <T3>
    // Expect edge: <${infer A extends number},${infer B extends number}> -[INFERS]-> <A>
    // Expect edge: <${infer A extends number},${infer B extends number}> -[INFERS]-> <B>
    // Expect edge: <A> -[CONSTRAINED_BY]-> number
    // Expect edge: <B> -[CONSTRAINED_BY]-> number
    // Expect edge: <ParsePair:conditional> -[HAS_CONSEQUENT]-> <[A, B]>
    // Expect edge: <[A, B]> -[CONTAINS]-> <A>
    // Expect edge: <[A, B]> -[CONTAINS]-> <B>
    void code;
  });
});
