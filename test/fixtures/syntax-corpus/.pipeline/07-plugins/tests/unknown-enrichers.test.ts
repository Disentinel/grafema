/**
 * Enrichment-phase tests for unknown
 *
 * Auto-generated by @grafema/lang-spec stage 10.
 * 491 post-file cases, 539 post-project cases.
 */

import { describe, test } from 'node:test';

describe('Unknown post-file enrichment', () => {
  test('aliasing::alias-method-extraction', () => {
    const code = "const log = console.log;\nlog('extracted');";
    // Expect edge: <log> -[ASSIGNED_FROM]-> <console.log>
    void code;
  });

  test('aliasing::alias-reassign-function', () => {
    const code = "let handler = function first() { return 1; };\nhandler();\n\nhandler = function second() { return 2; };\nhandler();";
    // Expect edge: <handler> -[ASSIGNED_FROM]-> <first>
    // Expect edge: <handler> -[ASSIGNED_FROM]-> <second>
    void code;
  });

  test('aliasing::alias-destructured-method', () => {
    const code = "const { parse, stringify } = JSON;\nconst parsed = parse('{\"a\":1}');";
    // Expect edge: <parsed> -[ASSIGNED_FROM]-> <parse('{"a":1}')>
    void code;
  });

  test('aliasing::alias-bind-partial', () => {
    const code = "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---";
    // Expect edge: <doubleIt> -[ASSIGNED_FROM]-> <multiply.bind(null, 2)>
    // Expect edge: <doubleIt:bound> -[CAPTURES]-> <2>
    void code;
  });

  test('aliasing::alias-computed-method', () => {
    const code = "const mathObj = { add(a, b) { return a + b; } };\nconst methodName = 'add';\nconst fn = mathObj[methodName];\nfn(1, 2);\n\n// --- Function reassignment ---";
    // Expect edge: <mathObj> -[ASSIGNED_FROM]-> <mathObj-object>
    // Expect edge: <methodName> -[ASSIGNED_FROM]-> <'add'>
    // Expect edge: <fn> -[ASSIGNED_FROM]-> <mathObj[methodName]>
    void code;
  });

  test('aliasing::alias-reassign-conditional', () => {
    const code = "let strategy;\nif (Math.random() > 0.5) {\n  strategy = function fast() { return 'fast'; };\n} else {\n  strategy = function slow() { return 'slow'; };\n}\nstrategy();\n\n// --- Callback identity through higher-order functions ---";
    // Expect edge: <strategy> -[ASSIGNED_FROM]-> <fast>
    // Expect edge: <if-random> -[HAS_ALTERNATE]-> <strategy>
    // Expect edge: <strategy> -[ASSIGNED_FROM]-> <slow>
    void code;
  });

  test('aliasing::alias-callback-returned', () => {
    const code = "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---";
    // Expect edge: <if-ascending> -[HAS_ALTERNATE]-> <descending-comparator>
    // Expect edge: <cmp> -[ASSIGNED_FROM]-> <getComparator(true)>
    void code;
  });

  test('aliasing::alias-callback-returned', () => {
    const code = "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---";
    // Expect edge: <if-ascending> -[HAS_ALTERNATE]-> <descending-comparator>
    // Expect edge: <cmp> -[ASSIGNED_FROM]-> <getComparator(true)>
    void code;
  });

  test('aliasing::arguments-basic', () => {
    const code = "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}";
    // Expect edge: <total> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <total += arguments[i]> -[MODIFIES]-> <total>
    // Expect edge: <sum> -[CAPTURES]-> <arguments>
    void code;
  });

  test('aliasing::alias-bind-partial', () => {
    const code = "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---";
    // Expect edge: <doubleIt> -[ASSIGNED_FROM]-> <multiply.bind(null, 2)>
    // Expect edge: <doubleIt:bound> -[CAPTURES]-> <2>
    void code;
  });

  test('aliasing::alias-import-dynamic-variable', () => {
    const code = "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);";
    // Expect edge: <modulePath> -[ASSIGNED_FROM]-> <'./declarations.js'>
    // Expect edge: <dynamicMod> -[ASSIGNED_FROM]-> <import(modulePath)>
    void code;
  });

  test('aliasing::arguments-callee', () => {
    const code = "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---";
    // Expect edge: <factorial> -[ASSIGNED_FROM]-> <factorial:fn>
    // Expect edge: <ternary> -[HAS_ALTERNATE]-> <n * arguments.callee(n - 1)>
    void code;
  });

  test('aliasing::arguments-basic', () => {
    const code = "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}";
    // Expect edge: <total> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <total += arguments[i]> -[MODIFIES]-> <total>
    // Expect edge: <sum> -[CAPTURES]-> <arguments>
    void code;
  });

  test('aliasing::arguments-array-conversion', () => {
    const code = "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}";
    // Expect edge: <fromArrayFn> -[ASSIGNED_FROM]-> <Array.from(arguments)>
    // Expect edge: <fromSpread> -[ASSIGNED_FROM]-> <[...arguments]>
    // Expect edge: <fromSlice> -[ASSIGNED_FROM]-> <[].slice.call(arguments)>
    void code;
  });

  test('aliasing::arguments-array-conversion', () => {
    const code = "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}";
    // Expect edge: <fromArrayFn> -[ASSIGNED_FROM]-> <Array.from(arguments)>
    // Expect edge: <fromSpread> -[ASSIGNED_FROM]-> <[...arguments]>
    // Expect edge: <fromSlice> -[ASSIGNED_FROM]-> <[].slice.call(arguments)>
    void code;
  });

  test('aliasing::alias-import-dynamic-conditional', () => {
    const code = "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);";
    // Expect edge: <impl> -[ASSIGNED_FROM]-> <import()>
    // Expect edge: <conditional> -[HAS_ALTERNATE]-> <'./expressions.js'>
    void code;
  });

  test('aliasing::arguments-callee', () => {
    const code = "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---";
    // Expect edge: <factorial> -[ASSIGNED_FROM]-> <factorial:fn>
    // Expect edge: <ternary> -[HAS_ALTERNATE]-> <n * arguments.callee(n - 1)>
    void code;
  });

  test('aliasing::alias-import-dynamic-variable', () => {
    const code = "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);";
    // Expect edge: <modulePath> -[ASSIGNED_FROM]-> <'./declarations.js'>
    // Expect edge: <dynamicMod> -[ASSIGNED_FROM]-> <import(modulePath)>
    void code;
  });

  test('aliasing::alias-import-dynamic-template', () => {
    const code = "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}";
    // Expect edge: <plugin> -[ASSIGNED_FROM]-> <dynamic-import>
    void code;
  });

  test('aliasing::alias-import-dynamic-template', () => {
    const code = "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}";
    // Expect edge: <plugin> -[ASSIGNED_FROM]-> <dynamic-import>
    void code;
  });

  test('aliasing::alias-import-dynamic-conditional', () => {
    const code = "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);";
    // Expect edge: <impl> -[ASSIGNED_FROM]-> <import()>
    // Expect edge: <conditional> -[HAS_ALTERNATE]-> <'./expressions.js'>
    void code;
  });

  test('aliasing::arrow-no-arguments', () => {
    const code = "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);";
    // Expect edge: <arrow> -[ASSIGNED_FROM]-> <arrow:fn>
    // Expect edge: <arguments[0]> -[CAPTURES]-> <outerWithArguments>
    // Expect edge: <arrowFromOuter> -[ASSIGNED_FROM]-> <outerWithArguments(42)>
    void code;
  });

  test('aliasing::arrow-no-arguments', () => {
    const code = "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);";
    // Expect edge: <arrow> -[ASSIGNED_FROM]-> <arrow:fn>
    // Expect edge: <arguments[0]> -[CAPTURES]-> <outerWithArguments>
    // Expect edge: <arrowFromOuter> -[ASSIGNED_FROM]-> <outerWithArguments(42)>
    void code;
  });

  test('aliasing::arguments-param-aliasing', () => {
    const code = "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode — bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}";
    // Expect edge: <arguments[0]> -[ASSIGNED_FROM]-> <99>
    // Expect edge: <aAfterMutation> -[ASSIGNED_FROM]-> <a>
    // Expect edge: <a> -[ASSIGNED_FROM]-> <'changed'>
    // Expect edge: <arg0AfterReassign> -[ASSIGNED_FROM]-> <arguments[0]>
    void code;
  });

  test('aliasing::arguments-param-aliasing', () => {
    const code = "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode — bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}";
    // Expect edge: <arguments[0]> -[ASSIGNED_FROM]-> <99>
    // Expect edge: <aAfterMutation> -[ASSIGNED_FROM]-> <a>
    // Expect edge: <a> -[ASSIGNED_FROM]-> <'changed'>
    // Expect edge: <arg0AfterReassign> -[ASSIGNED_FROM]-> <arguments[0]>
    void code;
  });

  test('aliasing::arguments-rest-coexistence', () => {
    const code = "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}";
    // Expect edge: <allCount> -[ASSIGNED_FROM]-> <arguments.length>
    // Expect edge: <firstFromArgs> -[ASSIGNED_FROM]-> <arguments[0]>
    // Expect edge: <restFromArgs> -[ASSIGNED_FROM]-> <arguments[1]>
    void code;
  });

  test('async-generators::async-await-basic', () => {
    const code = "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}";
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url)>
    // Expect edge: <data> -[ASSIGNED_FROM]-> <response.json()>
    void code;
  });

  test('aliasing::arguments-rest-coexistence', () => {
    const code = "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}";
    // Expect edge: <allCount> -[ASSIGNED_FROM]-> <arguments.length>
    // Expect edge: <firstFromArgs> -[ASSIGNED_FROM]-> <arguments[0]>
    // Expect edge: <restFromArgs> -[ASSIGNED_FROM]-> <arguments[1]>
    void code;
  });

  test('async-generators::async-await-basic', () => {
    const code = "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}";
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url)>
    // Expect edge: <data> -[ASSIGNED_FROM]-> <response.json()>
    void code;
  });

  test('async-generators::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};";
    // Expect edge: <asyncArrow> -[ASSIGNED_FROM]-> <asyncArrow:fn>
    void code;
  });

  test('async-generators::promise-construction', () => {
    const code = "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}";
    // Expect edge: <if-shouldResolve> -[HAS_ALTERNATE]-> <reject(new Error('failure'))>
    void code;
  });

  test('async-generators::async-await-try-catch', () => {
    const code = "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}";
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url)>
    // Expect edge: <if-not-ok> -[THROWS]-> <new Error>
    void code;
  });

  test('async-generators::promise-construction', () => {
    const code = "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}";
    // Expect edge: <if-shouldResolve> -[HAS_ALTERNATE]-> <reject(new Error('failure'))>
    void code;
  });

  test('async-generators::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};";
    // Expect edge: <asyncArrow> -[ASSIGNED_FROM]-> <asyncArrow:fn>
    void code;
  });

  test('async-generators::async-await-try-catch', () => {
    const code = "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}";
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url)>
    // Expect edge: <if-not-ok> -[THROWS]-> <new Error>
    void code;
  });

  test('async-generators::async-arrow-with-params', () => {
    const code = "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};";
    // Expect edge: <asyncArrowWithParams> -[ASSIGNED_FROM]-> <asyncArrowWithParams:fn>
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url, options)>
    void code;
  });

  test('async-generators::generator-basic', () => {
    const code = "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <start>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('async-generators::async-arrow-with-params', () => {
    const code = "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};";
    // Expect edge: <asyncArrowWithParams> -[ASSIGNED_FROM]-> <asyncArrowWithParams:fn>
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url, options)>
    void code;
  });

  test('async-generators::generator-basic', () => {
    const code = "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <start>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('async-generators::top-level-await', () => {
    const code = "const config = await import('./declarations.js');";
    // Expect edge: <config> -[ASSIGNED_FROM]-> <await import('./declarations.js')>
    void code;
  });

  test('async-generators::generator-infinite', () => {
    const code = "function* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}";
    // Expect edge: <a> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <a> -[ASSIGNED_FROM]-> <destructure-array>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <destructure-array>
    void code;
  });

  test('async-generators::async-generator', () => {
    const code = "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <start>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('async-generators::for-await-of', () => {
    const code = "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('async-generators::for-await-of', () => {
    const code = "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('async-generators::generator-finally-cleanup', () => {
    const code = "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}";
    // Expect edge: <resource> -[ASSIGNED_FROM]-> <{ acquired: true }>
    // Expect edge: <finally-block> -[WRITES_TO]-> <resource.acquired>
    // Expect edge: <resource.acquired> -[ASSIGNED_FROM]-> <false>
    void code;
  });

  test('async-generators::generator-observer-pattern', () => {
    const code = "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <value> -[ASSIGNED_FROM]-> <yield>
    void code;
  });

  test('async-generators::top-level-await', () => {
    const code = "const config = await import('./declarations.js');";
    // Expect edge: <config> -[ASSIGNED_FROM]-> <await import('./declarations.js')>
    void code;
  });

  test('async-generators::generator-two-way', () => {
    const code = "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}";
    // Expect edge: <total> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <value> -[ASSIGNED_FROM]-> <yield-total>
    // Expect edge: <total += value> -[WRITES_TO]-> <total>
    void code;
  });

  test('async-generators::promise-resolve-thenable', () => {
    const code = "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}";
    // Expect edge: <thenable> -[ASSIGNED_FROM]-> <thenable-object>
    void code;
  });

  test('async-generators::async-generator', () => {
    const code = "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <start>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('async-generators::yield-star-return-value', () => {
    const code = "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <yield* innerWithReturn()>
    void code;
  });

  test('async-generators::yield-yield-chained', () => {
    const code = "function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <yield yield 1>
    void code;
  });

  test('async-generators::for-await-sync-iterable', () => {
    const code = "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array — each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('async-generators::async-iterator-cancel-manual', () => {
    const code = "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}";
    // Expect edge: <iter> -[ASSIGNED_FROM]-> <asyncGen[Symbol.asyncIterator]()>
    // Expect edge: <first> -[ASSIGNED_FROM]-> <iter.next()>
    void code;
  });

  test('async-generators::generator-two-way', () => {
    const code = "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}";
    // Expect edge: <total> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <value> -[ASSIGNED_FROM]-> <yield-total>
    // Expect edge: <total += value> -[WRITES_TO]-> <total>
    void code;
  });

  test('async-generators::async-iter-manual', () => {
    const code = "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}";
    // Expect edge: <asyncIter> -[ASSIGNED_FROM]-> <asyncIterable[Symbol.asyncIterator]()>
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <step> -[ASSIGNED_FROM]-> <asyncIter.next()>
    // Expect edge: <step = await asyncIter.next()> -[WRITES_TO]-> <step>
    void code;
  });

  test('async-generators::async-iterator-cancel-break', () => {
    const code = "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}";
    // Expect edge: <reader> -[ASSIGNED_FROM]-> <{ locked: true }>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <reader.locked> -[ASSIGNED_FROM]-> <false>
    void code;
  });

  test('builtins::builtin-weakref', () => {
    const code = "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}";
    // Expect edge: <target> -[ASSIGNED_FROM]-> <{ data: 'important' }>
    // Expect edge: <ref> -[ASSIGNED_FROM]-> <new WeakRef(target)>
    // Expect edge: <deref> -[ASSIGNED_FROM]-> <ref.deref()>
    void code;
  });

  test('builtins::builtin-map-constructor', () => {
    const code = "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---";
    // Expect edge: <map> -[ASSIGNED_FROM]-> <new Map([...])>
    void code;
  });

  test('builtins::builtin-json-parse-reviver', () => {
    const code = "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}";
    // Expect edge: <if-date-check> -[HAS_ALTERNATE]-> <value>
    void code;
  });

  test('async-generators::async-destructure-await-default', () => {
    const code = "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};";
    // Expect edge: <asyncDestructureHandler> -[ASSIGNED_FROM]-> <asyncDestructureHandler:fn>
    void code;
  });

  test('builtins::builtin-json-stringify-replacer', () => {
    const code = "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---";
    // Expect edge: <if-typeof-function> -[HAS_ALTERNATE]-> <value>
    void code;
  });

  test('builtins::builtin-weakset', () => {
    const code = "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---";
    // Expect edge: <ws> -[ASSIGNED_FROM]-> <new WeakSet()>
    // Expect edge: <obj1> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <obj2> -[ASSIGNED_FROM]-> <{}2>
    // Expect edge: <has> -[ASSIGNED_FROM]-> <ws.has(obj1)>
    // Expect edge: <hasAfter> -[ASSIGNED_FROM]-> <ws.has(obj1)2>
    void code;
  });

  test('builtins::builtin-globalthis', () => {
    const code = "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---";
    // Expect edge: <g> -[ASSIGNED_FROM]-> <globalThis>
    // Expect edge: <hasConsole> -[ASSIGNED_FROM]-> <'console' in globalThis>
    void code;
  });

  test('builtins::builtin-finalization-registry', () => {
    const code = "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---";
    // Expect edge: <registry> -[ASSIGNED_FROM]-> <new FinalizationRegistry(...)>
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ id: 1 }>
    void code;
  });

  test('builtins::regex-lookahead', () => {
    const code = "const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;";
    // Expect edge: <posLookahead> -[ASSIGNED_FROM]-> </\d+(?=px)/>
    // Expect edge: <negLookahead> -[ASSIGNED_FROM]-> </\d+(?!px)/>
    void code;
  });

  test('builtins::builtin-regex-named-groups', () => {
    const code = "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---";
    // Expect edge: <pattern> -[ASSIGNED_FROM]-> </(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/>
    // Expect edge: <match> -[ASSIGNED_FROM]-> <dateStr.match(pattern)>
    // Expect edge: <year> -[ASSIGNED_FROM]-> <match.groups>
    // Expect edge: <month> -[ASSIGNED_FROM]-> <match.groups>
    // Expect edge: <day> -[ASSIGNED_FROM]-> <match.groups>
    void code;
  });

  test('builtins::regex-lookbehind', () => {
    const code = "const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;";
    // Expect edge: <posLookbehind> -[ASSIGNED_FROM]-> </(?<=\$)\d+/>
    // Expect edge: <negLookbehind> -[ASSIGNED_FROM]-> </(?<!\$)\d+/>
    void code;
  });

  test('builtins::builtin-regex-exec', () => {
    const code = "function regexExec(pattern, str) {\n  const regex = new RegExp(pattern, 'g');\n  const matches = [];\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    matches.push({ match: match[0], index: match.index });\n  }\n  return matches;\n}";
    // Expect edge: <regex> -[ASSIGNED_FROM]-> <new RegExp(pattern, 'g')>
    // Expect edge: <matches> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <match = regex.exec(str)> -[WRITES_TO]-> <match>
    void code;
  });

  test('async-generators::async-iter-manual', () => {
    const code = "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}";
    // Expect edge: <asyncIter> -[ASSIGNED_FROM]-> <asyncIterable[Symbol.asyncIterator]()>
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <step> -[ASSIGNED_FROM]-> <asyncIter.next()>
    // Expect edge: <step = await asyncIter.next()> -[WRITES_TO]-> <step>
    void code;
  });

  test('builtins::string-raw-template', () => {
    const code = "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file' — no escape processing";
    // Expect edge: <windowsPath> -[ASSIGNED_FROM]-> <String.raw`C:\Users\name\file`>
    void code;
  });

  test('builtins::regex-unicode-props', () => {
    const code = "const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;";
    // Expect edge: <emoji> -[ASSIGNED_FROM]-> </\p{Emoji}/u>
    // Expect edge: <greek> -[ASSIGNED_FROM]-> </\p{Script=Greek}/u>
    // Expect edge: <letter> -[ASSIGNED_FROM]-> </\p{Letter}/u>
    void code;
  });

  test('builtins::array-from-mapfn', () => {
    const code = "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---";
    // Expect edge: <indices> -[ASSIGNED_FROM]-> <Array.from({ length: 5 }, (_, i) => i)>
    void code;
  });

  test('callbacks::callback-error-first', () => {
    const code = "function readFileCallback(path, callback) {\n  try {\n    const data = `contents of ${path}`;\n    callback(null, data);\n  } catch (err) {\n    callback(err, null);\n  }\n}";
    // Expect edge: <data> -[ASSIGNED_FROM]-> <`contents of ${path}`>
    void code;
  });

  test('async-generators::promise-resolve-thenable', () => {
    const code = "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}";
    // Expect edge: <thenable> -[ASSIGNED_FROM]-> <thenable-object>
    void code;
  });

  test('callbacks::callback-error-first-usage', () => {
    const code = "function processFile(path) {\n  readFileCallback(path, function (err, data) {\n    if (err) {\n      console.error('Failed:', err);\n      return;\n    }\n    console.log('Data:', data);\n  });\n}\n\n// --- Callback hell (3+ levels) ---";
    // Expect edge: <if-err> -[HAS_ALTERNATE]-> <console.log('Data:', data)>
    void code;
  });

  test('callbacks::callback-settimeout', () => {
    const code = "function delayedExecution(fn, ms) {\n  const id = setTimeout(fn, ms);\n  return function cancel() {\n    clearTimeout(id);\n  };\n}";
    // Expect edge: <id> -[ASSIGNED_FROM]-> <setTimeout(fn, ms)>
    // Expect edge: <cancel> -[CAPTURES]-> <id>
    void code;
  });

  test('builtins::symbol-private-property', () => {
    const code = "const _private = Symbol('private');\nclass SymbolStore {\n  [_private] = new Map();\n  set(key, value) { this[_private].set(key, value); }\n  get(key) { return this[_private].get(key); }\n}";
    // Expect edge: <_private> -[ASSIGNED_FROM]-> <Symbol('private')>
    // Expect edge: <SymbolStore[_private]> -[ASSIGNED_FROM]-> <new Map()>
    void code;
  });

  test('async-generators::generator-observer-pattern', () => {
    const code = "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <value> -[ASSIGNED_FROM]-> <yield>
    void code;
  });

  test('callbacks::callback-promisify-usage', () => {
    const code = "const readFileAsync = promisify(readFileCallback);\n\n// --- Array callback patterns ---";
    // Expect edge: <readFileAsync> -[ASSIGNED_FROM]-> <promisify(readFileCallback)>
    void code;
  });

  test('callbacks::callback-higher-order', () => {
    const code = "function retry(fn, attempts, callback) {\n  fn(function (err, result) {\n    if (err && attempts > 1) {\n      retry(fn, attempts - 1, callback);\n    } else {\n      callback(err, result);\n    }\n  });\n}";
    // Expect edge: <if-err-attempts> -[HAS_ALTERNATE]-> <callback-call>
    void code;
  });

  test('builtins::sparse-array', () => {
    const code = "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false — hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}";
    // Expect edge: <sparse> -[ASSIGNED_FROM]-> <sparse-array>
    // Expect edge: <length> -[ASSIGNED_FROM]-> <sparse.length>
    // Expect edge: <hasIndex1> -[ASSIGNED_FROM]-> <1 in sparse>
    // Expect edge: <mapped> -[ASSIGNED_FROM]-> <sparse.map(x => x * 2)>
    void code;
  });

  test('callbacks::callback-microtask', () => {
    const code = "function withMicrotask(fn) {\n  queueMicrotask(() => {\n    fn();\n  });\n}\n\n// --- Promisify ---";
    // Expect edge: <microtask-callback> -[CAPTURES]-> <fn>
    void code;
  });

  test('cjs-patterns::require-simple', () => {
    const code = "const fs = require('fs');";
    // Expect edge: <fs> -[ASSIGNED_FROM]-> <require('fs')>
    void code;
  });

  test('cjs-patterns::require-destructured', () => {
    const code = "const { readFile, writeFile } = require('fs/promises');";
    // Expect edge: <readFile> -[ASSIGNED_FROM]-> <require('fs/promises')>
    // Expect edge: <writeFile> -[ASSIGNED_FROM]-> <require('fs/promises')>
    void code;
  });

  test('callbacks::callback-thisarg-filter', () => {
    const code = "class Validator {\n  threshold = 10;\n  filter(items) {\n    return items.filter(function(item) {\n      return item > this.threshold;\n    }, this);\n  }\n}";
    // Expect edge: <Validator.threshold> -[ASSIGNED_FROM]-> <10>
    void code;
  });

  test('callbacks::callback-thisarg-map', () => {
    const code = "class Processor {\n  multiplier = 3;\n  process(items) {\n    return items.map(function(item) {\n      return item * this.multiplier; // `this` = Processor instance via thisArg\n    }, this);\n  }\n}";
    // Expect edge: <Processor.multiplier> -[ASSIGNED_FROM]-> <3>
    void code;
  });

  test('cjs-patterns::cjs-const-decl', () => {
    const code = "const CJS_CONSTANT = 42;";
    // Expect edge: <CJS_CONSTANT> -[ASSIGNED_FROM]-> <42>
    void code;
  });

  test('callbacks::callback-continuation-passing', () => {
    const code = "function waterfall(tasks, callback) {\n  let index = 0;\n  function next(err, result) {\n    if (err || index >= tasks.length) return callback(err, result);\n    tasks[index++](result, next);\n  }\n  next(null, null);\n}\n\n// --- Event emitter pattern ---";
    // Expect edge: <index> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <index++> -[MODIFIES]-> <index>
    // Expect edge: <next> -[CAPTURES]-> <callback>
    // Expect edge: <next> -[CAPTURES]-> <tasks>
    // Expect edge: <next> -[CAPTURES]-> <index>
    void code;
  });

  test('async-generators::generator-finally-cleanup', () => {
    const code = "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}";
    // Expect edge: <resource> -[ASSIGNED_FROM]-> <{ acquired: true }>
    // Expect edge: <finally-block> -[WRITES_TO]-> <resource.acquired>
    // Expect edge: <resource.acquired> -[ASSIGNED_FROM]-> <false>
    void code;
  });

  test('cjs-patterns::require-path', () => {
    const code = "const path = require('path');";
    // Expect edge: <path> -[ASSIGNED_FROM]-> <require('path')>
    void code;
  });

  test('cjs-patterns::cjs-exports-named-1', () => {
    const code = "exports.CjsClass = CjsClass;";
    // Expect edge: <exports.CjsClass> -[WRITES_TO]-> <exports.CjsClass:access>
    // Expect edge: <exports.CjsClass:access> -[ASSIGNED_FROM]-> <CjsClass>
    // Expect edge: <exports.CjsClass> -[EXPORTS]-> <CjsClass>
    void code;
  });

  test('cjs-patterns::cjs-exports-named-2', () => {
    const code = "exports.CJS_CONSTANT = CJS_CONSTANT;";
    // Expect edge: <exports.CJS_CONSTANT> -[ASSIGNED_FROM]-> <CJS_CONSTANT>
    // Expect edge: <module> -[EXPORTS]-> <CJS_CONSTANT>
    void code;
  });

  test('cjs-patterns::cjs-exports-named', () => {
    const code = "exports.cjsFunction = cjsFunction;";
    // Expect edge: <exports.cjsFunction> -[WRITES_TO]-> <exports.cjsFunction:access>
    // Expect edge: <exports.cjsFunction:access> -[ASSIGNED_FROM]-> <cjsFunction>
    // Expect edge: <exports.cjsFunction> -[EXPORTS]-> <cjsFunction>
    void code;
  });

  test('callbacks::callback-promisify', () => {
    const code = "function promisify(fn) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args, function (err, result) {\n        if (err) reject(err);\n        else resolve(result);\n      });\n    });\n  };\n}";
    // Expect edge: <if-err> -[HAS_ALTERNATE]-> <resolve(result)>
    void code;
  });

  test('cjs-patterns::require-conditional', () => {
    const code = "let optionalDep;\ntry {\n  optionalDep = require('optional-package');\n} catch (e) {\n  optionalDep = null;\n}";
    // Expect edge: <optionalDep> -[ASSIGNED_FROM]-> <require('optional-package')>
    // Expect edge: <optionalDep> -[ASSIGNED_FROM]-> <null>
    void code;
  });

  test('callbacks::export-named-list', () => {
    const code = "export {\n  readFileCallback,\n  processFile,\n  callbackHell,\n  getUser,\n  getOrders,\n  getOrderDetails,\n  retry,\n  waterfall,\n  EventEmitter,\n  delayedExecution,\n  pollUntil,\n  withMicrotask,\n  promisify,\n  readFileAsync,\n  arrayCallbackPatterns,\n  Processor,\n  Validator,\n  forEachWithContext,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <readFileCallback>
    // Expect edge: <export-named-list> -[EXPORTS]-> <processFile>
    // Expect edge: <export-named-list> -[EXPORTS]-> <callbackHell>
    // Expect edge: <export-named-list> -[EXPORTS]-> <getUser>
    // Expect edge: <export-named-list> -[EXPORTS]-> <getOrders>
    // Expect edge: <export-named-list> -[EXPORTS]-> <getOrderDetails>
    // Expect edge: <export-named-list> -[EXPORTS]-> <retry>
    // Expect edge: <export-named-list> -[EXPORTS]-> <waterfall>
    // Expect edge: <export-named-list> -[EXPORTS]-> <EventEmitter>
    // Expect edge: <export-named-list> -[EXPORTS]-> <delayedExecution>
    // Expect edge: <export-named-list> -[EXPORTS]-> <pollUntil>
    // Expect edge: <export-named-list> -[EXPORTS]-> <withMicrotask>
    // Expect edge: <export-named-list> -[EXPORTS]-> <promisify>
    // Expect edge: <export-named-list> -[EXPORTS]-> <readFileAsync>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrayCallbackPatterns>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Processor>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Validator>
    // Expect edge: <export-named-list> -[EXPORTS]-> <forEachWithContext>
    void code;
  });

  test('cjs-patterns::cjs-dynamic-require', () => {
    const code = "function loadImplementation(useNative) {\n  const impl = useNative ? require('path') : require('fs');\n  return impl;\n}";
    // Expect edge: <impl> -[ASSIGNED_FROM]-> <ternary>
    // Expect edge: <ternary> -[HAS_ALTERNATE]-> <require('fs')>
    void code;
  });

  test('cjs-patterns::with-statement', () => {
    const code = "function withStatement(obj) {\n  with (obj) {\n    return toString();\n  }\n}\n\nexports.withStatement = withStatement;";
    // Expect edge: <exports.withStatement> -[ASSIGNED_FROM]-> <withStatement>
    // Expect edge: <MODULE> -[EXPORTS]-> <exports.withStatement>
    void code;
  });

  test('classes::class-basic', () => {
    const code = "class Animal {\n  constructor(name, sound) {\n    this.name = name;\n    this.sound = sound;\n  }\n\n  speak() {\n    return `${this.name} says ${this.sound}`;\n  }\n\n  toString() {\n    return `Animal(${this.name})`;\n  }\n}";
    // Expect edge: <Animal.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <Animal.sound> -[ASSIGNED_FROM]-> <sound>
    void code;
  });

  test('cjs-patterns::cjs-conditional-exports', () => {
    const code = "if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n  exports._testHelper = function () { return 'test-only'; };\n  exports._internal = cjsFunction;\n}";
    // Expect edge: <exports._testHelper> -[ASSIGNED_FROM]-> <testHelper:fn>
    // Expect edge: <exports._internal> -[ASSIGNED_FROM]-> <cjsFunction>
    void code;
  });

  test('classes::class-expr-anonymous', () => {
    const code = "const AnonymousClassExpr = class {\n  run() {\n    return 'running';\n  }\n};";
    // Expect edge: <AnonymousClassExpr> -[ASSIGNED_FROM]-> <AnonymousClassExpr:class>
    void code;
  });

  test('classes::class-static-members', () => {
    const code = "class MathUtils {\n  static PI = 3.14159;\n\n  static add(a, b) {\n    return a + b;\n  }\n\n  static #internalHelper() {\n    return 42;\n  }\n\n  static create() {\n    return new MathUtils();\n  }\n}";
    // Expect edge: <MathUtils.PI> -[ASSIGNED_FROM]-> <3.14159>
    void code;
  });

  test('classes::class-expr-named', () => {
    const code = "const NamedClassExpr = class InternalName {\n  constructor(value) {\n    this.value = value;\n  }\n\n  getValue() {\n    return this.value;\n  }\n};";
    // Expect edge: <NamedClassExpr> -[ASSIGNED_FROM]-> <InternalName>
    // Expect edge: <this.value> -[ASSIGNED_FROM]-> <value>
    // Expect edge: <InternalName.constructor> -[WRITES_TO]-> <this.value>
    void code;
  });

  test('cjs-patterns::with-property-fallback', () => {
    const code = "const fallbackColor = 'red';\nfunction withPropertyFallback(config) {\n  with (config) {\n    return fallbackColor; // config.fallbackColor ?? outer fallbackColor — ambiguous\n  }\n}\n\nexports.loadImplementation = loadImplementation;\nexports.annexBDemo = annexBDemo;\nexports.withNested = withNested;\nexports.withPropertyFallback = withPropertyFallback;";
    // Expect edge: <fallbackColor> -[ASSIGNED_FROM]-> <'red'>
    // Expect edge: <exports.loadImplementation> -[EXPORTS]-> <loadImplementation>
    // Expect edge: <exports.annexBDemo> -[EXPORTS]-> <annexBDemo>
    // Expect edge: <exports.withNested> -[EXPORTS]-> <withNested>
    // Expect edge: <exports.withPropertyFallback> -[EXPORTS]-> <withPropertyFallback>
    void code;
  });

  test('classes::class-inline-new', () => {
    const code = "const inlineInstance = new (class {\n  constructor() { this.x = 1; }\n  getX() { return this.x; }\n})();";
    // Expect edge: <inlineInstance> -[ASSIGNED_FROM]-> <new-anonymous-class>
    // Expect edge: <anonymous-class.constructor> -[WRITES_TO]-> <this.x>
    // Expect edge: <this.x> -[ASSIGNED_FROM]-> <1>
    void code;
  });

  test('classes::class-extends-super', () => {
    const code = "class Dog extends Animal {\n  constructor(name) {\n    super(name, 'woof');\n    this.tricks = [];\n  }\n\n  learn(trick) {\n    this.tricks.push(trick);\n  }\n\n  speak() {\n    return `${super.speak()}!`;\n  }\n}";
    // Expect edge: <this.tricks> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('classes::class-static-block', () => {
    const code = "class Config {\n  static defaults;\n\n  static {\n    Config.defaults = {\n      timeout: 5000,\n      retries: 3,\n    };\n  }\n\n  constructor(overrides = {}) {\n    this.settings = { ...Config.defaults, ...overrides };\n  }\n}";
    // Expect edge: <Config:static-block> -[WRITES_TO]-> <Config.defaults>
    // Expect edge: <Config.defaults> -[ASSIGNED_FROM]-> <{timeout: 5000, retries: 3}>
    // Expect edge: <Config.constructor> -[WRITES_TO]-> <this.settings>
    // Expect edge: <this.settings> -[ASSIGNED_FROM]-> <{...Config.defaults, ...overrides}>
    void code;
  });

  test('classes::class-computed-methods', () => {
    const code = "const METHOD_KEY = 'dynamicMethod';\n\nclass WithComputedMethods {\n  [METHOD_KEY]() {\n    return 'dynamic';\n  }\n\n  [Symbol.toPrimitive](hint) {\n    return hint === 'number' ? 42 : 'string';\n  }\n}";
    // Expect edge: <METHOD_KEY> -[ASSIGNED_FROM]-> <'dynamicMethod'>
    // Expect edge: <ternary> -[HAS_ALTERNATE]-> <'string'>
    void code;
  });

  test('classes::class-getters-setters', () => {
    const code = "class Temperature {\n  #celsius;\n\n  constructor(celsius) {\n    this.#celsius = celsius;\n  }\n\n  get fahrenheit() {\n    return this.#celsius * 9 / 5 + 32;\n  }\n\n  set fahrenheit(f) {\n    this.#celsius = (f - 32) * 5 / 9;\n  }\n\n  get celsius() {\n    return this.#celsius;\n  }\n\n  set celsius(c) {\n    this.#celsius = c;\n  }\n}";
    // Expect edge: <this.#celsius> -[ASSIGNED_FROM]-> <celsius>
    // Expect edge: <Temperature.constructor> -[WRITES_TO]-> <this.#celsius>
    // Expect edge: <Temperature.fahrenheit:setter> -[WRITES_TO]-> <this.#celsius>
    // Expect edge: <this.#celsius> -[ASSIGNED_FROM]-> <(f - 32) * 5 / 9>
    // Expect edge: <Temperature.celsius:setter> -[WRITES_TO]-> <this.#celsius>
    // Expect edge: <this.#celsius> -[ASSIGNED_FROM]-> <c>
    void code;
  });

  test('classes::in-brand-check', () => {
    const code = "class Branded {\n  #secret = true;\n  static isBranded(obj) {\n    return #secret in obj;\n  }\n}";
    // Expect edge: <#secret> -[ASSIGNED_FROM]-> <true>
    void code;
  });

  test('classes::new-arrow-throws', () => {
    const code = "const ArrowNotConstructable = () => {};\nconst methodShorthandObj = { method() {} };\n// new ArrowNotConstructable(); // TypeError: not a constructor\n// new methodShorthandObj.method(); // TypeError: not a constructor";
    // Expect edge: <ArrowNotConstructable> -[ASSIGNED_FROM]-> <ArrowNotConstructable:fn>
    // Expect edge: <methodShorthandObj> -[ASSIGNED_FROM]-> <methodShorthandObj:obj>
    void code;
  });

  test('classes::mixin-composition', () => {
    const code = "class User extends Serializable(Validatable(class {\n  constructor(name) { this.name = name; }\n})) {\n  greet() { return `Hi, ${this.name}`; }\n}";
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    void code;
  });

  test('classes::mixin-class-expression', () => {
    const code = "const Serializable = (SuperClass) => class extends SuperClass {\n  serialize() { return JSON.stringify(this); }\n};\n\nconst Validatable = (SuperClass) => class extends SuperClass {\n  validate() { return true; }\n};";
    // Expect edge: <Serializable> -[ASSIGNED_FROM]-> <Serializable:fn>
    // Expect edge: <Validatable> -[ASSIGNED_FROM]-> <Validatable:fn>
    void code;
  });

  test('classes::class-inline-extends', () => {
    const code = "const inlineChild = new (class extends Error {\n  constructor(msg) { super(msg); this.custom = true; }\n})('inline error');";
    // Expect edge: <inlineChild> -[ASSIGNED_FROM]-> <new (class extends Error {...})('inline error')>
    // Expect edge: <anonymous-class.constructor> -[WRITES_TO]-> <this.custom>
    // Expect edge: <this.custom> -[ASSIGNED_FROM]-> <true>
    void code;
  });

  test('classes::class-constructor-return-non-this', () => {
    const code = "class Singleton {\n  static instance;\n  constructor() {\n    if (Singleton.instance) return Singleton.instance;\n    Singleton.instance = this;\n  }\n}";
    // Expect edge: <Singleton.instance-write> -[ASSIGNED_FROM]-> <this>
    // Expect edge: <Singleton.constructor> -[WRITES_TO]-> <Singleton.instance-write>
    // Expect edge: <Singleton.instance-write> -[WRITES_TO]-> <Singleton.instance>
    void code;
  });

  test('classes::class-generator-method', () => {
    const code = "class Stream {\n  data = [];\n  *items() { for (const item of this.data) yield item; }\n  async *pages() { yield* this.data; }\n}";
    // Expect edge: <Stream.data> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('classes::class-static-getter-setter', () => {
    const code = "class Registry {\n  static #store = new Map();\n  static get size() { return this.#store.size; }\n  static set defaultValue(value) { this.#store.set('default', value); }\n}";
    // Expect edge: <Registry.#store> -[ASSIGNED_FROM]-> <new Map()>
    void code;
  });

  test('async-generators::async-iterator-cancel-break', () => {
    const code = "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}";
    // Expect edge: <reader> -[ASSIGNED_FROM]-> <{ locked: true }>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <reader.locked> -[ASSIGNED_FROM]-> <false>
    void code;
  });

  test('classes::method-chaining-usage', () => {
    const code = "const chainedQuery = new QueryBuilder()\n  .from('users')\n  .where('age > 18')\n  .orderBy('name')\n  .limit(10)\n  .build();";
    // Expect edge: <chainedQuery> -[ASSIGNED_FROM]-> <.build()>
    void code;
  });

  test('async-generators::async-iterator-cancel-manual', () => {
    const code = "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}";
    // Expect edge: <iter> -[ASSIGNED_FROM]-> <asyncGen[Symbol.asyncIterator]()>
    // Expect edge: <first> -[ASSIGNED_FROM]-> <iter.next()>
    void code;
  });

  test('classes::destructure-assign-to-this', () => {
    const code = "class ComponentState {\n  width = 0;\n  height = 0;\n\n  update(props) {\n    ({ width: this.width, height: this.height } = props);\n  }\n}";
    // Expect edge: <ComponentState.width> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <ComponentState.height> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <destructure-props> -[WRITES_TO]-> <this.width>
    // Expect edge: <destructure-props> -[WRITES_TO]-> <this.height>
    // Expect edge: <this.width> -[MODIFIES]-> <ComponentState.width>
    // Expect edge: <this.height> -[MODIFIES]-> <ComponentState.height>
    void code;
  });

  test('classes::class-private-cross-instance', () => {
    const code = "class Vec {\n  #x; #y;\n  constructor(x, y) { this.#x = x; this.#y = y; }\n  equals(other) {\n    return this.#x === other.#x && this.#y === other.#y;\n  }\n}";
    // Expect edge: <Vec.constructor> -[WRITES_TO]-> <this.#x>
    // Expect edge: <Vec.constructor> -[WRITES_TO]-> <this.#y>
    // Expect edge: <this.#x> -[ASSIGNED_FROM]-> <x>
    // Expect edge: <this.#y> -[ASSIGNED_FROM]-> <y>
    void code;
  });

  test('async-generators::yield-star-return-value', () => {
    const code = "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <yield* innerWithReturn()>
    void code;
  });

  test('classes::destructure-assign-to-this-defaults', () => {
    const code = "class ConfigFromOpts {\n  host = '';\n  port = 3000;\n\n  constructor(opts) {\n    ({ host: this.host, port: this.port = 3000 } = opts);\n  }\n}";
    // Expect edge: <ConfigFromOpts.host> -[ASSIGNED_FROM]-> <''>
    // Expect edge: <ConfigFromOpts.port> -[ASSIGNED_FROM]-> <3000>
    // Expect edge: <destructure-opts> -[WRITES_TO]-> <this.host>
    // Expect edge: <destructure-opts> -[WRITES_TO]-> <this.port>
    void code;
  });

  test('classes::default-param-this-access', () => {
    const code = "class ServiceWithDefaults {\n  defaultTimeout = 5000;\n  baseUrl = '/api';\n\n  fetch(url, timeout = this.defaultTimeout) {\n    return { url: this.baseUrl + url, timeout };\n  }\n}";
    // Expect edge: <ServiceWithDefaults.defaultTimeout> -[ASSIGNED_FROM]-> <5000>
    // Expect edge: <ServiceWithDefaults.baseUrl> -[ASSIGNED_FROM]-> <'/api'>
    void code;
  });

  test('classes::super-in-arrow-callback', () => {
    const code = "class ParentProcessor {\n  transform(item) { return { ...item, processed: true }; }\n  cleanup() { return 'cleaned'; }\n}\n\nclass ChildProcessor extends ParentProcessor {\n  processAll(items) {\n    return items.map(item => {\n      return super.transform(item);     // super captured via arrow\n    });\n  }\n\n  delayed() {\n    setTimeout(() => {\n      super.cleanup();                   // super in async callback arrow\n    }, 100);\n  }\n}";
    // Expect edge: <arrow-fn-1> -[CAPTURES]-> <ChildProcessor>
    // Expect edge: <arrow-fn-2> -[CAPTURES]-> <ChildProcessor>
    void code;
  });

  test('classes::computed-class-member-side-effect', () => {
    const code = "let classFieldId = 0;\nclass AutoIdFields {\n  [`field_${classFieldId++}`] = 'first';\n  [`field_${classFieldId++}`] = 'second';\n  [`method_${classFieldId++}`]() { return 'dynamic'; }\n}";
    // Expect edge: <classFieldId> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <AutoIdFields[computed1]> -[ASSIGNED_FROM]-> <'first'>
    // Expect edge: <`field_${classFieldId++}`_1> -[MODIFIES]-> <classFieldId>
    // Expect edge: <AutoIdFields[computed2]> -[ASSIGNED_FROM]-> <'second'>
    // Expect edge: <`field_${classFieldId++}`_2> -[MODIFIES]-> <classFieldId>
    // Expect edge: <`method_${classFieldId++}`> -[MODIFIES]-> <classFieldId>
    void code;
  });

  test('classes::class-in-array', () => {
    const code = "const classHandlers = [\n  class GetHandler { handle() { return 'get'; } },\n  class PostHandler { handle() { return 'post'; } },\n];";
    // Expect edge: <classHandlers> -[ASSIGNED_FROM]-> <classHandlers-array>
    void code;
  });

  test('closures::closure-module-var-read', () => {
    const code = "let requestCount = 0;\n\nfunction getRequestCount() {\n  return requestCount;\n}";
    // Expect edge: <requestCount> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <getRequestCount> -[CAPTURES]-> <requestCount>
    void code;
  });

  test('classes::super-in-field-initializer', () => {
    const code = "class FieldParent {\n  getDefaults() { return { timeout: 5000 }; }\n}\n\nclass FieldChild extends FieldParent {\n  defaults = super.getDefaults(); // super in instance field initializer\n}\n\n// --- Interleaved static blocks and static fields ---";
    // Expect edge: <FieldChild.defaults> -[ASSIGNED_FROM]-> <super.getDefaults()>
    void code;
  });

  test('closures::closure-module-var-write', () => {
    const code = "function incrementRequestCount() {\n  requestCount++;\n}";
    // Expect edge: <requestCount++> -[WRITES_TO]-> <requestCount>
    void code;
  });

  test('classes::class-in-ternary', () => {
    const code = "const StrategyClass = Math.random() > 0.5\n  ? class Aggressive { execute() { return 'fast'; } }\n  : class Conservative { execute() { return 'slow'; } };";
    // Expect edge: <StrategyClass> -[ASSIGNED_FROM]-> <ternary>
    // Expect edge: <ternary> -[HAS_ALTERNATE]-> <Conservative>
    void code;
  });

  test('closures::closure-factory-multiplier', () => {
    const code = "function createMultiplier(factor) {\n  return (x) => x * factor;\n}";
    // Expect edge: <createMultiplier:returnFn> -[CAPTURES]-> <factor>
    void code;
  });

  test('classes::super-in-static-method', () => {
    const code = "class StaticParent {\n  static defaultConfig() { return { timeout: 5000 }; }\n  static instances = [];\n}\n\nclass StaticChild extends StaticParent {\n  static defaultConfig() {\n    const base = super.defaultConfig(); // super = StaticParent (constructor, not prototype)\n    return { ...base, retries: 3 };\n  }\n\n  static allInstances = [...super.instances]; // super in static field initializer\n}\n\n// --- super in field initializers ---";
    // Expect edge: <StaticParent.instances> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <base> -[ASSIGNED_FROM]-> <super.defaultConfig()>
    // Expect edge: <StaticChild.allInstances> -[ASSIGNED_FROM]-> <[...super.instances]>
    void code;
  });

  test('async-generators::for-await-sync-iterable', () => {
    const code = "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array — each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('closures::closure-factory-counter', () => {
    const code = "function createCounter(initial = 0) {\n  let count = initial;\n  return {\n    increment() { return ++count; },\n    decrement() { return --count; },\n    value() { return count; },\n  };\n}";
    // Expect edge: <count> -[ASSIGNED_FROM]-> <initial>
    // Expect edge: <++count> -[MODIFIES]-> <count>
    // Expect edge: <--count> -[MODIFIES]-> <count>
    // Expect edge: <increment> -[CAPTURES]-> <count>
    // Expect edge: <decrement> -[CAPTURES]-> <count>
    // Expect edge: <value> -[CAPTURES]-> <count>
    void code;
  });

  test('classes::private-field-proxy-trap', () => {
    const code = "class SecureService {\n  #secret = 42;\n  getSecret() { return this.#secret; }\n}\n\nfunction proxyPrivateDemo() {\n  const instance = new SecureService();\n  const proxy = new Proxy(instance, {});\n  // proxy.getSecret() → TypeError: #secret not accessible through Proxy\n  return { instance, proxy };\n}\n\n// --- Class expressions in various positions ---";
    // Expect edge: <#secret> -[ASSIGNED_FROM]-> <42>
    // Expect edge: <instance> -[ASSIGNED_FROM]-> <new SecureService()>
    // Expect edge: <proxy> -[ASSIGNED_FROM]-> <new Proxy(instance, {})>
    void code;
  });

  test('closures::closure-shared-state', () => {
    const code = "let sharedCache = {};\n\nfunction setCache(key, value) {\n  sharedCache[key] = value;\n}\n\nfunction getCache(key) {\n  return sharedCache[key];\n}\n\nfunction clearCache() {\n  sharedCache = {};\n}\n\n// --- Factory functions returning closures ---";
    // Expect edge: <sharedCache> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <setCache> -[CAPTURES]-> <sharedCache>
    // Expect edge: <sharedCache[key]> -[ASSIGNED_FROM]-> <value>
    // Expect edge: <setCache> -[WRITES_TO]-> <sharedCache[key]>
    // Expect edge: <getCache> -[CAPTURES]-> <sharedCache>
    // Expect edge: <clearCache> -[CAPTURES]-> <sharedCache>
    // Expect edge: <sharedCache> -[ASSIGNED_FROM]-> <{}2>
    // Expect edge: <clearCache> -[WRITES_TO]-> <sharedCache>
    void code;
  });

  test('closures::closure-factory-accumulator', () => {
    const code = "function createAccumulator() {\n  const items = [];\n  return {\n    add(item) { items.push(item); },\n    getAll() { return [...items]; },\n    count() { return items.length; },\n  };\n}\n\n// --- Closure over loop variable ---";
    // Expect edge: <items> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <add> -[CAPTURES]-> <items>
    // Expect edge: <getAll> -[CAPTURES]-> <items>
    // Expect edge: <count> -[CAPTURES]-> <items>
    void code;
  });

  test('closures::closure-nested-deep', () => {
    const code = "function outermost(a) {\n  return function middle(b) {\n    return function innermost(c) {\n      return a + b + c;\n    };\n  };\n}";
    // Expect edge: <middle> -[CAPTURES]-> <a>
    // Expect edge: <innermost> -[CAPTURES]-> <a>
    // Expect edge: <innermost> -[CAPTURES]-> <b>
    void code;
  });

  test('classes::new-target-arrow-capture', () => {
    const code = "class AbstractFactory {\n  constructor() {\n    // new.target captured by arrow — like this/super, lexically bound\n    const getTarget = () => new.target;\n\n    if (getTarget() === AbstractFactory) {\n      throw new Error('AbstractFactory is abstract — use a subclass');\n    }\n\n    // Store for lazy cloning — arrow captures new.target from constructor\n    this._clone = () => new (new.target)();\n  }\n}\n\nclass ConcreteFactory extends AbstractFactory {\n  constructor() {\n    super(); // new.target === ConcreteFactory inside AbstractFactory\n  }\n}";
    // Expect edge: <getTarget> -[ASSIGNED_FROM]-> <getTarget:fn>
    // Expect edge: <getTarget:fn> -[CAPTURES]-> <new.target>
    // Expect edge: <AbstractFactory.constructor> -[WRITES_TO]-> <this._clone>
    // Expect edge: <this._clone> -[ASSIGNED_FROM]-> <_clone:fn>
    // Expect edge: <_clone:fn> -[CAPTURES]-> <new.target>
    void code;
  });

  test('closures::closure-loop-let-fix', () => {
    const code = "function closureLoopLetFix() {\n  const funcs = [];\n  for (let i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // each returns 0,1,2,3,4\n}";
    // Expect edge: <funcs> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <anonymous-closure> -[CAPTURES]-> <i>
    void code;
  });

  test('closures::this-module-level', () => {
    const code = "// In ESM: `this` is `undefined` at top level\nconst thisAtModuleLevel = this; // undefined in ESM, module.exports in CJS\n\n// --- Named function expression as argument (self-referencing) ---";
    // Expect edge: <thisAtModuleLevel> -[ASSIGNED_FROM]-> <this>
    void code;
  });

  test('closures::this-method-context', () => {
    const code = "const obj = {\n  name: 'context',\n  getName() {\n    return this.name;\n  },\n  getNameArrow: () => {\n    return this.name; // `this` is module/global, not obj\n  },\n};";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <obj-literal>
    void code;
  });

  test('closures::closure-loop-var-bug', () => {
    const code = "function closureLoopVarBug() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // all return 5\n}";
    // Expect edge: <funcs> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <anonymous-closure> -[CAPTURES]-> <i>
    void code;
  });

  test('closures::closure-loop-iife-fix', () => {
    const code = "function closureLoopIifeFix() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push((function (captured) {\n      return function () { return captured; };\n    })(i));\n  }\n  return funcs;\n}\n\n// --- Nested closures (3+ levels) ---";
    // Expect edge: <funcs> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <captured> -[CAPTURES]-> <i>
    // Expect edge: <inner-closure> -[CAPTURES]-> <captured>
    void code;
  });

  test('closures::closure-module-pattern', () => {
    const code = "const counterModule = (function () {\n  let count = 0;\n  return {\n    increment() { count++; },\n    decrement() { count--; },\n    getCount() { return count; },\n  };\n})();\n\n// --- Memoization via closure ---";
    // Expect edge: <counterModule> -[ASSIGNED_FROM]-> <counterModule:iife-call>
    // Expect edge: <count> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <count++> -[MODIFIES]-> <count>
    // Expect edge: <count--> -[MODIFIES]-> <count>
    // Expect edge: <increment> -[CAPTURES]-> <count>
    // Expect edge: <decrement> -[CAPTURES]-> <count>
    // Expect edge: <getCount> -[CAPTURES]-> <count>
    void code;
  });

  test('closures::this-bind', () => {
    const code = "function thisBind() {\n  function greet(greeting) {\n    return `${greeting}, ${this.name}`;\n  }\n  const user = { name: 'Alice' };\n  const bound = greet.bind(user);\n  return bound('Hello');\n}";
    // Expect edge: <user> -[ASSIGNED_FROM]-> <{ name: 'Alice' }>
    // Expect edge: <bound> -[ASSIGNED_FROM]-> <greet.bind(user)>
    void code;
  });

  test('closures::this-in-class-callback', () => {
    const code = "class EventHandler {\n  constructor(name) {\n    this.name = name;\n    this.handleBound = this.handle.bind(this);\n  }\n\n  handle(event) {\n    return `${this.name}: ${event}`;\n  }\n\n  handleArrow = (event) => {\n    return `${this.name}: ${event}`;\n  };\n}\n\n// --- Closure as private scope ---";
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <this.handleBound> -[ASSIGNED_FROM]-> <this.handle.bind(this)>
    // Expect edge: <EventHandler.handleArrow> -[CAPTURES]-> <this>
    void code;
  });

  test('closures::named-func-expr-as-argument', () => {
    const code = "let retryDone = false;\nsetTimeout(function retry() {\n  if (!retryDone) setTimeout(retry, 1000); // self-reference for recursive scheduling\n}, 1000);";
    // Expect edge: <retryDone> -[ASSIGNED_FROM]-> <false>
    // Expect edge: <retry> -[CAPTURES]-> <retryDone>
    void code;
  });

  test('closures::closure-nested-mutation', () => {
    const code = "function createTracker() {\n  let total = 0;\n  function addGroup(groupName) {\n    let groupTotal = 0;\n    return function addItem(value) {\n      groupTotal += value;\n      total += value;\n      return { groupName, groupTotal, total };\n    };\n  }\n  return { addGroup, getTotal: () => total };\n}\n\n// --- this binding ---";
    // Expect edge: <total> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <groupTotal> -[ASSIGNED_FROM]-> <0-inner>
    // Expect edge: <groupTotal += value> -[WRITES_TO]-> <groupTotal>
    // Expect edge: <total += value> -[WRITES_TO]-> <total>
    // Expect edge: <addItem> -[CAPTURES]-> <total>
    // Expect edge: <addItem> -[CAPTURES]-> <groupTotal>
    // Expect edge: <addItem> -[CAPTURES]-> <groupName>
    // Expect edge: <getTotal> -[CAPTURES]-> <total>
    void code;
  });

  test('closures::this-call-apply', () => {
    const code = "function thisCallApply() {\n  function introduce(role) {\n    return `${this.name} is ${role}`;\n  }\n  const person = { name: 'Bob' };\n  const viaCall = introduce.call(person, 'admin');\n  const viaApply = introduce.apply(person, ['admin']);\n  return { viaCall, viaApply };\n}";
    // Expect edge: <person> -[ASSIGNED_FROM]-> <object-literal>
    // Expect edge: <viaCall> -[ASSIGNED_FROM]-> <introduce.call>
    // Expect edge: <viaApply> -[ASSIGNED_FROM]-> <introduce.apply>
    void code;
  });

  test('closures::closure-once', () => {
    const code = "function once(fn) {\n  let called = false;\n  let result;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  };\n}";
    // Expect edge: <called> -[ASSIGNED_FROM]-> <false>
    // Expect edge: <called = true> -[WRITES_TO]-> <called>
    // Expect edge: <result = fn.apply(this, args)> -[WRITES_TO]-> <result>
    // Expect edge: <once:inner> -[CAPTURES]-> <called>
    // Expect edge: <once:inner> -[CAPTURES]-> <result>
    // Expect edge: <once:inner> -[CAPTURES]-> <fn>
    void code;
  });

  test('coercion-hoisting::hoist-function-decl', () => {
    const code = "function functionHoisting() {\n  const result = hoisted(); // works — function declarations are fully hoisted\n  function hoisted() { return 'hoisted'; }\n  return result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <hoisted()>
    void code;
  });

  test('closures::closure-memoize', () => {
    const code = "function memoize(fn) {\n  const cache = new Map();\n  return function (...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// --- Once (call-at-most-once) ---";
    // Expect edge: <cache> -[ASSIGNED_FROM]-> <new Map()>
    // Expect edge: <key> -[ASSIGNED_FROM]-> <JSON.stringify(args)>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <fn.apply(this, args)>
    // Expect edge: <memoize:returnFn> -[CAPTURES]-> <cache>
    // Expect edge: <memoize:returnFn> -[CAPTURES]-> <fn>
    void code;
  });

  test('closures::this-lost-in-callback', () => {
    const code = "function thisLostInCallback() {\n  const timer = {\n    seconds: 0,\n    start() {\n      // `this` lost: regular function callback\n      setTimeout(function () {\n        this.seconds++; // `this` is undefined/global\n      }, 1000);\n    },\n    startFixed() {\n      // `this` preserved: arrow function callback\n      setTimeout(() => {\n        this.seconds++;\n      }, 1000);\n    },\n  };\n  return timer;\n}";
    // Expect edge: <timer> -[ASSIGNED_FROM]-> <timer-object>
    // Expect edge: <timer.seconds> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <this.seconds++-regular> -[WRITES_TO]-> <this.seconds-regular>
    // Expect edge: <this.seconds++-arrow> -[WRITES_TO]-> <this.seconds-arrow>
    // Expect edge: <setTimeout-callback-arrow> -[CAPTURES]-> <timer-object>
    void code;
  });

  test('coercion-hoisting::hoist-var', () => {
    const code = "function varHoisting() {\n  console.log(x); // undefined — hoisted, not initialized\n  var x = 10;\n  console.log(x); // 10\n  return x;\n}";
    // Expect edge: <x> -[ASSIGNED_FROM]-> <10>
    void code;
  });

  test('async-generators::yield-yield-chained', () => {
    const code = "function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <yield yield 1>
    void code;
  });

  test('coercion-hoisting::hoist-function-expr-not', () => {
    const code = "function functionExprNotHoisted() {\n  try {\n    notHoisted(); // TypeError: notHoisted is not a function\n  } catch (e) {\n    // var notHoisted is hoisted as undefined, but assignment is not\n  }\n  var notHoisted = function () { return 'not hoisted'; };\n  return notHoisted();\n}\n\n// --- Temporal Dead Zone (TDZ) ---";
    // Expect edge: <notHoisted> -[ASSIGNED_FROM]-> <notHoisted:fn>
    void code;
  });

  test('coercion-hoisting::tdz-let', () => {
    const code = "function tdzLet() {\n  try {\n    console.log(x); // ReferenceError — TDZ\n  } catch (e) {\n    // let x exists but cannot be accessed before declaration\n  }\n  let x = 10;\n  return x;\n}";
    // Expect edge: <x> -[ASSIGNED_FROM]-> <10>
    // Expect edge: <console.log(x)> -[THROWS]-> <catch-block>
    void code;
  });

  test('coercion-hoisting::coerce-symbol-toprimitive', () => {
    const code = "const toPrimitive = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return 10;\n    if (hint === 'string') return 'ten';\n    return true;\n  },\n};\n\n// --- Hoisting ---";
    // Expect edge: <toPrimitive> -[ASSIGNED_FROM]-> <object-literal>
    void code;
  });

  test('coercion-hoisting::tdz-const', () => {
    const code = "function tdzConst() {\n  try {\n    console.log(C); // ReferenceError — TDZ\n  } catch (e) {\n    // const C in TDZ\n  }\n  const C = 42;\n  return C;\n}";
    // Expect edge: <C> -[ASSIGNED_FROM]-> <42>
    void code;
  });

  test('coercion-hoisting::coerce-valueof-tostring', () => {
    const code = "const customCoerce = {\n  valueOf() { return 42; },\n  toString() { return 'custom'; },\n};\n\nconst usedInMath = customCoerce + 1;        // 43 (valueOf)\nconst usedInTemplate = `${customCoerce}`;   // 'custom' (toString)";
    // Expect edge: <customCoerce> -[ASSIGNED_FROM]-> <customCoerce:obj>
    // Expect edge: <usedInMath> -[ASSIGNED_FROM]-> <customCoerce + 1>
    // Expect edge: <usedInTemplate> -[ASSIGNED_FROM]-> <`${customCoerce}`>
    void code;
  });

  test('coercion-hoisting::shadow-param-scope', () => {
    const code = "function paramShadowing(x) {\n  const x2 = x;\n  if (true) {\n    const x = 'shadowed'; // shadows parameter\n    console.log(x); // 'shadowed'\n  }\n  return x; // original param\n}";
    // Expect edge: <x2> -[ASSIGNED_FROM]-> <x:param>
    // Expect edge: <x:shadowed> -[ASSIGNED_FROM]-> <'shadowed'>
    void code;
  });

  test('coercion-hoisting::eval-direct', () => {
    const code = "function directEval(code) {\n  return eval(code);\n}";
    // Expect edge: <eval> -[CAPTURES]-> <directEval>
    void code;
  });

  test('coercion-hoisting::eval-indirect', () => {
    const code = "function indirectEval(code) {\n  const evaluate = eval;\n  return evaluate(code);\n}";
    // Expect edge: <evaluate> -[ASSIGNED_FROM]-> <eval>
    void code;
  });

  test('coercion-hoisting::eval-var-injection', () => {
    const code = "function evalVarInjection() {\n  eval('var injected = 42');\n  return injected; // 42 — eval injected into function scope\n}";
    // Expect edge: <eval('var injected = 42')> -[MODIFIES]-> <injected>
    // Expect edge: <injected> -[ASSIGNED_FROM]-> <42>
    void code;
  });

  test('coercion-hoisting::shadow-catch-scope', () => {
    const code = "function catchShadowing() {\n  const error = 'not an error';\n  try {\n    throw new Error('real error');\n  } catch (error) {\n    console.log(error.message); // 'real error' — shadows outer \"error\"\n  }\n  return error; // 'not an error'\n}\n\n// --- eval ---";
    // Expect edge: <error:outer> -[ASSIGNED_FROM]-> <'not an error'>
    // Expect edge: <try-block> -[THROWS]-> <new Error('real error')>
    void code;
  });

  test('coercion-hoisting::contextual-keyword-as-identifier', () => {
    const code = "function contextualKeywords() {\n  var async = 1;       // valid — \"async\" is not a reserved word\n  // var yield = 3;    // SyntaxError in strict/ESM — valid in sloppy scripts\n  // var let = 2;      // SyntaxError in strict — valid with var in sloppy\n  return async;\n}";
    // Expect edge: <async> -[ASSIGNED_FROM]-> <1>
    void code;
  });

  test('coercion-hoisting::eval-new-function', () => {
    const code = "function newFunction(body) {\n  const fn = new Function('a', 'b', body);\n  return fn(1, 2);\n}\n\n// --- Comma operator for side effects ---";
    // Expect edge: <fn> -[ASSIGNED_FROM]-> <new Function('a', 'b', body)>
    void code;
  });

  test('coercion-hoisting::coerce-comma-sequence', () => {
    const code = "function commaSequence() {\n  let x = 0;\n  const result = (x++, x++, x++, x);\n  return result; // 3\n}";
    // Expect edge: <x> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <comma-sequence>
    // Expect edge: <x++[1]> -[WRITES_TO]-> <x>
    // Expect edge: <x++[2]> -[WRITES_TO]-> <x>
    // Expect edge: <x++[3]> -[WRITES_TO]-> <x>
    void code;
  });

  test('coercion-hoisting::shadow-block-scope', () => {
    const code = "const outerConst = 'outer';\n\nfunction shadowingExample() {\n  const outerConst = 'shadowed'; // shadows module-level\n  if (true) {\n    const outerConst = 'inner-shadowed'; // shadows function-level\n    console.log(outerConst); // 'inner-shadowed'\n  }\n  return outerConst; // 'shadowed'\n}";
    // Expect edge: <outerConst:function> -[ASSIGNED_FROM]-> <'shadowed'>
    // Expect edge: <outerConst:block> -[ASSIGNED_FROM]-> <'inner-shadowed'>
    void code;
  });

  test('coercion-hoisting::block-label-ambiguity', () => {
    const code = "function blockLabelAmbiguity() {\n  // { a: 1 } in statement position is a block with labeled expression, NOT an object\n  // Parentheses force expression context:\n  const obj = eval('({ a: 1, b: 2 })'); // object literal\n  // eval('{ a: 1, b: 2 }');            // SyntaxError — block + label + illegal comma\n  return obj;\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <eval('({ a: 1, b: 2 })')>
    void code;
  });

  test('async-generators::async-destructure-await-default', () => {
    const code = "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};";
    // Expect edge: <asyncDestructureHandler> -[ASSIGNED_FROM]-> <asyncDestructureHandler:fn>
    void code;
  });

  test('coercion-hoisting::typeof-tdz-trap', () => {
    const code = "function typeofTdzTrap() {\n  try {\n    const result = typeof x; // ReferenceError — x is in TDZ, unlike undeclared\n  } catch (e) {\n    // typeof on TDZ variable THROWS, unlike typeof on undeclared\n  }\n  let x = 5;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <typeof x>
    // Expect edge: <x> -[ASSIGNED_FROM]-> <5>
    // Expect edge: <typeof x> -[THROWS]-> <catch-block>
    void code;
  });

  test('coercion-hoisting::var-function-collision', () => {
    const code = "function varFunctionCollision() {\n  console.log(typeof collision); // \"function\" — function hoists over var\n  var collision = 1;\n  function collision() { return 2; }\n  console.log(typeof collision); // \"number\" — assignment runs after\n  return collision;\n}";
    // Expect edge: <collision:var> -[ASSIGNED_FROM]-> <1>
    void code;
  });

  test('declarations::var-decl-init', () => {
    const code = "var mutableVar = 'hello';";
    // Expect edge: <mutableVar> -[ASSIGNED_FROM]-> <'hello'>
    void code;
  });

  test('declarations::let-decl-init', () => {
    const code = "let reassignable = 42;";
    // Expect edge: <reassignable> -[ASSIGNED_FROM]-> <42>
    void code;
  });

  test('coercion-hoisting::var-in-catch-clobber', () => {
    const code = "function varInCatchClobber() {\n  try {\n    throw new Error('oops');\n  } catch (e) {\n    var e = 'overwritten';  // var hoists to function scope, shares binding with catch param\n  }\n  return e; // 'overwritten' in sloppy; in strict var still hoists but catch e is separate\n}";
    // Expect edge: <try-block> -[THROWS]-> <new Error('oops')>
    // Expect edge: <e:var> -[ASSIGNED_FROM]-> <'overwritten'>
    void code;
  });

  test('coercion-hoisting::primitive-autoboxing', () => {
    const code = "function primitiveAutoboxing() {\n  const str = 'hello';\n  const upper = str.toUpperCase(); // auto-boxes to String object\n  str.customProp = 1; // sets on TEMPORARY boxed String, immediately GC'd\n  const lost = str.customProp; // undefined\n\n  const num = 42;\n  const fixed = num.toFixed(2); // auto-boxes to Number\n\n  return { upper, lost, fixed };\n}";
    // Expect edge: <str> -[ASSIGNED_FROM]-> <'hello'>
    // Expect edge: <upper> -[ASSIGNED_FROM]-> <str.toUpperCase()>
    // Expect edge: <str.customProp> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <lost> -[ASSIGNED_FROM]-> <str.customProp:read>
    // Expect edge: <num> -[ASSIGNED_FROM]-> <42>
    // Expect edge: <fixed> -[ASSIGNED_FROM]-> <num.toFixed(2)>
    void code;
  });

  test('coercion-hoisting::block-function-declaration-strict', () => {
    const code = "// NOTE: behavior differs between strict (ESM) and sloppy (script) mode.\n// This file is ESM (strict), so the function is block-scoped.\n// In sloppy mode (.cjs / <script>), the function would leak to function scope (Annex B).\nfunction blockFunctionDemo() {\n  let result = 'before';\n\n  if (true) {\n    function blockFn() { return 'inside'; }  // block-scoped in strict/ESM\n    result = blockFn();\n  }\n\n  // blockFn is NOT accessible here in strict mode\n  // In sloppy mode it WOULD be accessible (Annex B hoisting)\n  return result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <'before'>
    // Expect edge: <result = blockFn()> -[WRITES_TO]-> <result>
    // Expect edge: <result = blockFn()> -[ASSIGNED_FROM]-> <blockFn()>
    void code;
  });

  test('coercion-hoisting::var-redeclares-parameter', () => {
    const code = "function varRedeclaresParameter(x, y) {\n  var x = x || 'default'; // same binding as parameter x — NOT a new variable\n  var y;                    // re-declares y but does NOT reset it\n  return { x, y };\n}\n// varRedeclaresParameter(null, 42) → { x: 'default', y: 42 }\n// Contrast: let x = ... inside would be SyntaxError (cannot re-declare param)";
    // Expect edge: <x> -[ASSIGNED_FROM]-> <x || 'default'>
    void code;
  });

  test('declarations::const-decl-bool-literal', () => {
    const code = "const immutable = true;";
    // Expect edge: <immutable> -[ASSIGNED_FROM]-> <true>
    void code;
  });

  test('declarations::const-decl-bigint-literal', () => {
    const code = "const bigNumber = 42n;";
    // Expect edge: <bigNumber> -[ASSIGNED_FROM]-> <42n>
    void code;
  });

  test('declarations::var-decl-multi', () => {
    const code = "var multi1 = 1, multi2 = 2, multi3 = 3;";
    // Expect edge: <multi1> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <multi2> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <multi3> -[ASSIGNED_FROM]-> <3>
    void code;
  });

  test('declarations::const-decl-object-literal', () => {
    const code = "const objectConst = { key: 'value' };";
    // Expect edge: <objectConst> -[ASSIGNED_FROM]-> <objectConst:object>
    // Expect edge: <'key'> -[ASSIGNED_FROM]-> <'value'>
    void code;
  });

  test('declarations::const-decl-call-result-1', () => {
    const code = "const uniqueKey = Symbol('description');";
    // Expect edge: <uniqueKey> -[ASSIGNED_FROM]-> <Symbol('description')>
    void code;
  });

  test('declarations::const-decl-array-literal', () => {
    const code = "const arrayConst = [1, 2, 3];";
    // Expect edge: <arrayConst> -[ASSIGNED_FROM]-> <[1, 2, 3]>
    void code;
  });

  test('coercion-hoisting::eval-let-scope', () => {
    const code = "function evalLetScope() {\n  eval('let y = 2');   // y is block-scoped to the eval itself\n  try {\n    return y;          // ReferenceError — y doesn't exist here\n  } catch (e) {\n    return 'y not accessible';\n  }\n}";
    // Expect edge: <y> -[ASSIGNED_FROM]-> <2>
    void code;
  });

  test('declarations::const-decl-call-result', () => {
    const code = "const bigComputed = BigInt(Number.MAX_SAFE_INTEGER);";
    // Expect edge: <bigComputed> -[ASSIGNED_FROM]-> <BigInt(Number.MAX_SAFE_INTEGER)>
    void code;
  });

  test('declarations::const-decl-method-call-result', () => {
    const code = "const globalSymbol = Symbol.for('shared');";
    // Expect edge: <globalSymbol> -[ASSIGNED_FROM]-> <Symbol.for('shared')>
    void code;
  });

  test('coercion-hoisting::object-as-map-key-tostring', () => {
    const code = "function objectAsMapKey() {\n  const cache = {};\n  const obj = {};\n  cache[obj] = 'value';           // key is \"[object Object]\"\n  cache[{ a: 1 }] = 'another';   // SAME key \"[object Object]\" — overwrites!\n  return cache;\n}";
    // Expect edge: <cache> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <obj-literal>
    // Expect edge: <cache[obj]> -[ASSIGNED_FROM]-> <'value'>
    // Expect edge: <cache[{ a: 1 }]> -[ASSIGNED_FROM]-> <'another'>
    void code;
  });

  test('declarations::const-decl-regex-literal', () => {
    const code = "const regexSimple = /hello/;\nconst regexFlags = /pattern/gi;\nconst regexComplex = /^start.*end$/ms;\n\n// Function Declarations";
    // Expect edge: <regexSimple> -[ASSIGNED_FROM]-> </hello/>
    // Expect edge: <regexFlags> -[ASSIGNED_FROM]-> </pattern/gi>
    // Expect edge: <regexComplex> -[ASSIGNED_FROM]-> </^start.*end$/ms>
    void code;
  });

  test('coercion-hoisting::export-named-list', () => {
    const code = "export {\n  stringCoercion,\n  numberCoercion,\n  booleanCoercion,\n  equalityCoercion,\n  customCoerce,\n  usedInMath,\n  usedInTemplate,\n  toPrimitive,\n  varHoisting,\n  functionHoisting,\n  functionExprNotHoisted,\n  tdzLet,\n  tdzConst,\n  tdzClass,\n  outerConst,\n  shadowingExample,\n  paramShadowing,\n  catchShadowing,\n  directEval,\n  indirectEval,\n  newFunction,\n  commaSequence,\n  evalVarInjection,\n  evalFunctionInjection,\n  primitiveAutoboxing,\n  varFunctionCollision,\n  contextualKeywords,\n  objectAsMapKey,\n  blockFunctionDemo,\n  varInCatchClobber,\n  typeofTdzTrap,\n  evalLetScope,\n  blockLabelAmbiguity,\n  varRedeclaresParameter,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <stringCoercion>
    // Expect edge: <export-named-list> -[EXPORTS]-> <numberCoercion>
    // Expect edge: <export-named-list> -[EXPORTS]-> <booleanCoercion>
    // Expect edge: <export-named-list> -[EXPORTS]-> <equalityCoercion>
    // Expect edge: <export-named-list> -[EXPORTS]-> <customCoerce>
    // Expect edge: <export-named-list> -[EXPORTS]-> <usedInMath>
    // Expect edge: <export-named-list> -[EXPORTS]-> <usedInTemplate>
    // Expect edge: <export-named-list> -[EXPORTS]-> <toPrimitive>
    // Expect edge: <export-named-list> -[EXPORTS]-> <varHoisting>
    // Expect edge: <export-named-list> -[EXPORTS]-> <functionHoisting>
    // Expect edge: <export-named-list> -[EXPORTS]-> <functionExprNotHoisted>
    // Expect edge: <export-named-list> -[EXPORTS]-> <tdzLet>
    // Expect edge: <export-named-list> -[EXPORTS]-> <tdzConst>
    // Expect edge: <export-named-list> -[EXPORTS]-> <tdzClass>
    // Expect edge: <export-named-list> -[EXPORTS]-> <outerConst>
    // Expect edge: <export-named-list> -[EXPORTS]-> <shadowingExample>
    // Expect edge: <export-named-list> -[EXPORTS]-> <paramShadowing>
    // Expect edge: <export-named-list> -[EXPORTS]-> <catchShadowing>
    // Expect edge: <export-named-list> -[EXPORTS]-> <directEval>
    // Expect edge: <export-named-list> -[EXPORTS]-> <indirectEval>
    // Expect edge: <export-named-list> -[EXPORTS]-> <newFunction>
    // Expect edge: <export-named-list> -[EXPORTS]-> <commaSequence>
    // Expect edge: <export-named-list> -[EXPORTS]-> <evalVarInjection>
    // Expect edge: <export-named-list> -[EXPORTS]-> <evalFunctionInjection>
    // Expect edge: <export-named-list> -[EXPORTS]-> <primitiveAutoboxing>
    // Expect edge: <export-named-list> -[EXPORTS]-> <varFunctionCollision>
    // Expect edge: <export-named-list> -[EXPORTS]-> <contextualKeywords>
    // Expect edge: <export-named-list> -[EXPORTS]-> <objectAsMapKey>
    // Expect edge: <export-named-list> -[EXPORTS]-> <blockFunctionDemo>
    // Expect edge: <export-named-list> -[EXPORTS]-> <varInCatchClobber>
    // Expect edge: <export-named-list> -[EXPORTS]-> <typeofTdzTrap>
    // Expect edge: <export-named-list> -[EXPORTS]-> <evalLetScope>
    // Expect edge: <export-named-list> -[EXPORTS]-> <blockLabelAmbiguity>
    // Expect edge: <export-named-list> -[EXPORTS]-> <varRedeclaresParameter>
    void code;
  });

  test('declarations::func-expr-named', () => {
    const code = "const namedExpression = function multiply(x, y) {\n  return x * y;\n};";
    // Expect edge: <namedExpression> -[ASSIGNED_FROM]-> <multiply>
    void code;
  });

  test('declarations::arrow-single-param', () => {
    const code = "const arrowSingleParam = x => x * 2;";
    // Expect edge: <arrowSingleParam> -[ASSIGNED_FROM]-> <arrowSingleParam:fn>
    void code;
  });

  test('declarations::arrow-block-body', () => {
    const code = "const arrowBlock = (a, b) => {\n  return a + b;\n};";
    // Expect edge: <arrowBlock> -[ASSIGNED_FROM]-> <arrowBlock:fn>
    void code;
  });

  test('declarations::arrow-expression-body', () => {
    const code = "const arrowExpression = (a, b) => a + b;";
    // Expect edge: <arrowExpression> -[ASSIGNED_FROM]-> <arrowExpression:fn>
    void code;
  });

  test('declarations::arrow-no-params', () => {
    const code = "const arrowNoParams = () => 42;\n\n// Generator Functions";
    // Expect edge: <arrowNoParams> -[ASSIGNED_FROM]-> <arrowNoParams:fn>
    void code;
  });

  test('declarations::func-expr-anonymous', () => {
    const code = "const anonymousExpression = function (x) {\n  return x * 2;\n};\n\n// Arrow Functions";
    // Expect edge: <anonymousExpression> -[ASSIGNED_FROM]-> <anonymousExpression:fn>
    void code;
  });

  test('declarations::iife', () => {
    const code = "const iifeResult = (function () {\n  return 'iife';\n})();";
    // Expect edge: <iifeResult> -[ASSIGNED_FROM]-> <iife:call>
    void code;
  });

  test('declarations::iife-arrow', () => {
    const code = "const arrowIifeResult = (() => {\n  return 'arrow iife';\n})();\n\n// Named Exports";
    // Expect edge: <arrowIifeResult> -[ASSIGNED_FROM]-> <arrow-iife:call>
    void code;
  });

  test('declarations::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve('async arrow');\n};\n\n// Async Generator Functions";
    // Expect edge: <asyncArrow> -[ASSIGNED_FROM]-> <asyncArrow:fn>
    void code;
  });

  test('declarations::arrow-return-object-literal', () => {
    const code = "const arrowReturnsObject = (x) => ({ key: x, value: x * 2 });\n// Without parens: (x) => { key: x } — parsed as block with label \"key\"!";
    // Expect edge: <arrowReturnsObject> -[ASSIGNED_FROM]-> <arrowReturnsObject:fn>
    void code;
  });

  test('declarations::param-default-scope-quirk', () => {
    const code = "let outerX = 'outer';\nfunction paramDefaultScope(a = () => outerX, outerX) {\n  return a();\n}";
    // Expect edge: <outerX> -[ASSIGNED_FROM]-> <'outer'>
    void code;
  });

  test('declarations::async-iife', () => {
    const code = "const asyncIifeResult = (async () => {\n  return await Promise.resolve('async iife');\n})();";
    // Expect edge: <asyncIifeResult> -[ASSIGNED_FROM]-> <async-iife:call>
    void code;
  });

  test('declarations::new-target-in-function', () => {
    const code = "function FlexibleConstructor(name) {\n  if (!new.target) {\n    return new FlexibleConstructor(name); // redirect if called without new\n  }\n  this.name = name;\n}";
    // Expect edge: <FlexibleConstructor> -[WRITES_TO]-> <this.name>
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    void code;
  });

  test('declarations::func-expr-recursive-self-ref', () => {
    const code = "const factorialNamedExpr = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1); // fact visible ONLY inside\n};\n// typeof fact === 'undefined' — internal name not in enclosing scope";
    // Expect edge: <factorialNamedExpr> -[ASSIGNED_FROM]-> <fact>
    // Expect edge: <fact> -[HAS_ALTERNATE]-> <n * fact(n - 1)>
    void code;
  });

  test('error-handling::error-custom-class', () => {
    const code = "class AppError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n  }\n}";
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <'AppError'>
    // Expect edge: <AppError.constructor> -[WRITES_TO]-> <this.name>
    // Expect edge: <this.code> -[ASSIGNED_FROM]-> <code>
    // Expect edge: <AppError.constructor> -[WRITES_TO]-> <this.code>
    void code;
  });

  test('declarations::let-const-multi-declaration', () => {
    const code = "const constMultiA = 1, constMultiB = constMultiA + 1, constMultiC = constMultiA + constMultiB;\nlet letMultiX = 0, letMultiY = letMultiX + 1;";
    // Expect edge: <constMultiA> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <constMultiB> -[ASSIGNED_FROM]-> <constMultiA + 1>
    // Expect edge: <constMultiC> -[ASSIGNED_FROM]-> <constMultiA + constMultiB>
    // Expect edge: <letMultiX> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <letMultiY> -[ASSIGNED_FROM]-> <letMultiX + 1>
    void code;
  });

  test('builtins::builtin-json-parse-reviver', () => {
    const code = "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}";
    // Expect edge: <if-date-check> -[HAS_ALTERNATE]-> <value>
    void code;
  });

  test('declarations::numeric-separators', () => {
    const code = "const TIMEOUT_MS = 30_000;\nconst MAX_SAFE = 9_007_199_254_740_991;\nconst HEX_COLOR = 0xFF_EC_D9;\nconst BIT_MASK = 0b1111_0000_1010_0101;\nconst BIG_NUM = 1_000_000_000n;\nconst FLOAT_SEP = 1_000.123_456;";
    // Expect edge: <TIMEOUT_MS> -[ASSIGNED_FROM]-> <30_000>
    // Expect edge: <MAX_SAFE> -[ASSIGNED_FROM]-> <9_007_199_254_740_991>
    // Expect edge: <HEX_COLOR> -[ASSIGNED_FROM]-> <0xFF_EC_D9>
    // Expect edge: <BIT_MASK> -[ASSIGNED_FROM]-> <0b1111_0000_1010_0101>
    // Expect edge: <BIG_NUM> -[ASSIGNED_FROM]-> <1_000_000_000n>
    // Expect edge: <FLOAT_SEP> -[ASSIGNED_FROM]-> <1_000.123_456>
    void code;
  });

  test('error-handling::error-cause', () => {
    const code = "async function fetchWithCause(url) {\n  try {\n    const response = await fetch(url);\n    return await response.json();\n  } catch (err) {\n    throw new Error(`Failed to fetch ${url}`, { cause: err });\n  }\n}\n\n// --- Error wrapping / re-throw ---";
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url)>
    // Expect edge: <catch-block> -[THROWS]-> <new Error>
    void code;
  });

  test('error-handling::error-wrap-rethrow', () => {
    const code = "function parseConfig(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch (err) {\n    throw new AppError(`Invalid config: ${err.message}`, 'PARSE_ERROR');\n  }\n}";
    // Expect edge: <catch-block> -[THROWS]-> <new AppError>
    void code;
  });

  test('declarations::export-named-list', () => {
    const code = "export {\n  mutableVar,\n  reassignable,\n  immutable,\n  objectConst,\n  arrayConst,\n  bigNumber,\n  uniqueKey,\n  globalSymbol,\n  regexSimple,\n  regularFunction,\n  withDefaults,\n  withRestParams,\n  withMixedParams,\n  namedExpression,\n  anonymousExpression,\n  arrowBlock,\n  arrowExpression,\n  arrowSingleParam,\n  arrowNoParams,\n  numberGenerator,\n  delegatingGenerator,\n  asyncFunction,\n  asyncArrow,\n  asyncGenerator,\n  iifeResult,\n  arrowIifeResult,\n  paramDefaultChain,\n  paramDefaultScope,\n  arrowReturnsObject,\n  asyncIifeResult,\n  constMultiC,\n  letMultiY,\n  factorialNamedExpr,\n  FlexibleConstructor,\n  paramDefaultFromDestructured,\n  queryBuilder,\n  TIMEOUT_MS,\n  MAX_SAFE,\n  HEX_COLOR,\n  BIT_MASK,\n  BIG_NUM,\n  FLOAT_SEP,\n  functionNameInference,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <mutableVar>
    // Expect edge: <export-named-list> -[EXPORTS]-> <reassignable>
    // Expect edge: <export-named-list> -[EXPORTS]-> <immutable>
    // Expect edge: <export-named-list> -[EXPORTS]-> <objectConst>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrayConst>
    // Expect edge: <export-named-list> -[EXPORTS]-> <bigNumber>
    // Expect edge: <export-named-list> -[EXPORTS]-> <uniqueKey>
    // Expect edge: <export-named-list> -[EXPORTS]-> <globalSymbol>
    // Expect edge: <export-named-list> -[EXPORTS]-> <regexSimple>
    // Expect edge: <export-named-list> -[EXPORTS]-> <regularFunction>
    // Expect edge: <export-named-list> -[EXPORTS]-> <withDefaults>
    // Expect edge: <export-named-list> -[EXPORTS]-> <withRestParams>
    // Expect edge: <export-named-list> -[EXPORTS]-> <withMixedParams>
    // Expect edge: <export-named-list> -[EXPORTS]-> <namedExpression>
    // Expect edge: <export-named-list> -[EXPORTS]-> <anonymousExpression>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrowBlock>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrowExpression>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrowSingleParam>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrowNoParams>
    // Expect edge: <export-named-list> -[EXPORTS]-> <numberGenerator>
    // Expect edge: <export-named-list> -[EXPORTS]-> <delegatingGenerator>
    // Expect edge: <export-named-list> -[EXPORTS]-> <asyncFunction>
    // Expect edge: <export-named-list> -[EXPORTS]-> <asyncArrow>
    // Expect edge: <export-named-list> -[EXPORTS]-> <asyncGenerator>
    // Expect edge: <export-named-list> -[EXPORTS]-> <iifeResult>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrowIifeResult>
    // Expect edge: <export-named-list> -[EXPORTS]-> <paramDefaultChain>
    // Expect edge: <export-named-list> -[EXPORTS]-> <paramDefaultScope>
    // Expect edge: <export-named-list> -[EXPORTS]-> <arrowReturnsObject>
    // Expect edge: <export-named-list> -[EXPORTS]-> <asyncIifeResult>
    // Expect edge: <export-named-list> -[EXPORTS]-> <constMultiC>
    // Expect edge: <export-named-list> -[EXPORTS]-> <letMultiY>
    // Expect edge: <export-named-list> -[EXPORTS]-> <factorialNamedExpr>
    // Expect edge: <export-named-list> -[EXPORTS]-> <FlexibleConstructor>
    // Expect edge: <export-named-list> -[EXPORTS]-> <paramDefaultFromDestructured>
    // Expect edge: <export-named-list> -[EXPORTS]-> <queryBuilder>
    // Expect edge: <export-named-list> -[EXPORTS]-> <TIMEOUT_MS>
    // Expect edge: <export-named-list> -[EXPORTS]-> <MAX_SAFE>
    // Expect edge: <export-named-list> -[EXPORTS]-> <HEX_COLOR>
    // Expect edge: <export-named-list> -[EXPORTS]-> <BIT_MASK>
    // Expect edge: <export-named-list> -[EXPORTS]-> <BIG_NUM>
    // Expect edge: <export-named-list> -[EXPORTS]-> <FLOAT_SEP>
    // Expect edge: <export-named-list> -[EXPORTS]-> <functionNameInference>
    void code;
  });

  test('builtins::builtin-json-stringify-replacer', () => {
    const code = "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---";
    // Expect edge: <if-typeof-function> -[HAS_ALTERNATE]-> <value>
    void code;
  });

  test('error-handling::error-rethrow-conditional', () => {
    const code = "function processData(data) {\n  try {\n    return transform(data);\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err; // re-throw known errors as-is\n    }\n    throw new AppError(`Unexpected: ${err.message}`, 'INTERNAL');\n  }\n}\n\nfunction transform(data) {\n  if (!data) throw new ValidationError('data', 'Data is required');\n  return data;\n}\n\n// --- instanceof checks in catch ---";
    // Expect edge: <throw err> -[THROWS]-> <err>
    // Expect edge: <err instanceof ValidationError> -[HAS_ALTERNATE]-> <throw new AppError(...)>
    // Expect edge: <throw new AppError(...)> -[THROWS]-> <new AppError(...)>
    // Expect edge: <throw new ValidationError(...)> -[THROWS]-> <new ValidationError(...)>
    void code;
  });

  test('error-handling::error-custom-hierarchy', () => {
    const code = "class ValidationError extends AppError {\n  constructor(field, message) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource, id) {\n    super(`${resource} not found: ${id}`, 'NOT_FOUND');\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.id = id;\n  }\n}\n\n// --- Error cause (ES2022) ---";
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <'ValidationError'>
    // Expect edge: <this.field> -[ASSIGNED_FROM]-> <field>
    // Expect edge: <this.name2> -[ASSIGNED_FROM]-> <'NotFoundError'>
    // Expect edge: <this.resource> -[ASSIGNED_FROM]-> <resource>
    // Expect edge: <this.id> -[ASSIGNED_FROM]-> <id>
    void code;
  });

  test('error-handling::export-named-list', () => {
    const code = "export {\n  AppError,\n  ValidationError,\n  NotFoundError,\n  fetchWithCause,\n  parseConfig,\n  processData,\n  handleError,\n  pipeline,\n  safeExecute,\n  promiseErrorHandling,\n  chainedErrors,\n  aggregatedErrors,\n  withCleanup,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <AppError>
    // Expect edge: <export-named-list> -[EXPORTS]-> <ValidationError>
    // Expect edge: <export-named-list> -[EXPORTS]-> <NotFoundError>
    // Expect edge: <export-named-list> -[EXPORTS]-> <fetchWithCause>
    // Expect edge: <export-named-list> -[EXPORTS]-> <parseConfig>
    // Expect edge: <export-named-list> -[EXPORTS]-> <processData>
    // Expect edge: <export-named-list> -[EXPORTS]-> <handleError>
    // Expect edge: <export-named-list> -[EXPORTS]-> <pipeline>
    // Expect edge: <export-named-list> -[EXPORTS]-> <safeExecute>
    // Expect edge: <export-named-list> -[EXPORTS]-> <promiseErrorHandling>
    // Expect edge: <export-named-list> -[EXPORTS]-> <chainedErrors>
    // Expect edge: <export-named-list> -[EXPORTS]-> <aggregatedErrors>
    // Expect edge: <export-named-list> -[EXPORTS]-> <withCleanup>
    void code;
  });

  test('error-handling::error-aggregate', () => {
    const code = "function aggregatedErrors() {\n  const errors = [\n    new Error('first'),\n    new Error('second'),\n    new Error('third'),\n  ];\n  throw new AggregateError(errors, 'Multiple failures');\n}\n\n// --- Finally for cleanup ---";
    // Expect edge: <errors> -[ASSIGNED_FROM]-> <['first', 'second', 'third']>
    // Expect edge: <aggregatedErrors> -[THROWS]-> <new AggregateError(errors, 'Multiple failures')>
    void code;
  });

  test('expressions::delete-op', () => {
    const code = "function deleteOperator() {\n  const obj = { a: 1, b: 2 };\n  delete obj.a;\n  return obj;\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ a: 1, b: 2 }>
    void code;
  });

  test('expressions::update-expr', () => {
    const code = "function updateExpressions() {\n  let x = 0;\n  x++;\n  x--;\n  ++x;\n  --x;\n  return x;\n}";
    // Expect edge: <x> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <x++> -[WRITES_TO]-> <x>
    // Expect edge: <x--> -[WRITES_TO]-> <x>
    // Expect edge: <++x> -[WRITES_TO]-> <x>
    // Expect edge: <--x> -[WRITES_TO]-> <x>
    void code;
  });

  test('expressions::logical-ops', () => {
    const code = "function logicalOperators(a, b) {\n  const and = a && b;\n  const or = a || b;\n  const nullish = a ?? b;\n  const not = !a;\n  return { and, or, nullish, not };\n}";
    // Expect edge: <and> -[ASSIGNED_FROM]-> <a && b>
    // Expect edge: <or> -[ASSIGNED_FROM]-> <a || b>
    // Expect edge: <nullish> -[ASSIGNED_FROM]-> <a ?? b>
    // Expect edge: <not> -[ASSIGNED_FROM]-> <!a>
    void code;
  });

  test('expressions::tagged-template-usage', () => {
    const code = "const tagged = tag`Hello ${'world'} number ${42}`;";
    // Expect edge: <tagged> -[ASSIGNED_FROM]-> <tag`Hello ${'world'} number ${42}`>
    void code;
  });

  test('expressions::optional-chaining', () => {
    const code = "function optionalChaining(obj) {\n  const prop = obj?.nested?.deep;\n  const method = obj?.method?.();\n  const computed = obj?.items?.[0];\n  return { prop, method, computed };\n}";
    // Expect edge: <prop> -[ASSIGNED_FROM]-> <obj?.nested?.deep>
    // Expect edge: <method> -[ASSIGNED_FROM]-> <obj?.method?.()>
    // Expect edge: <computed> -[ASSIGNED_FROM]-> <obj?.items?.[0]>
    void code;
  });

  test('expressions::unary-ops', () => {
    const code = "function unaryOperators(x) {\n  const pos = +x;\n  const neg = -x;\n  const logNot = !x;\n  const bitNot = ~x;\n  const typeOfX = typeof x;\n  const voidX = void x;\n  return { pos, neg, logNot, bitNot, typeOfX, voidX };\n}";
    // Expect edge: <pos> -[ASSIGNED_FROM]-> <+x>
    // Expect edge: <neg> -[ASSIGNED_FROM]-> <-x>
    // Expect edge: <logNot> -[ASSIGNED_FROM]-> <!x>
    // Expect edge: <bitNot> -[ASSIGNED_FROM]-> <~x>
    // Expect edge: <typeOfX> -[ASSIGNED_FROM]-> <typeof x>
    // Expect edge: <voidX> -[ASSIGNED_FROM]-> <void x>
    void code;
  });

  test('builtins::builtin-map-constructor', () => {
    const code = "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---";
    // Expect edge: <map> -[ASSIGNED_FROM]-> <new Map([...])>
    void code;
  });

  test('expressions::chained-assignment-mixed', () => {
    const code = "function chainedAssignmentMixed() {\n  const obj = {};\n  obj.x = obj.y = [];\n  return obj;\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <obj.y> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <obj.x> -[ASSIGNED_FROM]-> <obj.y>
    // Expect edge: <obj.x = obj.y = []> -[WRITES_TO]-> <obj.x>
    // Expect edge: <obj.x = obj.y = []> -[WRITES_TO]-> <obj.y>
    void code;
  });

  test('expressions::chained-assignment', () => {
    const code = "function chainedAssignment() {\n  let a, b, c;\n  a = b = c = 42;\n  return { a, b, c };\n}";
    // Expect edge: <c> -[ASSIGNED_FROM]-> <42>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <c>
    // Expect edge: <a> -[ASSIGNED_FROM]-> <b>
    void code;
  });

  test('expressions::ternary', () => {
    const code = "function ternaryOperator(condition, value) {\n  const simple = condition ? 'yes' : 'no';\n  const nested = condition ? (value > 5 ? 'high' : 'low') : 'none';\n  return { simple, nested };\n}";
    // Expect edge: <simple> -[ASSIGNED_FROM]-> <condition ? 'yes' : 'no'>
    // Expect edge: <condition ? 'yes' : 'no'> -[HAS_ALTERNATE]-> <'no'>
    // Expect edge: <nested> -[ASSIGNED_FROM]-> <condition ? (value > 5 ? 'high' : 'low') : 'none'>
    // Expect edge: <condition ? (value > 5 ? 'high' : 'low') : 'none'> -[HAS_ALTERNATE]-> <'none'>
    // Expect edge: <value > 5 ? 'high' : 'low'> -[HAS_ALTERNATE]-> <'low'>
    void code;
  });

  test('expressions::grouping', () => {
    const code = "function groupingOperator(a, b, c) {\n  const withGrouping = (a + b) * c;\n  const withoutGrouping = a + b * c;\n  return { withGrouping, withoutGrouping };\n}";
    // Expect edge: <withGrouping> -[ASSIGNED_FROM]-> <(a + b) * c>
    // Expect edge: <withoutGrouping> -[ASSIGNED_FROM]-> <a + b * c>
    void code;
  });

  test('expressions::tagged-template-raw', () => {
    const code = "function rawTemplate(strings) {\n  return strings.raw[0];\n}\nconst rawResult = rawTemplate`\\n`;";
    // Expect edge: <rawResult> -[ASSIGNED_FROM]-> <rawTemplate`\n`>
    void code;
  });

  test('expressions::new-constructor-return-non-this', () => {
    const code = "function NonThisConstructor() {\n  return { custom: true }; // returns different object than `this`\n}\nconst nonThisInstance = new NonThisConstructor(); // NOT instanceof NonThisConstructor!";
    // Expect edge: <nonThisInstance> -[ASSIGNED_FROM]-> <new NonThisConstructor()>
    void code;
  });

  test('expressions::comma-in-arrow-body', () => {
    const code = "const commaArrow = (x) => (console.log(x), x * 2);";
    // Expect edge: <commaArrow> -[ASSIGNED_FROM]-> <commaArrow:fn>
    void code;
  });

  test('expressions::comma-in-array-subscript', () => {
    const code = "function commaSubscript() {\n  const matrix = [[1, 2], [3, 4]];\n  const result = matrix[0, 1]; // comma evaluates to 1 → matrix[1]\n  return result; // [3, 4]\n}";
    // Expect edge: <matrix> -[ASSIGNED_FROM]-> <[[1, 2], [3, 4]]>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <matrix[0, 1]>
    void code;
  });

  test('expressions::conditional-method-call', () => {
    const code = "function conditionalMethodCall(input) {\n  const value = (typeof input === 'string' ? input : String(input)).trim();\n  return value;\n}";
    // Expect edge: <value> -[ASSIGNED_FROM]-> <.trim()>
    // Expect edge: <conditional> -[HAS_ALTERNATE]-> <String(input)>
    void code;
  });

  test('expressions::typeof-undeclared', () => {
    const code = "function typeofUndeclared() {\n  const safe = typeof undeclaredVar; // \"undefined\" — NO ReferenceError\n  return safe;\n}";
    // Expect edge: <safe> -[ASSIGNED_FROM]-> <typeof undeclaredVar>
    void code;
  });

  test('expressions::new-precedence-trap', () => {
    const code = "function newPrecedence() {\n  const withParens = new Date().getTime();       // (new Date()).getTime()\n  // new Date.getTime()                          // new (Date.getTime)() — TypeError!\n  const noParens = new Map;                      // valid — no parens needed\n  return { withParens, noParens };\n}";
    // Expect edge: <withParens> -[ASSIGNED_FROM]-> <getTime()>
    // Expect edge: <noParens> -[ASSIGNED_FROM]-> <new Map>
    void code;
  });

  test('expressions::nullish-coalescing-chain', () => {
    const code = "function nullishChain(a, b, c, defaultValue) {\n  const value = a ?? b ?? c ?? defaultValue;\n  return value;\n}";
    // Expect edge: <value> -[ASSIGNED_FROM]-> <a ?? b ?? c ?? defaultValue>
    void code;
  });

  test('expressions::new-member-expression', () => {
    const code = "function newMemberExpression(mod) {\n  const instance = new mod.MyClass();\n  const nested = new mod.sub.Factory();\n  return { instance, nested };\n}";
    // Expect edge: <instance> -[ASSIGNED_FROM]-> <new mod.MyClass()>
    // Expect edge: <nested> -[ASSIGNED_FROM]-> <new mod.sub.Factory()>
    void code;
  });

  test('expressions::comma-in-condition', () => {
    const code = "function commaInWhile() {\n  let i = 0, total = 0;\n  while ((total += i, ++i < 5)) {\n    // comma in condition\n  }\n  return total; // 10\n}";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <total> -[ASSIGNED_FROM]-> <0_2>
    // Expect edge: <total += i> -[WRITES_TO]-> <total>
    // Expect edge: <++i> -[WRITES_TO]-> <i>
    void code;
  });

  test('expressions::assignment-in-if', () => {
    const code = "function assignmentInIf(compute) {\n  let result;\n  if (result = compute()) {            // assignment + truthiness check\n    return result;\n  }\n  return null;\n}";
    // Expect edge: <result = compute()> -[WRITES_TO]-> <result>
    // Expect edge: <result = compute()> -[ASSIGNED_FROM]-> <compute()>
    void code;
  });

  test('expressions::conditional-tag-template', () => {
    const code = "function conditionalTagTemplate(dangerous) {\n  const escape = dangerous ? (s) => s[0].toUpperCase() : (s) => s[0];\n  const result = escape`hello`;\n  return result;\n}";
    // Expect edge: <escape> -[ASSIGNED_FROM]-> <dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>
    // Expect edge: <dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]> -[HAS_ALTERNATE]-> <(s) => s[0]>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <escape`hello`>
    void code;
  });

  test('expressions::reflect-construct-newtarget', () => {
    const code = "class ReflectBase {\n  constructor() {\n    this.constructedBy = new.target.name;\n  }\n}\nclass ReflectDerived extends ReflectBase {}\n\nfunction reflectConstructDemo() {\n  const normal = new ReflectDerived();                       // constructedBy: 'ReflectDerived'\n  const spoofed = Reflect.construct(ReflectBase, [], ReflectDerived); // constructedBy: 'ReflectDerived' but runs Base constructor\n  return { normal, spoofed };\n}";
    // Expect edge: <this.constructedBy> -[ASSIGNED_FROM]-> <new.target.name>
    // Expect edge: <ReflectBase.constructor> -[WRITES_TO]-> <this.constructedBy>
    // Expect edge: <normal> -[ASSIGNED_FROM]-> <new ReflectDerived()>
    // Expect edge: <spoofed> -[ASSIGNED_FROM]-> <Reflect.construct(ReflectBase, [], ReflectDerived)>
    void code;
  });

  test('expressions::logical-assign-property', () => {
    const code = "function logicalAssignProperty() {\n  const config = { timeout: 0, retries: null, debug: false };\n  config.timeout ||= 5000;    // 5000 — 0 is falsy\n  config.retries ??= 3;       // 3 — null is nullish\n  config.debug &&= true;      // false — short-circuits\n  return config;\n}";
    // Expect edge: <config> -[ASSIGNED_FROM]-> <object-literal>
    // Expect edge: <timeout-prop> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <retries-prop> -[ASSIGNED_FROM]-> <null>
    // Expect edge: <debug-prop> -[ASSIGNED_FROM]-> <false>
    // Expect edge: <config.timeout ||= 5000> -[WRITES_TO]-> <config.timeout>
    // Expect edge: <config.timeout ||= 5000> -[ASSIGNED_FROM]-> <5000>
    // Expect edge: <config.retries ??= 3> -[WRITES_TO]-> <config.retries>
    // Expect edge: <config.retries ??= 3> -[ASSIGNED_FROM]-> <3>
    // Expect edge: <config.debug &&= true> -[WRITES_TO]-> <config.debug>
    // Expect edge: <config.debug &&= true> -[ASSIGNED_FROM]-> <true>
    void code;
  });

  test('expressions::tagged-template-chained', () => {
    const code = "function chainTag(strings) {\n  return (strings2) => strings[0] + strings2[0];\n}\nconst chainedResult = chainTag`hello``world`;";
    // Expect edge: <chainedResult> -[ASSIGNED_FROM]-> <chainTag`hello``world`>
    void code;
  });

  test('expressions::tagged-template-returns-class', () => {
    const code = "const styledDiv = {\n  div(strings, ...exprs) {\n    return class StyledComponent {\n      styles = strings.join('');\n    };\n  },\n};\nconst Component = styledDiv.div`color: red; font-size: 14px;`;";
    // Expect edge: <styledDiv> -[ASSIGNED_FROM]-> <styledDiv:obj>
    // Expect edge: <styles> -[ASSIGNED_FROM]-> <strings.join('')>
    // Expect edge: <Component> -[ASSIGNED_FROM]-> <styledDiv.div`color: red; font-size: 14px;`>
    void code;
  });

  test('expressions::tagged-template-returns-object', () => {
    const code = "function sql(strings, ...values) {\n  return { text: strings.join('?'), params: values }; // returns object, not string!\n}\nconst userId = 42;\nconst query = sql`SELECT * FROM users WHERE id = ${userId}`;";
    // Expect edge: <userId> -[ASSIGNED_FROM]-> <42>
    // Expect edge: <query> -[ASSIGNED_FROM]-> <sql`SELECT * FROM users WHERE id = ${userId}`>
    void code;
  });

  test('expressions::short-circuit-guard-call', () => {
    const code = "function shortCircuitGuard(callback, data) {\n  callback && callback(data);           // guard + call\n  const result = callback?.(data);      // optional call equivalent\n  return result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <callback?.(data)>
    void code;
  });

  test('expressions::in-operator-array', () => {
    const code = "function inOperatorArray() {\n  const hasIndex = 0 in [1, 2, 3];     // true — checks INDEX, not value\n  const hasStr = '0' in [1, 2, 3];     // true — coerced to string\n  const noIndex = 5 in [1, 2, 3];      // false\n  return { hasIndex, hasStr, noIndex };\n}\n\n// --- Reflect.construct with newTarget (constructor spoofing) ---";
    // Expect edge: <hasIndex> -[ASSIGNED_FROM]-> <0 in [1, 2, 3]>
    // Expect edge: <hasStr> -[ASSIGNED_FROM]-> <'0' in [1, 2, 3]>
    // Expect edge: <noIndex> -[ASSIGNED_FROM]-> <5 in [1, 2, 3]>
    void code;
  });

  test('expressions::await-comma-expression', () => {
    const code = "async function awaitCommaExpression(sideEffect, fetchData) {\n  const result = await (sideEffect(), fetchData());\n  // sideEffect() runs sync, fetchData() is awaited\n  return result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <await (sideEffect(), fetchData())>
    void code;
  });

  test('expressions::new-with-spread', () => {
    const code = "function newWithSpread() {\n  const args = [2024, 0, 15];\n  const date = new Date(...args);\n\n  function instantiate(Cls, ctorArgs) {\n    return new Cls(...ctorArgs);       // dynamic class + spread\n  }\n\n  return { date, instantiate };\n}";
    // Expect edge: <args> -[ASSIGNED_FROM]-> <[2024, 0, 15]>
    // Expect edge: <date> -[ASSIGNED_FROM]-> <new Date(...args)>
    void code;
  });

  test('expressions::nullish-logical-mixing-error', () => {
    const code = "// SyntaxError — cannot mix ?? with || or && without explicit parentheses:\n// a ?? b || c;    // SyntaxError\n// a || b ?? c;    // SyntaxError\n// a ?? b && c;    // SyntaxError\n// Must use: (a ?? b) || c  or  a ?? (b || c)";
    // Expect edge: <nullish-logical-mixing-error> -[THROWS]-> <a ?? b || c>
    // Expect edge: <nullish-logical-mixing-error> -[THROWS]-> <a || b ?? c>
    // Expect edge: <nullish-logical-mixing-error> -[THROWS]-> <a ?? b && c>
    void code;
  });

  test('expressions::assignment-in-condition', () => {
    const code = "function assignmentInCondition(regex, str) {\n  const matches = [];\n  let match;\n  while (match = regex.exec(str)) {   // assignment AS condition (no explicit comparison)\n    matches.push(match[0]);\n  }\n  return matches;\n}";
    // Expect edge: <matches> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <match = regex.exec(str)> -[WRITES_TO]-> <match>
    void code;
  });

  test('hashbang-entry::export-named-list', () => {
    const code = "export { hashbangMain };";
    // Expect edge: <export-hashbangMain> -[EXPORTS]-> <hashbangMain>
    void code;
  });

  test('expressions::async-arrow-returns-object', () => {
    const code = "const asyncArrowObject = async (data, processFn) => ({\n  id: data.id,\n  result: await processFn(data),\n  timestamp: Date.now(),\n});\n// Without parens: async (data) => { id: data.id } — parsed as block + label!";
    // Expect edge: <asyncArrowObject> -[ASSIGNED_FROM]-> <asyncArrowObject:fn>
    void code;
  });

  test('expressions::getter-returns-function', () => {
    const code = "function getterReturnsFunction() {\n  const obj = {\n    get handler() {\n      return (x) => x * 2;             // getter returns a function\n    },\n  };\n  const result = obj.handler(21);       // getter call + returned function call\n  return result; // 42\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <obj-literal>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <obj.handler(21)>
    void code;
  });

  test('index::import-meta', () => {
    const code = "const currentUrl = import.meta.url;\n\n// --- Module namespace object as first-class value ---";
    // Expect edge: <currentUrl> -[ASSIGNED_FROM]-> <import.meta.url>
    void code;
  });

  test('builtins::builtin-weakset', () => {
    const code = "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---";
    // Expect edge: <ws> -[ASSIGNED_FROM]-> <new WeakSet()>
    // Expect edge: <obj1> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <obj2> -[ASSIGNED_FROM]-> <{}2>
    // Expect edge: <has> -[ASSIGNED_FROM]-> <ws.has(obj1)>
    // Expect edge: <hasAfter> -[ASSIGNED_FROM]-> <ws.has(obj1)2>
    void code;
  });

  test('expressions::tag-on-call-result', () => {
    const code = "function tagOnCallResult() {\n  function getFormatter(type) {\n    return (strings, ...values) => ({ type, parts: strings, values });\n  }\n  const result = getFormatter('sql')`SELECT * FROM ${'users'}`;\n  return result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <tagged_template_call>
    void code;
  });

  test('builtins::builtin-weakref', () => {
    const code = "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}";
    // Expect edge: <target> -[ASSIGNED_FROM]-> <{ data: 'important' }>
    // Expect edge: <ref> -[ASSIGNED_FROM]-> <new WeakRef(target)>
    // Expect edge: <deref> -[ASSIGNED_FROM]-> <ref.deref()>
    void code;
  });

  test('index::import-dynamic', () => {
    const code = "const dynamicModule = await import('./patterns.js');";
    // Expect edge: <dynamicModule> -[ASSIGNED_FROM]-> <import('./patterns.js')>
    void code;
  });

  test('expressions::deep-optional-chain', () => {
    const code = "function deepOptionalChain(response) {\n  const value = response?.data?.items?.[0]?.getName?.();\n  const nested = response?.config?.headers?.['Content-Type']?.split?.('/');\n  return { value, nested };\n}";
    // Expect edge: <value> -[ASSIGNED_FROM]-> <response?.data?.items?.[0]?.getName?.()>
    // Expect edge: <nested> -[ASSIGNED_FROM]-> <response?.config?.headers?.['Content-Type']?.split?.('/')>
    void code;
  });

  test('index::module-namespace-destructured', () => {
    const code = "const { helperFunction: destructuredHelper } = allHelpers;";
    // Expect edge: <destructuredHelper> -[ASSIGNED_FROM]-> <{helperFunction: destructuredHelper}>
    void code;
  });

  test('index::export-named-list', () => {
    const code = "export { defaultExport, helperFunction, HELPER_CONST, Helper, allHelpers, mainFn, helperResult, destructuredHelper };";
    // Expect edge: <export-named-list> -[EXPORTS]-> <defaultExport>
    // Expect edge: <export-named-list> -[EXPORTS]-> <helperFunction>
    // Expect edge: <export-named-list> -[EXPORTS]-> <HELPER_CONST>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Helper>
    // Expect edge: <export-named-list> -[EXPORTS]-> <allHelpers>
    // Expect edge: <export-named-list> -[EXPORTS]-> <mainFn>
    // Expect edge: <export-named-list> -[EXPORTS]-> <helperResult>
    // Expect edge: <export-named-list> -[EXPORTS]-> <destructuredHelper>
    void code;
  });

  test('expressions::arrow-return-assignment', () => {
    const code = "function arrowReturnAssignment() {\n  let cache = null;\n\n  // Arrow returning assignment — parenthesized to make it expression body\n  const setCache = (val) => (cache = val);\n  setCache(42);\n\n  // With destructuring assignment in arrow\n  let first, second;\n  const swap = () => ([first, second] = [second, first]);\n\n  return { cache, setCache, swap };\n}";
    // Expect edge: <cache> -[ASSIGNED_FROM]-> <null>
    // Expect edge: <setCache> -[ASSIGNED_FROM]-> <setCache:fn>
    // Expect edge: <cache = val> -[WRITES_TO]-> <cache>
    // Expect edge: <swap> -[ASSIGNED_FROM]-> <swap:fn>
    // Expect edge: <[first, second] = [second, first]> -[WRITES_TO]-> <first>
    // Expect edge: <[first, second] = [second, first]> -[WRITES_TO]-> <second>
    void code;
  });

  test('expressions::void-as-undefined', () => {
    const code = "function voidAsUndefined(val) {\n  // void 0 is shorter than undefined and immune to shadowing\n  const isUndef = val === void 0;\n\n  // void with side effect — expression runs, result discarded\n  let sideEffectRan = false;\n  void (sideEffectRan = true);\n\n  // void in ternary — explicit undefined branch\n  const result = val !== void 0 ? val : 'fallback';\n\n  return { isUndef, sideEffectRan, result };\n}";
    // Expect edge: <isUndef> -[ASSIGNED_FROM]-> <val === void 0>
    // Expect edge: <sideEffectRan> -[ASSIGNED_FROM]-> <false>
    // Expect edge: <sideEffectRan = true> -[WRITES_TO]-> <sideEffectRan>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <val !== void 0 ? val : 'fallback'>
    // Expect edge: <val !== void 0 ? val : 'fallback'> -[HAS_ALTERNATE]-> <'fallback'>
    void code;
  });

  test('iterators::iter-usage-for-of', () => {
    const code = "function consumeRange(start, end) {\n  const range = new Range(start, end);\n  const values = [];\n  for (const n of range) {\n    values.push(n);\n  }\n  return values;\n}";
    // Expect edge: <range> -[ASSIGNED_FROM]-> <new Range(start, end)>
    // Expect edge: <values> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('iterators::iter-usage-destructuring', () => {
    const code = "function destructureRange(start, end) {\n  const [first, second, ...rest] = new Range(start, end);\n  return { first, second, rest };\n}\n\n// --- Iterator protocol manual ---";
    // Expect edge: <first> -[ASSIGNED_FROM]-> <new Range(start, end)>
    // Expect edge: <second> -[ASSIGNED_FROM]-> <new Range(start, end)>
    // Expect edge: <rest> -[ASSIGNED_FROM]-> <new Range(start, end)>
    void code;
  });

  test('builtins::builtin-finalization-registry', () => {
    const code = "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---";
    // Expect edge: <registry> -[ASSIGNED_FROM]-> <new FinalizationRegistry(...)>
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ id: 1 }>
    void code;
  });

  test('index::module-namespace-as-value', () => {
    const code = "function useNamespaceAsValue(ns) {\n  const fn = ns[arguments[1]]; // dynamic dispatch through namespace\n  return typeof fn === 'function' ? fn() : undefined;\n}\nconst helperResult = useNamespaceAsValue(allHelpers, 'helperFunction');";
    // Expect edge: <fn> -[ASSIGNED_FROM]-> <ns[arguments[1]]>
    // Expect edge: <useNamespaceAsValue> -[HAS_ALTERNATE]-> <undefined>
    // Expect edge: <helperResult> -[ASSIGNED_FROM]-> <useNamespaceAsValue(allHelpers, 'helperFunction')>
    void code;
  });

  test('iterators::iter-generator-iterable', () => {
    const code = "function* rangeGenerator(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\n// --- Custom async iterable ---";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <start>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('iterators::iter-infinite', () => {
    const code = "function naturals() {\n  let n = 1;\n  return {\n    [Symbol.iterator]() { return this; },\n    next() {\n      return { value: n++, done: false };\n    },\n  };\n}";
    // Expect edge: <n> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <n++> -[WRITES_TO]-> <n>
    void code;
  });

  test('iterators::iter-take', () => {
    const code = "function take(iterable, count) {\n  const result = [];\n  let i = 0;\n  for (const value of iterable) {\n    if (i++ >= count) break;\n    result.push(value);\n  }\n  return result;\n}\n\n// --- Generator as iterable ---";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('iterators::iter-manual-next', () => {
    const code = "function manualIteration(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  const results = [];\n  let step = iterator.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = iterator.next();\n  }\n  return results;\n}\n\n// --- Iterator with return() ---";
    // Expect edge: <iterator> -[ASSIGNED_FROM]-> <iterable[Symbol.iterator]()>
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <step> -[ASSIGNED_FROM]-> <iterator.next()>
    // Expect edge: <step = iterator.next()> -[WRITES_TO]-> <step>
    void code;
  });

  test('iterators::iter-async-for-await', () => {
    const code = "async function consumeAsyncRange(start, end) {\n  const values = [];\n  for await (const n of new AsyncRange(start, end, 0)) {\n    values.push(n);\n  }\n  return values;\n}\n\n// --- Async generator as async iterable ---";
    // Expect edge: <values> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('jsdoc-types::jsdoc-type-variable', () => {
    const code = "/** @type {Map<string, Function>} */\nconst handlers = new Map();\n\n/** @type {string | null} */\nlet currentUser = null;\n\n/** @type {readonly number[]} */\nconst PRIMES = [2, 3, 5, 7, 11];";
    // Expect edge: <handlers> -[ASSIGNED_FROM]-> <new Map()>
    // Expect edge: <currentUser> -[ASSIGNED_FROM]-> <null>
    // Expect edge: <PRIMES> -[ASSIGNED_FROM]-> <[2, 3, 5, 7, 11]>
    void code;
  });

  test('jsdoc-types::jsdoc-enum', () => {
    const code = "/** @enum {string} */\nconst Priority = {\n  Low: 'low',\n  Medium: 'medium',\n  High: 'high',\n};";
    // Expect edge: <Priority> -[ASSIGNED_FROM]-> <Priority-object>
    void code;
  });

  test('jsdoc-types::jsdoc-typedef', () => {
    const code = "/**\n * @typedef {Object} UserDef\n * @property {number} id\n * @property {string} name\n * @property {string} [email]\n */\n\n/** @type {UserDef} */\nconst admin = { id: 1, name: 'admin' };";
    // Expect edge: <admin> -[ASSIGNED_FROM]-> <{ id: 1, name: 'admin' }>
    void code;
  });

  test('iterators::export-named-list', () => {
    const code = "export {\n  Range,\n  consumeRange,\n  spreadRange,\n  destructureRange,\n  manualIteration,\n  createCleanupIterator,\n  naturals,\n  take,\n  rangeGenerator,\n  AsyncRange,\n  consumeAsyncRange,\n  asyncMap,\n  mapIter,\n  filterIter,\n  chainIter,\n  zipIter,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <Range>
    // Expect edge: <export-named-list> -[EXPORTS]-> <consumeRange>
    // Expect edge: <export-named-list> -[EXPORTS]-> <spreadRange>
    // Expect edge: <export-named-list> -[EXPORTS]-> <destructureRange>
    // Expect edge: <export-named-list> -[EXPORTS]-> <manualIteration>
    // Expect edge: <export-named-list> -[EXPORTS]-> <createCleanupIterator>
    // Expect edge: <export-named-list> -[EXPORTS]-> <naturals>
    // Expect edge: <export-named-list> -[EXPORTS]-> <take>
    // Expect edge: <export-named-list> -[EXPORTS]-> <rangeGenerator>
    // Expect edge: <export-named-list> -[EXPORTS]-> <AsyncRange>
    // Expect edge: <export-named-list> -[EXPORTS]-> <consumeAsyncRange>
    // Expect edge: <export-named-list> -[EXPORTS]-> <asyncMap>
    // Expect edge: <export-named-list> -[EXPORTS]-> <mapIter>
    // Expect edge: <export-named-list> -[EXPORTS]-> <filterIter>
    // Expect edge: <export-named-list> -[EXPORTS]-> <chainIter>
    // Expect edge: <export-named-list> -[EXPORTS]-> <zipIter>
    void code;
  });

  test('jsdoc-types::jsdoc-template', () => {
    const code = "/**\n * @template T\n * @param {T[]} items\n * @returns {T | undefined}\n */\nfunction first(items) {\n  return items[0];\n}\n\n/**\n * @template K, V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} fallback\n * @returns {V}\n */\nfunction getOrDefault(map, key, fallback) {\n  return map.has(key) ? map.get(key) : fallback;\n}";
    // Expect edge: <map.has(key) ? map.get(key) : fallback> -[HAS_ALTERNATE]-> <fallback>
    void code;
  });

  test('legacy-patterns::amd-require-call', () => {
    const code = "// require(['app/main', 'app/config'], function(main, config) {\n//   main.start(config);\n// });\n\n// --- UMD (Universal Module Definition) ---";
    // Expect edge: <main> -[ASSIGNED_FROM]-> <'app/main'>
    // Expect edge: <config> -[ASSIGNED_FROM]-> <'app/config'>
    void code;
  });

  test('jsdoc-types::export-named-list', () => {
    const code = "export {\n  createUser,\n  handlers,\n  currentUser,\n  PRIMES,\n  admin,\n  first,\n  getOrDefault,\n  applyDefaults,\n  NumberRange,\n  Priority,\n  isPositive,\n  convert,\n  greetThis,\n  oldProcess,\n  DataStore,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <createUser>
    // Expect edge: <export-named-list> -[EXPORTS]-> <handlers>
    // Expect edge: <export-named-list> -[EXPORTS]-> <currentUser>
    // Expect edge: <export-named-list> -[EXPORTS]-> <PRIMES>
    // Expect edge: <export-named-list> -[EXPORTS]-> <admin>
    // Expect edge: <export-named-list> -[EXPORTS]-> <first>
    // Expect edge: <export-named-list> -[EXPORTS]-> <getOrDefault>
    // Expect edge: <export-named-list> -[EXPORTS]-> <applyDefaults>
    // Expect edge: <export-named-list> -[EXPORTS]-> <NumberRange>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Priority>
    // Expect edge: <export-named-list> -[EXPORTS]-> <isPositive>
    // Expect edge: <export-named-list> -[EXPORTS]-> <convert>
    // Expect edge: <export-named-list> -[EXPORTS]-> <greetThis>
    // Expect edge: <export-named-list> -[EXPORTS]-> <oldProcess>
    // Expect edge: <export-named-list> -[EXPORTS]-> <DataStore>
    void code;
  });

  test('jsdoc-types::jsdoc-callback', () => {
    const code = "/**\n * @callback Predicate\n * @param {unknown} value\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst isPositive = (value) => typeof value === 'number' && value > 0;";
    // Expect edge: <isPositive> -[ASSIGNED_FROM]-> <isPositive:fn>
    void code;
  });

  test('jsdoc-types::jsdoc-overload', () => {
    const code = "/**\n * @overload\n * @param {string} value\n * @returns {number}\n */\n/**\n * @overload\n * @param {number} value\n * @returns {string}\n */\n/**\n * @param {string | number} value\n * @returns {number | string}\n */\nfunction convert(value) {\n  return typeof value === 'string' ? Number(value) : String(value);\n}";
    // Expect edge: <ternary> -[HAS_ALTERNATE]-> <String(value)>
    void code;
  });

  test('jsdoc-types::jsdoc-implements', () => {
    const code = "/** @implements {Iterable<number>} */\nclass NumberRange {\n  /** @param {number} start @param {number} end */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  [Symbol.iterator]() {\n    let i = this.start;\n    const end = this.end;\n    return { next() { return i <= end ? { value: i++, done: false } : { done: true }; } };\n  }\n}";
    // Expect edge: <NumberRange.constructor> -[WRITES_TO]-> <this.start>
    // Expect edge: <NumberRange.constructor> -[WRITES_TO]-> <this.end>
    // Expect edge: <this.start> -[ASSIGNED_FROM]-> <start>
    // Expect edge: <this.end> -[ASSIGNED_FROM]-> <end>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <this.start>
    // Expect edge: <end:local> -[ASSIGNED_FROM]-> <this.end>
    // Expect edge: <i++> -[WRITES_TO]-> <i>
    void code;
  });

  test('jsdoc-types::jsdoc-class-fields', () => {
    const code = "class DataStore {\n  /** @type {Map<string, unknown>} */\n  store = new Map();\n\n  /** @private */\n  _cache = {};\n\n  /**\n   * @param {string} key\n   * @param {unknown} value\n   */\n  set(key, value) {\n    this.store.set(key, value);\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this.store.size;\n  }\n}";
    // Expect edge: <DataStore.store> -[ASSIGNED_FROM]-> <new Map()>
    // Expect edge: <DataStore._cache> -[ASSIGNED_FROM]-> <{}>
    void code;
  });

  test('legacy-patterns::global-namespace-init', () => {
    const code = "var MyApp = MyApp || {};\nMyApp.utils = MyApp.utils || {};\nMyApp.utils.format = function (str) { return str.trim(); };";
    // Expect edge: <MyApp> -[ASSIGNED_FROM]-> <MyApp || {}>
    // Expect edge: <MyApp.utils> -[ASSIGNED_FROM]-> <MyApp.utils || {}>
    // Expect edge: <MyApp.utils.format> -[ASSIGNED_FROM]-> <format>
    void code;
  });

  test('legacy-patterns::global-namespace-revealing', () => {
    const code = "var RevealingModule = (function () {\n  var secret = 'hidden';\n  function getSecret() { return secret; }\n  function setSecret(s) { secret = s; }\n  return { get: getSecret, set: setSecret };\n})();\n\n// --- Polyfill Patterns ---";
    // Expect edge: <RevealingModule> -[ASSIGNED_FROM]-> <IIFE-call>
    // Expect edge: <secret> -[ASSIGNED_FROM]-> <'hidden'>
    // Expect edge: <setSecret> -[WRITES_TO]-> <secret>
    // Expect edge: <secret> -[ASSIGNED_FROM]-> <s>
    // Expect edge: <getSecret> -[CAPTURES]-> <secret>
    // Expect edge: <setSecret> -[CAPTURES]-> <secret>
    void code;
  });

  test('legacy-patterns::babel-class-call-check', () => {
    const code = "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}";
    // Expect edge: <instanceof-check> -[THROWS]-> <new TypeError(...)>
    void code;
  });

  test('legacy-patterns::global-namespace-iife', () => {
    const code = "var MyApp2 = (function (ns) {\n  var _private = 0;\n  ns.increment = function () { return ++_private; };\n  ns.getValue = function () { return _private; };\n  return ns;\n}(MyApp2 || {}));";
    // Expect edge: <MyApp2> -[ASSIGNED_FROM]-> <iife>
    // Expect edge: <_private> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <ns.increment> -[ASSIGNED_FROM]-> <increment:fn>
    // Expect edge: <++_private> -[MODIFIES]-> <_private>
    // Expect edge: <ns.getValue> -[ASSIGNED_FROM]-> <getValue:fn>
    // Expect edge: <iife> -[WRITES_TO]-> <ns.increment>
    // Expect edge: <iife> -[WRITES_TO]-> <ns.getValue>
    void code;
  });

  test('legacy-patterns::babel-class-compiled', () => {
    const code = "// Source: class Dog extends Animal { constructor(name) { super(name); } }\n// Compiled:\nvar Dog = (function (_Animal) {\n  _inherits(Dog, _Animal);\n  function Dog(name) {\n    _classCallCheck(this, Dog);\n    return _Animal.call(this, name);\n  }\n  return Dog;\n}(Animal));\n\n// --- TypeScript Compiled Output ---";
    // Expect edge: <Dog> -[ASSIGNED_FROM]-> <Dog:iife>
    void code;
  });

  test('legacy-patterns::babel-inherits', () => {
    const code = "function _inherits(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true }\n  });\n  if (superClass) Object.setPrototypeOf(subClass, superClass);\n}";
    // Expect edge: <subClass.prototype> -[ASSIGNED_FROM]-> <Object.create>
    void code;
  });

  test('legacy-patterns::polyfill-promise', () => {
    const code = "if (typeof Promise === 'undefined') {\n  // Simplified polyfill shape — real ones are 200+ lines\n  function Promise(executor) {\n    this._state = 'pending';\n    this._value = undefined;\n    this._callbacks = [];\n    executor(this._resolve.bind(this), this._reject.bind(this));\n  }\n  Promise.prototype.then = function (onFulfilled, onRejected) { /* ... */ };\n  Promise.prototype._resolve = function (value) { /* ... */ };\n  Promise.prototype._reject = function (reason) { /* ... */ };\n}";
    // Expect edge: <Promise> -[WRITES_TO]-> <this._state>
    // Expect edge: <this._state> -[ASSIGNED_FROM]-> <'pending'>
    // Expect edge: <Promise> -[WRITES_TO]-> <this._value>
    // Expect edge: <this._value> -[ASSIGNED_FROM]-> <undefined>
    // Expect edge: <Promise> -[WRITES_TO]-> <this._callbacks>
    // Expect edge: <this._callbacks> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('legacy-patterns::jquery-extend-pattern', () => {
    const code = "// $.extend(true, target, source1, source2); // deep merge\n// $.extend($.fn, { newPlugin: function() {} }); // add to prototype";
    // Expect edge: <$.extend(true, target, source1, source2)> -[MODIFIES]-> <target>
    // Expect edge: <$.extend($.fn, { newPlugin: function() {} })> -[MODIFIES]-> <$.fn>
    void code;
  });

  test('legacy-patterns::polyfill-symbol-shim', () => {
    const code = "if (typeof Symbol === 'undefined') {\n  var Symbol = function (description) {\n    return '__symbol_' + (description || '') + '_' + Math.random().toString(36);\n  };\n  Symbol.iterator = '@@iterator';\n}\n\n// --- Babel Compiled Output ---";
    // Expect edge: <Symbol> -[ASSIGNED_FROM]-> <Symbol:polyfill>
    // Expect edge: <if-symbol-undefined> -[WRITES_TO]-> <Symbol.iterator>
    // Expect edge: <Symbol.iterator> -[ASSIGNED_FROM]-> <'@@iterator'>
    void code;
  });

  test('legacy-patterns::polyfill-prototype-method', () => {
    const code = "if (!Array.prototype.flat) {\n  Array.prototype.flat = function (depth) {\n    depth = depth === undefined ? 1 : Math.floor(depth);\n    if (depth < 1) return Array.prototype.slice.call(this);\n    return Array.prototype.reduce.call(this, function (acc, val) {\n      return acc.concat(Array.isArray(val) && depth > 1 ? val.flat(depth - 1) : val);\n    }, []);\n  };\n}";
    // Expect edge: <Array.prototype.flat> -[ASSIGNED_FROM]-> <polyfill-flat>
    // Expect edge: <depth> -[ASSIGNED_FROM]-> <depth-ternary>
    // Expect edge: <depth-ternary> -[HAS_ALTERNATE]-> <Math.floor>
    // Expect edge: <ternary-arg> -[HAS_ALTERNATE]-> <val>
    void code;
  });

  test('modern-es::modern-array-at', () => {
    const code = "function arrayAt(arr) {\n  const first = arr.at(0);\n  const last = arr.at(-1);\n  const second = arr.at(1);\n  return { first, last, second };\n}";
    // Expect edge: <first> -[ASSIGNED_FROM]-> <arr.at(0)>
    // Expect edge: <last> -[ASSIGNED_FROM]-> <arr.at(-1)>
    // Expect edge: <second> -[ASSIGNED_FROM]-> <arr.at(1)>
    void code;
  });

  test('legacy-patterns::ts-compiled-spread', () => {
    const code = "var __spreadArray = function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};";
    // Expect edge: <__spreadArray> -[ASSIGNED_FROM]-> <__spreadArray:fn>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <il> -[ASSIGNED_FROM]-> <from.length>
    // Expect edge: <j> -[ASSIGNED_FROM]-> <to.length>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <j++> -[MODIFIES]-> <j>
    // Expect edge: <to[j] = from[i]> -[WRITES_TO]-> <to[j]>
    void code;
  });

  test('legacy-patterns::jquery-plugin-pattern', () => {
    const code = "// $.fn.highlight = function(color) {\n//   return this.each(function() {\n//     $(this).css('background-color', color || 'yellow');\n//   });\n// };\n// Usage: $('p').highlight('red');";
    // Expect edge: <$.fn.highlight> -[ASSIGNED_FROM]-> <highlight:fn>
    void code;
  });

  test('legacy-patterns::jquery-deferred', () => {
    const code = "// var dfd = $.Deferred();\n// dfd.done(function(data) { ... });\n// dfd.fail(function(err) { ... });\n// dfd.resolve(result); // or dfd.reject(error);\n\n// --- Script Concatenation / Namespace Export ---";
    // Expect edge: <dfd> -[ASSIGNED_FROM]-> <$.Deferred()>
    void code;
  });

  test('modern-es::modern-array-findlast', () => {
    const code = "function arrayFindLast(arr) {\n  const last = arr.findLast(x => x > 3);\n  const lastIdx = arr.findLastIndex(x => x > 3);\n  return { last, lastIdx };\n}";
    // Expect edge: <last> -[ASSIGNED_FROM]-> <arr.findLast(x => x > 3)>
    // Expect edge: <lastIdx> -[ASSIGNED_FROM]-> <arr.findLastIndex(x => x > 3)>
    void code;
  });

  test('modern-es::modern-promise-with-resolvers', () => {
    const code = "function createDeferred() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  return { promise, resolve, reject };\n}\n\n// --- Error.cause usage ---";
    // Expect edge: <promise> -[ASSIGNED_FROM]-> <Promise.withResolvers()>
    // Expect edge: <resolve> -[ASSIGNED_FROM]-> <Promise.withResolvers()>
    // Expect edge: <reject> -[ASSIGNED_FROM]-> <Promise.withResolvers()>
    void code;
  });

  test('modern-es::modern-error-cause', () => {
    const code = "function wrapError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    throw new Error('Wrapper failed', { cause: err });\n  }\n}\n\n// --- Object.hasOwn (ES2022) ---";
    // Expect edge: <catch-block> -[THROWS]-> <new Error()>
    void code;
  });

  test('modern-es::modern-using-sync', () => {
    const code = "function usingSyncExample() {\n  // Symbol.dispose — synchronous cleanup\n  const resource = {\n    data: 'important',\n    [Symbol.dispose]() {\n      this.data = null;\n    },\n  };\n  return resource;\n}";
    // Expect edge: <resource> -[ASSIGNED_FROM]-> <resource-object>
    // Expect edge: <data-property> -[ASSIGNED_FROM]-> <'important'>
    // Expect edge: <resource[Symbol.dispose]> -[WRITES_TO]-> <this.data>
    // Expect edge: <this.data> -[ASSIGNED_FROM]-> <null>
    void code;
  });

  test('modern-es::modern-using-async', () => {
    const code = "async function usingAsyncExample() {\n  const resource = {\n    data: 'important',\n    async [Symbol.asyncDispose]() {\n      await new Promise(r => setTimeout(r, 10));\n      this.data = null;\n    },\n  };\n  return resource;\n}\n\n// --- Iterator helpers (ES2025) ---";
    // Expect edge: <resource[Symbol.asyncDispose]> -[WRITES_TO]-> <this.data>
    // Expect edge: <this.data> -[ASSIGNED_FROM]-> <null>
    void code;
  });

  test('modern-es::modern-symbol-toprimitive', () => {
    const code = "class Money {\n  constructor(amount, currency) {\n    this.amount = amount;\n    this.currency = currency;\n  }\n\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return this.amount;\n    if (hint === 'string') return `${this.amount} ${this.currency}`;\n    return this.amount;\n  }\n}";
    // Expect edge: <this.amount> -[ASSIGNED_FROM]-> <amount>
    // Expect edge: <this.currency> -[ASSIGNED_FROM]-> <currency>
    void code;
  });

  test('modern-es::class-accessor-keyword', () => {
    const code = "class Reactive {\n  accessor count = 0;\n}\n\n// --- Import Attributes (ES2025) ---";
    // Expect edge: <Reactive.count> -[ASSIGNED_FROM]-> <0>
    void code;
  });

  test('modern-es::modern-iterator-helpers', () => {
    const code = "function iteratorHelpers(arr) {\n  // Iterator.from, .map, .filter, .take, .drop, .flatMap, .reduce, .toArray, .forEach, .some, .every, .find\n  const iter = arr.values();\n  const mapped = iter.map(x => x * 2);\n  const taken = mapped.take(3);\n  return [...taken];\n}\n\n// --- Set methods (ES2025) ---";
    // Expect edge: <iter> -[ASSIGNED_FROM]-> <arr.values()>
    // Expect edge: <mapped> -[ASSIGNED_FROM]-> <iter.map(x => x * 2)>
    // Expect edge: <taken> -[ASSIGNED_FROM]-> <mapped.take(3)>
    void code;
  });

  test('builtins::builtin-regex-named-groups', () => {
    const code = "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---";
    // Expect edge: <pattern> -[ASSIGNED_FROM]-> </(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/>
    // Expect edge: <match> -[ASSIGNED_FROM]-> <dateStr.match(pattern)>
    // Expect edge: <year> -[ASSIGNED_FROM]-> <match.groups>
    // Expect edge: <month> -[ASSIGNED_FROM]-> <match.groups>
    // Expect edge: <day> -[ASSIGNED_FROM]-> <match.groups>
    void code;
  });

  test('modern-es::modern-regex-indices', () => {
    const code = "function regexIndices(str) {\n  const regex = /(?<word>\\w+)/gd;\n  const match = regex.exec(str);\n  if (!match) return null;\n  const { indices } = match;\n  return { match: match[0], start: indices[0][0], end: indices[0][1], groups: indices.groups };\n}\n\n// --- Top-level await (ES2022) — already in async-generators.js, reference only ---\n\n// --- Logical assignment already in expressions.js (&&=, ||=, ??=) ---\n\n// --- Private class fields / methods already in classes.js ---\n\n// --- Class static block already in classes.js ---\n\n// --- Symbols: well-known symbols ---";
    // Expect edge: <regex> -[ASSIGNED_FROM]-> </(?<word>\w+)/gd>
    // Expect edge: <match> -[ASSIGNED_FROM]-> <regex.exec(str)>
    // Expect edge: <indices> -[ASSIGNED_FROM]-> <match.indices>
    void code;
  });

  test('modules-default-anon::export-default-anonymous-function', () => {
    const code = "export default function() {\n  return 'anonymous but hoisted';\n}\n\n// Only one `export default` per module — other forms as comments:";
    // Expect edge: <default-export> -[EXPORTS]-> <anonymous-default-function>
    void code;
  });

  test('modern-es::import-attributes-reexport', () => {
    const code = "// export { default as schema } from './schema.json' with { type: 'json' };\n\n// --- import.meta.resolve() (ES2025) ---";
    // Expect edge: <export-schema> -[EXPORTS]-> <schema>
    void code;
  });

  test('modules-helpers::export-inline-function', () => {
    const code = "export function helperFunction() {\n  return 'help';\n}";
    // Expect edge: <module> -[EXPORTS]-> <helperFunction>
    void code;
  });

  test('modern-es::modern-abort-controller', () => {
    const code = "async function fetchWithAbort(url, timeoutMs) {\n  const controller = new AbortController();\n  const { signal } = controller;\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal });\n    return await response.json();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// --- Disposable resources (ES2025) ---";
    // Expect edge: <controller> -[ASSIGNED_FROM]-> <new AbortController()>
    // Expect edge: <signal> -[ASSIGNED_FROM]-> <controller.signal>
    // Expect edge: <timeoutId> -[ASSIGNED_FROM]-> <setTimeout(...)>
    // Expect edge: <response> -[ASSIGNED_FROM]-> <fetch(url, { signal })>
    void code;
  });

  test('modules-default-anon::export-default-anonymous-class', () => {
    const code = "// export default class { run() { return 'anonymous class'; } }";
    // Expect edge: <default-export> -[EXPORTS]-> <anonymous-class>
    void code;
  });

  test('modern-es::using-declaration', () => {
    const code = "function usingDeclaration() {\n  function openFile(path) {\n    return {\n      path,\n      read() { return `contents of ${path}`; },\n      [Symbol.dispose]() { console.log(`closed ${path}`); },\n    };\n  }\n  using handle = openFile('/tmp/test');\n  return handle.read();\n}";
    // Expect edge: <handle> -[ASSIGNED_FROM]-> <openFile('/tmp/test')>
    void code;
  });

  test('modern-es::import-attributes-dynamic', () => {
    const code = "// const data = await import('./data.json', { with: { type: 'json' } });";
    // Expect edge: <data> -[ASSIGNED_FROM]-> <await import('./data.json', { with: { type: 'json' } })>
    void code;
  });

  test('modern-es::using-await-declaration', () => {
    const code = "async function usingAwaitDeclaration() {\n  function openStream(url) {\n    return {\n      url,\n      async readAll() { return 'data'; },\n      async [Symbol.asyncDispose]() { console.log(`closed ${url}`); },\n    };\n  }\n  await using stream = await openStream('http://example.com');\n  return stream.readAll();\n}";
    // Expect edge: <stream> -[ASSIGNED_FROM]-> <openStream('http://example.com')>
    void code;
  });

  test('modules-helpers::export-inline-class', () => {
    const code = "export class HelperClass {\n  method() {\n    return true;\n  }\n}";
    // Expect edge: <module> -[EXPORTS]-> <HelperClass>
    void code;
  });

  test('modules-helpers::export-default-function', () => {
    const code = "export default function defaultHelper() {\n  return 'default';\n}";
    // Expect edge: <export-default> -[EXPORTS]-> <defaultHelper>
    void code;
  });

  test('modules-helpers::export-inline-const', () => {
    const code = "export const HELPER_CONST = 42;";
    // Expect edge: <HELPER_CONST> -[ASSIGNED_FROM]-> <42>
    // Expect edge: <export-HELPER_CONST> -[EXPORTS]-> <HELPER_CONST>
    void code;
  });

  test('modules-helpers::export-default-class', () => {
    const code = "// export default class Router { navigate() { return '/'; } }\n// Also valid: export default class { anonymous() {} }\n// (Only one default export per module — shown above as function)";
    // Expect edge: <default-export> -[EXPORTS]-> <Router>
    void code;
  });

  test('modules-helpers::export-as-default', () => {
    const code = "// Alternative syntax for default export:\n// export { someFunction as default };\n// Semantically equivalent to export default, but uses named export syntax";
    // Expect edge: <export-as-default> -[EXPORTS]-> <someFunction>
    void code;
  });

  test('modules-default-anon::export-default-expression', () => {
    const code = "// export default [1, 2, 3];\n// export default { key: 'value' };\n// export default 42;";
    // Expect edge: <export-default-array> -[EXPORTS]-> <[1, 2, 3]>
    // Expect edge: <export-default-object> -[EXPORTS]-> <{ key: 'value' }>
    // Expect edge: <export-default-number> -[EXPORTS]-> <42>
    void code;
  });

  test('modern-es::import-meta-resolve', () => {
    const code = "const workerUrl = import.meta.resolve('./modules-helpers.js');\n\nasync function loadOptional(specifier) {\n  try {\n    const url = import.meta.resolve(specifier);\n    return await import(url);\n  } catch {\n    return null;\n  }\n}\n\n// --- WeakRef and FinalizationRegistry ---";
    // Expect edge: <workerUrl> -[ASSIGNED_FROM]-> <import.meta.resolve('./modules-helpers.js')>
    // Expect edge: <url> -[ASSIGNED_FROM]-> <import.meta.resolve(specifier)>
    void code;
  });

  test('modules-helpers::export-default-expression', () => {
    const code = "// export default [1, 2, 3];\n// export default 42;\n// Any expression can be a default export";
    // Expect edge: <export-default-array> -[EXPORTS]-> <[1, 2, 3]>
    // Expect edge: <export-default-number> -[EXPORTS]-> <42>
    void code;
  });

  test('modules-reexport::reexport-named', () => {
    const code = "export { helperFunction } from './modules-helpers.js';";
    // Expect edge: <export-helperFunction> -[EXPORTS]-> <helperFunction>
    void code;
  });

  test('modules-reexport::reexport-aliased', () => {
    const code = "export { HELPER_CONST as RENAMED_CONST } from './modules-helpers.js';";
    // Expect edge: <reexport-aliased> -[EXPORTS]-> <RENAMED_CONST>
    void code;
  });

  test('modern-es::finalization-registry', () => {
    const code = "const cleanupRegistry = new FinalizationRegistry((key) => {\n  console.log(`Object for key \"${key}\" was garbage collected`);\n});\n\nfunction trackObject(key, obj) {\n  cleanupRegistry.register(obj, key);\n}";
    // Expect edge: <cleanupRegistry> -[ASSIGNED_FROM]-> <new FinalizationRegistry>
    void code;
  });

  test('modules-reexport::reexport-default-as-named', () => {
    const code = "export { default as defaultFn } from './modules-helpers.js';";
    // Expect edge: <export-default-as-named> -[EXPORTS]-> <defaultFn>
    // Expect edge: <./modules-helpers.js> -[EXPORTS]-> <./modules-helpers.js:default>
    void code;
  });

  test('modules-helpers::export-multiple-names-same-binding', () => {
    const code = "const sharedValue = 'shared';\nexport { sharedValue, sharedValue as sharedAlias, sharedValue as sharedOther };";
    // Expect edge: <sharedValue> -[ASSIGNED_FROM]-> <'shared'>
    // Expect edge: <export-sharedValue> -[EXPORTS]-> <sharedValue>
    // Expect edge: <export-sharedAlias> -[EXPORTS]-> <sharedValue>
    // Expect edge: <export-sharedOther> -[EXPORTS]-> <sharedValue>
    void code;
  });

  test('modules-reexport::reexport-namespace', () => {
    const code = "export * as helpers from './modules-helpers.js';\n\n// --- Multi-file module patterns (construct references only) ---";
    // Expect edge: <export-namespace> -[EXPORTS]-> <import-all>
    void code;
  });

  test('modern-es::weakref-cache', () => {
    const code = "function createWeakCache() {\n  const cache = new Map();\n  return {\n    get(key, factory) {\n      const ref = cache.get(key);\n      const cached = ref?.deref();\n      if (cached) return cached;\n      const fresh = factory();\n      cache.set(key, new WeakRef(fresh));\n      return fresh;\n    },\n  };\n}";
    // Expect edge: <cache> -[ASSIGNED_FROM]-> <new Map()>
    // Expect edge: <ref> -[ASSIGNED_FROM]-> <cache.get(key)>
    // Expect edge: <cached> -[ASSIGNED_FROM]-> <ref?.deref()>
    // Expect edge: <fresh> -[ASSIGNED_FROM]-> <factory()>
    // Expect edge: <cache.set(key, new WeakRef(fresh))> -[WRITES_TO]-> <cache>
    void code;
  });

  test('patterns::obj-destructuring-nested', () => {
    const code = "function objectDestructuringNested() {\n  const data = { outer: { inner: { deep: 42 } } };\n  const { outer: { inner: { deep } } } = data;\n  return deep;\n}";
    // Expect edge: <data> -[ASSIGNED_FROM]-> <{ outer: { inner: { deep: 42 } } }>
    // Expect edge: <{ outer: { inner: { deep } } }> -[ASSIGNED_FROM]-> <deep>
    void code;
  });

  test('modules-reexport::star-import-namespace', () => {
    const code = "// import * as utils from './modules-helpers.js';\n// utils.helperFunction();          // method on namespace object\n// const { helperFunction } = utils; // destructured from namespace\n// const fn = utils['helperFunction']; // bracket access on namespace";
    // Expect edge: <helperFunction> -[ASSIGNED_FROM]-> <utils>
    // Expect edge: <fn> -[ASSIGNED_FROM]-> <utils['helperFunction']>
    void code;
  });

  test('patterns::param-destructuring-object', () => {
    const code = "function withObjectParam({ name, age, role = 'guest' }) {\n  return `${name} (${age}) - ${role}`;\n}";
    // Expect edge: <destructured-param> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <destructured-param> -[ASSIGNED_FROM]-> <age>
    // Expect edge: <destructured-param> -[ASSIGNED_FROM]-> <role>
    void code;
  });

  test('patterns::array-destructuring-swap', () => {
    const code = "function arrayDestructuringSwap() {\n  let left = 'left';\n  let right = 'right';\n  [left, right] = [right, left];\n  return { left, right };\n}";
    // Expect edge: <left> -[ASSIGNED_FROM]-> <'left'>
    // Expect edge: <right> -[ASSIGNED_FROM]-> <'right'>
    // Expect edge: <[left, right]> -[ASSIGNED_FROM]-> <[right, left]>
    // Expect edge: <[left, right]> -[WRITES_TO]-> <left>
    // Expect edge: <[left, right]> -[WRITES_TO]-> <right>
    void code;
  });

  test('modules-reexport::circular-import-live-binding', () => {
    const code = "// File A: export let count = 0; export function inc() { count++; }\n// File B: import { count, inc } from './a.js'; inc(); console.log(count); // 1 — live binding!\n// Graph impact: imported let is NOT a copy — mutations in source module visible to importers";
    // Expect edge: <count> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <count++> -[MODIFIES]-> <count>
    // Expect edge: <fileA> -[EXPORTS]-> <count>
    // Expect edge: <fileA> -[EXPORTS]-> <inc>
    void code;
  });

  test('patterns::param-destructuring-array', () => {
    const code = "function withArrayParam([first, second, ...rest]) {\n  return { first, second, rest };\n}";
    // Expect edge: <arrayParam> -[ASSIGNED_FROM]-> <first>
    // Expect edge: <arrayParam> -[ASSIGNED_FROM]-> <second>
    // Expect edge: <arrayParam> -[ASSIGNED_FROM]-> <rest>
    void code;
  });

  test('modules-reexport::star-reexport-collision', () => {
    const code = "// a.js: export const x = 1;\n// b.js: export const x = 2;\n// barrel.js: export * from './a'; export * from './b'; // x is ambiguous!\n// Explicit re-export wins: export * from './a'; export { x } from './b';";
    // Expect edge: <a.js:x> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <a.js> -[EXPORTS]-> <a.js:x>
    // Expect edge: <b.js:x> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <b.js> -[EXPORTS]-> <b.js:x>
    // Expect edge: <star-export-a> -[EXPORTS]-> <a.js:x>
    // Expect edge: <star-export-b> -[EXPORTS]-> <b.js:x>
    // Expect edge: <explicit-x-export> -[EXPORTS]-> <b.js:x>
    void code;
  });

  test('patterns::param-destructuring-nested', () => {
    const code = "function withNestedParam({ user: { name }, settings: { theme = 'light' } }) {\n  return { name, theme };\n}";
    // Expect edge: <destructured-param> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <destructured-param> -[ASSIGNED_FROM]-> <theme>
    void code;
  });

  test('modules-reexport::import-meta-url', () => {
    const code = "// const __filename = new URL(import.meta.url).pathname;\n// const __dirname = new URL('.', import.meta.url).pathname;\n// const workerUrl = new URL('./worker.js', import.meta.url); // implicit file dependency";
    // Expect edge: <__filename> -[ASSIGNED_FROM]-> <new URL(import.meta.url).pathname>
    // Expect edge: <__dirname> -[ASSIGNED_FROM]-> <new URL('.', import.meta.url).pathname>
    // Expect edge: <workerUrl> -[ASSIGNED_FROM]-> <new URL('./worker.js', import.meta.url)>
    void code;
  });

  test('patterns::spread-calls', () => {
    const code = "function spreadInCalls() {\n  const args = [1, 2, 3];\n  const max = Math.max(...args);\n  return max;\n}";
    // Expect edge: <args> -[ASSIGNED_FROM]-> <[1, 2, 3]>
    // Expect edge: <max> -[ASSIGNED_FROM]-> <Math.max(...args)>
    void code;
  });

  test('patterns::destructure-assign-nested-target', () => {
    const code = "function destructureAssignNestedTarget() {\n  const state = { user: { name: 'old' } };\n  let name;\n  ({ user: { name } } = state);\n  return name;\n}";
    // Expect edge: <state> -[ASSIGNED_FROM]-> <{ user: { name: 'old' } }>
    // Expect edge: <name> -[ASSIGNED_FROM]-> <state.user.name>
    void code;
  });

  test('patterns::spread-objects', () => {
    const code = "function spreadInObjects() {\n  const base = { a: 1, b: 2 };\n  const extended = { ...base, c: 3, b: 'overridden' };\n  const clone = { ...base };\n  return { extended, clone };\n}";
    // Expect edge: <base> -[ASSIGNED_FROM]-> <{ a: 1, b: 2 }>
    // Expect edge: <extended> -[ASSIGNED_FROM]-> <{ ...base, c: 3, b: 'overridden' }>
    // Expect edge: <clone> -[ASSIGNED_FROM]-> <{ ...base }>
    void code;
  });

  test('patterns::spread-arrays', () => {
    const code = "function spreadInArrays() {\n  const source = [1, 2, 3];\n  const extended = [0, ...source, 4, 5];\n  const clone = [...source];\n  return { extended, clone };\n}";
    // Expect edge: <source> -[ASSIGNED_FROM]-> <[1, 2, 3]>
    // Expect edge: <extended> -[ASSIGNED_FROM]-> <[0, ...source, 4, 5]>
    // Expect edge: <clone> -[ASSIGNED_FROM]-> <[...source]>
    void code;
  });

  test('patterns::destructure-computed-key', () => {
    const code = "function destructureComputedKey() {\n  const key = 'name';\n  const { [key]: value } = { name: 'Alice' };\n  return value;\n}";
    // Expect edge: <key> -[ASSIGNED_FROM]-> <'name'>
    // Expect edge: <{ [key]: value }> -[ASSIGNED_FROM]-> <{ name: 'Alice' }>
    // Expect edge: <{ [key]: value }> -[WRITES_TO]-> <value>
    void code;
  });

  test('patterns::destructure-nested-defaults-combined', () => {
    const code = "function destructureNestedDefaults() {\n  const { a: { b = 10 } = {} } = {};\n  return b; // 10 — default for inner AND outer\n}";
    // Expect edge: <destructuring> -[ASSIGNED_FROM]-> <b>
    // Expect edge: <destructuring> -[ASSIGNED_FROM]-> <{}:source>
    void code;
  });

  test('patterns::destructure-assign-to-properties', () => {
    const code = "function destructureAssignToProperties() {\n  const obj = {};\n  ({ a: obj.x, b: obj.y } = { a: 1, b: 2 });\n  return obj; // { x: 1, y: 2 }\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <destructure-assign> -[WRITES_TO]-> <obj.x>
    // Expect edge: <destructure-assign> -[WRITES_TO]-> <obj.y>
    // Expect edge: <obj.x> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <obj.y> -[ASSIGNED_FROM]-> <2>
    void code;
  });

  test('patterns::spread-duplicate-key-override', () => {
    const code = "function spreadDuplicateKeyOverride(overrides) {\n  // Key 'debug' at positions (1) and (3) with spread between — (3) always wins\n  const config = {\n    debug: false,       // (1) explicit default\n    ...overrides,       // (2) user overrides — may set debug\n    debug: true,        // (3) THIS ALWAYS WINS — overrides the override\n    timestamp: Date.now(),\n  };\n  return config;\n}";
    // Expect edge: <config> -[ASSIGNED_FROM]-> <config-object>
    // Expect edge: <debug-1> -[ASSIGNED_FROM]-> <false>
    // Expect edge: <debug-3> -[ASSIGNED_FROM]-> <true>
    // Expect edge: <timestamp> -[ASSIGNED_FROM]-> <Date.now()>
    void code;
  });

  test('patterns::destructure-computed-default-rename', () => {
    const code = "function destructureComputedDefaultRename() {\n  const key = 'name';\n  const { [key]: renamed = 'anonymous' } = { name: 'Alice' };\n  const { [key]: missing = 'anonymous' } = {};\n  return { renamed, missing };\n}";
    // Expect edge: <key> -[ASSIGNED_FROM]-> <'name'>
    // Expect edge: <renamed> -[ASSIGNED_FROM]-> <destructure1>
    // Expect edge: <missing> -[ASSIGNED_FROM]-> <destructure2>
    void code;
  });

  test('patterns::destructure-nested-rest', () => {
    const code = "function destructureNestedRest() {\n  const [first, ...[second, ...deep]] = [1, 2, 3, 4, 5];\n  // first=1, second=2, deep=[3,4,5]\n  return { first, second, deep };\n}";
    // Expect edge: <[first, ...[second, ...deep]]> -[ASSIGNED_FROM]-> <[1, 2, 3, 4, 5]>
    // Expect edge: <first> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <second> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <deep> -[ASSIGNED_FROM]-> <[3, 4, 5]>
    void code;
  });

  test('property-access::prop-dot-notation', () => {
    const code = "function dotAccess(obj) {\n  const a = obj.name;\n  const b = obj.nested.deep.value;\n  return { a, b };\n}";
    // Expect edge: <a> -[ASSIGNED_FROM]-> <obj.name>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <obj.nested.deep.value>
    void code;
  });

  test('property-access::prop-dynamic-access', () => {
    const code = "function dynamicAccess(obj, keys) {\n  const results = {};\n  for (const key of keys) {\n    results[key] = obj[key];\n  }\n  return results;\n}\n\n// --- Property chain ---";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <results[key]> -[ASSIGNED_FROM]-> <obj[key]>
    // Expect edge: <results[key]> -[WRITES_TO]-> <results>
    void code;
  });

  test('property-access::prop-bracket-notation', () => {
    const code = "function bracketAccess(obj, key) {\n  const a = obj['name'];\n  const b = obj[key];\n  const c = obj['complex-key'];\n  return { a, b, c };\n}";
    // Expect edge: <a> -[ASSIGNED_FROM]-> <obj['name']>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <obj[key]>
    // Expect edge: <c> -[ASSIGNED_FROM]-> <obj['complex-key']>
    void code;
  });

  test('property-access::prop-dot-assign', () => {
    const code = "function dotAssign(obj) {\n  obj.name = 'new';\n  obj.nested = {};\n  obj.nested.deep = 42;\n  return obj;\n}";
    // Expect edge: <obj.name> -[ASSIGNED_FROM]-> <'new'>
    // Expect edge: <dotAssign> -[WRITES_TO]-> <obj.name>
    // Expect edge: <obj.nested> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <dotAssign> -[WRITES_TO]-> <obj.nested>
    // Expect edge: <obj.nested.deep> -[ASSIGNED_FROM]-> <42>
    // Expect edge: <dotAssign> -[WRITES_TO]-> <obj.nested.deep>
    void code;
  });

  test('property-access::prop-bracket-assign', () => {
    const code = "function bracketAssign(obj, key, value) {\n  obj[key] = value;\n  obj['fixed-key'] = 'fixed';\n  return obj;\n}";
    // Expect edge: <obj[key]> -[ASSIGNED_FROM]-> <value>
    // Expect edge: <obj['fixed-key']> -[ASSIGNED_FROM]-> <'fixed'>
    void code;
  });

  test('patterns::destructure-rest-own-only', () => {
    const code = "function destructureRestOwnOnly() {\n  const proto = { inherited: 1 };\n  const child = Object.create(proto);\n  child.own = 2;\n  child.also = 3;\n\n  const { own, ...rest } = child;\n  // rest === { also: 3 } — inherited NOT included in rest\n  // But:\n  const { inherited } = child; // 1 — named destructuring DOES access prototype\n  return { own, rest, inherited };\n}";
    // Expect edge: <proto> -[ASSIGNED_FROM]-> <{ inherited: 1 }>
    // Expect edge: <child> -[ASSIGNED_FROM]-> <Object.create(proto)>
    // Expect edge: <child.own> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <child.also> -[ASSIGNED_FROM]-> <3>
    // Expect edge: <own> -[ASSIGNED_FROM]-> <{ own, ...rest }>
    // Expect edge: <rest> -[ASSIGNED_FROM]-> <{ own, ...rest }>
    // Expect edge: <inherited> -[ASSIGNED_FROM]-> <{ inherited }>
    void code;
  });

  test('property-access::prop-object-keys', () => {
    const code = "function objectEnumeration(obj) {\n  const keys = Object.keys(obj);\n  const values = Object.values(obj);\n  const entries = Object.entries(obj);\n  return { keys, values, entries };\n}";
    // Expect edge: <keys> -[ASSIGNED_FROM]-> <Object.keys(obj)>
    // Expect edge: <values> -[ASSIGNED_FROM]-> <Object.values(obj)>
    // Expect edge: <entries> -[ASSIGNED_FROM]-> <Object.entries(obj)>
    void code;
  });

  test('property-access::prop-freeze', () => {
    const code = "function frozen() {\n  const obj = { a: 1, b: { c: 2 } };\n  Object.freeze(obj);\n  obj.a = 999;       // silently fails (or throws in strict)\n  obj.b.c = 999;     // succeeds — shallow freeze\n  return obj;\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ a: 1, b: { c: 2 } }>
    // Expect edge: <obj.a> -[ASSIGNED_FROM]-> <999>
    // Expect edge: <obj.b.c> -[ASSIGNED_FROM]-> <999-2>
    void code;
  });

  test('property-access::prop-optional-chain-mixed', () => {
    const code = "function optionalChainMixed(obj) {\n  const a = obj?.level1?.level2;\n  const b = obj?.['dynamic-key']?.value;\n  const c = obj?.method?.();\n  const d = obj?.arr?.[0]?.name;\n  return { a, b, c, d };\n}\n\n// --- Property assignment patterns ---";
    // Expect edge: <a> -[ASSIGNED_FROM]-> <obj?.level1?.level2>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <obj?.['dynamic-key']?.value>
    // Expect edge: <c> -[ASSIGNED_FROM]-> <obj?.method?.()>
    // Expect edge: <d> -[ASSIGNED_FROM]-> <obj?.arr?.[0]?.name>
    void code;
  });

  test('property-access::prop-seal', () => {
    const code = "function sealed() {\n  const obj = { a: 1 };\n  Object.seal(obj);\n  obj.a = 2;         // allowed — existing property\n  obj.b = 3;         // silently fails — no new properties\n  delete obj.a;      // silently fails — cannot delete\n  return obj;\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ a: 1 }>
    // Expect edge: <obj.a> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <obj.b> -[ASSIGNED_FROM]-> <3>
    void code;
  });

  test('property-access::prop-delete', () => {
    const code = "function propertyDeletion(obj) {\n  const hadKey = 'key' in obj;\n  delete obj.key;\n  const hasKey = 'key' in obj;\n  return { hadKey, hasKey };\n}\n\n// --- Property enumeration order ---";
    // Expect edge: <hadKey> -[ASSIGNED_FROM]-> <'key' in obj>
    // Expect edge: <hasKey> -[ASSIGNED_FROM]-> <'key' in obj_2>
    void code;
  });

  test('property-access::prop-prevent-extensions', () => {
    const code = "function preventExtensions() {\n  const obj = { a: 1 };\n  Object.preventExtensions(obj);\n  obj.b = 2;         // silently fails\n  obj.a = 99;        // allowed\n  delete obj.a;      // allowed\n  return obj;\n}\n\n// --- Property existence checks ---";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ a: 1 }>
    // Expect edge: <a> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <obj.b> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <preventExtensions> -[WRITES_TO]-> <obj.b>
    // Expect edge: <obj.a> -[ASSIGNED_FROM]-> <99>
    // Expect edge: <preventExtensions> -[WRITES_TO]-> <obj.a>
    void code;
  });

  test('property-access::prop-compound-assign', () => {
    const code = "function compoundPropertyAssign(obj) {\n  obj.count += 1;\n  obj.total -= 5;\n  obj.name += ' suffix';\n  obj.flags |= 0x04;\n  obj.mask &= 0xff;\n  return obj;\n}\n\n// --- Object.keys / values / entries ---";
    // Expect edge: <obj.count += 1> -[WRITES_TO]-> <obj.count>
    // Expect edge: <obj.total -= 5> -[WRITES_TO]-> <obj.total>
    // Expect edge: <obj.name += ' suffix'> -[WRITES_TO]-> <obj.name>
    // Expect edge: <obj.flags |= 0x04> -[WRITES_TO]-> <obj.flags>
    // Expect edge: <obj.mask &= 0xff> -[WRITES_TO]-> <obj.mask>
    void code;
  });

  test('property-access::prop-circular-object', () => {
    const code = "function circularObject() {\n  const a = {};\n  const b = { ref: a };\n  a.ref = b;\n  return a;\n}";
    // Expect edge: <a> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <{ ref: a }>
    // Expect edge: <a.ref> -[ASSIGNED_FROM]-> <b>
    // Expect edge: <circularObject> -[WRITES_TO]-> <a.ref>
    void code;
  });

  test('property-access::prop-object-assign', () => {
    const code = "function objectAssign() {\n  const target = { a: 1 };\n  const source1 = { b: 2 };\n  const source2 = { c: 3, a: 'overridden' };\n  return Object.assign(target, source1, source2);\n}\n\n// --- Object.freeze / seal / preventExtensions ---";
    // Expect edge: <target> -[ASSIGNED_FROM]-> <{ a: 1 }>
    // Expect edge: <target.a> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <source1> -[ASSIGNED_FROM]-> <{ b: 2 }>
    // Expect edge: <source1.b> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <source2> -[ASSIGNED_FROM]-> <{ c: 3, a: 'overridden' }>
    // Expect edge: <source2.c> -[ASSIGNED_FROM]-> <3>
    // Expect edge: <source2.a> -[ASSIGNED_FROM]-> <'overridden'>
    void code;
  });

  test('property-access::prop-proto-direct', () => {
    const code = "function protoDirectAssign() {\n  const obj = {};\n  obj.__proto__ = { inherited: true };\n  return obj.inherited;\n}\n\n// --- Null-prototype dictionary ---";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <obj.__proto__> -[ASSIGNED_FROM]-> <{ inherited: true }>
    // Expect edge: <protoDirectAssign> -[WRITES_TO]-> <obj.__proto__>
    void code;
  });

  test('builtins::builtin-globalthis', () => {
    const code = "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---";
    // Expect edge: <g> -[ASSIGNED_FROM]-> <globalThis>
    // Expect edge: <hasConsole> -[ASSIGNED_FROM]-> <'console' in globalThis>
    void code;
  });

  test('property-access::prop-enumeration-order', () => {
    const code = "function enumerationOrder() {\n  const obj = {};\n  obj.b = 1;\n  obj.a = 2;\n  obj[1] = 3;\n  obj[0] = 4;\n  obj.c = 5;\n  // Integer keys first (sorted), then string keys (insertion order)\n  return Object.keys(obj); // ['0', '1', 'b', 'a', 'c']\n}\n\n// --- Getter/setter via Object.defineProperty ---";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <obj.b> -[WRITES_TO]-> <obj>
    // Expect edge: <obj.b> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <obj.a> -[WRITES_TO]-> <obj>
    // Expect edge: <obj.a> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <obj[1]> -[WRITES_TO]-> <obj>
    // Expect edge: <obj[1]> -[ASSIGNED_FROM]-> <3>
    // Expect edge: <obj[0]> -[WRITES_TO]-> <obj>
    // Expect edge: <obj[0]> -[ASSIGNED_FROM]-> <4>
    // Expect edge: <obj.c> -[WRITES_TO]-> <obj>
    // Expect edge: <obj.c> -[ASSIGNED_FROM]-> <5>
    void code;
  });

  test('property-access::prop-symbol-key', () => {
    const code = "function symbolKey() {\n  const sym = Symbol('myKey');\n  const obj = { [sym]: 'symbol value' };\n  return obj[sym];\n}\n\n// --- __proto__ direct assignment ---";
    // Expect edge: <sym> -[ASSIGNED_FROM]-> <Symbol('myKey')>
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ [sym]: 'symbol value' }>
    // Expect edge: <[sym]> -[ASSIGNED_FROM]-> <'symbol value'>
    void code;
  });

  test('property-access::prop-define-accessor', () => {
    const code = "function defineAccessor() {\n  const obj = { _value: 0 };\n  Object.defineProperty(obj, 'value', {\n    get() { return this._value; },\n    set(v) { this._value = Math.max(0, v); },\n    enumerable: true,\n  });\n  return obj;\n}\n\n// --- Object.is ---";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <{ _value: 0 }>
    // Expect edge: <this._value_assign> -[ASSIGNED_FROM]-> <Math.max(0, v)>
    // Expect edge: <set> -[WRITES_TO]-> <this._value_assign>
    void code;
  });

  test('property-access::prop-object-is', () => {
    const code = "function objectIsComparison() {\n  const a = Object.is(NaN, NaN);       // true (unlike ===)\n  const b = Object.is(0, -0);          // false (unlike ===)\n  const c = Object.is(1, 1);           // true\n  return { a, b, c };\n}\n\n// --- structuredClone ---";
    // Expect edge: <a> -[ASSIGNED_FROM]-> <Object.is(NaN, NaN)>
    // Expect edge: <b> -[ASSIGNED_FROM]-> <Object.is(0, -0)>
    // Expect edge: <c> -[ASSIGNED_FROM]-> <Object.is(1, 1)>
    void code;
  });

  test('property-access::optional-chaining-delete', () => {
    const code = "function optionalChainingDelete(obj) {\n  const result = delete obj?.prop; // true if obj is nullish (no-op), normal delete otherwise\n  return result;\n}\n\n// --- Getter side effects in destructuring and spread ---";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <delete obj?.prop>
    void code;
  });

  test('property-access::prop-circular-class', () => {
    const code = "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n}\n\n// --- Symbol as property key ---";
    // Expect edge: <TreeNode.constructor> -[WRITES_TO]-> <this.value>
    // Expect edge: <this.value> -[ASSIGNED_FROM]-> <value>
    // Expect edge: <TreeNode.constructor> -[WRITES_TO]-> <this.parent>
    // Expect edge: <this.parent> -[ASSIGNED_FROM]-> <null>
    // Expect edge: <TreeNode.constructor> -[WRITES_TO]-> <this.children>
    // Expect edge: <this.children> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <TreeNode.addChild> -[WRITES_TO]-> <child.parent>
    // Expect edge: <child.parent> -[ASSIGNED_FROM]-> <TreeNode.addChild>
    void code;
  });

  test('property-access::prop-null-proto-dict', () => {
    const code = "function nullPrototypeDict() {\n  const dict = Object.create(null);\n  dict['key with spaces'] = 1;\n  dict['another-key'] = 2;\n  return dict;\n}\n\n// --- Proxy handler traps (full set) ---";
    // Expect edge: <dict> -[ASSIGNED_FROM]-> <Object.create(null)>
    // Expect edge: <dict['key with spaces']> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <dict['another-key']> -[ASSIGNED_FROM]-> <2>
    void code;
  });

  test('property-access::prop-getter-only-no-setter', () => {
    const code = "function getterOnlyNoSetter() {\n  const obj = {\n    get value() { return 42; },\n  };\n  obj.value = 99; // silently fails in sloppy, throws in strict\n  return obj.value; // still 42\n}";
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <obj-literal>
    // Expect edge: <obj.value-write> -[ASSIGNED_FROM]-> <99>
    void code;
  });

  test('property-access::prop-getter-side-effect', () => {
    const code = "function getterSideEffect() {\n  let callCount = 0;\n  const obj = {\n    get value() {\n      callCount++;\n      return 42;\n    },\n    set value(v) {\n      console.log('set to', v);\n    },\n  };\n  const x = obj.value;   // triggers getter — side effect\n  obj.value = 10;         // triggers setter — side effect\n  return { x, callCount };\n}\n\n// --- Circular references ---";
    // Expect edge: <callCount> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <obj:object>
    // Expect edge: <callCount++> -[MODIFIES]-> <callCount>
    // Expect edge: <x> -[ASSIGNED_FROM]-> <obj.value:read>
    // Expect edge: <obj.value:write> -[WRITES_TO]-> <obj>
    // Expect edge: <obj.value:write> -[ASSIGNED_FROM]-> <10>
    void code;
  });

  test('prototypes::proto-static-method', () => {
    const code = "Person.create = function (name, age) {\n  return new Person(name, age);\n};\n\n// --- Prototypal inheritance ---";
    // Expect edge: <Person.create> -[ASSIGNED_FROM]-> <Person.create:fn>
    void code;
  });

  test('prototypes::proto-object-create-null', () => {
    const code = "const nullProto = Object.create(null);\nnullProto.key = 'value';\n\n// --- Prototype chain inspection ---";
    // Expect edge: <nullProto> -[ASSIGNED_FROM]-> <Object.create(null)>
    // Expect edge: <nullProto.key> -[ASSIGNED_FROM]-> <'value'>
    // Expect edge: <MODULE> -[WRITES_TO]-> <nullProto.key>
    void code;
  });

  test('prototypes::proto-constructor-function', () => {
    const code = "function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function () {\n  return `Hi, I'm ${this.name}`;\n};\n\nPerson.prototype.toString = function () {\n  return `Person(${this.name}, ${this.age})`;\n};";
    // Expect edge: <Person> -[WRITES_TO]-> <this.name>
    // Expect edge: <Person> -[WRITES_TO]-> <this.age>
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <this.age> -[ASSIGNED_FROM]-> <age>
    // Expect edge: <Person.prototype.greet> -[ASSIGNED_FROM]-> <greet:fn>
    // Expect edge: <Person.prototype.toString> -[ASSIGNED_FROM]-> <toString:fn>
    void code;
  });

  test('property-access::getter-throws-in-destructuring', () => {
    const code = "function getterThrowsInDestructuring() {\n  const dangerous = {\n    get boom() { throw new Error('trap!'); },\n    safe: 1,\n  };\n  try {\n    const { boom } = dangerous; // throws during destructuring\n  } catch (e) {\n    return e.message;\n  }\n}\n\n// --- Proxy wrapping a class constructor ---";
    // Expect edge: <dangerous> -[ASSIGNED_FROM]-> <dangerous:object>
    // Expect edge: <throw new Error('trap!')> -[THROWS]-> <new Error('trap!')>
    // Expect edge: <safe:property> -[ASSIGNED_FROM]-> <1>
    void code;
  });

  test('property-access::getter-destructuring-side-effect', () => {
    const code = "function getterInDestructuring() {\n  let callCount = 0;\n  const sneaky = {\n    get value() { callCount++; return callCount; },\n  };\n  const { value } = sneaky;        // getter fires — callCount incremented\n  const copy = { ...sneaky };      // spread triggers ALL getters\n  return { value, copy, callCount };\n}";
    // Expect edge: <callCount> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <sneaky> -[ASSIGNED_FROM]-> <sneaky:obj>
    // Expect edge: <callCount++> -[MODIFIES]-> <callCount>
    // Expect edge: <value> -[ASSIGNED_FROM]-> <{ value }>
    // Expect edge: <copy> -[ASSIGNED_FROM]-> <copy:obj>
    void code;
  });

  test('property-access::prop-proxy-revocable', () => {
    const code = "function proxyRevocable() {\n  const { proxy, revoke } = Proxy.revocable({}, {\n    get(t, prop) { return prop in t ? t[prop] : 'default'; },\n  });\n  proxy.x = 1;\n  const val = proxy.x;\n  revoke();\n  return val;\n}";
    // Expect edge: <proxy> -[ASSIGNED_FROM]-> <Proxy.revocable({}, handler)>
    // Expect edge: <revoke> -[ASSIGNED_FROM]-> <Proxy.revocable({}, handler)>
    // Expect edge: <proxy.x> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <val> -[ASSIGNED_FROM]-> <proxy.x:read>
    void code;
  });

  test('prototypes::proto-set-prototype', () => {
    const code = "function reparent(obj, newParent) {\n  Object.setPrototypeOf(obj, newParent);\n  return obj;\n}\n\n// --- Mixin pattern ---";
    // Expect edge: <obj> -[MODIFIES]-> <newParent>
    void code;
  });

  test('property-access::getter-computed-destructuring', () => {
    const code = "function getterComputedDestructuring() {\n  let fired = false;\n  const obj = {\n    get secret() { fired = true; return 42; },\n  };\n  const key = 'secret';\n  const { [key]: extracted } = obj; // getter via computed key\n  return { extracted, fired };\n}";
    // Expect edge: <fired> -[ASSIGNED_FROM]-> <false>
    // Expect edge: <obj> -[ASSIGNED_FROM]-> <obj-literal>
    // Expect edge: <obj.secret> -[WRITES_TO]-> <fired>
    // Expect edge: <key> -[ASSIGNED_FROM]-> <'secret'>
    // Expect edge: <extracted> -[ASSIGNED_FROM]-> <obj[key]>
    void code;
  });

  test('prototypes::proto-mixin-applied', () => {
    const code = "function Widget(name) {\n  this.name = name;\n}\napplyMixins(Widget, Serializable, EventEmitterMixin);\n\n// --- Property descriptors ---";
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <Widget> -[WRITES_TO]-> <this.name>
    void code;
  });

  test('builtins::regex-lookahead', () => {
    const code = "const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;";
    // Expect edge: <posLookahead> -[ASSIGNED_FROM]-> </\d+(?=px)/>
    // Expect edge: <negLookahead> -[ASSIGNED_FROM]-> </\d+(?!px)/>
    void code;
  });

  test('property-access::proxy-class-constructor', () => {
    const code = "class OriginalClass {\n  constructor(name) { this.name = name; }\n  greet() { return `Hi, ${this.name}`; }\n}\n\nconst TrackedClass = new Proxy(OriginalClass, {\n  construct(target, args, newTarget) {\n    return Reflect.construct(target, args, newTarget);\n  },\n});\n\nconst trackedInstance = new TrackedClass('Alice');\n\n// --- delete on computed properties ---";
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <OriginalClass.constructor> -[WRITES_TO]-> <this.name>
    // Expect edge: <TrackedClass> -[ASSIGNED_FROM]-> <new Proxy(OriginalClass, {...})>
    // Expect edge: <trackedInstance> -[ASSIGNED_FROM]-> <new TrackedClass('Alice')>
    void code;
  });

  test('prototypes::proto-object-create', () => {
    const code = "const baseProto = {\n  type: 'base',\n  identify() {\n    return this.type;\n  },\n};\n\nconst derived = Object.create(baseProto);\nderived.type = 'derived';\nderived.extra = function () {\n  return 'extra';\n};";
    // Expect edge: <baseProto> -[ASSIGNED_FROM]-> <baseProto:object>
    // Expect edge: <baseProto.type> -[ASSIGNED_FROM]-> <'base'>
    // Expect edge: <derived> -[ASSIGNED_FROM]-> <Object.create(baseProto)>
    // Expect edge: <derived.type> -[ASSIGNED_FROM]-> <'derived'>
    // Expect edge: <derived.extra> -[ASSIGNED_FROM]-> <derived.extra:fn>
    void code;
  });

  test('prototypes::monkey-patch-builtin', () => {
    const code = "Array.prototype.last = function () {\n  return this[this.length - 1];\n};\n[1, 2, 3].last();";
    // Expect edge: <Array.prototype.last> -[ASSIGNED_FROM]-> <last:fn>
    void code;
  });

  test('builtins::regex-lookbehind', () => {
    const code = "const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;";
    // Expect edge: <posLookbehind> -[ASSIGNED_FROM]-> </(?<=\$)\d+/>
    // Expect edge: <negLookbehind> -[ASSIGNED_FROM]-> </(?<!\$)\d+/>
    void code;
  });

  test('prototypes::proto-inheritance-chain', () => {
    const code = "function Employee(name, age, role) {\n  Person.call(this, name, age);\n  this.role = role;\n}\n\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\nEmployee.prototype.describe = function () {\n  return `${this.greet()}, I'm a ${this.role}`;\n};\n\n// --- Object.create ---";
    // Expect edge: <this.role> -[ASSIGNED_FROM]-> <role>
    // Expect edge: <Employee> -[WRITES_TO]-> <this.role>
    // Expect edge: <Employee.prototype> -[ASSIGNED_FROM]-> <Object.create(Person.prototype)>
    // Expect edge: <Employee.prototype.constructor> -[ASSIGNED_FROM]-> <Employee>
    void code;
  });

  test('prototypes::proto-define-getter-setter', () => {
    const code = "function withComputedProp(obj) {\n  let _internal = 0;\n  Object.defineProperty(obj, 'computed', {\n    get() { return _internal * 2; },\n    set(v) { _internal = v; },\n    enumerable: true,\n    configurable: true,\n  });\n  return obj;\n}";
    // Expect edge: <_internal> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <computed-setter> -[WRITES_TO]-> <_internal>
    // Expect edge: <_internal> -[ASSIGNED_FROM]-> <v>
    void code;
  });

  test('prototypes::proto-chain-inspection', () => {
    const code = "function inspectPrototype(obj) {\n  const proto = Object.getPrototypeOf(obj);\n  const hasOwn = obj.hasOwnProperty('name');\n  const hasOwn2 = Object.hasOwn(obj, 'name');\n  const inChain = 'toString' in obj;\n  return { proto, hasOwn, hasOwn2, inChain };\n}\n\n// --- Object.setPrototypeOf ---";
    // Expect edge: <proto> -[ASSIGNED_FROM]-> <Object.getPrototypeOf(obj)>
    // Expect edge: <hasOwn> -[ASSIGNED_FROM]-> <obj.hasOwnProperty('name')>
    // Expect edge: <hasOwn2> -[ASSIGNED_FROM]-> <Object.hasOwn(obj, 'name')>
    // Expect edge: <inChain> -[ASSIGNED_FROM]-> <'toString' in obj>
    void code;
  });

  test('prototypes::monkey-patch-third-party', () => {
    const code = "function patchRouter(router) {\n  const originalGet = router.get;\n  router.get = function (path, handler) {\n    console.log(`GET ${path}`);\n    return originalGet.call(this, path, handler);\n  };\n}";
    // Expect edge: <originalGet> -[ASSIGNED_FROM]-> <router.get>
    // Expect edge: <router.get> -[ASSIGNED_FROM]-> <router.get:replacement>
    // Expect edge: <patchRouter> -[MODIFIES]-> <router>
    void code;
  });

  test('prototypes::super-in-object-literal', () => {
    const code = "const parentObj = {\n  greet() { return 'hello from parent'; },\n};\n\nconst childObj = {\n  __proto__: parentObj,\n  greet() {\n    return super.greet() + ' and child';\n  },\n};";
    // Expect edge: <parentObj> -[ASSIGNED_FROM]-> <parentObj:obj>
    // Expect edge: <childObj> -[ASSIGNED_FROM]-> <childObj:obj>
    // Expect edge: <__proto__> -[ASSIGNED_FROM]-> <parentObj>
    void code;
  });

  test('prototypes::monkey-patch-global', () => {
    const code = "const originalFetch = globalThis.fetch;\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n  apply(target, thisArg, args) {\n    console.log('intercepted:', args[0]);\n    return Reflect.apply(target, thisArg, args);\n  },\n});";
    // Expect edge: <originalFetch> -[ASSIGNED_FROM]-> <globalThis.fetch>
    // Expect edge: <globalThis.fetch> -[ASSIGNED_FROM]-> <fetch-proxy>
    void code;
  });

  test('runtime-apis::runtime-message-channel', () => {
    const code = "function messageChannelPattern() {\n  const { port1, port2 } = new MessageChannel();\n  port1.onmessage = (e) => console.log(e.data);\n  port2.postMessage('hello');\n}";
    // Expect edge: <port1> -[ASSIGNED_FROM]-> <new MessageChannel()>
    // Expect edge: <port2> -[ASSIGNED_FROM]-> <new MessageChannel()>
    // Expect edge: <port1.onmessage> -[ASSIGNED_FROM]-> <onmessage-handler>
    void code;
  });

  test('runtime-apis::runtime-transfer-ownership', () => {
    const code = "function transferOwnership(worker) {\n  const buffer = new ArrayBuffer(1024);\n  worker.postMessage(buffer, [buffer]); // buffer neutered in sender\n}\n\n// --- import.meta Extensions (Plugin: node-modules) ---";
    // Expect edge: <buffer> -[ASSIGNED_FROM]-> <new ArrayBuffer(1024)>
    void code;
  });

  test('prototypes::method-vs-function-property-super', () => {
    const code = "const superParent = {\n  greet() { return 'parent'; },\n};\n\nconst superChild = {\n  __proto__: superParent,\n\n  // Method shorthand — HAS [[HomeObject]], super works\n  shorthand() {\n    return super.greet(); // 'parent' ✓\n  },\n\n  // Function property — NO [[HomeObject]], super is SyntaxError\n  funcProp: function() {\n    // super.greet(); // Would be SyntaxError: 'super' keyword unexpected here\n    return 'no super access';\n  },\n\n  // Arrow property — NO own [[HomeObject]], inherits from defining scope\n  arrowProp: () => {\n    // super.greet(); // Would use enclosing scope's super, not this object's\n    return 'arrow has no own super';\n  },\n};";
    // Expect edge: <superParent> -[ASSIGNED_FROM]-> <superParent:obj>
    // Expect edge: <superChild> -[ASSIGNED_FROM]-> <superChild:obj>
    // Expect edge: <__proto__:superParent> -[ASSIGNED_FROM]-> <superParent:obj>
    // Expect edge: <superChild.funcProp> -[ASSIGNED_FROM]-> <superChild.funcProp:fn>
    // Expect edge: <superChild.arrowProp> -[ASSIGNED_FROM]-> <superChild.arrowProp:fn>
    void code;
  });

  test('builtins::regex-unicode-props', () => {
    const code = "const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;";
    // Expect edge: <emoji> -[ASSIGNED_FROM]-> </\p{Emoji}/u>
    // Expect edge: <greek> -[ASSIGNED_FROM]-> </\p{Script=Greek}/u>
    // Expect edge: <letter> -[ASSIGNED_FROM]-> </\p{Letter}/u>
    void code;
  });

  test('prototypes::export-named-list', () => {
    const code = "export {\n  Person,\n  Employee,\n  baseProto,\n  derived,\n  nullProto,\n  inspectPrototype,\n  reparent,\n  Serializable,\n  EventEmitterMixin,\n  applyMixins,\n  Widget,\n  createReadonly,\n  withComputedProp,\n  defineMultiple,\n  getDescriptor,\n  getAllDescriptors,\n  EvenNumber,\n  patchRouter,\n  originalFetch,\n  parentObj,\n  childObj,\n  superParent,\n  superChild,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <Person>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Employee>
    // Expect edge: <export-named-list> -[EXPORTS]-> <baseProto>
    // Expect edge: <export-named-list> -[EXPORTS]-> <derived>
    // Expect edge: <export-named-list> -[EXPORTS]-> <nullProto>
    // Expect edge: <export-named-list> -[EXPORTS]-> <inspectPrototype>
    // Expect edge: <export-named-list> -[EXPORTS]-> <reparent>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Serializable>
    // Expect edge: <export-named-list> -[EXPORTS]-> <EventEmitterMixin>
    // Expect edge: <export-named-list> -[EXPORTS]-> <applyMixins>
    // Expect edge: <export-named-list> -[EXPORTS]-> <Widget>
    // Expect edge: <export-named-list> -[EXPORTS]-> <createReadonly>
    // Expect edge: <export-named-list> -[EXPORTS]-> <withComputedProp>
    // Expect edge: <export-named-list> -[EXPORTS]-> <defineMultiple>
    // Expect edge: <export-named-list> -[EXPORTS]-> <getDescriptor>
    // Expect edge: <export-named-list> -[EXPORTS]-> <getAllDescriptors>
    // Expect edge: <export-named-list> -[EXPORTS]-> <EvenNumber>
    // Expect edge: <export-named-list> -[EXPORTS]-> <patchRouter>
    // Expect edge: <export-named-list> -[EXPORTS]-> <originalFetch>
    // Expect edge: <export-named-list> -[EXPORTS]-> <parentObj>
    // Expect edge: <export-named-list> -[EXPORTS]-> <childObj>
    // Expect edge: <export-named-list> -[EXPORTS]-> <superParent>
    // Expect edge: <export-named-list> -[EXPORTS]-> <superChild>
    void code;
  });

  test('runtime-apis::runtime-broadcast-channel', () => {
    const code = "function broadcastChannelPattern() {\n  const bc = new BroadcastChannel('updates');\n  bc.postMessage({ type: 'refresh' });\n  bc.onmessage = (e) => console.log(e.data);\n  bc.close();\n}";
    // Expect edge: <bc> -[ASSIGNED_FROM]-> <new BroadcastChannel('updates')>
    // Expect edge: <bc.onmessage> -[ASSIGNED_FROM]-> <(e) => console.log(e.data)>
    void code;
  });

  test('runtime-apis::export-named-list', () => {
    const code = "export {\n  sharedMemory,\n  atomicsSynchronization,\n  workerCommunication,\n  messageChannelPattern,\n  broadcastChannelPattern,\n  transferOwnership,\n  importMetaExtensions,\n  deferredPromise,\n};";
    // Expect edge: <export-named-list> -[EXPORTS]-> <sharedMemory>
    // Expect edge: <export-named-list> -[EXPORTS]-> <atomicsSynchronization>
    // Expect edge: <export-named-list> -[EXPORTS]-> <workerCommunication>
    // Expect edge: <export-named-list> -[EXPORTS]-> <messageChannelPattern>
    // Expect edge: <export-named-list> -[EXPORTS]-> <broadcastChannelPattern>
    // Expect edge: <export-named-list> -[EXPORTS]-> <transferOwnership>
    // Expect edge: <export-named-list> -[EXPORTS]-> <importMetaExtensions>
    // Expect edge: <export-named-list> -[EXPORTS]-> <deferredPromise>
    void code;
  });

  test('statements::if-else', () => {
    const code = "function ifElseStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  } else {\n    return 'non-positive';\n  }\n}";
    // Expect edge: <if-else> -[HAS_ALTERNATE]-> <'non-positive'>
    void code;
  });

  test('runtime-apis::runtime-import-meta-resolve', () => {
    const code = "function importMetaExtensions() {\n  const depPath = import.meta.resolve('lodash');\n  const localPath = import.meta.resolve('./utils.js');\n  // Node.js 21+:\n  // const dir = import.meta.dirname;   // replaces __dirname\n  // const file = import.meta.filename; // replaces __filename\n  return { depPath, localPath };\n}\n\n// --- Global Error Sinks (Plugin: error-flow) ---\n// These create implicit edges from ANY uncaught throw/reject to handler.";
    // Expect edge: <depPath> -[ASSIGNED_FROM]-> <import.meta.resolve('lodash')>
    // Expect edge: <localPath> -[ASSIGNED_FROM]-> <import.meta.resolve('./utils.js')>
    void code;
  });

  test('builtins::string-raw-template', () => {
    const code = "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file' — no escape processing";
    // Expect edge: <windowsPath> -[ASSIGNED_FROM]-> <String.raw`C:\Users\name\file`>
    void code;
  });

  test('runtime-apis::runtime-promise-try', () => {
    const code = "// const result = await Promise.try(() => {\n//   if (cached) return cachedValue;    // sync return → wrapped in Promise\n//   return fetchFromNetwork();          // async return\n// });";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <Promise.try(...)>
    // Expect edge: <if-cached> -[HAS_ALTERNATE]-> <fetchFromNetwork()>
    void code;
  });

  test('statements::for-in', () => {
    const code = "function forIn(obj) {\n  const keys = [];\n  for (const key in obj) {\n    keys.push(key);\n  }\n  return keys;\n}";
    // Expect edge: <keys> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('runtime-apis::runtime-worker-postmessage', () => {
    const code = "function workerCommunication() {\n  const worker = new Worker('./task.js');\n  worker.postMessage({ type: 'start', payload: 'data' });\n  worker.onmessage = (e) => console.log(e.data);\n  worker.onerror = (err) => console.error(err);\n  worker.terminate();\n}";
    // Expect edge: <worker> -[ASSIGNED_FROM]-> <new Worker('./task.js')>
    // Expect edge: <worker.onmessage> -[ASSIGNED_FROM]-> <onmessage-handler>
    // Expect edge: <worker.onerror> -[ASSIGNED_FROM]-> <onerror-handler>
    void code;
  });

  test('statements::do-while', () => {
    const code = "function doWhileLoop() {\n  let attempts = 0;\n  do {\n    attempts++;\n  } while (attempts < 3);\n  return attempts;\n}";
    // Expect edge: <attempts> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <attempts++> -[MODIFIES]-> <attempts>
    void code;
  });

  test('statements::while', () => {
    const code = "function whileLoop() {\n  let count = 0;\n  while (count < 5) {\n    count++;\n  }\n  return count;\n}";
    // Expect edge: <count> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <count++> -[MODIFIES]-> <count>
    void code;
  });

  test('statements::for-classic', () => {
    const code = "function classicFor() {\n  const results = [];\n  for (let i = 0; i < 10; i++) {\n    results.push(i);\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('statements::switch-break', () => {
    const code = "function switchWithBreak(action) {\n  let result;\n  switch (action) {\n    case 'start':\n      result = 'starting';\n      break;\n    case 'stop':\n      result = 'stopping';\n      break;\n    default:\n      result = 'unknown';\n  }\n  return result;\n}";
    // Expect edge: <case-start> -[WRITES_TO]-> <result>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <'starting'>
    // Expect edge: <case-stop> -[WRITES_TO]-> <result>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <'stopping'>
    // Expect edge: <default-case> -[WRITES_TO]-> <result>
    // Expect edge: <result> -[ASSIGNED_FROM]-> <'unknown'>
    void code;
  });

  test('statements::for-of', () => {
    const code = "function forOf(iterable) {\n  const values = [];\n  for (const item of iterable) {\n    values.push(item);\n  }\n  return values;\n}";
    // Expect edge: <values> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('statements::if-else-if-chain', () => {
    const code = "function ifElseIfChain(x) {\n  if (x > 0) {\n    return 'positive';\n  } else if (x < 0) {\n    return 'negative';\n  } else {\n    return 'zero';\n  }\n}";
    // Expect edge: <if-x>0> -[HAS_ALTERNATE]-> <else-if-x<0>
    // Expect edge: <else-if-x<0> -[HAS_ALTERNATE]-> <else>
    void code;
  });

  test('runtime-apis::runtime-promise-withresolvers-deferred', () => {
    const code = "function deferredPromise() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  // resolve/reject passed to different scopes as callbacks\n  setTimeout(() => reject(new Error('timeout')), 5000);\n  return { promise, resolve, reject };\n}";
    // Expect edge: <timeout-callback> -[CAPTURES]-> <reject>
    void code;
  });

  test('statements::for-of-destructuring', () => {
    const code = "function forOfDestructuring(entries) {\n  const result = {};\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}";
    // Expect edge: <result> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <result[key] = value> -[WRITES_TO]-> <result[key]>
    void code;
  });

  test('statements::try-catch', () => {
    const code = "function tryCatch() {\n  try {\n    JSON.parse('invalid');\n  } catch (error) {\n    console.error(error.message);\n  }\n}";
    // Expect edge: <JSON.parse('invalid')> -[THROWS]-> <catch-block>
    void code;
  });

  test('statements::try-catch-finally', () => {
    const code = "function tryCatchFinally() {\n  let resource;\n  try {\n    resource = openResource();\n  } catch (error) {\n    handleError(error);\n  } finally {\n    cleanup(resource);\n  }\n}";
    // Expect edge: <resource> -[ASSIGNED_FROM]-> <openResource()>
    void code;
  });

  test('statements::empty-statement', () => {
    const code = "function emptyStatements() {\n  ;\n  for (let i = 0; i < 0; i++);\n}";
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0-init>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('builtins::array-from-mapfn', () => {
    const code = "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---";
    // Expect edge: <indices> -[ASSIGNED_FROM]-> <Array.from({ length: 5 }, (_, i) => i)>
    void code;
  });

  test('statements::finally-throw-override', () => {
    const code = "function finallyThrowOverride() {\n  try {\n    throw new Error('original');\n  } catch (e) {\n    throw new Error('from catch');\n  } finally {\n    throw new Error('from finally'); // swallows catch throw\n  }\n}";
    // Expect edge: <try-block> -[THROWS]-> <new Error('original')>
    // Expect edge: <catch-block> -[THROWS]-> <new Error('from catch')>
    // Expect edge: <finally-block> -[THROWS]-> <new Error('from finally')>
    void code;
  });

  test('statements::tdz-switch-fallthrough', () => {
    const code = "function tdzSwitch(x) {\n  switch (x) {\n    case 1:\n      let y = 1; // y scoped to ENTIRE switch block\n      break;\n    case 2:\n      // console.log(y); // ReferenceError — TDZ\n      break;\n  }\n}";
    // Expect edge: <y> -[ASSIGNED_FROM]-> <1-init>
    void code;
  });

  test('statements::for-of-no-declaration', () => {
    const code = "function forOfNoDeclaration(items) {\n  let item;\n  for (item of items) {           // REASSIGNS existing var, not declaration\n    console.log(item);\n  }\n  return item; // last item — outer var mutated\n}";
    // Expect edge: <for-of> -[MODIFIES]-> <item>
    void code;
  });

  test('statements::destructure-catch-clause', () => {
    const code = "function destructureCatchClause() {\n  try {\n    throw { code: 'ENOENT', message: 'not found' };\n  } catch ({ code, message }) {\n    return { code, message };\n  }\n}";
    // Expect edge: <try-block> -[THROWS]-> <{ code: 'ENOENT', message: 'not found' }>
    // Expect edge: <code> -[ASSIGNED_FROM]-> <{ code: 'ENOENT', message: 'not found' }>
    // Expect edge: <message> -[ASSIGNED_FROM]-> <{ code: 'ENOENT', message: 'not found' }>
    void code;
  });

  test('statements::throw', () => {
    const code = "function throwError(type) {\n  if (type === 'error') {\n    throw new Error('Something went wrong');\n  }\n  if (type === 'custom') {\n    throw { code: 'CUSTOM', message: 'Custom error' };\n  }\n  if (type === 'string') {\n    throw 'simple string error';\n  }\n}";
    // Expect edge: <throw-error> -[THROWS]-> <new Error('Something went wrong')>
    // Expect edge: <throw-custom> -[THROWS]-> <custom-object>
    // Expect edge: <throw-string> -[THROWS]-> <'simple string error'>
    void code;
  });

  test('statements::labeled-continue', () => {
    const code = "function labeledContinue() {\n  const results = [];\n  loop: for (let i = 0; i < 5; i++) {\n    if (i === 3) continue loop;\n    results.push(i);\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    void code;
  });

  test('statements::for-in-no-declaration', () => {
    const code = "function forInNoDeclaration(obj) {\n  let key;\n  for (key in obj) {              // REASSIGNS existing var\n    console.log(key);\n  }\n  return key; // last key — outer var mutated\n}";
    // Expect edge: <for-in> -[MODIFIES]-> <key>
    void code;
  });

  test('builtins::sparse-array', () => {
    const code = "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false — hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}";
    // Expect edge: <sparse> -[ASSIGNED_FROM]-> <sparse-array>
    // Expect edge: <length> -[ASSIGNED_FROM]-> <sparse.length>
    // Expect edge: <hasIndex1> -[ASSIGNED_FROM]-> <1 in sparse>
    // Expect edge: <mapped> -[ASSIGNED_FROM]-> <sparse.map(x => x * 2)>
    void code;
  });

  test('statements::for-of-destructure-assign', () => {
    const code = "function forOfDestructureAssign(pairs) {\n  let a, b;\n  for ([a, b] of pairs) {        // destructuring assignment in for-of head\n    console.log(a, b);\n  }\n  return { a, b }; // last pair values\n}";
    // Expect edge: <[a, b]> -[ASSIGNED_FROM]-> <a>
    // Expect edge: <[a, b]> -[ASSIGNED_FROM]-> <b>
    void code;
  });

  test('statements::for-of-destructuring-object', () => {
    const code = "function forOfDestructuringObject() {\n  const points = [{ x: 1, y: 2 }, { x: 3, y: 4 }];\n  const results = [];\n  for (const { x, y } of points) {\n    results.push(x + y);\n  }\n  return results;\n}";
    // Expect edge: <points> -[ASSIGNED_FROM]-> <[{ x: 1, y: 2 }, { x: 3, y: 4 }]>
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('statements::for-in-destructuring', () => {
    const code = "function forInDestructuring() {\n  const results = [];\n  for (const { length } in { abc: 1, de: 2, f: 3 }) {\n    results.push(length); // 3, 2, 1 — destructures the string KEY, not value\n  }\n  return results;\n}";
    // Expect edge: <results> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('statements::destructure-catch-nested', () => {
    const code = "function destructureCatchNested() {\n  try {\n    throw { errors: [{ code: 'E1', path: '/api' }], status: 500 };\n  } catch ({ errors: [{ code, path }], status }) {\n    return { code, path, status };\n  }\n}";
    // Expect edge: <try-block> -[THROWS]-> <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>
    // Expect edge: <code> -[ASSIGNED_FROM]-> <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>
    // Expect edge: <path> -[ASSIGNED_FROM]-> <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>
    // Expect edge: <status> -[ASSIGNED_FROM]-> <{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>
    void code;
  });

  test('ts-specific::ts-typed-arrow', () => {
    const code = "const typedArrow = (x: number): number => x * 2;";
    // Expect edge: <typedArrow> -[ASSIGNED_FROM]-> <typedArrow:fn>
    void code;
  });

  test('ts-specific::enum-heterogeneous', () => {
    const code = "enum Mixed {\n  No = 0,\n  Yes = 'YES',\n}";
    // Expect edge: <Mixed.No> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <Mixed.Yes> -[ASSIGNED_FROM]-> <'YES'>
    void code;
  });

  test('statements::for-comma-update', () => {
    const code = "function forCommaUpdate() {\n  const arr = [1, 2, 3, 4, 5];\n\n  // Two-pointer technique — comma in both init and update\n  for (let lo = 0, hi = arr.length - 1; lo < hi; lo++, hi--) {\n    [arr[lo], arr[hi]] = [arr[hi], arr[lo]]; // swap\n  }\n\n  // Side effect in update clause\n  let processed = 0;\n  for (let i = 0; i < 3; i++, processed++) {\n    // comma separates two update expressions\n  }\n\n  return { arr, processed };\n}";
    // Expect edge: <arr> -[ASSIGNED_FROM]-> <[1, 2, 3, 4, 5]>
    // Expect edge: <lo> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <hi> -[ASSIGNED_FROM]-> <arr.length - 1>
    // Expect edge: <lo++> -[MODIFIES]-> <lo>
    // Expect edge: <hi--> -[MODIFIES]-> <hi>
    // Expect edge: <[arr[lo], arr[hi]] = [arr[hi], arr[lo]]> -[MODIFIES]-> <arr>
    // Expect edge: <processed> -[ASSIGNED_FROM]-> <0-2>
    // Expect edge: <i> -[ASSIGNED_FROM]-> <0-3>
    // Expect edge: <i++> -[MODIFIES]-> <i>
    // Expect edge: <processed++> -[MODIFIES]-> <processed>
    void code;
  });

  test('ts-specific::enum-const', () => {
    const code = "const enum Flags {\n  Read = 1,\n  Write = 2,\n  Execute = 4,\n}";
    // Expect edge: <Flags.Read> -[ASSIGNED_FROM]-> <1>
    // Expect edge: <Flags.Write> -[ASSIGNED_FROM]-> <2>
    // Expect edge: <Flags.Execute> -[ASSIGNED_FROM]-> <4>
    void code;
  });

  test('ts-specific::enum-string', () => {
    const code = "enum Status {\n  Active = 'ACTIVE',\n  Inactive = 'INACTIVE',\n  Pending = 'PENDING',\n}";
    // Expect edge: <Status.Active> -[ASSIGNED_FROM]-> <'ACTIVE'>
    // Expect edge: <Status.Inactive> -[ASSIGNED_FROM]-> <'INACTIVE'>
    // Expect edge: <Status.Pending> -[ASSIGNED_FROM]-> <'PENDING'>
    void code;
  });

  test('ts-specific::satisfies', () => {
    const code = "const theme = {\n  primary: '#007bff',\n  secondary: '#6c757d',\n} satisfies Record<string, string>;";
    // Expect edge: <theme> -[ASSIGNED_FROM]-> <{primary: '#007bff', secondary: '#6c757d'}>
    void code;
  });

  test('ts-specific::type-assertion-as', () => {
    const code = "function typeAssertions(value: unknown) {\n  const asString = value as string;\n  const angleBracket = <number>value;\n  return { asString, angleBracket };\n}";
    // Expect edge: <asString> -[ASSIGNED_FROM]-> <value as string>
    // Expect edge: <angleBracket> -[ASSIGNED_FROM]-> <<number>value>
    void code;
  });

  test('ts-specific::non-null-assertion', () => {
    const code = "function nonNullAssertion(map: Map<string, string>) {\n  const value = map.get('key')!;\n  return value.toUpperCase();\n}";
    // Expect edge: <value> -[ASSIGNED_FROM]-> <map.get('key')!>
    void code;
  });

  test('ts-specific::access-modifiers', () => {
    const code = "class Service {\n  public name: string;\n  protected config: Record<string, unknown>;\n  private secret: string;\n\n  constructor(name: string, secret: string) {\n    this.name = name;\n    this.config = {};\n    this.secret = secret;\n  }\n}";
    // Expect edge: <Service.constructor> -[WRITES_TO]-> <this.name>
    // Expect edge: <Service.constructor> -[WRITES_TO]-> <this.config>
    // Expect edge: <Service.constructor> -[WRITES_TO]-> <this.secret>
    // Expect edge: <this.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <this.config> -[ASSIGNED_FROM]-> <{}>
    // Expect edge: <this.secret> -[ASSIGNED_FROM]-> <secret>
    void code;
  });

  test('ts-specific::generic-class', () => {
    const code = "class Container<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n\n  map<U>(fn: (value: T) => U): Container<U> {\n    return new Container(fn(this.value));\n  }\n}";
    // Expect edge: <this.value> -[ASSIGNED_FROM]-> <constructor.value>
    // Expect edge: <Container.constructor> -[WRITES_TO]-> <this.value>
    void code;
  });

  test('ts-specific::as-const', () => {
    const code = "const config = {\n  api: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n} as const;\n\nconst directions = ['up', 'down', 'left', 'right'] as const;";
    // Expect edge: <config> -[ASSIGNED_FROM]-> <config:as-const>
    // Expect edge: <config:object.api> -[ASSIGNED_FROM]-> <'https://api.example.com'>
    // Expect edge: <config:object.timeout> -[ASSIGNED_FROM]-> <5000>
    // Expect edge: <config:object.retries> -[ASSIGNED_FROM]-> <3>
    // Expect edge: <directions> -[ASSIGNED_FROM]-> <directions:as-const>
    void code;
  });

  test('ts-specific::parameter-properties', () => {
    const code = "class ServiceWithParamProps {\n  constructor(\n    public name: string,\n    protected config: Record<string, unknown>,\n    private secret: string,\n    readonly id: number,\n  ) {}\n}";
    // Expect edge: <ServiceWithParamProps.name> -[ASSIGNED_FROM]-> <name>
    // Expect edge: <ServiceWithParamProps.config> -[ASSIGNED_FROM]-> <config>
    // Expect edge: <ServiceWithParamProps.secret> -[ASSIGNED_FROM]-> <secret>
    // Expect edge: <ServiceWithParamProps.id> -[ASSIGNED_FROM]-> <id>
    void code;
  });

  test('ts-specific::conditional-type', () => {
    const code = "type IsString<T> = T extends string ? true : false;";
    // Expect edge: <IsString> -[ASSIGNED_FROM]-> <T extends string ? true : false>
    // Expect edge: <T extends string ? true : false> -[HAS_ALTERNATE]-> <false>
    void code;
  });

  test('ts-specific::decorator-method', () => {
    const code = "function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey}`);\n    return original.apply(this, args);\n  };\n}";
    // Expect edge: <original> -[ASSIGNED_FROM]-> <descriptor.value>
    // Expect edge: <descriptor.value> -[ASSIGNED_FROM]-> <wrapper:fn>
    void code;
  });

  test('ts-specific::conditional-type-infer', () => {
    const code = "type UnpackPromise<T> = T extends Promise<infer U> ? U : T;";
    // Expect edge: <UnpackPromise> -[ASSIGNED_FROM]-> <T extends Promise<infer U> ? U : T>
    // Expect edge: <T extends Promise<infer U> ? U : T> -[HAS_ALTERNATE]-> <T:false-branch>
    void code;
  });

  test('ts-specific::conditional-type-exclude', () => {
    const code = "type StrictNonNull<T> = T extends null | undefined ? never : T;";
    // Expect edge: <StrictNonNull> -[ASSIGNED_FROM]-> <T extends null | undefined ? never : T>
    // Expect edge: <T extends null | undefined ? never : T> -[HAS_ALTERNATE]-> <T>
    void code;
  });

  test('ts-specific::mapped-type-readonly', () => {
    const code = "type ReadonlyAll<T> = { readonly [K in keyof T]: T[K] };";
    // Expect edge: <ReadonlyAll> -[ASSIGNED_FROM]-> <ReadonlyAll:mapped>
    void code;
  });

  test('ts-specific::mapped-type-mutable', () => {
    const code = "type Mutable<T> = { -readonly [K in keyof T]: T[K] };";
    // Expect edge: <Mutable> -[ASSIGNED_FROM]-> <Mutable:mapped>
    void code;
  });

  test('ts-specific::mapped-type-optional', () => {
    const code = "type Optional<T> = { [K in keyof T]?: T[K] };";
    // Expect edge: <Optional> -[ASSIGNED_FROM]-> <Optional:mapped>
    void code;
  });

  test('ts-specific::template-literal-type', () => {
    const code = "type EventName = 'click' | 'focus' | 'blur';\ntype OnEvent = `on${Capitalize<EventName>}`;\ntype CSSProperty = `${string}-${string}`;";
    // Expect edge: <OnEvent> -[ASSIGNED_FROM]-> <`on${Capitalize<EventName>}`>
    // Expect edge: <CSSProperty> -[ASSIGNED_FROM]-> <`${string}-${string}`>
    void code;
  });

  test('ts-specific::union-intersection', () => {
    const code = "type StringOrNumber = string | number;\ntype ObjA = { a: string };\ntype ObjB = { b: number };\ntype Combined = ObjA & ObjB;";
    // Expect edge: <StringOrNumber> -[ASSIGNED_FROM]-> <string | number>
    // Expect edge: <ObjA> -[ASSIGNED_FROM]-> <{ a: string }>
    // Expect edge: <ObjB> -[ASSIGNED_FROM]-> <{ b: number }>
    // Expect edge: <Combined> -[ASSIGNED_FROM]-> <ObjA & ObjB>
    void code;
  });

  test('ts-specific::keyof-typeof', () => {
    const code = "type UserKeys = keyof User;\nconst sampleUser = { name: 'Alice', age: 30 };\ntype InferredUser = typeof sampleUser;";
    // Expect edge: <UserKeys> -[ASSIGNED_FROM]-> <keyof User>
    // Expect edge: <sampleUser> -[ASSIGNED_FROM]-> <{ name: 'Alice', age: 30 }>
    // Expect edge: <InferredUser> -[ASSIGNED_FROM]-> <typeof sampleUser>
    void code;
  });

  test('ts-specific::index-access-type', () => {
    const code = "type UserName = User['name'];\ntype UserNameOrAge = User['name' | 'age'];";
    // Expect edge: <UserName> -[ASSIGNED_FROM]-> <User['name']>
    // Expect edge: <UserNameOrAge> -[ASSIGNED_FROM]-> <User['name' | 'age']>
    void code;
  });

  test('ts-specific::ts-import-type', () => {
    const code = "// import type { User } from './types';\n// import { type Role, Permission } from './auth';\n// (commented out — no actual modules to import from, but syntax is valid)\ntype ImportedType = User;";
    // Expect edge: <ImportedType> -[ASSIGNED_FROM]-> <User>
    void code;
  });

  test('ts-specific::ts-export-type', () => {
    const code = "export type { Admin };\n// export { type Status }; — inline type export (already exported as value above)";
    // Expect edge: <export-type-Admin> -[EXPORTS]-> <Admin>
    // Expect edge: <module> -[EXPORTS]-> <Admin>
    void code;
  });

  test('ts-specific::ts-declare-module', () => {
    const code = "declare module '*.css' {\n  const content: Record<string, string>;\n  export default content;\n}";
    // Expect edge: <default-export> -[EXPORTS]-> <content>
    void code;
  });

  test('ts-specific::utility-types', () => {
    const code = "type PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype PickedUser = Pick<User, 'name' | 'age'>;\ntype OmittedUser = Omit<User, 'email'>;\ntype UserRecord = Record<string, User>;\ntype ExtractedType = Extract<string | number | boolean, string | boolean>;\ntype ExcludedType = Exclude<string | number | boolean, boolean>;";
    // Expect edge: <PartialUser> -[ASSIGNED_FROM]-> <Partial<User>>
    // Expect edge: <RequiredUser> -[ASSIGNED_FROM]-> <Required<User>>
    // Expect edge: <PickedUser> -[ASSIGNED_FROM]-> <Pick<User, 'name' | 'age'>>
    // Expect edge: <OmittedUser> -[ASSIGNED_FROM]-> <Omit<User, 'email'>>
    // Expect edge: <UserRecord> -[ASSIGNED_FROM]-> <Record<string, User>>
    // Expect edge: <ExtractedType> -[ASSIGNED_FROM]-> <Extract<string | number | boolean, string | boolean>>
    // Expect edge: <ExcludedType> -[ASSIGNED_FROM]-> <Exclude<string | number | boolean, boolean>>
    void code;
  });

  test('ts-specific::ts-recursive-type', () => {
    const code = "type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };";
    // Expect edge: <JSONValue> -[ASSIGNED_FROM]-> <JSONValue:union>
    void code;
  });

  test('ts-specific::ts-const-type-param', () => {
    const code = "function literal<const T>(value: T): T {\n  return value;\n}\nconst literalResult = literal({ x: 1, y: [2, 3] } as const);";
    // Expect edge: <literalResult> -[ASSIGNED_FROM]-> <literal({ x: 1, y: [2, 3] } as const)>
    void code;
  });

  test('ts-specific::ts-asserts-guard', () => {
    const code = "function assertDefined<T>(val: T | undefined): asserts val is T {\n  if (val === undefined) throw new Error('undefined');\n}";
    // Expect edge: <throw-error> -[THROWS]-> <new Error('undefined')>
    void code;
  });

  test('ts-specific::ts-import-assertions', () => {
    const code = "// import data from './data.json' with { type: 'json' };\n// (commented out — import attributes syntax, requires runtime support)\ntype ImportedJSON = Record<string, unknown>;";
    // Expect edge: <ImportedJSON> -[ASSIGNED_FROM]-> <Record<string, unknown>>
    void code;
  });

  test('ts-specific::ts-import-type-star', () => {
    const code = "// import type * as AllTypes from './modules-helpers.js';\n// (commented out — no actual modules to import from, but syntax is valid)\ntype AllTypesPlaceholder = Record<string, unknown>;";
    // Expect edge: <AllTypesPlaceholder> -[ASSIGNED_FROM]-> <Record<string, unknown>>
    void code;
  });

  test('ts-specific::ts-template-literal-infer', () => {
    const code = "type ParseRoute<T extends string> =\n  T extends `/${infer Segment}/${infer Rest}`\n    ? [Segment, ...ParseRoute<`/${Rest}`>]\n    : T extends `/${infer Segment}`\n      ? [Segment]\n      : [];";
    // Expect edge: <ParseRoute> -[ASSIGNED_FROM]-> <ParseRoute-conditional>
    // Expect edge: <ParseRoute-conditional> -[HAS_ALTERNATE]-> <[Segment]>
    // Expect edge: <ParseRoute-conditional> -[HAS_ALTERNATE]-> <[]>
    void code;
  });

  test('ts-specific::ts-exhaustive-never', () => {
    const code = "type ShapeUnion = { kind: 'circle'; radius: number } | { kind: 'square'; side: number };\n\nfunction shapeArea(shape: ShapeUnion): number {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n    default: {\n      const _exhaustive: never = shape;\n      throw new Error(`Unknown shape: ${_exhaustive}`);\n    }\n  }\n}";
    // Expect edge: <_exhaustive> -[ASSIGNED_FROM]-> <shape>
    void code;
  });

  test('ts-specific::ts-this-type', () => {
    const code = "class Builder {\n  private builderValue = 0;\n\n  add(n: number): this {\n    this.builderValue += n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.builderValue *= n;\n    return this;\n  }\n}\n\nclass AdvancedBuilder extends Builder {\n  negate(): this {\n    return this;\n  }\n}";
    // Expect edge: <Builder.builderValue> -[ASSIGNED_FROM]-> <0>
    // Expect edge: <this.builderValue += n> -[WRITES_TO]-> <this.builderValue>
    // Expect edge: <this.builderValue *= n> -[WRITES_TO]-> <this.builderValue2>
    void code;
  });

  test('ts-specific::ts-branded-type', () => {
    const code = "type UserId = string & { readonly __brand: unique symbol };\ntype OrderId = string & { readonly __brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction createOrderId(id: string): OrderId {\n  return id as OrderId;\n}";
    // Expect edge: <UserId> -[ASSIGNED_FROM]-> <string & { readonly __brand: unique symbol }>
    // Expect edge: <OrderId> -[ASSIGNED_FROM]-> <string & { readonly __brand: unique symbol }#2>
    void code;
  });

  test('ts-specific::ts-declaration-merging', () => {
    const code = "class Box { x = 0; }\ninterface Box { y: number; }\n// Box now has both x (from class) and y (from interface)";
    // Expect edge: <Box.x> -[ASSIGNED_FROM]-> <0>
    void code;
  });

  test('ts-specific::ts-const-enum-computed', () => {
    const code = "const enum BitFlags {\n  Read = 1 << 0,\n  Write = 1 << 1,\n  Execute = 1 << 2,\n  ReadWrite = Read | Write,\n}";
    // Expect edge: <BitFlags.Read> -[ASSIGNED_FROM]-> <1 << 0>
    // Expect edge: <BitFlags.Write> -[ASSIGNED_FROM]-> <1 << 1>
    // Expect edge: <BitFlags.Execute> -[ASSIGNED_FROM]-> <1 << 2>
    // Expect edge: <BitFlags.ReadWrite> -[ASSIGNED_FROM]-> <Read | Write>
    void code;
  });

  test('ts-specific::ts-unique-symbol', () => {
    const code = "declare const uniqueSym: unique symbol;\ntype WithSymKey = { [uniqueSym]: string };";
    // Expect edge: <WithSymKey> -[ASSIGNED_FROM]-> <WithSymKey:object>
    void code;
  });

  test('ts-specific::ts-decorator-metadata', () => {
    const code = "function track(constructor: Function, context: ClassDecoratorContext) {\n  context.metadata.tracked = true;\n}\n\nfunction log(target: Function, context: ClassMethodDecoratorContext) {\n  context.addInitializer(function() {\n    console.log(`${String(context.name)} initialized`);\n  });\n}\n\n@track\nclass TrackedService {\n  @log\n  process(data: string) { return data; }\n}\n// const meta = TrackedService[Symbol.metadata]; // { tracked: true }";
    // Expect edge: <track> -[WRITES_TO]-> <context.metadata.tracked>
    // Expect edge: <context.metadata.tracked> -[ASSIGNED_FROM]-> <true>
    void code;
  });

  test('ts-specific::ts-constructor-overloads', () => {
    const code = "class Point {\n  x: number;\n  y: number;\n  constructor(x: number, y: number);\n  constructor(coords: [number, number]);\n  constructor(xOrCoords: number | [number, number], y?: number) {\n    if (Array.isArray(xOrCoords)) {\n      this.x = xOrCoords[0];\n      this.y = xOrCoords[1];\n    } else {\n      this.x = xOrCoords;\n      this.y = y!;\n    }\n  }\n}";
    // Expect edge: <Array.isArray(xOrCoords)> -[HAS_ALTERNATE]-> <this.x:branch2>
    // Expect edge: <Array.isArray(xOrCoords)> -[HAS_ALTERNATE]-> <this.y:branch2>
    // Expect edge: <this.x:branch1> -[ASSIGNED_FROM]-> <xOrCoords[0]>
    // Expect edge: <this.y:branch1> -[ASSIGNED_FROM]-> <xOrCoords[1]>
    // Expect edge: <this.x:branch2> -[ASSIGNED_FROM]-> <xOrCoords>
    // Expect edge: <this.y:branch2> -[ASSIGNED_FROM]-> <y!>
    void code;
  });

  test('ts-specific::ts-mapped-type-as-clause', () => {
    const code = "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\ntype RemoveKind<T> = {\n  [K in keyof T as Exclude<K, 'kind'>]: T[K]\n};";
    // Expect edge: <Getters> -[ASSIGNED_FROM]-> <Getters:mapped>
    // Expect edge: <RemoveKind> -[ASSIGNED_FROM]-> <RemoveKind:mapped>
    void code;
  });

  test('ts-specific::ts-this-type-guard', () => {
    const code = "class FSNode {\n  isFile(): this is FSFileNode { return this instanceof FSFileNode; }\n  isDir(): this is FSDirNode { return this instanceof FSDirNode; }\n}\n\nclass FSFileNode extends FSNode {\n  content: string = '';\n}\n\nclass FSDirNode extends FSNode {\n  children: FSNode[] = [];\n}";
    // Expect edge: <FSFileNode.content> -[ASSIGNED_FROM]-> <''>
    // Expect edge: <FSDirNode.children> -[ASSIGNED_FROM]-> <[]>
    void code;
  });

  test('ts-specific::ts-distributive-conditional', () => {
    const code = "type ToArray<T> = T extends any ? T[] : never;\ntype DistResult = ToArray<string | number>; // string[] | number[]\n\ntype ToArrayND<T> = [T] extends [any] ? T[] : never;\ntype NonDistResult = ToArrayND<string | number>; // (string | number)[]";
    // Expect edge: <T extends any ? T[] : never> -[HAS_ALTERNATE]-> <never>
    // Expect edge: <[T] extends [any] ? T[] : never> -[HAS_ALTERNATE]-> <never_nd>
    void code;
  });

  test('ts-specific::ts-function-type-intersection', () => {
    const code = "type StringHandler = (input: string) => string;\ntype NumberHandler = (input: number) => number;\ntype BothHandler = StringHandler & NumberHandler;";
    // Expect edge: <StringHandler> -[ASSIGNED_FROM]-> <StringHandler:fn-type>
    // Expect edge: <NumberHandler> -[ASSIGNED_FROM]-> <NumberHandler:fn-type>
    // Expect edge: <BothHandler> -[ASSIGNED_FROM]-> <StringHandler & NumberHandler>
    void code;
  });

  test('ts-specific::ts-import-type-inline', () => {
    const code = "// Type-level import() — resolves types without runtime import\ntype InlineImported = import('./modules-helpers.js').default;\n// In function signatures: function handle(req: import('express').Request): void {}\n\n// --- TypeScript using with type annotations ---";
    // Expect edge: <InlineImported> -[ASSIGNED_FROM]-> <import('./modules-helpers.js').default>
    void code;
  });

  test('ts-specific::ts-enum-reverse-mapping', () => {
    const code = "enum HttpStatus {\n  OK = 200,\n  NotFound = 404,\n  ServerError = 500,\n}\nconst statusName = HttpStatus[200];           // 'OK' — reverse mapping\nconst statusCode = HttpStatus.OK;             // 200 — forward mapping\n// String enums do NOT have reverse mapping";
    // Expect edge: <HttpStatus.OK> -[ASSIGNED_FROM]-> <200>
    // Expect edge: <HttpStatus.NotFound> -[ASSIGNED_FROM]-> <404>
    // Expect edge: <HttpStatus.ServerError> -[ASSIGNED_FROM]-> <500>
    // Expect edge: <statusName> -[ASSIGNED_FROM]-> <HttpStatus[200]>
    // Expect edge: <statusCode> -[ASSIGNED_FROM]-> <HttpStatus.OK>
    void code;
  });

  test('ts-specific::ts-import-equals-require', () => {
    const code = "// CJS-style import — emits: const CjsLib = require('./module')\n// import CjsLib = require('./module');\n// const instance = new CjsLib();\n// (commented out: requires actual CJS module; syntax is ExportAssignment / ImportEqualsDeclaration)\n\n// --- Getter and setter with different types (TS 4.3+) ---";
    // Expect edge: <instance> -[ASSIGNED_FROM]-> <new CjsLib()>
    void code;
  });

  test('ts-specific::ts-export-equals', () => {
    const code = "// CJS-style export assignment — emits: module.exports = CjsLibrary\nclass CjsLibrary {\n  static VERSION = '1.0';\n  process(data: string): string { return data.toUpperCase(); }\n}\n// export = CjsLibrary;\n// (commented out: only one module export mode per file; shown for AST coverage)";
    // Expect edge: <CjsLibrary.VERSION> -[ASSIGNED_FROM]-> <'1.0'>
    // Expect edge: <export=CjsLibrary> -[EXPORTS]-> <CjsLibrary>
    void code;
  });

  test('ts-specific::ts-getter-setter-different-types', () => {
    const code = "class SmartField {\n  #raw: string = '';\n\n  get value(): string {\n    return this.#raw;\n  }\n\n  // Setter accepts wider type than getter returns\n  set value(input: string | number) {\n    this.#raw = String(input);\n  }\n}\n\n// --- Inline type modifier on import/export specifiers (TS 4.5+) ---";
    // Expect edge: <SmartField.#raw> -[ASSIGNED_FROM]-> <''>
    // Expect edge: <SmartField.#raw> -[ASSIGNED_FROM]-> <String(input)>
    // Expect edge: <SmartField.value:setter> -[WRITES_TO]-> <SmartField.#raw>
    void code;
  });

  test('ts-specific::ts-using-typed', () => {
    const code = "// using with type annotations (TS extension of ES2025 Explicit Resource Management)\n// using handle: FileHandle = openFile('/tmp/data');\n// await using conn: DBConnection = await pool.connect();\n// for (using reader: Reader of getReaders()) { reader.process(); }\n\n// --- satisfies + as const combo ---";
    // Expect edge: <handle> -[ASSIGNED_FROM]-> <openFile('/tmp/data')>
    // Expect edge: <conn> -[ASSIGNED_FROM]-> <await pool.connect()>
    void code;
  });

  test('ts-specific::ts-inline-type-modifier', () => {
    const code = "// Mixed value + type in single import:\n// import { Component, type Props, type State } from './ui';\n// Component → runtime import (IMPORTS_FROM edge)\n// Props, State → type-only (erased, NO runtime dependency)\n\n// Mixed value + type in single re-export:\n// export { handler, type HandlerConfig } from './handlers';\n\n// Contrast with import type (entire statement is type-only):\n// import type { OnlyTypes } from './types';\n\n// --- this parameter combined with destructuring ---";
    // Expect edge: <export-handlers> -[EXPORTS]-> <handler>
    // Expect edge: <export-handlers> -[EXPORTS]-> <HandlerConfig>
    void code;
  });

  test('ts-specific::ts-satisfies-as-const', () => {
    const code = "const routes = {\n  home: '/',\n  about: '/about',\n  user: '/user/:id',\n} as const satisfies Record<string, string>;\n\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n} satisfies Record<string, string | number[]>;\n\n// --- TS CJS interop: export = / import = require() ---";
    // Expect edge: <routes> -[ASSIGNED_FROM]-> <routes:obj>
    // Expect edge: <routes:obj.home> -[ASSIGNED_FROM]-> <'/'>
    // Expect edge: <routes:obj.about> -[ASSIGNED_FROM]-> <'/about'>
    // Expect edge: <routes:obj.user> -[ASSIGNED_FROM]-> <'/user/:id'>
    // Expect edge: <palette> -[ASSIGNED_FROM]-> <palette:obj>
    // Expect edge: <palette:obj.red> -[ASSIGNED_FROM]-> <[255, 0, 0]>
    // Expect edge: <palette:obj.green> -[ASSIGNED_FROM]-> <'#00ff00'>
    void code;
  });

  test('ts-specific::ts-infer-constrained', () => {
    const code = "type FirstString<T> = T extends [infer S extends string, ...unknown[]] ? S : never;\ntype NumericKeys<T> = { [K in keyof T as K extends `${infer N extends number}` ? K : never]: T[K] };\ntype ParsePair<T> = T extends `${infer A extends number},${infer B extends number}` ? [A, B] : never;\n\n// --- Inline import() type expressions ---";
    // Expect edge: <FirstString> -[ASSIGNED_FROM]-> <FirstString:conditional>
    // Expect edge: <FirstString:conditional> -[HAS_ALTERNATE]-> <never1>
    // Expect edge: <NumericKeys> -[ASSIGNED_FROM]-> <NumericKeys:mapped>
    // Expect edge: <NumericKeys:remapping> -[HAS_ALTERNATE]-> <never2>
    // Expect edge: <ParsePair> -[ASSIGNED_FROM]-> <ParsePair:conditional>
    // Expect edge: <ParsePair:conditional> -[HAS_ALTERNATE]-> <never3>
    void code;
  });
});

describe('Unknown post-project enrichment', () => {
  test('aliasing::alias-method-extraction', () => {
    const code = "const log = console.log;\nlog('extracted');";
    // Expect edge: <console.log> -[READS_FROM]-> <console>
    // Expect edge: <log('extracted')> -[CALLS]-> <log>
    void code;
  });

  test('aliasing::alias-reassign-function', () => {
    const code = "let handler = function first() { return 1; };\nhandler();\n\nhandler = function second() { return 2; };\nhandler();";
    // Expect edge: <handler()_1> -[CALLS]-> <handler>
    // Expect edge: <handler()_2> -[CALLS]-> <handler>
    void code;
  });

  test('aliasing::alias-destructured-method', () => {
    const code = "const { parse, stringify } = JSON;\nconst parsed = parse('{\"a\":1}');";
    // Expect edge: <parse> -[ALIASES]-> <JSON.parse>
    // Expect edge: <stringify> -[ALIASES]-> <JSON.stringify>
    // Expect edge: <parse('{"a":1}')> -[CALLS]-> <parse>
    void code;
  });

  test('aliasing::alias-bind-partial', () => {
    const code = "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---";
    // Expect edge: <a * b> -[READS_FROM]-> <a>
    // Expect edge: <a * b> -[READS_FROM]-> <b>
    // Expect edge: <multiply.bind(null, 2)> -[CALLS]-> <multiply>
    // Expect edge: <doubleIt:bound> -[DERIVES_FROM]-> <multiply>
    // Expect edge: <doubleIt(5)> -[CALLS]-> <doubleIt>
    void code;
  });

  test('aliasing::alias-computed-method', () => {
    const code = "const mathObj = { add(a, b) { return a + b; } };\nconst methodName = 'add';\nconst fn = mathObj[methodName];\nfn(1, 2);\n\n// --- Function reassignment ---";
    // Expect edge: <a + b> -[READS_FROM]-> <a>
    // Expect edge: <a + b> -[READS_FROM]-> <b>
    // Expect edge: <mathObj[methodName]> -[READS_FROM]-> <mathObj>
    // Expect edge: <mathObj[methodName]> -[READS_FROM]-> <methodName>
    // Expect edge: <mathObj[methodName]> -[RESOLVES_TO]-> <add>
    // Expect edge: <fn(1, 2)> -[CALLS]-> <fn>
    void code;
  });

  test('aliasing::alias-reassign-conditional', () => {
    const code = "let strategy;\nif (Math.random() > 0.5) {\n  strategy = function fast() { return 'fast'; };\n} else {\n  strategy = function slow() { return 'slow'; };\n}\nstrategy();\n\n// --- Callback identity through higher-order functions ---";
    // Expect edge: <strategy()> -[CALLS]-> <strategy>
    void code;
  });

  test('aliasing::alias-callback-passed', () => {
    const code = "function applyToArray(arr, callback) {\n  return arr.map(callback);\n}\nfunction double(x) { return x * 2; }\napplyToArray([1, 2, 3], double);";
    // Expect edge: <arr.map(callback)> -[CALLS_ON]-> <arr>
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    // Expect edge: <applyToArray([1, 2, 3], double)> -[CALLS]-> <applyToArray>
    // Expect edge: <callback> -[ALIASES]-> <double>
    void code;
  });

  test('aliasing::alias-callback-returned', () => {
    const code = "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---";
    // Expect edge: <a - b> -[READS_FROM]-> <a1>
    // Expect edge: <a - b> -[READS_FROM]-> <b1>
    // Expect edge: <b - a> -[READS_FROM]-> <b2>
    // Expect edge: <b - a> -[READS_FROM]-> <a2>
    // Expect edge: <getComparator(true)> -[CALLS]-> <getComparator>
    // Expect edge: <[3, 1, 2].sort(cmp)> -[CALLS_ON]-> <[3, 1, 2]>
    void code;
  });

  test('aliasing::alias-callback-returned', () => {
    const code = "function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---";
    // Expect edge: <a1 - b1> -[READS_FROM]-> <a1>
    // Expect edge: <a1 - b1> -[READS_FROM]-> <b1>
    // Expect edge: <b2 - a2> -[READS_FROM]-> <b2>
    // Expect edge: <b2 - a2> -[READS_FROM]-> <a2>
    // Expect edge: <getComparator(true)> -[CALLS]-> <getComparator>
    // Expect edge: <[3, 1, 2].sort(cmp)> -[CALLS_ON]-> <[3, 1, 2]>
    void code;
  });

  test('aliasing::arguments-basic', () => {
    const code = "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}";
    // Expect edge: <i < arguments.length> -[READS_FROM]-> <i>
    // Expect edge: <i < arguments.length> -[READS_FROM]-> <arguments.length>
    // Expect edge: <arguments.length> -[READS_FROM]-> <arguments>
    // Expect edge: <total += arguments[i]> -[READS_FROM]-> <arguments[i]>
    // Expect edge: <arguments[i]> -[READS_FROM]-> <arguments>
    // Expect edge: <arguments[i]> -[READS_FROM]-> <i>
    void code;
  });

  test('aliasing::alias-bind-partial', () => {
    const code = "function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---";
    // Expect edge: <a * b> -[READS_FROM]-> <a>
    // Expect edge: <a * b> -[READS_FROM]-> <b>
    // Expect edge: <multiply.bind(null, 2)> -[CALLS]-> <multiply>
    // Expect edge: <doubleIt:bound> -[DERIVES_FROM]-> <multiply>
    // Expect edge: <doubleIt(5)> -[CALLS]-> <doubleIt>
    void code;
  });

  test('aliasing::alias-import-dynamic-variable', () => {
    const code = "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);";
    // Expect edge: <import(modulePath)> -[IMPORTS_FROM]-> <./declarations.js>
    // Expect edge: <dynamicMod> -[ALIASES]-> <./declarations.js>
    void code;
  });

  test('aliasing::arguments-callee', () => {
    const code = "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---";
    // Expect edge: <n <= 1> -[READS_FROM]-> <n>
    // Expect edge: <n <= 1> -[READS_FROM]-> <1>
    // Expect edge: <n * arguments.callee(n - 1)> -[READS_FROM]-> <n>
    // Expect edge: <n * arguments.callee(n - 1)> -[READS_FROM]-> <arguments.callee(n - 1)>
    // Expect edge: <arguments.callee(n - 1)> -[CALLS]-> <arguments.callee>
    // Expect edge: <n - 1> -[READS_FROM]-> <n>
    // Expect edge: <n - 1> -[READS_FROM]-> <1>
    // Expect edge: <arguments.callee> -[ALIASES]-> <factorial:fn>
    void code;
  });

  test('aliasing::arguments-basic', () => {
    const code = "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}";
    // Expect edge: <i < arguments.length> -[READS_FROM]-> <i>
    // Expect edge: <i < arguments.length> -[READS_FROM]-> <arguments.length>
    // Expect edge: <arguments.length> -[READS_FROM]-> <arguments>
    // Expect edge: <total += arguments[i]> -[READS_FROM]-> <arguments[i]>
    // Expect edge: <arguments[i]> -[READS_FROM]-> <arguments>
    // Expect edge: <arguments[i]> -[READS_FROM]-> <i>
    void code;
  });

  test('aliasing::arguments-array-conversion', () => {
    const code = "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}";
    // Expect edge: <Array.from(arguments)> -[CALLS]-> <Array.from>
    // Expect edge: <[].slice.call(arguments)> -[CALLS]-> <[].slice.call>
    // Expect edge: <[].slice> -[READS_FROM]-> <[]>
    // Expect edge: <{ fromArrayFn, fromSpread, fromSlice }> -[READS_FROM]-> <fromArrayFn>
    // Expect edge: <{ fromArrayFn, fromSpread, fromSlice }> -[READS_FROM]-> <fromSpread>
    // Expect edge: <{ fromArrayFn, fromSpread, fromSlice }> -[READS_FROM]-> <fromSlice>
    void code;
  });

  test('aliasing::arguments-array-conversion', () => {
    const code = "function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}";
    // Expect edge: <Array.from(arguments)> -[CALLS]-> <Array.from>
    // Expect edge: <[].slice.call(arguments)> -[CALLS]-> <[].slice.call>
    // Expect edge: <[].slice> -[READS_FROM]-> <[]>
    // Expect edge: <{ fromArrayFn, fromSpread, fromSlice }> -[READS_FROM]-> <fromArrayFn>
    // Expect edge: <{ fromArrayFn, fromSpread, fromSlice }> -[READS_FROM]-> <fromSpread>
    // Expect edge: <{ fromArrayFn, fromSpread, fromSlice }> -[READS_FROM]-> <fromSlice>
    void code;
  });

  test('aliasing::alias-import-dynamic-conditional', () => {
    const code = "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);";
    // Expect edge: <Math.random() > 0.5> -[READS_FROM]-> <Math.random()>
    // Expect edge: <Math.random() > 0.5> -[READS_FROM]-> <0.5>
    // Expect edge: <import()> -[IMPORTS_FROM]-> <'./declarations.js'>
    // Expect edge: <import()> -[IMPORTS_FROM]-> <'./expressions.js'>
    void code;
  });

  test('aliasing::arguments-callee', () => {
    const code = "const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---";
    // Expect edge: <n <= 1> -[READS_FROM]-> <n>
    // Expect edge: <n <= 1> -[READS_FROM]-> <1>
    // Expect edge: <n * arguments.callee(n - 1)> -[READS_FROM]-> <n>
    // Expect edge: <n * arguments.callee(n - 1)> -[READS_FROM]-> <arguments.callee(n - 1)>
    // Expect edge: <arguments.callee(n - 1)> -[CALLS]-> <arguments.callee>
    // Expect edge: <n - 1> -[READS_FROM]-> <n>
    // Expect edge: <n - 1> -[READS_FROM]-> <1>
    // Expect edge: <arguments.callee> -[ALIASES]-> <factorial:fn>
    void code;
  });

  test('aliasing::alias-import-dynamic-variable', () => {
    const code = "const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);";
    // Expect edge: <import(modulePath)> -[IMPORTS_FROM]-> <./declarations.js>
    // Expect edge: <dynamicMod> -[ALIASES]-> <./declarations.js>
    void code;
  });

  test('aliasing::alias-import-dynamic-template', () => {
    const code = "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}";
    // Expect edge: <dynamic-import> -[IMPORTS_FROM]-> <template-literal>
    // Expect edge: <template-literal> -[READS_FROM]-> <name>
    // Expect edge: <plugin.default> -[READS_FROM]-> <plugin>
    void code;
  });

  test('aliasing::alias-import-dynamic-template', () => {
    const code = "async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}";
    // Expect edge: <dynamic-import> -[IMPORTS_FROM]-> <template-literal>
    // Expect edge: <template-literal> -[READS_FROM]-> <name>
    // Expect edge: <plugin.default> -[READS_FROM]-> <plugin>
    void code;
  });

  test('aliasing::alias-import-dynamic-conditional', () => {
    const code = "const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);";
    // Expect edge: <Math.random() > 0.5> -[READS_FROM]-> <Math.random()>
    // Expect edge: <Math.random() > 0.5> -[READS_FROM]-> <0.5>
    // Expect edge: <import()> -[IMPORTS_FROM]-> <'./declarations.js'>
    // Expect edge: <import()> -[IMPORTS_FROM]-> <'./expressions.js'>
    void code;
  });

  test('aliasing::arrow-no-arguments', () => {
    const code = "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);";
    // Expect edge: <outerWithArguments(42)> -[CALLS]-> <outerWithArguments>
    void code;
  });

  test('aliasing::arrow-no-arguments', () => {
    const code = "function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);";
    // Expect edge: <outerWithArguments(42)> -[CALLS]-> <outerWithArguments>
    void code;
  });

  test('aliasing::arguments-param-aliasing', () => {
    const code = "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode — bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}";
    // Expect edge: <arguments> -[ALIASES]-> <a>
    // Expect edge: <arguments> -[ALIASES]-> <b>
    // Expect edge: <a> -[ALIASES]-> <arguments[0]>
    // Expect edge: <{ aAfterMutation, arg0AfterReassign }> -[READS_FROM]-> <aAfterMutation>
    // Expect edge: <{ aAfterMutation, arg0AfterReassign }> -[READS_FROM]-> <arg0AfterReassign>
    void code;
  });

  test('aliasing::arguments-param-aliasing', () => {
    const code = "function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode — bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}";
    // Expect edge: <arguments> -[ALIASES]-> <a>
    // Expect edge: <arguments> -[ALIASES]-> <b>
    // Expect edge: <a> -[ALIASES]-> <arguments[0]>
    // Expect edge: <{ aAfterMutation, arg0AfterReassign }> -[READS_FROM]-> <aAfterMutation>
    // Expect edge: <{ aAfterMutation, arg0AfterReassign }> -[READS_FROM]-> <arg0AfterReassign>
    void code;
  });

  test('aliasing::arguments-rest-coexistence', () => {
    const code = "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}";
    // Expect edge: <arguments.length> -[READS_FROM]-> <arguments>
    // Expect edge: <arguments[0]> -[READS_FROM]-> <arguments>
    // Expect edge: <arguments[1]> -[READS_FROM]-> <arguments>
    // Expect edge: <return-object> -[READS_FROM]-> <allCount>
    // Expect edge: <return-object> -[READS_FROM]-> <firstFromArgs>
    // Expect edge: <return-object> -[READS_FROM]-> <restFromArgs>
    // Expect edge: <return-object> -[READS_FROM]-> <rest>
    void code;
  });

  test('async-generators::async-await-basic', () => {
    const code = "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}";
    // Expect edge: <fetch(url)> -[CALLS]-> <fetch>
    // Expect edge: <response.json()> -[CALLS]-> <response.json>
    // Expect edge: <response.json> -[READS_FROM]-> <response>
    void code;
  });

  test('aliasing::arguments-rest-coexistence', () => {
    const code = "function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}";
    // Expect edge: <arguments.length> -[READS_FROM]-> <arguments>
    // Expect edge: <arguments[0]> -[READS_FROM]-> <arguments>
    // Expect edge: <arguments[1]> -[READS_FROM]-> <arguments>
    // Expect edge: <return-object> -[READS_FROM]-> <allCount>
    // Expect edge: <return-object> -[READS_FROM]-> <firstFromArgs>
    // Expect edge: <return-object> -[READS_FROM]-> <restFromArgs>
    // Expect edge: <return-object> -[READS_FROM]-> <rest>
    void code;
  });

  test('async-generators::async-await-basic', () => {
    const code = "async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}";
    // Expect edge: <fetch(url)> -[CALLS]-> <fetch>
    // Expect edge: <response.json()> -[CALLS]-> <response.json>
    // Expect edge: <response.json> -[READS_FROM]-> <response>
    void code;
  });

  test('async-generators::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};";
    // Expect edge: <Promise.resolve(42)> -[CALLS]-> <Promise>
    void code;
  });

  test('async-generators::promise-construction', () => {
    const code = "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}";
    // Expect edge: <resolve('success')> -[CALLS]-> <resolve>
    // Expect edge: <reject(new Error('failure'))> -[CALLS]-> <reject>
    void code;
  });

  test('async-generators::async-await-try-catch', () => {
    const code = "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}";
    // Expect edge: <!response.ok> -[READS_FROM]-> <response.ok>
    // Expect edge: <response.ok> -[READS_FROM]-> <response>
    // Expect edge: <`HTTP ${response.status}`> -[READS_FROM]-> <response.status>
    // Expect edge: <response.status> -[READS_FROM]-> <response>
    // Expect edge: <response.json()> -[CALLS_ON]-> <response>
    void code;
  });

  test('async-generators::promise-construction', () => {
    const code = "function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}";
    // Expect edge: <resolve('success')> -[CALLS]-> <resolve>
    // Expect edge: <reject(new Error('failure'))> -[CALLS]-> <reject>
    void code;
  });

  test('async-generators::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};";
    // Expect edge: <Promise.resolve(42)> -[CALLS]-> <Promise>
    void code;
  });

  test('async-generators::async-await-try-catch', () => {
    const code = "async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}";
    // Expect edge: <!response.ok> -[READS_FROM]-> <response.ok>
    // Expect edge: <response.ok> -[READS_FROM]-> <response>
    // Expect edge: <`HTTP ${response.status}`> -[READS_FROM]-> <response.status>
    // Expect edge: <response.status> -[READS_FROM]-> <response>
    // Expect edge: <response.json()> -[CALLS_ON]-> <response>
    void code;
  });

  test('async-generators::async-arrow-with-params', () => {
    const code = "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};";
    // Expect edge: <response.json()> -[CALLS_ON]-> <response>
    void code;
  });

  test('async-generators::generator-basic', () => {
    const code = "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}";
    // Expect edge: <i <= end> -[READS_FROM]-> <i>
    // Expect edge: <i <= end> -[READS_FROM]-> <end>
    // Expect edge: <yield i> -[READS_FROM]-> <i>
    void code;
  });

  test('async-generators::promise-chaining', () => {
    const code = "function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}";
    // Expect edge: <response.json()> -[READS_FROM]-> <response>
    // Expect edge: <data.result> -[READS_FROM]-> <data>
    void code;
  });

  test('async-generators::async-arrow-with-params', () => {
    const code = "const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};";
    // Expect edge: <response.json()> -[CALLS_ON]-> <response>
    void code;
  });

  test('async-generators::generator-basic', () => {
    const code = "function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}";
    // Expect edge: <i <= end> -[READS_FROM]-> <i>
    // Expect edge: <i <= end> -[READS_FROM]-> <end>
    // Expect edge: <yield i> -[READS_FROM]-> <i>
    void code;
  });

  test('async-generators::promise-chaining', () => {
    const code = "function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}";
    // Expect edge: <response.json()> -[READS_FROM]-> <response>
    // Expect edge: <data.result> -[READS_FROM]-> <data>
    void code;
  });

  test('async-generators::generator-delegation', () => {
    const code = "function* innerGenerator() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* outerGenerator() {\n  yield 1;\n  yield* innerGenerator();\n  yield 2;\n}";
    // Expect edge: <innerGenerator()> -[CALLS]-> <innerGenerator>
    void code;
  });

  test('async-generators::top-level-await', () => {
    const code = "const config = await import('./declarations.js');";
    // Expect edge: <import('./declarations.js')> -[IMPORTS_FROM]-> <./declarations.js>
    void code;
  });

  test('async-generators::generator-infinite', () => {
    const code = "function* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}";
    // Expect edge: <yield-a> -[READS_FROM]-> <a>
    // Expect edge: <a-plus-b> -[READS_FROM]-> <a>
    // Expect edge: <a-plus-b> -[READS_FROM]-> <b>
    // Expect edge: <destructure-array> -[READS_FROM]-> <b>
    // Expect edge: <destructure-array> -[READS_FROM]-> <a-plus-b>
    void code;
  });

  test('async-generators::async-return-thenable', () => {
    const code = "async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}";
    // Expect edge: <resolve(42)> -[CALLS]-> <resolve>
    void code;
  });

  test('async-generators::async-generator', () => {
    const code = "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}";
    // Expect edge: <i <= end> -[READS_FROM]-> <i>
    // Expect edge: <i <= end> -[READS_FROM]-> <end>
    void code;
  });

  test('async-generators::for-await-of', () => {
    const code = "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results.push(item)> -[CALLS_ON]-> <results>
    void code;
  });

  test('async-generators::for-await-of', () => {
    const code = "async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results.push(item)> -[CALLS_ON]-> <results>
    void code;
  });

  test('async-generators::generator-finally-cleanup', () => {
    const code = "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}";
    // Expect edge: <yield resource> -[READS_FROM]-> <resource>
    // Expect edge: <yield { transformed: true }> -[READS_FROM]-> <{ transformed: true }>
    // Expect edge: <resource.acquired> -[READS_FROM]-> <resource>
    void code;
  });

  test('async-generators::generator-observer-pattern', () => {
    const code = "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---";
    // Expect edge: <results.push(value)> -[CALLS]-> <results.push>
    // Expect edge: <results.push> -[READS_FROM]-> <results>
    void code;
  });

  test('async-generators::top-level-await', () => {
    const code = "const config = await import('./declarations.js');";
    // Expect edge: <import('./declarations.js')> -[IMPORTS_FROM]-> <./declarations.js>
    void code;
  });

  test('async-generators::generator-two-way', () => {
    const code = "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}";
    // Expect edge: <yield-total> -[READS_FROM]-> <total>
    // Expect edge: <total += value> -[READS_FROM]-> <value>
    void code;
  });

  test('async-generators::generator-break-triggers-finally', () => {
    const code = "function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return() → finally runs\n  }\n}";
    // Expect edge: <item.transformed> -[READS_FROM]-> <item>
    void code;
  });

  test('async-generators::promise-resolve-thenable', () => {
    const code = "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}";
    // Expect edge: <resolve(nested-thenable)> -[CALLS]-> <resolve>
    // Expect edge: <resolve2(42)> -[CALLS]-> <resolve2>
    void code;
  });

  test('async-generators::async-generator', () => {
    const code = "async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}";
    // Expect edge: <i <= end> -[READS_FROM]-> <i>
    // Expect edge: <i <= end> -[READS_FROM]-> <end>
    void code;
  });

  test('async-generators::yield-star-return-value', () => {
    const code = "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}";
    // Expect edge: <innerWithReturn()> -[CALLS]-> <innerWithReturn>
    void code;
  });

  test('async-generators::for-await-sync-iterable', () => {
    const code = "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array — each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results.push(item)> -[CALLS_ON]-> <results>
    // Expect edge: <return results> -[READS_FROM]-> <results>
    void code;
  });

  test('async-generators::async-iterator-cancel-manual', () => {
    const code = "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}";
    // Expect edge: <asyncGen[Symbol.asyncIterator]()> -[CALLS]-> <asyncGen[Symbol.asyncIterator]>
    // Expect edge: <asyncGen[Symbol.asyncIterator]> -[READS_FROM]-> <asyncGen>
    // Expect edge: <iter.next()> -[CALLS]-> <iter.next>
    // Expect edge: <iter.next> -[READS_FROM]-> <iter>
    // Expect edge: <iter.return()> -[CALLS]-> <iter.return>
    // Expect edge: <iter.return> -[READS_FROM]-> <iter>
    // Expect edge: <return first> -[READS_FROM]-> <first>
    void code;
  });

  test('builtins::builtin-json-stringify', () => {
    const code = "function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}";
    // Expect edge: <JSON.stringify(obj)> -[CALLS]-> <JSON.stringify>
    // Expect edge: <JSON.stringify> -[READS_FROM]-> <JSON>
    void code;
  });

  test('async-generators::async-generator-destructure-default', () => {
    const code = "async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---";
    // Expect edge: <{ ...data, priority }> -[READS_FROM]-> <priority>
    void code;
  });

  test('builtins::builtin-json-parse', () => {
    const code = "function jsonParse(str) {\n  return JSON.parse(str);\n}";
    // Expect edge: <JSON.parse(str)> -[CALLS]-> <JSON.parse>
    // Expect edge: <JSON.parse> -[READS_FROM]-> <JSON>
    void code;
  });

  test('async-generators::generator-two-way', () => {
    const code = "function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}";
    // Expect edge: <yield-total> -[READS_FROM]-> <total>
    // Expect edge: <total += value> -[READS_FROM]-> <value>
    void code;
  });

  test('async-generators::async-iter-manual', () => {
    const code = "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}";
    // Expect edge: <asyncIterable[Symbol.asyncIterator]()> -[CALLS]-> <asyncIterable[Symbol.asyncIterator]>
    // Expect edge: <asyncIterable[Symbol.asyncIterator]> -[READS_FROM]-> <asyncIterable>
    // Expect edge: <asyncIter.next()> -[READS_FROM]-> <asyncIter>
    // Expect edge: <!step.done> -[READS_FROM]-> <step.done>
    // Expect edge: <step.done> -[READS_FROM]-> <step>
    // Expect edge: <results.push(step.value)> -[READS_FROM]-> <results>
    // Expect edge: <step.value> -[READS_FROM]-> <step>
    // Expect edge: <step = await asyncIter.next()> -[READS_FROM]-> <asyncIter.next()#2>
    // Expect edge: <asyncIter.next()#2> -[READS_FROM]-> <asyncIter>
    // Expect edge: <asyncIter.return?.()> -[CALLS]-> <asyncIter.return>
    // Expect edge: <asyncIter.return> -[READS_FROM]-> <asyncIter>
    void code;
  });

  test('async-generators::async-iterator-cancel-break', () => {
    const code = "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}";
    // Expect edge: <i < 10> -[READS_FROM]-> <i>
    // Expect edge: <i < 10> -[READS_FROM]-> <10>
    // Expect edge: <{ chunk: i, size: i * 100 }> -[READS_FROM]-> <i>
    // Expect edge: <{ chunk: i, size: i * 100 }> -[READS_FROM]-> <i * 100>
    // Expect edge: <i * 100> -[READS_FROM]-> <i>
    // Expect edge: <i * 100> -[READS_FROM]-> <100>
    // Expect edge: <reader.locked> -[READS_FROM]-> <reader>
    void code;
  });

  test('builtins::builtin-weakref', () => {
    const code = "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}";
    // Expect edge: <ref.deref()> -[READS_FROM]-> <ref>
    // Expect edge: <deref?.data> -[READS_FROM]-> <deref>
    void code;
  });

  test('builtins::builtin-map-constructor', () => {
    const code = "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---";
    // Expect edge: <new Map([...])> -[CALLS]-> <Map>
    void code;
  });

  test('builtins::builtin-json-parse-reviver', () => {
    const code = "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}";
    // Expect edge: <JSON.parse(str, reviver)> -[CALLS]-> <JSON.parse>
    // Expect edge: <key === 'date'> -[READS_FROM]-> <key>
    // Expect edge: <key === 'date'> -[READS_FROM]-> <'date'>
    // Expect edge: <new Date(value)> -[CALLS]-> <Date>
    void code;
  });

  test('async-generators::async-destructure-await-default', () => {
    const code = "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};";
    // Expect edge: <getConfigValue('timeout')> -[CALLS]-> <getConfigValue>
    // Expect edge: <getConfigValue('retries')> -[CALLS]-> <getConfigValue>
    // Expect edge: <{ timeout, retries }> -[READS_FROM]-> <timeout>
    // Expect edge: <{ timeout, retries }> -[READS_FROM]-> <retries>
    void code;
  });

  test('builtins::builtin-json-stringify-replacer', () => {
    const code = "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---";
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[CALLS]-> <JSON.stringify>
    // Expect edge: <typeof value === 'function'> -[READS_FROM]-> <typeof value>
    // Expect edge: <typeof value === 'function'> -[READS_FROM]-> <'function'>
    // Expect edge: <typeof value> -[READS_FROM]-> <value>
    void code;
  });

  test('builtins::builtin-weakset', () => {
    const code = "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---";
    // Expect edge: <new WeakSet()> -[CALLS]-> <WeakSet>
    // Expect edge: <ws.add(obj1)> -[CALLS_ON]-> <ws>
    // Expect edge: <ws.has(obj1)> -[CALLS_ON]-> <ws>
    // Expect edge: <ws.delete(obj1)> -[CALLS_ON]-> <ws>
    // Expect edge: <ws.has(obj1)2> -[CALLS_ON]-> <ws>
    // Expect edge: <{ has, hasAfter }> -[READS_FROM]-> <has>
    // Expect edge: <{ has, hasAfter }> -[READS_FROM]-> <hasAfter>
    void code;
  });

  test('builtins::builtin-globalthis', () => {
    const code = "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---";
    // Expect edge: <'console' in globalThis> -[READS_FROM]-> <'console'>
    // Expect edge: <'console' in globalThis> -[READS_FROM]-> <globalThis>
    // Expect edge: <{ g, hasConsole }> -[READS_FROM]-> <g>
    // Expect edge: <{ g, hasConsole }> -[READS_FROM]-> <hasConsole>
    void code;
  });

  test('async-generators::async-return-thenable', () => {
    const code = "async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}";
    // Expect edge: <resolve(42)> -[CALLS]-> <resolve>
    void code;
  });

  test('builtins::builtin-finalization-registry', () => {
    const code = "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---";
    // Expect edge: <`Cleaned up: ${heldValue}`> -[READS_FROM]-> <heldValue>
    void code;
  });

  test('builtins::builtin-regex-named-groups', () => {
    const code = "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---";
    // Expect edge: <dateStr.match(pattern)> -[READS_FROM]-> <dateStr>
    // Expect edge: <match.groups> -[READS_FROM]-> <match>
    // Expect edge: <{ year, month, day }> -[READS_FROM]-> <year>
    // Expect edge: <{ year, month, day }> -[READS_FROM]-> <month>
    // Expect edge: <{ year, month, day }> -[READS_FROM]-> <day>
    void code;
  });

  test('builtins::builtin-regex-exec', () => {
    const code = "function regexExec(pattern, str) {\n  const regex = new RegExp(pattern, 'g');\n  const matches = [];\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    matches.push({ match: match[0], index: match.index });\n  }\n  return matches;\n}";
    // Expect edge: <(match = regex.exec(str)) !== null> -[READS_FROM]-> <match = regex.exec(str)>
    // Expect edge: <(match = regex.exec(str)) !== null> -[READS_FROM]-> <null>
    // Expect edge: <match = regex.exec(str)> -[READS_FROM]-> <regex.exec(str)>
    // Expect edge: <{ match: match[0], index: match.index }> -[READS_FROM]-> <match[0]>
    // Expect edge: <{ match: match[0], index: match.index }> -[READS_FROM]-> <match.index>
    // Expect edge: <match[0]> -[READS_FROM]-> <match>
    // Expect edge: <match.index> -[READS_FROM]-> <match>
    void code;
  });

  test('async-generators::async-iter-manual', () => {
    const code = "async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}";
    // Expect edge: <asyncIterable[Symbol.asyncIterator]()> -[CALLS]-> <asyncIterable[Symbol.asyncIterator]>
    // Expect edge: <asyncIterable[Symbol.asyncIterator]> -[READS_FROM]-> <asyncIterable>
    // Expect edge: <asyncIter.next()> -[READS_FROM]-> <asyncIter>
    // Expect edge: <!step.done> -[READS_FROM]-> <step.done>
    // Expect edge: <step.done> -[READS_FROM]-> <step>
    // Expect edge: <results.push(step.value)> -[READS_FROM]-> <results>
    // Expect edge: <step.value> -[READS_FROM]-> <step>
    // Expect edge: <step = await asyncIter.next()> -[READS_FROM]-> <asyncIter.next()#2>
    // Expect edge: <asyncIter.next()#2> -[READS_FROM]-> <asyncIter>
    // Expect edge: <asyncIter.return?.()> -[CALLS]-> <asyncIter.return>
    // Expect edge: <asyncIter.return> -[READS_FROM]-> <asyncIter>
    void code;
  });

  test('builtins::string-raw-template', () => {
    const code = "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file' — no escape processing";
    // Expect edge: <String.raw`C:\Users\name\file`> -[CALLS]-> <String.raw>
    // Expect edge: <String.raw> -[READS_FROM]-> <String>
    void code;
  });

  test('builtins::array-from-mapfn', () => {
    const code = "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---";
    // Expect edge: <Array.from({ length: 5 }, (_, i) => i)> -[CALLS]-> <Array.from>
    void code;
  });

  test('callbacks::callback-error-first', () => {
    const code = "function readFileCallback(path, callback) {\n  try {\n    const data = `contents of ${path}`;\n    callback(null, data);\n  } catch (err) {\n    callback(err, null);\n  }\n}";
    // Expect edge: <`contents of ${path}`> -[READS_FROM]-> <path>
    // Expect edge: <callback(null, data)> -[CALLS]-> <callback>
    // Expect edge: <callback(err, null)> -[CALLS]-> <callback>
    void code;
  });

  test('async-generators::promise-resolve-thenable', () => {
    const code = "async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}";
    // Expect edge: <resolve(nested-thenable)> -[CALLS]-> <resolve>
    // Expect edge: <resolve2(42)> -[CALLS]-> <resolve2>
    void code;
  });

  test('callbacks::callback-settimeout', () => {
    const code = "function delayedExecution(fn, ms) {\n  const id = setTimeout(fn, ms);\n  return function cancel() {\n    clearTimeout(id);\n  };\n}";
    // Expect edge: <setTimeout(fn, ms)> -[CALLS]-> <setTimeout>
    // Expect edge: <clearTimeout(id)> -[CALLS]-> <clearTimeout>
    void code;
  });

  test('builtins::symbol-private-property', () => {
    const code = "const _private = Symbol('private');\nclass SymbolStore {\n  [_private] = new Map();\n  set(key, value) { this[_private].set(key, value); }\n  get(key) { return this[_private].get(key); }\n}";
    // Expect edge: <this[_private]> -[READS_FROM]-> <_private>
    // Expect edge: <this[_private].set(key, value)> -[CALLS_ON]-> <this[_private]>
    // Expect edge: <this[_private]2> -[READS_FROM]-> <_private>
    // Expect edge: <this[_private].get(key)> -[CALLS_ON]-> <this[_private]2>
    void code;
  });

  test('async-generators::generator-observer-pattern', () => {
    const code = "function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---";
    // Expect edge: <results.push(value)> -[CALLS]-> <results.push>
    // Expect edge: <results.push> -[READS_FROM]-> <results>
    // Expect edge: <return results> -[READS_FROM]-> <results>
    void code;
  });

  test('callbacks::callback-promisify-usage', () => {
    const code = "const readFileAsync = promisify(readFileCallback);\n\n// --- Array callback patterns ---";
    // Expect edge: <promisify(readFileCallback)> -[CALLS]-> <promisify>
    void code;
  });

  test('callbacks::callback-higher-order', () => {
    const code = "function retry(fn, attempts, callback) {\n  fn(function (err, result) {\n    if (err && attempts > 1) {\n      retry(fn, attempts - 1, callback);\n    } else {\n      callback(err, result);\n    }\n  });\n}";
    // Expect edge: <fn-call> -[CALLS]-> <fn>
    // Expect edge: <err && attempts > 1> -[READS_FROM]-> <err>
    // Expect edge: <err && attempts > 1> -[READS_FROM]-> <attempts > 1>
    // Expect edge: <attempts > 1> -[READS_FROM]-> <attempts>
    // Expect edge: <attempts > 1> -[READS_FROM]-> <1>
    // Expect edge: <retry-recursive> -[CALLS]-> <retry>
    // Expect edge: <attempts - 1> -[READS_FROM]-> <attempts>
    // Expect edge: <attempts - 1> -[READS_FROM]-> <1>
    // Expect edge: <callback-call> -[CALLS]-> <callback>
    void code;
  });

  test('builtins::sparse-array', () => {
    const code = "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false — hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}";
    // Expect edge: <sparse.length> -[READS_FROM]-> <sparse>
    // Expect edge: <1 in sparse> -[READS_FROM]-> <1-key>
    // Expect edge: <1 in sparse> -[READS_FROM]-> <sparse>
    // Expect edge: <sparse.map(x => x * 2)> -[CALLS_ON]-> <sparse>
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('callbacks::callback-microtask', () => {
    const code = "function withMicrotask(fn) {\n  queueMicrotask(() => {\n    fn();\n  });\n}\n\n// --- Promisify ---";
    // Expect edge: <queueMicrotask(...)> -[CALLS]-> <queueMicrotask>
    // Expect edge: <fn()> -[CALLS]-> <fn>
    void code;
  });

  test('cjs-patterns::require-simple', () => {
    const code = "const fs = require('fs');";
    // Expect edge: <require('fs')> -[IMPORTS]-> <fs-module>
    void code;
  });

  test('cjs-patterns::require-destructured', () => {
    const code = "const { readFile, writeFile } = require('fs/promises');";
    // Expect edge: <require('fs/promises')> -[CALLS]-> <require>
    // Expect edge: <require('fs/promises')> -[IMPORTS_FROM]-> <fs/promises>
    void code;
  });

  test('callbacks::callback-thisarg-filter', () => {
    const code = "class Validator {\n  threshold = 10;\n  filter(items) {\n    return items.filter(function(item) {\n      return item > this.threshold;\n    }, this);\n  }\n}";
    // Expect edge: <items.filter(...)> -[CALLS_ON]-> <items>
    // Expect edge: <item > this.threshold> -[READS_FROM]-> <item>
    // Expect edge: <item > this.threshold> -[READS_FROM]-> <this.threshold>
    // Expect edge: <this.threshold> -[RESOLVES_TO]-> <Validator.threshold>
    void code;
  });

  test('callbacks::callback-thisarg-map', () => {
    const code = "class Processor {\n  multiplier = 3;\n  process(items) {\n    return items.map(function(item) {\n      return item * this.multiplier; // `this` = Processor instance via thisArg\n    }, this);\n  }\n}";
    // Expect edge: <items.map(...)> -[CALLS_ON]-> <items>
    // Expect edge: <item * this.multiplier> -[READS_FROM]-> <item>
    // Expect edge: <item * this.multiplier> -[READS_FROM]-> <this.multiplier>
    // Expect edge: <this.multiplier> -[RESOLVES_TO]-> <Processor.multiplier>
    void code;
  });

  test('callbacks::callback-continuation-passing', () => {
    const code = "function waterfall(tasks, callback) {\n  let index = 0;\n  function next(err, result) {\n    if (err || index >= tasks.length) return callback(err, result);\n    tasks[index++](result, next);\n  }\n  next(null, null);\n}\n\n// --- Event emitter pattern ---";
    // Expect edge: <err || index >= tasks.length> -[READS_FROM]-> <err>
    // Expect edge: <err || index >= tasks.length> -[READS_FROM]-> <index >= tasks.length>
    // Expect edge: <index >= tasks.length> -[READS_FROM]-> <index>
    // Expect edge: <index >= tasks.length> -[READS_FROM]-> <tasks.length>
    // Expect edge: <tasks.length> -[READS_FROM]-> <tasks>
    // Expect edge: <callback(err, result)> -[CALLS]-> <callback>
    // Expect edge: <tasks[index++]> -[READS_FROM]-> <tasks>
    // Expect edge: <tasks[index++]> -[READS_FROM]-> <index++>
    // Expect edge: <tasks[index++](result, next)> -[CALLS]-> <tasks[index++]>
    // Expect edge: <next(null, null)> -[CALLS]-> <next>
    void code;
  });

  test('async-generators::generator-finally-cleanup', () => {
    const code = "function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}";
    // Expect edge: <yield resource> -[READS_FROM]-> <resource>
    // Expect edge: <yield { transformed: true }> -[READS_FROM]-> <{ transformed: true }>
    // Expect edge: <resource.acquired> -[READS_FROM]-> <resource>
    void code;
  });

  test('callbacks::callback-thisarg-foreach', () => {
    const code = "function forEachWithContext(items, logger) {\n  items.forEach(function(item) {\n    this.log(item); // `this` = logger\n  }, logger);\n}";
    // Expect edge: <items.forEach> -[CALLS_ON]-> <items>
    // Expect edge: <this.log(item)> -[CALLS]-> <this.log>
    void code;
  });

  test('cjs-patterns::require-path', () => {
    const code = "const path = require('path');";
    // Expect edge: <require('path')> -[CALLS]-> <require>
    // Expect edge: <require('path')> -[IMPORTS]-> <path-module>
    // Expect edge: <module> -[IMPORTS_FROM]-> <path-module>
    void code;
  });

  test('callbacks::callback-promisify', () => {
    const code = "function promisify(fn) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args, function (err, result) {\n        if (err) reject(err);\n        else resolve(result);\n      });\n    });\n  };\n}";
    // Expect edge: <fn(...args, callback)> -[CALLS]-> <fn>
    // Expect edge: <reject(err)> -[CALLS]-> <reject>
    // Expect edge: <resolve(result)> -[CALLS]-> <resolve>
    void code;
  });

  test('async-generators::generator-break-triggers-finally', () => {
    const code = "function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return() → finally runs\n  }\n}";
    // Expect edge: <item.transformed> -[READS_FROM]-> <item>
    // Expect edge: <break> -[FLOWS_INTO]-> <for-of>
    void code;
  });

  test('cjs-patterns::cjs-dynamic-require', () => {
    const code = "function loadImplementation(useNative) {\n  const impl = useNative ? require('path') : require('fs');\n  return impl;\n}";
    // Expect edge: <require('path')> -[CALLS]-> <require>
    // Expect edge: <require('fs')> -[CALLS]-> <require>
    void code;
  });

  test('cjs-patterns::with-statement', () => {
    const code = "function withStatement(obj) {\n  with (obj) {\n    return toString();\n  }\n}\n\nexports.withStatement = withStatement;";
    // Expect edge: <toString()> -[RESOLVES_TO]-> <obj>
    void code;
  });

  test('cjs-patterns::block-function-decl-annex-b', () => {
    const code = "// Sloppy mode (CJS) — Annex B behavior: function leaks out of block\nfunction annexBDemo() {\n  console.log(typeof leaked); // \"undefined\" — var-hoisted but not initialized\n\n  if (true) {\n    function leaked() { return 'I escaped!'; }\n  }\n\n  return leaked(); // works in sloppy mode — Annex B hoisting\n}";
    // Expect edge: <typeof leaked> -[READS_FROM]-> <leaked>
    // Expect edge: <leaked()> -[CALLS]-> <leaked>
    void code;
  });

  test('cjs-patterns::with-nested', () => {
    const code = "function withNested(defaults, overrides) {\n  with (defaults) {\n    with (overrides) {\n      return color; // overrides.color ?? defaults.color ?? outer scope\n    }\n  }\n}";
    // Expect edge: <color> -[RESOLVES_TO]-> <with-overrides-scope>
    void code;
  });

  test('classes::class-basic', () => {
    const code = "class Animal {\n  constructor(name, sound) {\n    this.name = name;\n    this.sound = sound;\n  }\n\n  speak() {\n    return `${this.name} says ${this.sound}`;\n  }\n\n  toString() {\n    return `Animal(${this.name})`;\n  }\n}";
    // Expect edge: <template-literal-speak> -[READS_FROM]-> <Animal.name>
    // Expect edge: <template-literal-speak> -[READS_FROM]-> <Animal.sound>
    // Expect edge: <template-literal-toString> -[READS_FROM]-> <Animal.name>
    void code;
  });

  test('cjs-patterns::cjs-conditional-exports', () => {
    const code = "if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n  exports._testHelper = function () { return 'test-only'; };\n  exports._internal = cjsFunction;\n}";
    // Expect edge: <condition> -[READS_FROM]-> <typeof-check>
    // Expect edge: <condition> -[READS_FROM]-> <env-check>
    // Expect edge: <typeof-check> -[READS_FROM]-> <process>
    // Expect edge: <env-check> -[READS_FROM]-> <process.env.NODE_ENV>
    // Expect edge: <process.env.NODE_ENV> -[READS_FROM]-> <process>
    void code;
  });

  test('classes::class-static-members', () => {
    const code = "class MathUtils {\n  static PI = 3.14159;\n\n  static add(a, b) {\n    return a + b;\n  }\n\n  static #internalHelper() {\n    return 42;\n  }\n\n  static create() {\n    return new MathUtils();\n  }\n}";
    // Expect edge: <a + b> -[READS_FROM]-> <a>
    // Expect edge: <a + b> -[READS_FROM]-> <b>
    // Expect edge: <new MathUtils()> -[CALLS]-> <MathUtils>
    void code;
  });

  test('classes::class-expr-named', () => {
    const code = "const NamedClassExpr = class InternalName {\n  constructor(value) {\n    this.value = value;\n  }\n\n  getValue() {\n    return this.value;\n  }\n};";
    // Expect edge: <InternalName.getValue> -[READS_FROM]-> <this.value>
    void code;
  });

  test('cjs-patterns::with-property-fallback', () => {
    const code = "const fallbackColor = 'red';\nfunction withPropertyFallback(config) {\n  with (config) {\n    return fallbackColor; // config.fallbackColor ?? outer fallbackColor — ambiguous\n  }\n}\n\nexports.loadImplementation = loadImplementation;\nexports.annexBDemo = annexBDemo;\nexports.withNested = withNested;\nexports.withPropertyFallback = withPropertyFallback;";
    // Expect edge: <fallbackColor-ref> -[READS_FROM]-> <fallbackColor>
    // Expect edge: <fallbackColor-ref> -[READS_FROM]-> <config>
    void code;
  });

  test('classes::class-inline-new', () => {
    const code = "const inlineInstance = new (class {\n  constructor() { this.x = 1; }\n  getX() { return this.x; }\n})();";
    // Expect edge: <new-anonymous-class> -[CALLS]-> <anonymous-class>
    // Expect edge: <anonymous-class.getX> -[READS_FROM]-> <this.x>
    void code;
  });

  test('classes::class-extends-super', () => {
    const code = "class Dog extends Animal {\n  constructor(name) {\n    super(name, 'woof');\n    this.tricks = [];\n  }\n\n  learn(trick) {\n    this.tricks.push(trick);\n  }\n\n  speak() {\n    return `${super.speak()}!`;\n  }\n}";
    // Expect edge: <Dog> -[EXTENDS]-> <Animal>
    // Expect edge: <`${super.speak()}!`> -[READS_FROM]-> <super.speak()>
    void code;
  });

  test('classes::class-static-block', () => {
    const code = "class Config {\n  static defaults;\n\n  static {\n    Config.defaults = {\n      timeout: 5000,\n      retries: 3,\n    };\n  }\n\n  constructor(overrides = {}) {\n    this.settings = { ...Config.defaults, ...overrides };\n  }\n}";
    // Expect edge: <{...Config.defaults, ...overrides}> -[READS_FROM]-> <Config.defaults>
    // Expect edge: <{...Config.defaults, ...overrides}> -[READS_FROM]-> <overrides>
    void code;
  });

  test('classes::class-computed-methods', () => {
    const code = "const METHOD_KEY = 'dynamicMethod';\n\nclass WithComputedMethods {\n  [METHOD_KEY]() {\n    return 'dynamic';\n  }\n\n  [Symbol.toPrimitive](hint) {\n    return hint === 'number' ? 42 : 'string';\n  }\n}";
    // Expect edge: <WithComputedMethods.[METHOD_KEY]> -[DEPENDS_ON]-> <METHOD_KEY>
    // Expect edge: <hint === 'number'> -[READS_FROM]-> <hint>
    // Expect edge: <hint === 'number'> -[READS_FROM]-> <'number'>
    void code;
  });

  test('classes::class-new-target', () => {
    const code = "class AbstractBase {\n  constructor() {\n    if (new.target === AbstractBase) {\n      throw new Error('Cannot instantiate AbstractBase directly');\n    }\n  }\n}\n\nclass Concrete extends AbstractBase {\n  constructor() {\n    super();\n  }\n}";
    // Expect edge: <new.target === AbstractBase> -[READS_FROM]-> <new.target>
    // Expect edge: <new.target === AbstractBase> -[READS_FROM]-> <AbstractBase>
    // Expect edge: <Concrete> -[EXTENDS]-> <AbstractBase>
    // Expect edge: <super()> -[CALLS]-> <AbstractBase.constructor>
    void code;
  });

  test('classes::class-getters-setters', () => {
    const code = "class Temperature {\n  #celsius;\n\n  constructor(celsius) {\n    this.#celsius = celsius;\n  }\n\n  get fahrenheit() {\n    return this.#celsius * 9 / 5 + 32;\n  }\n\n  set fahrenheit(f) {\n    this.#celsius = (f - 32) * 5 / 9;\n  }\n\n  get celsius() {\n    return this.#celsius;\n  }\n\n  set celsius(c) {\n    this.#celsius = c;\n  }\n}";
    // Expect edge: <this.#celsius * 9 / 5 + 32> -[READS_FROM]-> <this.#celsius>
    // Expect edge: <(f - 32) * 5 / 9> -[READS_FROM]-> <f>
    void code;
  });

  test('classes::in-brand-check', () => {
    const code = "class Branded {\n  #secret = true;\n  static isBranded(obj) {\n    return #secret in obj;\n  }\n}";
    // Expect edge: <#secret in obj> -[READS_FROM]-> <#secret>
    // Expect edge: <#secret in obj> -[READS_FROM]-> <obj>
    void code;
  });

  test('classes::mixin-composition', () => {
    const code = "class User extends Serializable(Validatable(class {\n  constructor(name) { this.name = name; }\n})) {\n  greet() { return `Hi, ${this.name}`; }\n}";
    // Expect edge: <User> -[EXTENDS]-> <Serializable(Validatable-result)>
    // Expect edge: <template-literal> -[READS_FROM]-> <this.name-read>
    void code;
  });

  test('classes::class-multi-level-inheritance', () => {
    const code = "class Base {\n  baseMethod() {\n    return 'base';\n  }\n}\n\nclass Middle extends Base {\n  middleMethod() {\n    return 'middle';\n  }\n}\n\nclass Derived extends Middle {\n  derivedMethod() {\n    return 'derived';\n  }\n\n  allMethods() {\n    return [this.baseMethod(), this.middleMethod(), this.derivedMethod()];\n  }\n}";
    // Expect edge: <Middle> -[EXTENDS]-> <Base>
    // Expect edge: <Derived> -[EXTENDS]-> <Middle>
    // Expect edge: <this.baseMethod()> -[CALLS]-> <Base.baseMethod>
    // Expect edge: <this.middleMethod()> -[CALLS]-> <Middle.middleMethod>
    // Expect edge: <this.derivedMethod()> -[CALLS]-> <Derived.derivedMethod>
    void code;
  });

  test('classes::mixin-class-expression', () => {
    const code = "const Serializable = (SuperClass) => class extends SuperClass {\n  serialize() { return JSON.stringify(this); }\n};\n\nconst Validatable = (SuperClass) => class extends SuperClass {\n  validate() { return true; }\n};";
    // Expect edge: <Serializable:class> -[EXTENDS]-> <SuperClass>
    // Expect edge: <JSON.stringify(this)> -[CALLS]-> <JSON.stringify>
    // Expect edge: <Validatable:class> -[EXTENDS]-> <SuperClass2>
    void code;
  });

  test('classes::class-async-method', () => {
    const code = "class ApiClient {\n  async fetch(url) { return url; }\n  static async create() { return new ApiClient(); }\n}";
    // Expect edge: <new ApiClient()> -[CALLS]-> <ApiClient>
    void code;
  });

  test('classes::class-inline-extends', () => {
    const code = "const inlineChild = new (class extends Error {\n  constructor(msg) { super(msg); this.custom = true; }\n})('inline error');";
    // Expect edge: <new (class extends Error {...})('inline error')> -[CALLS]-> <anonymous-class>
    void code;
  });

  test('classes::class-constructor-return-non-this', () => {
    const code = "class Singleton {\n  static instance;\n  constructor() {\n    if (Singleton.instance) return Singleton.instance;\n    Singleton.instance = this;\n  }\n}";
    // Expect edge: <Singleton.instance-read> -[READS_FROM]-> <Singleton.instance>
    void code;
  });

  test('classes::class-generator-method', () => {
    const code = "class Stream {\n  data = [];\n  *items() { for (const item of this.data) yield item; }\n  async *pages() { yield* this.data; }\n}";
    // Expect edge: <yield item> -[READS_FROM]-> <item>
    // Expect edge: <yield* this.data> -[READS_FROM]-> <this.data>
    void code;
  });

  test('classes::class-static-getter-setter', () => {
    const code = "class Registry {\n  static #store = new Map();\n  static get size() { return this.#store.size; }\n  static set defaultValue(value) { this.#store.set('default', value); }\n}";
    // Expect edge: <new Map()> -[CALLS]-> <Map>
    // Expect edge: <this.#store.size> -[READS_FROM]-> <Registry.#store>
    // Expect edge: <this.#store.set('default', value)> -[CALLS_ON]-> <Registry.#store>
    void code;
  });

  test('async-generators::async-iterator-cancel-break', () => {
    const code = "async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}";
    // Expect edge: <i < 10> -[READS_FROM]-> <i>
    // Expect edge: <i < 10> -[READS_FROM]-> <10>
    // Expect edge: <{ chunk: i, size: i * 100 }> -[READS_FROM]-> <i>
    // Expect edge: <{ chunk: i, size: i * 100 }> -[READS_FROM]-> <i * 100>
    // Expect edge: <i * 100> -[READS_FROM]-> <i>
    // Expect edge: <i * 100> -[READS_FROM]-> <100>
    // Expect edge: <reader.locked> -[READS_FROM]-> <reader>
    void code;
  });

  test('classes::super-computed-access', () => {
    const code = "class DynamicChild extends Animal {\n  callDynamic(methodName) {\n    return super[methodName](); // dynamic dispatch through prototype chain\n  }\n  delegateAll(methods) {\n    return methods.map(m => super[m]());\n  }\n}\n\n// --- Method chaining / fluent API ---";
    // Expect edge: <super[methodName]> -[READS_FROM]-> <methodName>
    // Expect edge: <super[methodName]()> -[CALLS]-> <super[methodName]>
    // Expect edge: <methods.map(m => super[m]())> -[CALLS_ON]-> <methods>
    // Expect edge: <super[m]> -[READS_FROM]-> <m>
    // Expect edge: <super[m]()> -[CALLS]-> <super[m]>
    void code;
  });

  test('classes::method-chaining-usage', () => {
    const code = "const chainedQuery = new QueryBuilder()\n  .from('users')\n  .where('age > 18')\n  .orderBy('name')\n  .limit(10)\n  .build();";
    // Expect edge: <new QueryBuilder()> -[CALLS]-> QueryBuilder
    void code;
  });

  test('async-generators::async-iterator-cancel-manual', () => {
    const code = "async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}";
    // Expect edge: <asyncGen[Symbol.asyncIterator]()> -[CALLS]-> <asyncGen[Symbol.asyncIterator]>
    // Expect edge: <asyncGen[Symbol.asyncIterator]> -[READS_FROM]-> <asyncGen>
    // Expect edge: <iter.next()> -[CALLS]-> <iter.next>
    // Expect edge: <iter.next> -[READS_FROM]-> <iter>
    // Expect edge: <iter.return()> -[CALLS]-> <iter.return>
    // Expect edge: <iter.return> -[READS_FROM]-> <iter>
    // Expect edge: <return first> -[READS_FROM]-> <first>
    void code;
  });

  test('classes::destructure-assign-to-this', () => {
    const code = "class ComponentState {\n  width = 0;\n  height = 0;\n\n  update(props) {\n    ({ width: this.width, height: this.height } = props);\n  }\n}";
    // Expect edge: <destructure-props> -[READS_FROM]-> <props.width>
    // Expect edge: <destructure-props> -[READS_FROM]-> <props.height>
    void code;
  });

  test('classes::class-private-cross-instance', () => {
    const code = "class Vec {\n  #x; #y;\n  constructor(x, y) { this.#x = x; this.#y = y; }\n  equals(other) {\n    return this.#x === other.#x && this.#y === other.#y;\n  }\n}";
    // Expect edge: <this.#x === other.#x> -[READS_FROM]-> <this.#x>
    // Expect edge: <this.#x === other.#x> -[READS_FROM]-> <other.#x>
    // Expect edge: <this.#y === other.#y> -[READS_FROM]-> <this.#y>
    // Expect edge: <this.#y === other.#y> -[READS_FROM]-> <other.#y>
    // Expect edge: <equals-return> -[READS_FROM]-> <this.#x === other.#x>
    // Expect edge: <equals-return> -[READS_FROM]-> <this.#y === other.#y>
    void code;
  });

  test('async-generators::yield-star-return-value', () => {
    const code = "function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}";
    // Expect edge: <innerWithReturn()> -[CALLS]-> <innerWithReturn>
    void code;
  });

  test('classes::super-in-nested-arrows', () => {
    const code = "class DeepSuper extends ParentProcessor {\n  deepProcess(items) {\n    return items.map(item => {\n      return this.validate(item).then(valid => {\n        return super.transform(valid);   // super through 2 levels of arrows\n      });\n    });\n  }\n  validate(item) { return Promise.resolve(item); }\n}";
    // Expect edge: <DeepSuper> -[EXTENDS]-> <ParentProcessor>
    // Expect edge: <items.map(...)> -[CALLS_ON]-> <items>
    // Expect edge: <this.validate(item)> -[CALLS]-> <DeepSuper.validate>
    // Expect edge: <...then(...)> -[CALLS_ON]-> <this.validate(item)>
    // Expect edge: <super.transform(valid)> -[CALLS_ON]-> <ParentProcessor>
    // Expect edge: <Promise.resolve(item)> -[CALLS_ON]-> <Promise>
    void code;
  });

  test('classes::object-assign-this', () => {
    const code = "class MergeConfig {\n  constructor(opts) {\n    Object.assign(this, opts);           // copies ALL properties from opts\n  }\n}\n\nclass MergeConfigDefaults {\n  constructor(defaults, overrides) {\n    Object.assign(this, defaults, overrides); // merge with precedence\n  }\n}\n\n// --- super in static context ---";
    // Expect edge: <Object.assign(this, opts)> -[CALLS]-> <Object.assign>
    // Expect edge: <Object.assign(this, defaults, overrides)> -[CALLS]-> <Object.assign>
    void code;
  });

  test('classes::destructure-assign-to-this-defaults', () => {
    const code = "class ConfigFromOpts {\n  host = '';\n  port = 3000;\n\n  constructor(opts) {\n    ({ host: this.host, port: this.port = 3000 } = opts);\n  }\n}";
    // Expect edge: <destructure-opts> -[READS_FROM]-> <opts>
    void code;
  });

  test('classes::default-param-this-access', () => {
    const code = "class ServiceWithDefaults {\n  defaultTimeout = 5000;\n  baseUrl = '/api';\n\n  fetch(url, timeout = this.defaultTimeout) {\n    return { url: this.baseUrl + url, timeout };\n  }\n}";
    // Expect edge: <this.defaultTimeout> -[READS_FROM]-> <ServiceWithDefaults.defaultTimeout>
    // Expect edge: <this.baseUrl + url> -[READS_FROM]-> <this.baseUrl>
    // Expect edge: <this.baseUrl + url> -[READS_FROM]-> <url>
    // Expect edge: <this.baseUrl> -[READS_FROM]-> <ServiceWithDefaults.baseUrl>
    void code;
  });

  test('classes::super-in-arrow-callback', () => {
    const code = "class ParentProcessor {\n  transform(item) { return { ...item, processed: true }; }\n  cleanup() { return 'cleaned'; }\n}\n\nclass ChildProcessor extends ParentProcessor {\n  processAll(items) {\n    return items.map(item => {\n      return super.transform(item);     // super captured via arrow\n    });\n  }\n\n  delayed() {\n    setTimeout(() => {\n      super.cleanup();                   // super in async callback arrow\n    }, 100);\n  }\n}";
    // Expect edge: <{ ...item, processed: true }> -[READS_FROM]-> <item>
    // Expect edge: <ChildProcessor> -[EXTENDS]-> <ParentProcessor>
    // Expect edge: <items.map(...)> -[CALLS_ON]-> <items>
    // Expect edge: <super.transform(item)> -[CALLS]-> <ParentProcessor.transform>
    // Expect edge: <super.cleanup()> -[CALLS]-> <ParentProcessor.cleanup>
    void code;
  });

  test('classes::computed-class-member-side-effect', () => {
    const code = "let classFieldId = 0;\nclass AutoIdFields {\n  [`field_${classFieldId++}`] = 'first';\n  [`field_${classFieldId++}`] = 'second';\n  [`method_${classFieldId++}`]() { return 'dynamic'; }\n}";
    // Expect edge: <`field_${classFieldId++}`_1> -[READS_FROM]-> <classFieldId>
    // Expect edge: <`field_${classFieldId++}`_2> -[READS_FROM]-> <classFieldId>
    // Expect edge: <`method_${classFieldId++}`> -[READS_FROM]-> <classFieldId>
    void code;
  });

  test('classes::class-as-argument', () => {
    const code = "function registerClass(cls) { return new cls(); }\nregisterClass(class InlinePlugin { activate() { return true; } });";
    // Expect edge: <new cls()> -[READS_FROM]-> <cls>
    // Expect edge: <registerClass(class InlinePlugin)> -[CALLS]-> <registerClass>
    void code;
  });

  test('closures::closure-module-var-read', () => {
    const code = "let requestCount = 0;\n\nfunction getRequestCount() {\n  return requestCount;\n}";
    // Expect edge: <getRequestCount> -[READS_FROM]-> <requestCount>
    void code;
  });

  test('classes::super-in-field-initializer', () => {
    const code = "class FieldParent {\n  getDefaults() { return { timeout: 5000 }; }\n}\n\nclass FieldChild extends FieldParent {\n  defaults = super.getDefaults(); // super in instance field initializer\n}\n\n// --- Interleaved static blocks and static fields ---";
    // Expect edge: <FieldChild> -[EXTENDS]-> <FieldParent>
    // Expect edge: <super.getDefaults()> -[CALLS]-> <super.getDefaults>
    // Expect edge: <super.getDefaults> -[RESOLVES_TO]-> <FieldParent.getDefaults>
    void code;
  });

  test('closures::closure-module-var-write', () => {
    const code = "function incrementRequestCount() {\n  requestCount++;\n}";
    // Expect edge: <requestCount++> -[READS_FROM]-> <requestCount>
    void code;
  });

  test('classes::class-in-ternary', () => {
    const code = "const StrategyClass = Math.random() > 0.5\n  ? class Aggressive { execute() { return 'fast'; } }\n  : class Conservative { execute() { return 'slow'; } };";
    // Expect edge: <Math.random() > 0.5> -[READS_FROM]-> <Math.random()>
    // Expect edge: <Math.random() > 0.5> -[READS_FROM]-> <0.5>
    // Expect edge: <Math.random()> -[CALLS]-> <Math.random>
    void code;
  });

  test('closures::closure-factory-multiplier', () => {
    const code = "function createMultiplier(factor) {\n  return (x) => x * factor;\n}";
    // Expect edge: <x * factor> -[READS_FROM]-> <x>
    // Expect edge: <x * factor> -[READS_FROM]-> <factor>
    void code;
  });

  test('classes::super-in-static-method', () => {
    const code = "class StaticParent {\n  static defaultConfig() { return { timeout: 5000 }; }\n  static instances = [];\n}\n\nclass StaticChild extends StaticParent {\n  static defaultConfig() {\n    const base = super.defaultConfig(); // super = StaticParent (constructor, not prototype)\n    return { ...base, retries: 3 };\n  }\n\n  static allInstances = [...super.instances]; // super in static field initializer\n}\n\n// --- super in field initializers ---";
    // Expect edge: <StaticChild> -[EXTENDS]-> <StaticParent>
    // Expect edge: <super.defaultConfig()> -[CALLS]-> <StaticParent.defaultConfig>
    // Expect edge: <{ ...base, retries: 3 }> -[READS_FROM]-> <base>
    // Expect edge: <[...super.instances]> -[READS_FROM]-> <super.instances>
    // Expect edge: <super.instances> -[READS_FROM]-> <StaticParent.instances>
    void code;
  });

  test('async-generators::for-await-sync-iterable', () => {
    const code = "async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array — each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}";
    // Expect edge: <results.push(item)> -[CALLS_ON]-> <results>
    // Expect edge: <return results> -[READS_FROM]-> <results>
    void code;
  });

  test('classes::private-field-proxy-trap', () => {
    const code = "class SecureService {\n  #secret = 42;\n  getSecret() { return this.#secret; }\n}\n\nfunction proxyPrivateDemo() {\n  const instance = new SecureService();\n  const proxy = new Proxy(instance, {});\n  // proxy.getSecret() → TypeError: #secret not accessible through Proxy\n  return { instance, proxy };\n}\n\n// --- Class expressions in various positions ---";
    // Expect edge: <this.#secret> -[READS_FROM]-> <#secret>
    // Expect edge: <new SecureService()> -[CALLS]-> <SecureService>
    // Expect edge: <{ instance, proxy }> -[READS_FROM]-> <instance>
    // Expect edge: <{ instance, proxy }> -[READS_FROM]-> <proxy>
    void code;
  });

  test('closures::closure-shared-state', () => {
    const code = "let sharedCache = {};\n\nfunction setCache(key, value) {\n  sharedCache[key] = value;\n}\n\nfunction getCache(key) {\n  return sharedCache[key];\n}\n\nfunction clearCache() {\n  sharedCache = {};\n}\n\n// --- Factory functions returning closures ---";
    // Expect edge: <sharedCache[key]> -[READS_FROM]-> <sharedCache>
    // Expect edge: <sharedCache[key]> -[READS_FROM]-> <key>
    // Expect edge: <sharedCache[key2]> -[READS_FROM]-> <sharedCache>
    // Expect edge: <sharedCache[key2]> -[READS_FROM]-> <key2>
    void code;
  });

  test('closures::closure-factory-accumulator', () => {
    const code = "function createAccumulator() {\n  const items = [];\n  return {\n    add(item) { items.push(item); },\n    getAll() { return [...items]; },\n    count() { return items.length; },\n  };\n}\n\n// --- Closure over loop variable ---";
    // Expect edge: <items.push(item)> -[CALLS]-> <items.push>
    // Expect edge: <items.push> -[READS_FROM]-> <items>
    // Expect edge: <[...items]> -[READS_FROM]-> <items>
    // Expect edge: <items.length> -[READS_FROM]-> <items>
    void code;
  });

  test('closures::closure-nested-deep', () => {
    const code = "function outermost(a) {\n  return function middle(b) {\n    return function innermost(c) {\n      return a + b + c;\n    };\n  };\n}";
    // Expect edge: <a + b + c> -[READS_FROM]-> <a>
    // Expect edge: <a + b + c> -[READS_FROM]-> <b>
    // Expect edge: <a + b + c> -[READS_FROM]-> <c>
    void code;
  });

  test('classes::new-target-arrow-capture', () => {
    const code = "class AbstractFactory {\n  constructor() {\n    // new.target captured by arrow — like this/super, lexically bound\n    const getTarget = () => new.target;\n\n    if (getTarget() === AbstractFactory) {\n      throw new Error('AbstractFactory is abstract — use a subclass');\n    }\n\n    // Store for lazy cloning — arrow captures new.target from constructor\n    this._clone = () => new (new.target)();\n  }\n}\n\nclass ConcreteFactory extends AbstractFactory {\n  constructor() {\n    super(); // new.target === ConcreteFactory inside AbstractFactory\n  }\n}";
    // Expect edge: <getTarget() === AbstractFactory> -[READS_FROM]-> <getTarget()>
    // Expect edge: <getTarget() === AbstractFactory> -[READS_FROM]-> <AbstractFactory>
    // Expect edge: <getTarget()> -[CALLS]-> <getTarget>
    // Expect edge: <new (new.target)()> -[CALLS]-> <new.target>
    // Expect edge: <ConcreteFactory> -[EXTENDS]-> <AbstractFactory>
    // Expect edge: <super()> -[CALLS]-> <AbstractFactory.constructor>
    void code;
  });

  test('closures::closure-loop-let-fix', () => {
    const code = "function closureLoopLetFix() {\n  const funcs = [];\n  for (let i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // each returns 0,1,2,3,4\n}";
    // Expect edge: <i < 5> -[READS_FROM]-> <i>
    // Expect edge: <i < 5> -[READS_FROM]-> <5>
    // Expect edge: <funcs.push(...)> -[CALLS]-> <funcs.push>
    // Expect edge: <funcs.push> -[READS_FROM]-> <funcs>
    void code;
  });

  test('async-generators::async-generator-destructure-default', () => {
    const code = "async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---";
    // Expect edge: <{ ...data, priority }> -[READS_FROM]-> <priority>
    void code;
  });

  test('closures::this-module-level', () => {
    const code = "// In ESM: `this` is `undefined` at top level\nconst thisAtModuleLevel = this; // undefined in ESM, module.exports in CJS\n\n// --- Named function expression as argument (self-referencing) ---";
    // Expect edge: <this> -[DEPENDS_ON]-> <module>
    void code;
  });

  test('closures::this-method-context', () => {
    const code = "const obj = {\n  name: 'context',\n  getName() {\n    return this.name;\n  },\n  getNameArrow: () => {\n    return this.name; // `this` is module/global, not obj\n  },\n};";
    // Expect edge: <this.name-method> -[READS_FROM]-> <obj-literal>
    void code;
  });

  test('closures::closure-loop-var-bug', () => {
    const code = "function closureLoopVarBug() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // all return 5\n}";
    // Expect edge: <i < 5> -[READS_FROM]-> <i>
    // Expect edge: <i < 5> -[READS_FROM]-> <5>
    // Expect edge: <funcs.push(...)> -[CALLS_ON]-> <funcs>
    // Expect edge: <return i> -[READS_FROM]-> <i>
    void code;
  });

  test('closures::closure-loop-iife-fix', () => {
    const code = "function closureLoopIifeFix() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push((function (captured) {\n      return function () { return captured; };\n    })(i));\n  }\n  return funcs;\n}\n\n// --- Nested closures (3+ levels) ---";
    // Expect edge: <i < 5> -[READS_FROM]-> <i>
    // Expect edge: <i < 5> -[READS_FROM]-> <5>
    // Expect edge: <funcs.push(...)> -[CALLS_ON]-> <funcs>
    // Expect edge: <iife-call> -[CALLS]-> <iife>
    void code;
  });

  test('closures::closure-module-pattern', () => {
    const code = "const counterModule = (function () {\n  let count = 0;\n  return {\n    increment() { count++; },\n    decrement() { count--; },\n    getCount() { return count; },\n  };\n})();\n\n// --- Memoization via closure ---";
    // Expect edge: <counterModule:iife-call> -[CALLS]-> <counterModule:iife>
    // Expect edge: <getCount> -[READS_FROM]-> <count>
    void code;
  });

  test('closures::this-bind', () => {
    const code = "function thisBind() {\n  function greet(greeting) {\n    return `${greeting}, ${this.name}`;\n  }\n  const user = { name: 'Alice' };\n  const bound = greet.bind(user);\n  return bound('Hello');\n}";
    // Expect edge: <`${greeting}, ${this.name}`> -[READS_FROM]-> <greeting>
    // Expect edge: <`${greeting}, ${this.name}`> -[READS_FROM]-> <this.name>
    // Expect edge: <bound('Hello')> -[CALLS]-> <bound>
    void code;
  });

  test('closures::this-in-class-callback', () => {
    const code = "class EventHandler {\n  constructor(name) {\n    this.name = name;\n    this.handleBound = this.handle.bind(this);\n  }\n\n  handle(event) {\n    return `${this.name}: ${event}`;\n  }\n\n  handleArrow = (event) => {\n    return `${this.name}: ${event}`;\n  };\n}\n\n// --- Closure as private scope ---";
    // Expect edge: <this.handle.bind(this)> -[CALLS]-> <this.handle>
    // Expect edge: <`${this.name}: ${event}`> -[READS_FROM]-> <this.name>
    // Expect edge: <`${this.name}: ${event}`> -[READS_FROM]-> <event>
    // Expect edge: <`${this.name}: ${event}`:arrow> -[READS_FROM]-> <this.name>
    // Expect edge: <`${this.name}: ${event}`:arrow> -[READS_FROM]-> <event:arrow>
    void code;
  });

  test('closures::named-func-expr-as-argument', () => {
    const code = "let retryDone = false;\nsetTimeout(function retry() {\n  if (!retryDone) setTimeout(retry, 1000); // self-reference for recursive scheduling\n}, 1000);";
    // Expect edge: <!retryDone> -[READS_FROM]-> <retryDone>
    void code;
  });

  test('closures::closure-nested-mutation', () => {
    const code = "function createTracker() {\n  let total = 0;\n  function addGroup(groupName) {\n    let groupTotal = 0;\n    return function addItem(value) {\n      groupTotal += value;\n      total += value;\n      return { groupName, groupTotal, total };\n    };\n  }\n  return { addGroup, getTotal: () => total };\n}\n\n// --- this binding ---";
    // Expect edge: <groupTotal += value> -[READS_FROM]-> <value>
    // Expect edge: <total += value> -[READS_FROM]-> <value>
    // Expect edge: <{ groupName, groupTotal, total }> -[READS_FROM]-> <groupName>
    // Expect edge: <{ groupName, groupTotal, total }> -[READS_FROM]-> <groupTotal>
    // Expect edge: <{ groupName, groupTotal, total }> -[READS_FROM]-> <total>
    // Expect edge: <getTotal> -[READS_FROM]-> <total>
    // Expect edge: <{ addGroup, getTotal: () => total }> -[READS_FROM]-> <addGroup>
    // Expect edge: <{ addGroup, getTotal: () => total }> -[READS_FROM]-> <getTotal>
    void code;
  });

  test('closures::this-call-apply', () => {
    const code = "function thisCallApply() {\n  function introduce(role) {\n    return `${this.name} is ${role}`;\n  }\n  const person = { name: 'Bob' };\n  const viaCall = introduce.call(person, 'admin');\n  const viaApply = introduce.apply(person, ['admin']);\n  return { viaCall, viaApply };\n}";
    // Expect edge: <template-literal> -[READS_FROM]-> <this.name>
    // Expect edge: <template-literal> -[READS_FROM]-> <role>
    // Expect edge: <introduce.call> -[CALLS]-> <introduce>
    // Expect edge: <introduce.apply> -[CALLS]-> <introduce>
    void code;
  });

  test('closures::closure-once', () => {
    const code = "function once(fn) {\n  let called = false;\n  let result;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  };\n}";
    // Expect edge: <!called> -[READS_FROM]-> <called>
    // Expect edge: <called = true> -[READS_FROM]-> <true>
    // Expect edge: <result = fn.apply(this, args)> -[READS_FROM]-> <fn.apply(this, args)>
    // Expect edge: <fn.apply(this, args)> -[CALLS]-> <fn>
    void code;
  });

  test('coercion-hoisting::hoist-function-decl', () => {
    const code = "function functionHoisting() {\n  const result = hoisted(); // works — function declarations are fully hoisted\n  function hoisted() { return 'hoisted'; }\n  return result;\n}";
    // Expect edge: <hoisted()> -[CALLS]-> <hoisted>
    void code;
  });

  test('closures::closure-memoize', () => {
    const code = "function memoize(fn) {\n  const cache = new Map();\n  return function (...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// --- Once (call-at-most-once) ---";
    // Expect edge: <fn.apply(this, args)> -[CALLS]-> <fn>
    // Expect edge: <cache.has(key)> -[CALLS_ON]-> <cache>
    // Expect edge: <cache.get(key)> -[CALLS_ON]-> <cache>
    // Expect edge: <cache.set(key, result)> -[CALLS_ON]-> <cache>
    void code;
  });

  test('coercion-hoisting::hoist-var', () => {
    const code = "function varHoisting() {\n  console.log(x); // undefined — hoisted, not initialized\n  var x = 10;\n  console.log(x); // 10\n  return x;\n}";
    // Expect edge: <console.log(x):1> -[CALLS]-> <console.log>
    // Expect edge: <console.log(x):2> -[CALLS]-> <console.log>
    void code;
  });

  test('coercion-hoisting::hoist-function-expr-not', () => {
    const code = "function functionExprNotHoisted() {\n  try {\n    notHoisted(); // TypeError: notHoisted is not a function\n  } catch (e) {\n    // var notHoisted is hoisted as undefined, but assignment is not\n  }\n  var notHoisted = function () { return 'not hoisted'; };\n  return notHoisted();\n}\n\n// --- Temporal Dead Zone (TDZ) ---";
    // Expect edge: <notHoisted()> -[CALLS]-> <notHoisted>
    // Expect edge: <notHoisted()_return> -[CALLS]-> <notHoisted>
    void code;
  });

  test('coercion-hoisting::tdz-let', () => {
    const code = "function tdzLet() {\n  try {\n    console.log(x); // ReferenceError — TDZ\n  } catch (e) {\n    // let x exists but cannot be accessed before declaration\n  }\n  let x = 10;\n  return x;\n}";
    // Expect edge: <console.log(x)> -[CALLS]-> <console.log>
    // Expect edge: <console.log(x)> -[READS_FROM]-> <x>
    void code;
  });

  test('coercion-hoisting::tdz-class', () => {
    const code = "function tdzClass() {\n  try {\n    new MyClass(); // ReferenceError — class TDZ\n  } catch (e) {\n    // class declarations have TDZ like let/const\n  }\n  class MyClass {}\n  return new MyClass();\n}\n\n// --- Variable shadowing ---";
    // Expect edge: <new MyClass()> -[CALLS]-> <MyClass>
    // Expect edge: <new MyClass():return> -[CALLS]-> <MyClass>
    void code;
  });

  test('coercion-hoisting::coerce-symbol-toprimitive', () => {
    const code = "const toPrimitive = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return 10;\n    if (hint === 'string') return 'ten';\n    return true;\n  },\n};\n\n// --- Hoisting ---";
    // Expect edge: <hint === 'number'> -[READS_FROM]-> <hint>
    // Expect edge: <hint === 'number'> -[READS_FROM]-> <'number'>
    // Expect edge: <hint === 'string'> -[READS_FROM]-> <hint>
    // Expect edge: <hint === 'string'> -[READS_FROM]-> <'string'>
    void code;
  });

  test('coercion-hoisting::tdz-const', () => {
    const code = "function tdzConst() {\n  try {\n    console.log(C); // ReferenceError — TDZ\n  } catch (e) {\n    // const C in TDZ\n  }\n  const C = 42;\n  return C;\n}";
    // Expect edge: <console.log(C)> -[CALLS]-> <console.log>
    // Expect edge: <console.log(C)> -[READS_FROM]-> <C>
    void code;
  });

  test('coercion-hoisting::coerce-valueof-tostring', () => {
    const code = "const customCoerce = {\n  valueOf() { return 42; },\n  toString() { return 'custom'; },\n};\n\nconst usedInMath = customCoerce + 1;        // 43 (valueOf)\nconst usedInTemplate = `${customCoerce}`;   // 'custom' (toString)";
    // Expect edge: <customCoerce + 1> -[READS_FROM]-> <customCoerce>
    // Expect edge: <customCoerce + 1> -[READS_FROM]-> <1>
    // Expect edge: <customCoerce + 1> -[CALLS]-> <valueOf>
    // Expect edge: <`${customCoerce}`> -[READS_FROM]-> <customCoerce>
    // Expect edge: <`${customCoerce}`> -[CALLS]-> <toString>
    void code;
  });

  test('coercion-hoisting::shadow-param-scope', () => {
    const code = "function paramShadowing(x) {\n  const x2 = x;\n  if (true) {\n    const x = 'shadowed'; // shadows parameter\n    console.log(x); // 'shadowed'\n  }\n  return x; // original param\n}";
    // Expect edge: <console.log(x)> -[CALLS]-> <console.log>
    void code;
  });

  test('coercion-hoisting::eval-direct', () => {
    const code = "function directEval(code) {\n  return eval(code);\n}";
    // Expect edge: <eval(code)> -[CALLS]-> <eval>
    void code;
  });

  test('coercion-hoisting::eval-indirect', () => {
    const code = "function indirectEval(code) {\n  const evaluate = eval;\n  return evaluate(code);\n}";
    // Expect edge: <evaluate(code)> -[CALLS]-> <evaluate>
    // Expect edge: <evaluate> -[READS_FROM]-> <eval>
    void code;
  });

  test('coercion-hoisting::eval-var-injection', () => {
    const code = "function evalVarInjection() {\n  eval('var injected = 42');\n  return injected; // 42 — eval injected into function scope\n}";
    // Expect edge: <eval('var injected = 42')> -[CALLS]-> <eval>
    void code;
  });

  test('coercion-hoisting::shadow-catch-scope', () => {
    const code = "function catchShadowing() {\n  const error = 'not an error';\n  try {\n    throw new Error('real error');\n  } catch (error) {\n    console.log(error.message); // 'real error' — shadows outer \"error\"\n  }\n  return error; // 'not an error'\n}\n\n// --- eval ---";
    // Expect edge: <error.message> -[READS_FROM]-> <error:catch>
    void code;
  });

  test('coercion-hoisting::eval-function-injection', () => {
    const code = "function evalFunctionInjection() {\n  eval('function surprise() { return \"boo\"; }');\n  return surprise(); // \"boo\"\n}";
    // Expect edge: <surprise()> -[CALLS]-> <surprise>
    void code;
  });

  test('coercion-hoisting::eval-new-function', () => {
    const code = "function newFunction(body) {\n  const fn = new Function('a', 'b', body);\n  return fn(1, 2);\n}\n\n// --- Comma operator for side effects ---";
    // Expect edge: <fn(1, 2)> -[CALLS]-> <fn>
    void code;
  });

  test('coercion-hoisting::coerce-comma-sequence', () => {
    const code = "function commaSequence() {\n  let x = 0;\n  const result = (x++, x++, x++, x);\n  return result; // 3\n}";
    // Expect edge: <x++[1]> -[READS_FROM]-> <x>
    // Expect edge: <x++[2]> -[READS_FROM]-> <x>
    // Expect edge: <x++[3]> -[READS_FROM]-> <x>
    // Expect edge: <x-final> -[READS_FROM]-> <x>
    void code;
  });

  test('coercion-hoisting::shadow-block-scope', () => {
    const code = "const outerConst = 'outer';\n\nfunction shadowingExample() {\n  const outerConst = 'shadowed'; // shadows module-level\n  if (true) {\n    const outerConst = 'inner-shadowed'; // shadows function-level\n    console.log(outerConst); // 'inner-shadowed'\n  }\n  return outerConst; // 'shadowed'\n}";
    // Expect edge: <console.log(outerConst)> -[CALLS]-> <console.log>
    void code;
  });

  test('coercion-hoisting::block-label-ambiguity', () => {
    const code = "function blockLabelAmbiguity() {\n  // { a: 1 } in statement position is a block with labeled expression, NOT an object\n  // Parentheses force expression context:\n  const obj = eval('({ a: 1, b: 2 })'); // object literal\n  // eval('{ a: 1, b: 2 }');            // SyntaxError — block + label + illegal comma\n  return obj;\n}";
    // Expect edge: <eval('({ a: 1, b: 2 })')> -[CALLS]-> <eval>
    void code;
  });

  test('async-generators::async-destructure-await-default', () => {
    const code = "async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};";
    // Expect edge: <getConfigValue('timeout')> -[CALLS]-> <getConfigValue>
    // Expect edge: <getConfigValue('retries')> -[CALLS]-> <getConfigValue>
    // Expect edge: <{ timeout, retries }> -[READS_FROM]-> <timeout>
    // Expect edge: <{ timeout, retries }> -[READS_FROM]-> <retries>
    void code;
  });

  test('coercion-hoisting::typeof-tdz-trap', () => {
    const code = "function typeofTdzTrap() {\n  try {\n    const result = typeof x; // ReferenceError — x is in TDZ, unlike undeclared\n  } catch (e) {\n    // typeof on TDZ variable THROWS, unlike typeof on undeclared\n  }\n  let x = 5;\n}";
    // Expect edge: <typeof x> -[READS_FROM]-> <x>
    void code;
  });

  test('coercion-hoisting::var-function-collision', () => {
    const code = "function varFunctionCollision() {\n  console.log(typeof collision); // \"function\" — function hoists over var\n  var collision = 1;\n  function collision() { return 2; }\n  console.log(typeof collision); // \"number\" — assignment runs after\n  return collision;\n}";
    // Expect edge: <console.log(typeof collision)1> -[CALLS]-> <console.log>
    // Expect edge: <typeof collision1> -[READS_FROM]-> <collision:fn>
    // Expect edge: <console.log(typeof collision)2> -[CALLS]-> <console.log>
    // Expect edge: <typeof collision2> -[READS_FROM]-> <collision:var>
    void code;
  });

  test('coercion-hoisting::var-in-catch-clobber', () => {
    const code = "function varInCatchClobber() {\n  try {\n    throw new Error('oops');\n  } catch (e) {\n    var e = 'overwritten';  // var hoists to function scope, shares binding with catch param\n  }\n  return e; // 'overwritten' in sloppy; in strict var still hoists but catch e is separate\n}";
    // Expect edge: <return e> -[READS_FROM]-> <e:var>
    void code;
  });

  test('coercion-hoisting::primitive-autoboxing', () => {
    const code = "function primitiveAutoboxing() {\n  const str = 'hello';\n  const upper = str.toUpperCase(); // auto-boxes to String object\n  str.customProp = 1; // sets on TEMPORARY boxed String, immediately GC'd\n  const lost = str.customProp; // undefined\n\n  const num = 42;\n  const fixed = num.toFixed(2); // auto-boxes to Number\n\n  return { upper, lost, fixed };\n}";
    // Expect edge: <str.toUpperCase()> -[CALLS_ON]-> <str>
    // Expect edge: <num.toFixed(2)> -[CALLS_ON]-> <num>
    // Expect edge: <{ upper, lost, fixed }> -[READS_FROM]-> <upper>
    // Expect edge: <{ upper, lost, fixed }> -[READS_FROM]-> <lost>
    // Expect edge: <{ upper, lost, fixed }> -[READS_FROM]-> <fixed>
    void code;
  });

  test('coercion-hoisting::block-function-declaration-strict', () => {
    const code = "// NOTE: behavior differs between strict (ESM) and sloppy (script) mode.\n// This file is ESM (strict), so the function is block-scoped.\n// In sloppy mode (.cjs / <script>), the function would leak to function scope (Annex B).\nfunction blockFunctionDemo() {\n  let result = 'before';\n\n  if (true) {\n    function blockFn() { return 'inside'; }  // block-scoped in strict/ESM\n    result = blockFn();\n  }\n\n  // blockFn is NOT accessible here in strict mode\n  // In sloppy mode it WOULD be accessible (Annex B hoisting)\n  return result;\n}";
    // Expect edge: <blockFn()> -[CALLS]-> <blockFn>
    void code;
  });

  test('coercion-hoisting::var-redeclares-parameter', () => {
    const code = "function varRedeclaresParameter(x, y) {\n  var x = x || 'default'; // same binding as parameter x — NOT a new variable\n  var y;                    // re-declares y but does NOT reset it\n  return { x, y };\n}\n// varRedeclaresParameter(null, 42) → { x: 'default', y: 42 }\n// Contrast: let x = ... inside would be SyntaxError (cannot re-declare param)";
    // Expect edge: <x || 'default'> -[READS_FROM]-> <x>
    // Expect edge: <x || 'default'> -[READS_FROM]-> <'default'>
    // Expect edge: <{ x, y }> -[READS_FROM]-> <x>
    // Expect edge: <{ x, y }> -[READS_FROM]-> <y>
    void code;
  });

  test('declarations::const-decl-call-result-1', () => {
    const code = "const uniqueKey = Symbol('description');";
    // Expect edge: <Symbol('description')> -[CALLS]-> <Symbol>
    void code;
  });

  test('coercion-hoisting::eval-let-scope', () => {
    const code = "function evalLetScope() {\n  eval('let y = 2');   // y is block-scoped to the eval itself\n  try {\n    return y;          // ReferenceError — y doesn't exist here\n  } catch (e) {\n    return 'y not accessible';\n  }\n}";
    // Expect edge: <return y> -[READS_FROM]-> <y>
    void code;
  });

  test('declarations::func-decl', () => {
    const code = "function regularFunction(param1, param2) {\n  return param1 + param2;\n}";
    // Expect edge: <param1 + param2> -[READS_FROM]-> <param1>
    // Expect edge: <param1 + param2> -[READS_FROM]-> <param2>
    void code;
  });

  test('declarations::const-decl-call-result', () => {
    const code = "const bigComputed = BigInt(Number.MAX_SAFE_INTEGER);";
    // Expect edge: <BigInt(Number.MAX_SAFE_INTEGER)> -[CALLS]-> <BigInt>
    // Expect edge: <Number.MAX_SAFE_INTEGER> -[READS_FROM]-> <Number>
    void code;
  });

  test('declarations::func-decl-rest-params', () => {
    const code = "function withRestParams(...args) {\n  return args.length;\n}";
    // Expect edge: <args.length> -[READS_FROM]-> <args>
    void code;
  });

  test('declarations::const-decl-method-call-result', () => {
    const code = "const globalSymbol = Symbol.for('shared');";
    // Expect edge: <Symbol.for('shared')> -[CALLS]-> <Symbol.for>
    // Expect edge: <Symbol.for> -[READS_FROM]-> <Symbol>
    void code;
  });

  test('coercion-hoisting::object-as-map-key-tostring', () => {
    const code = "function objectAsMapKey() {\n  const cache = {};\n  const obj = {};\n  cache[obj] = 'value';           // key is \"[object Object]\"\n  cache[{ a: 1 }] = 'another';   // SAME key \"[object Object]\" — overwrites!\n  return cache;\n}";
    // Expect edge: <cache[obj]> -[READS_FROM]-> <cache>
    // Expect edge: <cache[obj]> -[READS_FROM]-> <obj>
    // Expect edge: <obj> -[FLOWS_INTO]-> <obj-toString>
    // Expect edge: <cache[obj]> -[DEPENDS_ON]-> <obj-toString>
    // Expect edge: <cache[{ a: 1 }]> -[READS_FROM]-> <cache>
    // Expect edge: <cache[{ a: 1 }]> -[READS_FROM]-> <{ a: 1 }>
    // Expect edge: <{ a: 1 }> -[FLOWS_INTO]-> <inline-obj-toString>
    // Expect edge: <cache[{ a: 1 }]> -[DEPENDS_ON]-> <inline-obj-toString>
    void code;
  });

  test('declarations::func-decl-defaults', () => {
    const code = "function withDefaults(a = 10, b = 'default') {\n  return `${a}${b}`;\n}";
    // Expect edge: <`${a}${b}`> -[READS_FROM]-> <a>
    // Expect edge: <`${a}${b}`> -[READS_FROM]-> <b>
    void code;
  });

  test('declarations::func-expr-named', () => {
    const code = "const namedExpression = function multiply(x, y) {\n  return x * y;\n};";
    // Expect edge: <x * y> -[READS_FROM]-> <x>
    // Expect edge: <x * y> -[READS_FROM]-> <y>
    void code;
  });

  test('declarations::arrow-single-param', () => {
    const code = "const arrowSingleParam = x => x * 2;";
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('declarations::arrow-block-body', () => {
    const code = "const arrowBlock = (a, b) => {\n  return a + b;\n};";
    // Expect edge: <a + b> -[READS_FROM]-> <a>
    // Expect edge: <a + b> -[READS_FROM]-> <b>
    void code;
  });

  test('declarations::arrow-expression-body', () => {
    const code = "const arrowExpression = (a, b) => a + b;";
    // Expect edge: <a + b> -[READS_FROM]-> <a>
    // Expect edge: <a + b> -[READS_FROM]-> <b>
    void code;
  });

  test('declarations::func-expr-anonymous', () => {
    const code = "const anonymousExpression = function (x) {\n  return x * 2;\n};\n\n// Arrow Functions";
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('declarations::func-decl-mixed-params', () => {
    const code = "function withMixedParams(required, optional = null, ...rest) {\n  return [required, optional, ...rest];\n}\n\n// Function Expressions";
    // Expect edge: <[required, optional, ...rest]> -[READS_FROM]-> <required>
    // Expect edge: <[required, optional, ...rest]> -[READS_FROM]-> <optional>
    // Expect edge: <[required, optional, ...rest]> -[READS_FROM]-> <rest>
    void code;
  });

  test('builtins::builtin-json-parse', () => {
    const code = "function jsonParse(str) {\n  return JSON.parse(str);\n}";
    // Expect edge: <JSON.parse(str)> -[CALLS]-> <JSON.parse>
    // Expect edge: <JSON.parse> -[READS_FROM]-> <JSON>
    void code;
  });

  test('declarations::async-func-decl', () => {
    const code = "async function asyncFunction() {\n  return await Promise.resolve(42);\n}";
    // Expect edge: <Promise.resolve(42)> -[CALLS]-> <Promise.resolve>
    void code;
  });

  test('declarations::generator-delegation', () => {
    const code = "function* delegatingGenerator() {\n  yield* numberGenerator();\n  yield 4;\n}\n\n// Async Functions";
    // Expect edge: <numberGenerator()> -[CALLS]-> <numberGenerator>
    void code;
  });

  test('declarations::iife', () => {
    const code = "const iifeResult = (function () {\n  return 'iife';\n})();";
    // Expect edge: <iife:call> -[CALLS]-> <iife:fn>
    void code;
  });

  test('declarations::iife-arrow', () => {
    const code = "const arrowIifeResult = (() => {\n  return 'arrow iife';\n})();\n\n// Named Exports";
    // Expect edge: <arrow-iife:call> -[CALLS]-> <arrow-iife:fn>
    void code;
  });

  test('declarations::async-arrow', () => {
    const code = "const asyncArrow = async () => {\n  return await Promise.resolve('async arrow');\n};\n\n// Async Generator Functions";
    // Expect edge: <Promise.resolve('async arrow')> -[CALLS]-> <Promise.resolve>
    void code;
  });

  test('declarations::arrow-return-object-literal', () => {
    const code = "const arrowReturnsObject = (x) => ({ key: x, value: x * 2 });\n// Without parens: (x) => { key: x } — parsed as block with label \"key\"!";
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('declarations::param-default-scope-quirk', () => {
    const code = "let outerX = 'outer';\nfunction paramDefaultScope(a = () => outerX, outerX) {\n  return a();\n}";
    // Expect edge: <a:default> -[READS_FROM]-> <outerX>
    // Expect edge: <a()> -[CALLS]-> <a>
    void code;
  });

  test('declarations::async-iife', () => {
    const code = "const asyncIifeResult = (async () => {\n  return await Promise.resolve('async iife');\n})();";
    // Expect edge: <async-iife:call> -[CALLS]-> <async-iife:fn>
    void code;
  });

  test('declarations::async-generator-decl', () => {
    const code = "async function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\n// IIFE (Immediately Invoked Function Expression)";
    // Expect edge: <Promise.resolve(1)> -[CALLS_ON]-> <Promise>
    // Expect edge: <Promise.resolve(2)> -[CALLS_ON]-> <Promise>
    void code;
  });

  test('declarations::param-default-depends-on-prior', () => {
    const code = "function paramDefaultChain(a, b = a * 2, c = a + b) {\n  return { a, b, c };\n}";
    // Expect edge: <a * 2> -[READS_FROM]-> <a>
    // Expect edge: <a * 2> -[READS_FROM]-> <2>
    // Expect edge: <a + b> -[READS_FROM]-> <a>
    // Expect edge: <a + b> -[READS_FROM]-> <b>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <b>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <c>
    void code;
  });

  test('declarations::new-target-in-function', () => {
    const code = "function FlexibleConstructor(name) {\n  if (!new.target) {\n    return new FlexibleConstructor(name); // redirect if called without new\n  }\n  this.name = name;\n}";
    // Expect edge: <!new.target> -[READS_FROM]-> <new.target>
    // Expect edge: <new FlexibleConstructor(name)> -[CALLS]-> <FlexibleConstructor>
    void code;
  });

  test('declarations::func-expr-recursive-self-ref', () => {
    const code = "const factorialNamedExpr = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1); // fact visible ONLY inside\n};\n// typeof fact === 'undefined' — internal name not in enclosing scope";
    // Expect edge: <n <= 1> -[READS_FROM]-> <n>
    // Expect edge: <n <= 1> -[READS_FROM]-> <1>
    // Expect edge: <n * fact(n - 1)> -[READS_FROM]-> <n>
    // Expect edge: <n * fact(n - 1)> -[READS_FROM]-> <fact(n - 1)>
    // Expect edge: <fact(n - 1)> -[CALLS]-> <fact>
    // Expect edge: <n - 1> -[READS_FROM]-> <n>
    // Expect edge: <n - 1> -[READS_FROM]-> <1>
    void code;
  });

  test('error-handling::error-custom-class', () => {
    const code = "class AppError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n  }\n}";
    // Expect edge: <AppError> -[EXTENDS]-> <Error>
    // Expect edge: <super(message)> -[CALLS]-> <Error>
    void code;
  });

  test('declarations::let-const-multi-declaration', () => {
    const code = "const constMultiA = 1, constMultiB = constMultiA + 1, constMultiC = constMultiA + constMultiB;\nlet letMultiX = 0, letMultiY = letMultiX + 1;";
    // Expect edge: <constMultiA + 1> -[READS_FROM]-> <constMultiA>
    // Expect edge: <constMultiA + constMultiB> -[READS_FROM]-> <constMultiA>
    // Expect edge: <constMultiA + constMultiB> -[READS_FROM]-> <constMultiB>
    // Expect edge: <letMultiX + 1> -[READS_FROM]-> <letMultiX>
    void code;
  });

  test('builtins::builtin-json-parse-reviver', () => {
    const code = "function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}";
    // Expect edge: <JSON.parse(str, reviver)> -[CALLS]-> <JSON.parse>
    // Expect edge: <key === 'date'> -[READS_FROM]-> <key>
    // Expect edge: <key === 'date'> -[READS_FROM]-> <'date'>
    // Expect edge: <new Date(value)> -[CALLS]-> <Date>
    void code;
  });

  test('builtins::builtin-json-stringify', () => {
    const code = "function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}";
    // Expect edge: <JSON.stringify(obj)> -[CALLS]-> <JSON.stringify>
    void code;
  });

  test('error-handling::error-cause', () => {
    const code = "async function fetchWithCause(url) {\n  try {\n    const response = await fetch(url);\n    return await response.json();\n  } catch (err) {\n    throw new Error(`Failed to fetch ${url}`, { cause: err });\n  }\n}\n\n// --- Error wrapping / re-throw ---";
    // Expect edge: <response.json()> -[CALLS_ON]-> <response>
    // Expect edge: <`Failed to fetch ${url}`> -[READS_FROM]-> <url>
    // Expect edge: <{ cause: err }> -[READS_FROM]-> <err>
    void code;
  });

  test('error-handling::error-wrap-rethrow', () => {
    const code = "function parseConfig(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch (err) {\n    throw new AppError(`Invalid config: ${err.message}`, 'PARSE_ERROR');\n  }\n}";
    // Expect edge: <JSON.parse(raw)> -[CALLS]-> <JSON.parse>
    // Expect edge: <new AppError> -[CALLS]-> <AppError>
    // Expect edge: <`Invalid config: ${err.message}`> -[READS_FROM]-> <err.message>
    // Expect edge: <err.message> -[READS_FROM]-> <err>
    void code;
  });

  test('error-handling::error-async-catch-all', () => {
    const code = "async function safeExecute(asyncFn) {\n  try {\n    return { ok: true, value: await asyncFn() };\n  } catch (err) {\n    return { ok: false, error: err };\n  }\n}\n\n// --- Promise rejection handling ---";
    // Expect edge: <asyncFn()> -[CALLS]-> <asyncFn>
    void code;
  });

  test('declarations::param-default-from-destructured', () => {
    const code = "function paramDefaultFromDestructured({width, height}, area = width * height) {\n  return { width, height, area };\n}\n\n// Also with nested destructuring feeding later default:\nfunction queryBuilder({table, schema = 'public'}, fullName = `${schema}.${table}`) {\n  return `SELECT * FROM ${fullName}`;\n}";
    // Expect edge: <width * height> -[READS_FROM]-> <width>
    // Expect edge: <width * height> -[READS_FROM]-> <height>
    // Expect edge: <{ width, height, area }> -[READS_FROM]-> <width>
    // Expect edge: <{ width, height, area }> -[READS_FROM]-> <height>
    // Expect edge: <{ width, height, area }> -[READS_FROM]-> <area>
    // Expect edge: <`${schema}.${table}`> -[READS_FROM]-> <schema>
    // Expect edge: <`${schema}.${table}`> -[READS_FROM]-> <table>
    // Expect edge: <`SELECT * FROM ${fullName}`> -[READS_FROM]-> <fullName>
    void code;
  });

  test('error-handling::error-promise-catch', () => {
    const code = "function promiseErrorHandling() {\n  return Promise.reject(new Error('boom'))\n    .catch(err => {\n      console.error('Caught:', err.message);\n      return 'recovered';\n    });\n}";
    // Expect edge: <err.message> -[READS_FROM]-> <err>
    void code;
  });

  test('builtins::builtin-json-stringify-replacer', () => {
    const code = "function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---";
    // Expect edge: <JSON.stringify(obj, replacer, 2)> -[CALLS]-> <JSON.stringify>
    // Expect edge: <typeof value === 'function'> -[READS_FROM]-> <typeof value>
    // Expect edge: <typeof value === 'function'> -[READS_FROM]-> <'function'>
    // Expect edge: <typeof value> -[READS_FROM]-> <value>
    void code;
  });

  test('error-handling::error-rethrow-conditional', () => {
    const code = "function processData(data) {\n  try {\n    return transform(data);\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err; // re-throw known errors as-is\n    }\n    throw new AppError(`Unexpected: ${err.message}`, 'INTERNAL');\n  }\n}\n\nfunction transform(data) {\n  if (!data) throw new ValidationError('data', 'Data is required');\n  return data;\n}\n\n// --- instanceof checks in catch ---";
    // Expect edge: <transform(data)> -[CALLS]-> <transform>
    // Expect edge: <err instanceof ValidationError> -[READS_FROM]-> <err>
    // Expect edge: <new AppError(...)> -[READS_FROM]-> <err>
    // Expect edge: <!data> -[READS_FROM]-> <transform:data>
    void code;
  });

  test('error-handling::error-custom-hierarchy', () => {
    const code = "class ValidationError extends AppError {\n  constructor(field, message) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource, id) {\n    super(`${resource} not found: ${id}`, 'NOT_FOUND');\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.id = id;\n  }\n}\n\n// --- Error cause (ES2022) ---";
    // Expect edge: <`${resource} not found: ${id}`> -[READS_FROM]-> <resource>
    // Expect edge: <`${resource} not found: ${id}`> -[READS_FROM]-> <id>
    void code;
  });

  test('error-handling::error-aggregate', () => {
    const code = "function aggregatedErrors() {\n  const errors = [\n    new Error('first'),\n    new Error('second'),\n    new Error('third'),\n  ];\n  throw new AggregateError(errors, 'Multiple failures');\n}\n\n// --- Finally for cleanup ---";
    // Expect edge: <new Error('first')> -[CALLS]-> <Error>
    // Expect edge: <new Error('second')> -[CALLS]-> <Error>
    // Expect edge: <new Error('third')> -[CALLS]-> <Error>
    // Expect edge: <new AggregateError(errors, 'Multiple failures')> -[CALLS]-> <AggregateError>
    void code;
  });

  test('expressions::delete-op', () => {
    const code = "function deleteOperator() {\n  const obj = { a: 1, b: 2 };\n  delete obj.a;\n  return obj;\n}";
    // Expect edge: <obj.a> -[READS_FROM]-> <obj>
    void code;
  });

  test('expressions::update-expr', () => {
    const code = "function updateExpressions() {\n  let x = 0;\n  x++;\n  x--;\n  ++x;\n  --x;\n  return x;\n}";
    // Expect edge: <x++> -[READS_FROM]-> <x>
    // Expect edge: <x--> -[READS_FROM]-> <x>
    // Expect edge: <++x> -[READS_FROM]-> <x>
    // Expect edge: <--x> -[READS_FROM]-> <x>
    void code;
  });

  test('expressions::logical-ops', () => {
    const code = "function logicalOperators(a, b) {\n  const and = a && b;\n  const or = a || b;\n  const nullish = a ?? b;\n  const not = !a;\n  return { and, or, nullish, not };\n}";
    // Expect edge: <a && b> -[READS_FROM]-> <a>
    // Expect edge: <a && b> -[READS_FROM]-> <b>
    // Expect edge: <a || b> -[READS_FROM]-> <a>
    // Expect edge: <a || b> -[READS_FROM]-> <b>
    // Expect edge: <a ?? b> -[READS_FROM]-> <a>
    // Expect edge: <a ?? b> -[READS_FROM]-> <b>
    // Expect edge: <!a> -[READS_FROM]-> <a>
    // Expect edge: <{ and, or, nullish, not }> -[READS_FROM]-> <and>
    // Expect edge: <{ and, or, nullish, not }> -[READS_FROM]-> <or>
    // Expect edge: <{ and, or, nullish, not }> -[READS_FROM]-> <nullish>
    // Expect edge: <{ and, or, nullish, not }> -[READS_FROM]-> <not>
    void code;
  });

  test('expressions::tagged-template-usage', () => {
    const code = "const tagged = tag`Hello ${'world'} number ${42}`;";
    // Expect edge: <tag`Hello ${'world'} number ${42}`> -[CALLS]-> <tag>
    void code;
  });

  test('expressions::tagged-template-fn', () => {
    const code = "function tag(strings, ...values) {\n  return strings.raw.join('') + values.join('');\n}";
    // Expect edge: <strings.raw> -[READS_FROM]-> <strings>
    // Expect edge: <strings.raw.join('')> -[CALLS_ON]-> <strings.raw>
    // Expect edge: <values.join('')> -[CALLS_ON]-> <values>
    // Expect edge: <strings.raw.join('') + values.join('')> -[READS_FROM]-> <strings.raw.join('')>
    // Expect edge: <strings.raw.join('') + values.join('')> -[READS_FROM]-> <values.join('')>
    void code;
  });

  test('expressions::optional-chaining', () => {
    const code = "function optionalChaining(obj) {\n  const prop = obj?.nested?.deep;\n  const method = obj?.method?.();\n  const computed = obj?.items?.[0];\n  return { prop, method, computed };\n}";
    // Expect edge: <obj?.nested?.deep> -[READS_FROM]-> <obj>
    // Expect edge: <obj?.method?.()> -[READS_FROM]-> <obj>
    // Expect edge: <obj?.items?.[0]> -[READS_FROM]-> <obj>
    // Expect edge: <obj?.items?.[0]> -[READS_FROM]-> <0>
    // Expect edge: <{ prop, method, computed }> -[READS_FROM]-> <prop>
    // Expect edge: <{ prop, method, computed }> -[READS_FROM]-> <method>
    // Expect edge: <{ prop, method, computed }> -[READS_FROM]-> <computed>
    void code;
  });

  test('expressions::unary-ops', () => {
    const code = "function unaryOperators(x) {\n  const pos = +x;\n  const neg = -x;\n  const logNot = !x;\n  const bitNot = ~x;\n  const typeOfX = typeof x;\n  const voidX = void x;\n  return { pos, neg, logNot, bitNot, typeOfX, voidX };\n}";
    // Expect edge: <+x> -[READS_FROM]-> <x>
    // Expect edge: <-x> -[READS_FROM]-> <x>
    // Expect edge: <!x> -[READS_FROM]-> <x>
    // Expect edge: <~x> -[READS_FROM]-> <x>
    // Expect edge: <typeof x> -[READS_FROM]-> <x>
    // Expect edge: <void x> -[READS_FROM]-> <x>
    // Expect edge: <{ pos, neg, logNot, bitNot, typeOfX, voidX }> -[READS_FROM]-> <pos>
    // Expect edge: <{ pos, neg, logNot, bitNot, typeOfX, voidX }> -[READS_FROM]-> <neg>
    // Expect edge: <{ pos, neg, logNot, bitNot, typeOfX, voidX }> -[READS_FROM]-> <logNot>
    // Expect edge: <{ pos, neg, logNot, bitNot, typeOfX, voidX }> -[READS_FROM]-> <bitNot>
    // Expect edge: <{ pos, neg, logNot, bitNot, typeOfX, voidX }> -[READS_FROM]-> <typeOfX>
    // Expect edge: <{ pos, neg, logNot, bitNot, typeOfX, voidX }> -[READS_FROM]-> <voidX>
    void code;
  });

  test('builtins::builtin-map-constructor', () => {
    const code = "function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---";
    // Expect edge: <new Map([...])> -[CALLS]-> <Map>
    void code;
  });

  test('expressions::chained-assignment-mixed', () => {
    const code = "function chainedAssignmentMixed() {\n  const obj = {};\n  obj.x = obj.y = [];\n  return obj;\n}";
    // Expect edge: <obj.x = obj.y = []> -[READS_FROM]-> <[]>
    void code;
  });

  test('expressions::chained-assignment', () => {
    const code = "function chainedAssignment() {\n  let a, b, c;\n  a = b = c = 42;\n  return { a, b, c };\n}";
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <b>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <c>
    void code;
  });

  test('expressions::ternary', () => {
    const code = "function ternaryOperator(condition, value) {\n  const simple = condition ? 'yes' : 'no';\n  const nested = condition ? (value > 5 ? 'high' : 'low') : 'none';\n  return { simple, nested };\n}";
    // Expect edge: <value > 5> -[READS_FROM]-> <value>
    // Expect edge: <value > 5> -[READS_FROM]-> <5>
    void code;
  });

  test('expressions::grouping', () => {
    const code = "function groupingOperator(a, b, c) {\n  const withGrouping = (a + b) * c;\n  const withoutGrouping = a + b * c;\n  return { withGrouping, withoutGrouping };\n}";
    // Expect edge: <(a + b) * c> -[READS_FROM]-> <a + b>
    // Expect edge: <(a + b) * c> -[READS_FROM]-> <c>
    // Expect edge: <a + b> -[READS_FROM]-> <a>
    // Expect edge: <a + b> -[READS_FROM]-> <b>
    // Expect edge: <a + b * c> -[READS_FROM]-> <a>
    // Expect edge: <a + b * c> -[READS_FROM]-> <b * c>
    // Expect edge: <b * c> -[READS_FROM]-> <b>
    // Expect edge: <b * c> -[READS_FROM]-> <c>
    // Expect edge: <{ withGrouping, withoutGrouping }> -[READS_FROM]-> <withGrouping>
    // Expect edge: <{ withGrouping, withoutGrouping }> -[READS_FROM]-> <withoutGrouping>
    void code;
  });

  test('expressions::tagged-template-raw', () => {
    const code = "function rawTemplate(strings) {\n  return strings.raw[0];\n}\nconst rawResult = rawTemplate`\\n`;";
    // Expect edge: <strings.raw[0]> -[READS_FROM]-> <strings>
    // Expect edge: <rawTemplate`\n`> -[CALLS]-> <rawTemplate>
    void code;
  });

  test('expressions::void-promise', () => {
    const code = "void async function () { await Promise.resolve('ping'); }();";
    // Expect edge: <iife-call> -[CALLS]-> <async-iife>
    // Expect edge: <Promise.resolve('ping')> -[CALLS]-> <Promise.resolve>
    // Expect edge: <Promise.resolve> -[READS_FROM]-> <Promise>
    void code;
  });

  test('expressions::void-iife', () => {
    const code = "void function () { console.log('fire and forget'); }();";
    // Expect edge: <iife-call> -[CALLS]-> <anonymous-fn>
    // Expect edge: <console.log('fire and forget')> -[CALLS]-> <console.log>
    void code;
  });

  test('expressions::new-constructor-return-non-this', () => {
    const code = "function NonThisConstructor() {\n  return { custom: true }; // returns different object than `this`\n}\nconst nonThisInstance = new NonThisConstructor(); // NOT instanceof NonThisConstructor!";
    // Expect edge: <new NonThisConstructor()> -[CALLS]-> <NonThisConstructor>
    void code;
  });

  test('expressions::comma-in-arrow-body', () => {
    const code = "const commaArrow = (x) => (console.log(x), x * 2);";
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('expressions::comma-in-array-subscript', () => {
    const code = "function commaSubscript() {\n  const matrix = [[1, 2], [3, 4]];\n  const result = matrix[0, 1]; // comma evaluates to 1 → matrix[1]\n  return result; // [3, 4]\n}";
    // Expect edge: <matrix[0, 1]> -[READS_FROM]-> <matrix>
    void code;
  });

  test('expressions::conditional-method-call', () => {
    const code = "function conditionalMethodCall(input) {\n  const value = (typeof input === 'string' ? input : String(input)).trim();\n  return value;\n}";
    // Expect edge: <.trim()> -[CALLS_ON]-> <conditional>
    // Expect edge: <typeof input === 'string'> -[READS_FROM]-> <typeof input>
    // Expect edge: <typeof input === 'string'> -[READS_FROM]-> <'string'>
    // Expect edge: <typeof input> -[READS_FROM]-> <input>
    void code;
  });

  test('expressions::typeof-undeclared', () => {
    const code = "function typeofUndeclared() {\n  const safe = typeof undeclaredVar; // \"undefined\" — NO ReferenceError\n  return safe;\n}";
    // Expect edge: <typeof undeclaredVar> -[READS_FROM]-> <undeclaredVar>
    // Expect edge: <typeof undeclaredVar> -[RESOLVES_TO]-> <'undefined'>
    void code;
  });

  test('expressions::new-precedence-trap', () => {
    const code = "function newPrecedence() {\n  const withParens = new Date().getTime();       // (new Date()).getTime()\n  // new Date.getTime()                          // new (Date.getTime)() — TypeError!\n  const noParens = new Map;                      // valid — no parens needed\n  return { withParens, noParens };\n}";
    // Expect edge: <getTime()> -[CALLS]-> <Date().getTime>
    // Expect edge: <Date().getTime> -[CALLS_ON]-> <new Date()>
    // Expect edge: <new Date()> -[CALLS]-> <Date>
    // Expect edge: <new Map> -[CALLS]-> <Map>
    // Expect edge: <{ withParens, noParens }> -[READS_FROM]-> <withParens>
    // Expect edge: <{ withParens, noParens }> -[READS_FROM]-> <noParens>
    void code;
  });

  test('expressions::nullish-coalescing-chain', () => {
    const code = "function nullishChain(a, b, c, defaultValue) {\n  const value = a ?? b ?? c ?? defaultValue;\n  return value;\n}";
    // Expect edge: <a ?? b ?? c ?? defaultValue> -[READS_FROM]-> <a>
    // Expect edge: <a ?? b ?? c ?? defaultValue> -[READS_FROM]-> <b>
    // Expect edge: <a ?? b ?? c ?? defaultValue> -[READS_FROM]-> <c>
    // Expect edge: <a ?? b ?? c ?? defaultValue> -[READS_FROM]-> <defaultValue>
    void code;
  });

  test('expressions::new-member-expression', () => {
    const code = "function newMemberExpression(mod) {\n  const instance = new mod.MyClass();\n  const nested = new mod.sub.Factory();\n  return { instance, nested };\n}";
    // Expect edge: <new mod.MyClass()> -[CALLS]-> <mod.MyClass>
    // Expect edge: <mod.MyClass> -[READS_FROM]-> <mod>
    // Expect edge: <new mod.sub.Factory()> -[CALLS]-> <mod.sub.Factory>
    // Expect edge: <mod.sub.Factory> -[READS_FROM]-> <mod.sub>
    // Expect edge: <mod.sub> -[READS_FROM]-> <mod>
    // Expect edge: <{ instance, nested }> -[READS_FROM]-> <instance>
    // Expect edge: <{ instance, nested }> -[READS_FROM]-> <nested>
    void code;
  });

  test('expressions::comma-in-condition', () => {
    const code = "function commaInWhile() {\n  let i = 0, total = 0;\n  while ((total += i, ++i < 5)) {\n    // comma in condition\n  }\n  return total; // 10\n}";
    // Expect edge: <total += i> -[READS_FROM]-> <i>
    // Expect edge: <return total> -[READS_FROM]-> <total>
    void code;
  });

  test('expressions::reflect-construct-factory', () => {
    const code = "function createInstance(Cls, args) {\n  return Reflect.construct(Cls, args); // factory pattern — construct without `new`\n}\n\n// --- Tagged template returning non-string ---";
    // Expect edge: <Reflect.construct(Cls, args)> -[CALLS]-> <Reflect.construct>
    // Expect edge: <Reflect.construct> -[READS_FROM]-> <Reflect>
    void code;
  });

  test('expressions::assignment-in-if', () => {
    const code = "function assignmentInIf(compute) {\n  let result;\n  if (result = compute()) {            // assignment + truthiness check\n    return result;\n  }\n  return null;\n}";
    // Expect edge: <compute()> -[CALLS]-> <compute>
    void code;
  });

  test('expressions::conditional-tag-template', () => {
    const code = "function conditionalTagTemplate(dangerous) {\n  const escape = dangerous ? (s) => s[0].toUpperCase() : (s) => s[0];\n  const result = escape`hello`;\n  return result;\n}";
    // Expect edge: <dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]> -[READS_FROM]-> <dangerous>
    // Expect edge: <s[0].toUpperCase()> -[CALLS]-> <s[0]>
    // Expect edge: <s[0]> -[READS_FROM]-> <s1>
    // Expect edge: <s2[0]> -[READS_FROM]-> <s2>
    // Expect edge: <escape`hello`> -[CALLS]-> <escape>
    void code;
  });

  test('expressions::reflect-construct-newtarget', () => {
    const code = "class ReflectBase {\n  constructor() {\n    this.constructedBy = new.target.name;\n  }\n}\nclass ReflectDerived extends ReflectBase {}\n\nfunction reflectConstructDemo() {\n  const normal = new ReflectDerived();                       // constructedBy: 'ReflectDerived'\n  const spoofed = Reflect.construct(ReflectBase, [], ReflectDerived); // constructedBy: 'ReflectDerived' but runs Base constructor\n  return { normal, spoofed };\n}";
    // Expect edge: <ReflectBase.constructor> -[READS_FROM]-> <new.target.name>
    // Expect edge: <ReflectDerived> -[EXTENDS]-> <ReflectBase>
    // Expect edge: <new ReflectDerived()> -[CALLS]-> <ReflectDerived>
    // Expect edge: <{ normal, spoofed }> -[READS_FROM]-> <normal>
    // Expect edge: <{ normal, spoofed }> -[READS_FROM]-> <spoofed>
    void code;
  });

  test('expressions::logical-assign-property', () => {
    const code = "function logicalAssignProperty() {\n  const config = { timeout: 0, retries: null, debug: false };\n  config.timeout ||= 5000;    // 5000 — 0 is falsy\n  config.retries ??= 3;       // 3 — null is nullish\n  config.debug &&= true;      // false — short-circuits\n  return config;\n}";
    // Expect edge: <config.timeout ||= 5000> -[READS_FROM]-> <config.timeout>
    // Expect edge: <config.retries ??= 3> -[READS_FROM]-> <config.retries>
    // Expect edge: <config.debug &&= true> -[READS_FROM]-> <config.debug>
    void code;
  });

  test('expressions::tagged-template-chained', () => {
    const code = "function chainTag(strings) {\n  return (strings2) => strings[0] + strings2[0];\n}\nconst chainedResult = chainTag`hello``world`;";
    // Expect edge: <strings[0] + strings2[0]> -[READS_FROM]-> <strings[0]>
    // Expect edge: <strings[0] + strings2[0]> -[READS_FROM]-> <strings2[0]>
    // Expect edge: <strings[0]> -[READS_FROM]-> <strings>
    // Expect edge: <strings2[0]> -[READS_FROM]-> <strings2>
    // Expect edge: <chainTag`hello`> -[CALLS]-> <chainTag>
    // Expect edge: <chainTag`hello``world`> -[CALLS]-> <chainTag`hello`>
    void code;
  });

  test('expressions::tagged-template-returns-class', () => {
    const code = "const styledDiv = {\n  div(strings, ...exprs) {\n    return class StyledComponent {\n      styles = strings.join('');\n    };\n  },\n};\nconst Component = styledDiv.div`color: red; font-size: 14px;`;";
    // Expect edge: <strings.join('')> -[CALLS_ON]-> <strings>
    // Expect edge: <styledDiv.div`color: red; font-size: 14px;`> -[CALLS]-> <styledDiv.div>
    // Expect edge: <styledDiv.div> -[READS_FROM]-> <styledDiv>
    void code;
  });

  test('expressions::tagged-template-returns-object', () => {
    const code = "function sql(strings, ...values) {\n  return { text: strings.join('?'), params: values }; // returns object, not string!\n}\nconst userId = 42;\nconst query = sql`SELECT * FROM users WHERE id = ${userId}`;";
    // Expect edge: <strings.join('?')> -[CALLS_ON]-> <strings>
    // Expect edge: <sql`SELECT * FROM users WHERE id = ${userId}`> -[CALLS]-> <sql>
    void code;
  });

  test('expressions::short-circuit-guard-call', () => {
    const code = "function shortCircuitGuard(callback, data) {\n  callback && callback(data);           // guard + call\n  const result = callback?.(data);      // optional call equivalent\n  return result;\n}";
    // Expect edge: <callback && callback(data)> -[READS_FROM]-> <callback>
    // Expect edge: <callback(data)> -[CALLS]-> <callback>
    // Expect edge: <callback?.(data)> -[CALLS]-> <callback>
    void code;
  });

  test('expressions::await-comma-expression', () => {
    const code = "async function awaitCommaExpression(sideEffect, fetchData) {\n  const result = await (sideEffect(), fetchData());\n  // sideEffect() runs sync, fetchData() is awaited\n  return result;\n}";
    // Expect edge: <sideEffect()> -[CALLS]-> <sideEffect>
    // Expect edge: <fetchData()> -[CALLS]-> <fetchData>
    void code;
  });

  test('expressions::new-with-spread', () => {
    const code = "function newWithSpread() {\n  const args = [2024, 0, 15];\n  const date = new Date(...args);\n\n  function instantiate(Cls, ctorArgs) {\n    return new Cls(...ctorArgs);       // dynamic class + spread\n  }\n\n  return { date, instantiate };\n}";
    // Expect edge: <new Date(...args)> -[CALLS]-> <Date>
    // Expect edge: <new Date(...args)> -[READS_FROM]-> <args>
    // Expect edge: <new Cls(...ctorArgs)> -[CALLS]-> <Cls>
    // Expect edge: <new Cls(...ctorArgs)> -[READS_FROM]-> <ctorArgs>
    void code;
  });

  test('expressions::nullish-logical-mixing-error', () => {
    const code = "// SyntaxError — cannot mix ?? with || or && without explicit parentheses:\n// a ?? b || c;    // SyntaxError\n// a || b ?? c;    // SyntaxError\n// a ?? b && c;    // SyntaxError\n// Must use: (a ?? b) || c  or  a ?? (b || c)";
    // Expect edge: <(a ?? b) || c> -[RESOLVES_TO]-> <nullish-logical-mixing-error>
    // Expect edge: <a ?? (b || c)> -[RESOLVES_TO]-> <nullish-logical-mixing-error>
    void code;
  });

  test('expressions::assignment-in-condition', () => {
    const code = "function assignmentInCondition(regex, str) {\n  const matches = [];\n  let match;\n  while (match = regex.exec(str)) {   // assignment AS condition (no explicit comparison)\n    matches.push(match[0]);\n  }\n  return matches;\n}";
    // Expect edge: <match = regex.exec(str)> -[READS_FROM]-> <regex.exec(str)>
    // Expect edge: <regex.exec(str)> -[CALLS]-> <regex.exec>
    // Expect edge: <regex.exec> -[READS_FROM]-> <regex>
    // Expect edge: <matches.push(match[0])> -[CALLS]-> <matches.push>
    // Expect edge: <matches.push> -[READS_FROM]-> <matches>
    // Expect edge: <match[0]> -[READS_FROM]-> <match>
    // Expect edge: <match[0]> -[READS_FROM]-> <0>
    void code;
  });

  test('index::import-named', () => {
    const code = "import { helperFunction, HELPER_CONST } from './modules-helpers.js';";
    // Expect edge: <import-modules-helpers> -[IMPORTS]-> <helperFunction>
    // Expect edge: <import-modules-helpers> -[IMPORTS]-> <HELPER_CONST>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('index::import-default', () => {
    const code = "import defaultExport from './modules-helpers.js';";
    // Expect edge: <import-modules-helpers> -[IMPORTS]-> <defaultExport>
    // Expect edge: <import-modules-helpers> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('expressions::async-arrow-returns-object', () => {
    const code = "const asyncArrowObject = async (data, processFn) => ({\n  id: data.id,\n  result: await processFn(data),\n  timestamp: Date.now(),\n});\n// Without parens: async (data) => { id: data.id } — parsed as block + label!";
    // Expect edge: <data.id> -[READS_FROM]-> <data>
    // Expect edge: <processFn(data)> -[CALLS]-> <processFn>
    // Expect edge: <Date.now()> -[CALLS]-> <Date.now>
    void code;
  });

  test('index::import-aliased', () => {
    const code = "import { HelperClass as Helper } from './modules-helpers.js';";
    // Expect edge: <import-modules-helpers> -[IMPORTS]-> <Helper>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('hashbang-entry::hashbang-comment', () => {
    const code = "// The #!/usr/bin/env node line above is a HashbangComment node in the AST.\n// It is the ONLY position where # is legal outside a string/comment/private-field.\n\nfunction hashbangMain(args) {\n  return { ran: true, args };\n}";
    // Expect edge: <{ ran: true, args }> -[READS_FROM]-> <args>
    void code;
  });

  test('expressions::getter-returns-function', () => {
    const code = "function getterReturnsFunction() {\n  const obj = {\n    get handler() {\n      return (x) => x * 2;             // getter returns a function\n    },\n  };\n  const result = obj.handler(21);       // getter call + returned function call\n  return result; // 42\n}";
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    // Expect edge: <obj.handler(21)> -[CALLS]-> <obj.handler>
    // Expect edge: <obj.handler> -[READS_FROM]-> <obj>
    void code;
  });

  test('index::import-namespace', () => {
    const code = "import * as allHelpers from './modules-helpers.js';";
    // Expect edge: <import-allHelpers> -[IMPORTS]-> <allHelpers>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('index::import-default-as-named', () => {
    const code = "import { default as mainFn } from './modules-helpers.js';";
    // Expect edge: <import-modules-helpers> -[IMPORTS]-> <mainFn>
    // Expect edge: <import-modules-helpers> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('index::reexport-star', () => {
    const code = "export * from './modules-reexport.js';";
    // Expect edge: <export-star> -[IMPORTS_FROM]-> <./modules-reexport.js>
    void code;
  });

  test('index::import-meta', () => {
    const code = "const currentUrl = import.meta.url;\n\n// --- Module namespace object as first-class value ---";
    // Expect edge: <import.meta.url> -[READS_FROM]-> <import.meta>
    void code;
  });

  test('builtins::builtin-weakset', () => {
    const code = "function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---";
    // Expect edge: <new WeakSet()> -[CALLS]-> <WeakSet>
    // Expect edge: <ws.add(obj1)> -[CALLS_ON]-> <ws>
    // Expect edge: <ws.has(obj1)> -[CALLS_ON]-> <ws>
    // Expect edge: <ws.delete(obj1)> -[CALLS_ON]-> <ws>
    // Expect edge: <ws.has(obj1)2> -[CALLS_ON]-> <ws>
    // Expect edge: <{ has, hasAfter }> -[READS_FROM]-> <has>
    // Expect edge: <{ has, hasAfter }> -[READS_FROM]-> <hasAfter>
    void code;
  });

  test('expressions::tag-on-call-result', () => {
    const code = "function tagOnCallResult() {\n  function getFormatter(type) {\n    return (strings, ...values) => ({ type, parts: strings, values });\n  }\n  const result = getFormatter('sql')`SELECT * FROM ${'users'}`;\n  return result;\n}";
    // Expect edge: <{ type, parts: strings, values }> -[READS_FROM]-> <type>
    // Expect edge: <{ type, parts: strings, values }> -[READS_FROM]-> <strings>
    // Expect edge: <{ type, parts: strings, values }> -[READS_FROM]-> <...values>
    // Expect edge: <getFormatter('sql')> -[CALLS]-> <getFormatter>
    // Expect edge: <tagged_template_call> -[CALLS]-> <getFormatter('sql')>
    void code;
  });

  test('builtins::builtin-weakref', () => {
    const code = "function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}";
    // Expect edge: <ref.deref()> -[CALLS_ON]-> <ref>
    // Expect edge: <deref?.data> -[READS_FROM]-> <deref>
    void code;
  });

  test('index::import-dynamic', () => {
    const code = "const dynamicModule = await import('./patterns.js');";
    // Expect edge: <module> -[IMPORTS_FROM]-> <./patterns.js>
    void code;
  });

  test('expressions::deep-optional-chain', () => {
    const code = "function deepOptionalChain(response) {\n  const value = response?.data?.items?.[0]?.getName?.();\n  const nested = response?.config?.headers?.['Content-Type']?.split?.('/');\n  return { value, nested };\n}";
    // Expect edge: <response?.data> -[READS_FROM]-> <response>
    // Expect edge: <response?.config> -[READS_FROM]-> <response>
    // Expect edge: <{ value, nested }> -[READS_FROM]-> <value>
    // Expect edge: <{ value, nested }> -[READS_FROM]-> <nested>
    void code;
  });

  test('index::module-namespace-destructured', () => {
    const code = "const { helperFunction: destructuredHelper } = allHelpers;";
    // Expect edge: <{helperFunction: destructuredHelper}> -[READS_FROM]-> <allHelpers>
    // Expect edge: <{helperFunction: destructuredHelper}> -[READS_FROM]-> <allHelpers.helperFunction>
    // Expect edge: <allHelpers.helperFunction> -[READS_FROM]-> <allHelpers>
    void code;
  });

  test('expressions::arrow-return-assignment', () => {
    const code = "function arrowReturnAssignment() {\n  let cache = null;\n\n  // Arrow returning assignment — parenthesized to make it expression body\n  const setCache = (val) => (cache = val);\n  setCache(42);\n\n  // With destructuring assignment in arrow\n  let first, second;\n  const swap = () => ([first, second] = [second, first]);\n\n  return { cache, setCache, swap };\n}";
    // Expect edge: <cache = val> -[READS_FROM]-> <val>
    // Expect edge: <setCache(42)> -[CALLS]-> <setCache>
    // Expect edge: <[first, second] = [second, first]> -[READS_FROM]-> <[second, first]>
    // Expect edge: <[second, first]> -[READS_FROM]-> <second>
    // Expect edge: <[second, first]> -[READS_FROM]-> <first>
    // Expect edge: <{ cache, setCache, swap }> -[READS_FROM]-> <cache>
    // Expect edge: <{ cache, setCache, swap }> -[READS_FROM]-> <setCache>
    // Expect edge: <{ cache, setCache, swap }> -[READS_FROM]-> <swap>
    void code;
  });

  test('expressions::void-as-undefined', () => {
    const code = "function voidAsUndefined(val) {\n  // void 0 is shorter than undefined and immune to shadowing\n  const isUndef = val === void 0;\n\n  // void with side effect — expression runs, result discarded\n  let sideEffectRan = false;\n  void (sideEffectRan = true);\n\n  // void in ternary — explicit undefined branch\n  const result = val !== void 0 ? val : 'fallback';\n\n  return { isUndef, sideEffectRan, result };\n}";
    // Expect edge: <val === void 0> -[READS_FROM]-> <val>
    // Expect edge: <val === void 0> -[READS_FROM]-> <void 0>
    // Expect edge: <void 0> -[READS_FROM]-> <0>
    // Expect edge: <void (sideEffectRan = true)> -[READS_FROM]-> <sideEffectRan = true>
    // Expect edge: <sideEffectRan = true> -[READS_FROM]-> <true>
    // Expect edge: <val !== void 0> -[READS_FROM]-> <val>
    // Expect edge: <val !== void 0> -[READS_FROM]-> <void 0 (ternary)>
    // Expect edge: <void 0 (ternary)> -[READS_FROM]-> <0 (ternary)>
    // Expect edge: <{ isUndef, sideEffectRan, result }> -[READS_FROM]-> <isUndef>
    // Expect edge: <{ isUndef, sideEffectRan, result }> -[READS_FROM]-> <sideEffectRan>
    // Expect edge: <{ isUndef, sideEffectRan, result }> -[READS_FROM]-> <result>
    void code;
  });

  test('iterators::iter-usage-destructuring', () => {
    const code = "function destructureRange(start, end) {\n  const [first, second, ...rest] = new Range(start, end);\n  return { first, second, rest };\n}\n\n// --- Iterator protocol manual ---";
    // Expect edge: <{ first, second, rest }> -[READS_FROM]-> <first>
    // Expect edge: <{ first, second, rest }> -[READS_FROM]-> <second>
    // Expect edge: <{ first, second, rest }> -[READS_FROM]-> <rest>
    void code;
  });

  test('builtins::builtin-finalization-registry', () => {
    const code = "function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---";
    // Expect edge: <`Cleaned up: ${heldValue}`> -[READS_FROM]-> <heldValue>
    void code;
  });

  test('index::module-namespace-as-value', () => {
    const code = "function useNamespaceAsValue(ns) {\n  const fn = ns[arguments[1]]; // dynamic dispatch through namespace\n  return typeof fn === 'function' ? fn() : undefined;\n}\nconst helperResult = useNamespaceAsValue(allHelpers, 'helperFunction');";
    // Expect edge: <ns[arguments[1]]> -[READS_FROM]-> <ns>
    // Expect edge: <typeof fn === 'function'> -[READS_FROM]-> <typeof fn>
    // Expect edge: <typeof fn === 'function'> -[READS_FROM]-> <'function'>
    // Expect edge: <typeof fn> -[READS_FROM]-> <fn>
    // Expect edge: <fn()> -[CALLS]-> <fn>
    // Expect edge: <useNamespaceAsValue(allHelpers, 'helperFunction')> -[CALLS]-> <useNamespaceAsValue>
    void code;
  });

  test('iterators::iter-generator-iterable', () => {
    const code = "function* rangeGenerator(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\n// --- Custom async iterable ---";
    // Expect edge: <i <= end> -[READS_FROM]-> <i>
    // Expect edge: <i <= end> -[READS_FROM]-> <end>
    void code;
  });

  test('iterators::iter-infinite', () => {
    const code = "function naturals() {\n  let n = 1;\n  return {\n    [Symbol.iterator]() { return this; },\n    next() {\n      return { value: n++, done: false };\n    },\n  };\n}";
    // Expect edge: <n++> -[READS_FROM]-> <n>
    void code;
  });

  test('iterators::iter-async-generator', () => {
    const code = "async function* asyncMap(iterable, fn) {\n  for await (const item of iterable) {\n    yield fn(item);\n  }\n}\n\n// --- Composable iterators ---";
    // Expect edge: <fn(item)> -[CALLS]-> <fn>
    void code;
  });

  test('iterators::iter-take', () => {
    const code = "function take(iterable, count) {\n  const result = [];\n  let i = 0;\n  for (const value of iterable) {\n    if (i++ >= count) break;\n    result.push(value);\n  }\n  return result;\n}\n\n// --- Generator as iterable ---";
    // Expect edge: <i++ >= count> -[READS_FROM]-> <i++>
    // Expect edge: <i++ >= count> -[READS_FROM]-> <count>
    // Expect edge: <result.push(value)> -[CALLS]-> <result.push>
    // Expect edge: <result.push> -[READS_FROM]-> <result>
    void code;
  });

  test('iterators::iter-compose-map', () => {
    const code = "function* mapIter(iterable, fn) {\n  for (const item of iterable) {\n    yield fn(item);\n  }\n}";
    // Expect edge: <fn(item)> -[CALLS]-> <fn>
    void code;
  });

  test('iterators::iter-manual-next', () => {
    const code = "function manualIteration(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  const results = [];\n  let step = iterator.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = iterator.next();\n  }\n  return results;\n}\n\n// --- Iterator with return() ---";
    // Expect edge: <iterable[Symbol.iterator]()> -[CALLS]-> <iterable[Symbol.iterator]>
    // Expect edge: <iterable[Symbol.iterator]> -[READS_FROM]-> <iterable>
    // Expect edge: <iterator.next()> -[READS_FROM]-> <iterator>
    // Expect edge: <!step.done> -[READS_FROM]-> <step.done>
    // Expect edge: <step.done> -[READS_FROM]-> <step>
    // Expect edge: <results.push(step.value)> -[READS_FROM]-> <results>
    // Expect edge: <step.value> -[READS_FROM]-> <step>
    // Expect edge: <step = iterator.next()> -[READS_FROM]-> <iterator.next()#2>
    // Expect edge: <iterator.next()#2> -[READS_FROM]-> <iterator>
    void code;
  });

  test('iterators::iter-compose-filter', () => {
    const code = "function* filterIter(iterable, predicate) {\n  for (const item of iterable) {\n    if (predicate(item)) yield item;\n  }\n}";
    // Expect edge: <predicate(item)> -[CALLS]-> <predicate>
    void code;
  });

  test('iterators::iter-async-for-await', () => {
    const code = "async function consumeAsyncRange(start, end) {\n  const values = [];\n  for await (const n of new AsyncRange(start, end, 0)) {\n    values.push(n);\n  }\n  return values;\n}\n\n// --- Async generator as async iterable ---";
    // Expect edge: <values.push(n)> -[CALLS]-> <values.push>
    // Expect edge: <values.push> -[READS_FROM]-> <values>
    void code;
  });

  test('jsdoc-types::jsdoc-type-variable', () => {
    const code = "/** @type {Map<string, Function>} */\nconst handlers = new Map();\n\n/** @type {string | null} */\nlet currentUser = null;\n\n/** @type {readonly number[]} */\nconst PRIMES = [2, 3, 5, 7, 11];";
    // Expect edge: <handlers> -[HAS_TYPE]-> <Map<string, Function>>
    // Expect edge: <currentUser> -[HAS_TYPE]-> <string | null>
    // Expect edge: <PRIMES> -[HAS_TYPE]-> <readonly number[]>
    void code;
  });

  test('jsdoc-types::jsdoc-param-returns', () => {
    const code = "/**\n * @param {string} name\n * @param {number} age\n * @returns {{ name: string, age: number }}\n */\nfunction createUser(name, age) {\n  return { name, age };\n}";
    // Expect edge: <createUser> -[DEPENDS_ON]-> <@param-name>
    // Expect edge: <createUser> -[DEPENDS_ON]-> <@param-age>
    // Expect edge: <createUser> -[DEPENDS_ON]-> <@returns>
    // Expect edge: <@param-name> -[ALIASES]-> <name>
    // Expect edge: <@param-age> -[ALIASES]-> <age>
    // Expect edge: <@returns> -[ALIASES]-> <{ name, age }>
    // Expect edge: <{ name, age }> -[READS_FROM]-> <name>
    // Expect edge: <{ name, age }> -[READS_FROM]-> <age>
    void code;
  });

  test('jsdoc-types::jsdoc-typedef', () => {
    const code = "/**\n * @typedef {Object} UserDef\n * @property {number} id\n * @property {string} name\n * @property {string} [email]\n */\n\n/** @type {UserDef} */\nconst admin = { id: 1, name: 'admin' };";
    // Expect edge: <admin> -[HAS_TYPE]-> <UserDef>
    void code;
  });

  test('jsdoc-types::jsdoc-template-constraint', () => {
    const code = "/**\n * @template {object} T\n * @param {T} target\n * @param {Partial<T>} overrides\n * @returns {T}\n */\nfunction applyDefaults(target, overrides) {\n  return { ...target, ...overrides };\n}";
    // Expect edge: <{ ...target, ...overrides }> -[READS_FROM]-> <target>
    // Expect edge: <{ ...target, ...overrides }> -[READS_FROM]-> <overrides>
    // Expect edge: <target> -[HAS_TYPE]-> <target:T>
    // Expect edge: <overrides> -[HAS_TYPE]-> <overrides:Partial<T>>
    void code;
  });

  test('jsdoc-types::jsdoc-import-type', () => {
    const code = "/** @type {import('./modules-helpers.js').HelperClass} */\nlet helperRef;";
    // Expect edge: <helperRef> -[HAS_TYPE]-> <@type-helperRef>
    // Expect edge: <@type-helperRef> -[RESOLVES_TO]-> <import('./modules-helpers.js').HelperClass>
    // Expect edge: <import('./modules-helpers.js').HelperClass> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('jsdoc-types::jsdoc-deprecated', () => {
    const code = "/**\n * @deprecated Use newProcess() instead\n * @param {string} input\n * @returns {string}\n */\nfunction oldProcess(input) {\n  return input;\n}";
    // Expect edge: <oldProcess:jsdoc> -[DEPENDS_ON]-> <oldProcess>
    // Expect edge: <oldProcess:jsdoc> -[HAS_TYPE]-> <input>
    void code;
  });

  test('jsdoc-types::jsdoc-template', () => {
    const code = "/**\n * @template T\n * @param {T[]} items\n * @returns {T | undefined}\n */\nfunction first(items) {\n  return items[0];\n}\n\n/**\n * @template K, V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} fallback\n * @returns {V}\n */\nfunction getOrDefault(map, key, fallback) {\n  return map.has(key) ? map.get(key) : fallback;\n}";
    // Expect edge: <items> -[HAS_TYPE]-> <T>
    // Expect edge: <items[0]> -[READS_FROM]-> <items>
    // Expect edge: <map> -[HAS_TYPE]-> <K>
    // Expect edge: <map> -[HAS_TYPE]-> <V>
    // Expect edge: <key> -[HAS_TYPE]-> <K>
    // Expect edge: <fallback> -[HAS_TYPE]-> <V>
    // Expect edge: <map.has(key)> -[CALLS_ON]-> <map>
    // Expect edge: <map.get(key)> -[CALLS_ON]-> <map>
    void code;
  });

  test('jsdoc-types::jsdoc-this', () => {
    const code = "/**\n * @this {{ name: string }}\n * @param {string} greeting\n * @returns {string}\n */\nfunction greetThis(greeting) {\n  return `${greeting}, ${this.name}`;\n}";
    // Expect edge: <greetThis> -[HAS_TYPE]-> <@this>
    // Expect edge: <greetThis> -[HAS_TYPE]-> <@param-greeting>
    // Expect edge: <@param-greeting> -[HAS_TYPE]-> <greeting>
    // Expect edge: <template-literal> -[READS_FROM]-> <greeting>
    // Expect edge: <template-literal> -[READS_FROM]-> <this.name>
    void code;
  });

  test('legacy-patterns::amd-require-call', () => {
    const code = "// require(['app/main', 'app/config'], function(main, config) {\n//   main.start(config);\n// });\n\n// --- UMD (Universal Module Definition) ---";
    // Expect edge: <main.start(config)> -[CALLS]-> <main.start>
    // Expect edge: <main.start> -[READS_FROM]-> <main>
    void code;
  });

  test('jsdoc-types::jsdoc-callback', () => {
    const code = "/**\n * @callback Predicate\n * @param {unknown} value\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst isPositive = (value) => typeof value === 'number' && value > 0;";
    // Expect edge: <isPositive> -[HAS_TYPE]-> <Predicate>
    // Expect edge: <typeof value === 'number' && value > 0> -[READS_FROM]-> <typeof value === 'number'>
    // Expect edge: <typeof value === 'number' && value > 0> -[READS_FROM]-> <value > 0>
    // Expect edge: <typeof value === 'number'> -[READS_FROM]-> <typeof value>
    // Expect edge: <typeof value === 'number'> -[READS_FROM]-> <'number'>
    // Expect edge: <typeof value> -[READS_FROM]-> <isPositive:value>
    // Expect edge: <value > 0> -[READS_FROM]-> <isPositive:value>
    // Expect edge: <value > 0> -[READS_FROM]-> <0>
    void code;
  });

  test('legacy-patterns::amd-define-named', () => {
    const code = "// define('myModule', ['dep1', 'dep2'], function(dep1, dep2) {\n//   return { init: function() {} };\n// });";
    // Expect edge: <dep1> -[DERIVES_FROM]-> <'dep1'>
    // Expect edge: <dep2> -[DERIVES_FROM]-> <'dep2'>
    void code;
  });

  test('jsdoc-types::jsdoc-overload', () => {
    const code = "/**\n * @overload\n * @param {string} value\n * @returns {number}\n */\n/**\n * @overload\n * @param {number} value\n * @returns {string}\n */\n/**\n * @param {string | number} value\n * @returns {number | string}\n */\nfunction convert(value) {\n  return typeof value === 'string' ? Number(value) : String(value);\n}";
    // Expect edge: <value> -[HAS_TYPE]-> <string | number>
    // Expect edge: <typeof value === 'string'> -[READS_FROM]-> <value>
    // Expect edge: <Number(value)> -[CALLS]-> <Number>
    // Expect edge: <String(value)> -[CALLS]-> <String>
    void code;
  });

  test('jsdoc-types::jsdoc-implements', () => {
    const code = "/** @implements {Iterable<number>} */\nclass NumberRange {\n  /** @param {number} start @param {number} end */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  [Symbol.iterator]() {\n    let i = this.start;\n    const end = this.end;\n    return { next() { return i <= end ? { value: i++, done: false } : { done: true }; } };\n  }\n}";
    // Expect edge: <NumberRange> -[IMPLEMENTS]-> <Iterable<number>>
    // Expect edge: <i <= end> -[READS_FROM]-> <i>
    // Expect edge: <i <= end> -[READS_FROM]-> <end:local>
    // Expect edge: <i++> -[READS_FROM]-> <i>
    void code;
  });

  test('jsdoc-types::jsdoc-class-fields', () => {
    const code = "class DataStore {\n  /** @type {Map<string, unknown>} */\n  store = new Map();\n\n  /** @private */\n  _cache = {};\n\n  /**\n   * @param {string} key\n   * @param {unknown} value\n   */\n  set(key, value) {\n    this.store.set(key, value);\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this.store.size;\n  }\n}";
    // Expect edge: <new Map()> -[CALLS]-> <Map>
    // Expect edge: <this.store.set(key, value)> -[CALLS_ON]-> <this.store>
    // Expect edge: <this.store> -[READS_FROM]-> <DataStore.store>
    // Expect edge: <this.store.size> -[READS_FROM]-> <this.store>
    void code;
  });

  test('legacy-patterns::global-namespace-init', () => {
    const code = "var MyApp = MyApp || {};\nMyApp.utils = MyApp.utils || {};\nMyApp.utils.format = function (str) { return str.trim(); };";
    // Expect edge: <MyApp || {}> -[READS_FROM]-> <MyApp>
    // Expect edge: <MyApp || {}> -[READS_FROM]-> <{}>
    // Expect edge: <MyApp.utils || {}> -[READS_FROM]-> <MyApp.utils>
    // Expect edge: <MyApp.utils || {}> -[READS_FROM]-> <{} (utils)>
    // Expect edge: <str.trim()> -[CALLS_ON]-> <str>
    void code;
  });

  test('legacy-patterns::amd-define-deps', () => {
    const code = "// define(['jquery', 'underscore'], function($, _) {\n//   return {\n//     render: function(data) {\n//       return _.template($('#tpl').html())(data);\n//     }\n//   };\n// });";
    // Expect edge: <template-invocation> -[CALLS]-> <_.template-call>
    // Expect edge: <_.template-call> -[READS_FROM]-> <_>
    // Expect edge: <$('#tpl').html()> -[CALLS]-> <$>
    // Expect edge: <$> -[IMPORTS_FROM]-> <'jquery'>
    // Expect edge: <_> -[IMPORTS_FROM]-> <'underscore'>
    void code;
  });

  test('legacy-patterns::global-namespace-revealing', () => {
    const code = "var RevealingModule = (function () {\n  var secret = 'hidden';\n  function getSecret() { return secret; }\n  function setSecret(s) { secret = s; }\n  return { get: getSecret, set: setSecret };\n})();\n\n// --- Polyfill Patterns ---";
    // Expect edge: <IIFE-call> -[CALLS]-> <IIFE>
    // Expect edge: <getSecret> -[READS_FROM]-> <secret>
    void code;
  });

  test('legacy-patterns::babel-class-call-check', () => {
    const code = "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}";
    // Expect edge: <!(instance instanceof Constructor)> -[READS_FROM]-> <instance>
    // Expect edge: <!(instance instanceof Constructor)> -[READS_FROM]-> <Constructor>
    void code;
  });

  test('legacy-patterns::global-namespace-iife', () => {
    const code = "var MyApp2 = (function (ns) {\n  var _private = 0;\n  ns.increment = function () { return ++_private; };\n  ns.getValue = function () { return _private; };\n  return ns;\n}(MyApp2 || {}));";
    // Expect edge: <getValue:fn> -[READS_FROM]-> <_private>
    // Expect edge: <MyApp2 || {}> -[READS_FROM]-> <MyApp2>
    // Expect edge: <MyApp2 || {}> -[READS_FROM]-> <{}>
    void code;
  });

  test('legacy-patterns::babel-class-compiled', () => {
    const code = "// Source: class Dog extends Animal { constructor(name) { super(name); } }\n// Compiled:\nvar Dog = (function (_Animal) {\n  _inherits(Dog, _Animal);\n  function Dog(name) {\n    _classCallCheck(this, Dog);\n    return _Animal.call(this, name);\n  }\n  return Dog;\n}(Animal));\n\n// --- TypeScript Compiled Output ---";
    // Expect edge: <_inherits(Dog, _Animal)> -[CALLS]-> <_inherits>
    // Expect edge: <_classCallCheck(this, Dog)> -[CALLS]-> <_classCallCheck>
    // Expect edge: <_Animal.call(this, name)> -[CALLS]-> <_Animal>
    // Expect edge: <Dog:iife> -[READS_FROM]-> <Animal>
    void code;
  });

  test('legacy-patterns::babel-inherits', () => {
    const code = "function _inherits(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true }\n  });\n  if (superClass) Object.setPrototypeOf(subClass, superClass);\n}";
    // Expect edge: <superClass && superClass.prototype> -[READS_FROM]-> <superClass>
    // Expect edge: <superClass && superClass.prototype> -[READS_FROM]-> <superClass.prototype>
    // Expect edge: <superClass.prototype> -[READS_FROM]-> <superClass>
    // Expect edge: <constructor-descriptor> -[READS_FROM]-> <subClass>
    void code;
  });

  test('legacy-patterns::polyfill-promise', () => {
    const code = "if (typeof Promise === 'undefined') {\n  // Simplified polyfill shape — real ones are 200+ lines\n  function Promise(executor) {\n    this._state = 'pending';\n    this._value = undefined;\n    this._callbacks = [];\n    executor(this._resolve.bind(this), this._reject.bind(this));\n  }\n  Promise.prototype.then = function (onFulfilled, onRejected) { /* ... */ };\n  Promise.prototype._resolve = function (value) { /* ... */ };\n  Promise.prototype._reject = function (reason) { /* ... */ };\n}";
    // Expect edge: <typeof Promise === 'undefined'> -[READS_FROM]-> <Promise>
    // Expect edge: <executor(this._resolve.bind(this), this._reject.bind(this))> -[CALLS]-> <executor>
    // Expect edge: <this._resolve.bind(this)> -[READS_FROM]-> <Promise.prototype._resolve>
    // Expect edge: <this._reject.bind(this)> -[READS_FROM]-> <Promise.prototype._reject>
    void code;
  });

  test('legacy-patterns::jquery-extend-pattern', () => {
    const code = "// $.extend(true, target, source1, source2); // deep merge\n// $.extend($.fn, { newPlugin: function() {} }); // add to prototype";
    // Expect edge: <$.extend(true, target, source1, source2)> -[CALLS]-> <$.extend>
    // Expect edge: <$.extend($.fn, { newPlugin: function() {} })> -[CALLS]-> <$.extend>
    void code;
  });

  test('legacy-patterns::polyfill-symbol-shim', () => {
    const code = "if (typeof Symbol === 'undefined') {\n  var Symbol = function (description) {\n    return '__symbol_' + (description || '') + '_' + Math.random().toString(36);\n  };\n  Symbol.iterator = '@@iterator';\n}\n\n// --- Babel Compiled Output ---";
    // Expect edge: <typeof Symbol === 'undefined'> -[READS_FROM]-> <typeof Symbol>
    // Expect edge: <typeof Symbol === 'undefined'> -[READS_FROM]-> <'undefined'>
    // Expect edge: <typeof Symbol> -[READS_FROM]-> <Symbol>
    // Expect edge: <'__symbol_' + (description || '') + '_' + Math.random().toString(36)> -[READS_FROM]-> <'__symbol_'>
    // Expect edge: <'__symbol_' + (description || '') + '_' + Math.random().toString(36)> -[READS_FROM]-> <description || ''>
    // Expect edge: <'__symbol_' + (description || '') + '_' + Math.random().toString(36)> -[READS_FROM]-> <'_'>
    // Expect edge: <'__symbol_' + (description || '') + '_' + Math.random().toString(36)> -[READS_FROM]-> <Math.random().toString(36)>
    // Expect edge: <description || ''> -[READS_FROM]-> <description>
    // Expect edge: <description || ''> -[READS_FROM]-> <''>
    // Expect edge: <Math.random().toString(36)> -[CALLS]-> <Math.random()>
    // Expect edge: <Math.random()> -[CALLS]-> <Math.random>
    void code;
  });

  test('legacy-patterns::polyfill-prototype-method', () => {
    const code = "if (!Array.prototype.flat) {\n  Array.prototype.flat = function (depth) {\n    depth = depth === undefined ? 1 : Math.floor(depth);\n    if (depth < 1) return Array.prototype.slice.call(this);\n    return Array.prototype.reduce.call(this, function (acc, val) {\n      return acc.concat(Array.isArray(val) && depth > 1 ? val.flat(depth - 1) : val);\n    }, []);\n  };\n}";
    // Expect edge: <!Array.prototype.flat> -[READS_FROM]-> <Array.prototype.flat>
    // Expect edge: <recursive-flat> -[CALLS_ON]-> <val>
    void code;
  });

  test('modern-es::modern-array-at', () => {
    const code = "function arrayAt(arr) {\n  const first = arr.at(0);\n  const last = arr.at(-1);\n  const second = arr.at(1);\n  return { first, last, second };\n}";
    // Expect edge: <arr.at(0)> -[READS_FROM]-> <arr>
    // Expect edge: <arr.at(-1)> -[READS_FROM]-> <arr>
    // Expect edge: <arr.at(1)> -[READS_FROM]-> <arr>
    // Expect edge: <{ first, last, second }> -[READS_FROM]-> <first>
    // Expect edge: <{ first, last, second }> -[READS_FROM]-> <last>
    // Expect edge: <{ first, last, second }> -[READS_FROM]-> <second>
    void code;
  });

  test('legacy-patterns::ts-compiled-spread', () => {
    const code = "var __spreadArray = function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};";
    // Expect edge: <from.length> -[READS_FROM]-> <from>
    // Expect edge: <to.length> -[READS_FROM]-> <to>
    // Expect edge: <i < il> -[READS_FROM]-> <i>
    // Expect edge: <i < il> -[READS_FROM]-> <il>
    // Expect edge: <to[j] = from[i]> -[READS_FROM]-> <from[i]>
    // Expect edge: <to[j]> -[READS_FROM]-> <to>
    // Expect edge: <to[j]> -[READS_FROM]-> <j>
    // Expect edge: <from[i]> -[READS_FROM]-> <from>
    // Expect edge: <from[i]> -[READS_FROM]-> <i>
    void code;
  });

  test('legacy-patterns::jquery-plugin-pattern', () => {
    const code = "// $.fn.highlight = function(color) {\n//   return this.each(function() {\n//     $(this).css('background-color', color || 'yellow');\n//   });\n// };\n// Usage: $('p').highlight('red');";
    // Expect edge: <$(this).css(...)> -[CALLS_ON]-> <$(this)>
    // Expect edge: <color || 'yellow'> -[READS_FROM]-> <color>
    // Expect edge: <color || 'yellow'> -[READS_FROM]-> <'yellow'>
    // Expect edge: <$('p').highlight('red')> -[CALLS_ON]-> <$('p')>
    void code;
  });

  test('modern-es::modern-map-groupby', () => {
    const code = "function mapGroupBy(items) {\n  return Map.groupBy(items, item => item.category);\n}\n\n// --- Promise.withResolvers (ES2024) ---";
    // Expect edge: <Map.groupBy(items, item => item.category)> -[CALLS]-> <Map.groupBy>
    // Expect edge: <item.category> -[READS_FROM]-> <item>
    void code;
  });

  test('modern-es::modern-object-hasown', () => {
    const code = "function hasOwnCheck(obj, key) {\n  return Object.hasOwn(obj, key);\n}\n\n// --- structuredClone (ES2022) ---";
    // Expect edge: <Object.hasOwn(obj, key)> -[CALLS]-> <Object.hasOwn>
    // Expect edge: <Object.hasOwn> -[READS_FROM]-> <Object>
    void code;
  });

  test('legacy-patterns::jquery-deferred', () => {
    const code = "// var dfd = $.Deferred();\n// dfd.done(function(data) { ... });\n// dfd.fail(function(err) { ... });\n// dfd.resolve(result); // or dfd.reject(error);\n\n// --- Script Concatenation / Namespace Export ---";
    // Expect edge: <$.Deferred()> -[CALLS]-> <$.Deferred>
    // Expect edge: <$.Deferred> -[READS_FROM]-> <$>
    // Expect edge: <dfd.done(callback)> -[CALLS]-> <dfd.done>
    // Expect edge: <dfd.done> -[READS_FROM]-> <dfd>
    // Expect edge: <dfd.fail(callback)> -[CALLS]-> <dfd.fail>
    // Expect edge: <dfd.fail> -[READS_FROM]-> <dfd>
    // Expect edge: <dfd.resolve(result)> -[CALLS]-> <dfd.resolve>
    // Expect edge: <dfd.resolve> -[READS_FROM]-> <dfd>
    // Expect edge: <dfd.reject(error)> -[CALLS]-> <dfd.reject>
    // Expect edge: <dfd.reject> -[READS_FROM]-> <dfd>
    void code;
  });

  test('modern-es::modern-object-groupby', () => {
    const code = "function objectGroupBy(items) {\n  return Object.groupBy(items, item => item.category);\n}";
    // Expect edge: <Object.groupBy(items, item => item.category)> -[CALLS]-> <Object.groupBy>
    // Expect edge: <item.category> -[READS_FROM]-> <item>
    void code;
  });

  test('modern-es::modern-array-findlast', () => {
    const code = "function arrayFindLast(arr) {\n  const last = arr.findLast(x => x > 3);\n  const lastIdx = arr.findLastIndex(x => x > 3);\n  return { last, lastIdx };\n}";
    // Expect edge: <arr.findLast(x => x > 3)> -[CALLS_ON]-> <arr>
    // Expect edge: <x > 3> -[READS_FROM]-> <x>
    // Expect edge: <x > 3> -[READS_FROM]-> <3>
    // Expect edge: <arr.findLastIndex(x => x > 3)> -[CALLS_ON]-> <arr>
    // Expect edge: <x2 > 3> -[READS_FROM]-> <x2>
    // Expect edge: <x2 > 3> -[READS_FROM]-> <3-2>
    // Expect edge: <{ last, lastIdx }> -[READS_FROM]-> <last>
    // Expect edge: <{ last, lastIdx }> -[READS_FROM]-> <lastIdx>
    void code;
  });

  test('modern-es::modern-structured-clone', () => {
    const code = "function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Hashbang (ES2023) ---\n// Note: hashbang must be at very top of file, so this is just a reference\n// #!/usr/bin/env node — would be first line in a CLI script\n\n// --- RegExp: d flag / match indices (ES2022) ---";
    // Expect edge: <structuredClone(obj)> -[CALLS]-> <structuredClone>
    void code;
  });

  test('modern-es::modern-promise-with-resolvers', () => {
    const code = "function createDeferred() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  return { promise, resolve, reject };\n}\n\n// --- Error.cause usage ---";
    // Expect edge: <Promise.withResolvers()> -[CALLS]-> <Promise.withResolvers>
    // Expect edge: <return-object> -[READS_FROM]-> <promise>
    // Expect edge: <return-object> -[READS_FROM]-> <resolve>
    // Expect edge: <return-object> -[READS_FROM]-> <reject>
    void code;
  });

  test('modern-es::modern-error-cause', () => {
    const code = "function wrapError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    throw new Error('Wrapper failed', { cause: err });\n  }\n}\n\n// --- Object.hasOwn (ES2022) ---";
    // Expect edge: <fn()> -[CALLS]-> <fn>
    // Expect edge: <{ cause: err }> -[READS_FROM]-> <err>
    void code;
  });

  test('modern-es::modern-symbol-species', () => {
    const code = "class SpecialArray extends Array {\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n\n// --- AbortController ---";
    // Expect edge: <SpecialArray> -[EXTENDS]-> <Array>
    // Expect edge: <SpecialArray[Symbol.species]> -[READS_FROM]-> <Array>
    void code;
  });

  test('modern-es::reexport-namespace', () => {
    const code = "// export * as utils from './modules-helpers.js';\n// (commented — would conflict with existing exports; syntax reference only)";
    // Expect edge: <export-namespace> -[DEPENDS_ON]-> <import-all>
    // Expect edge: <import-all> -[IMPORTS_FROM]-> <./modules-helpers.js>
    // Expect edge: <export-namespace> -[ALIASES]-> <utils>
    void code;
  });

  test('modern-es::using-in-for', () => {
    const code = "function usingInFor(readers) {\n  for (using reader of readers) {\n    reader.process();\n  }\n}";
    // Expect edge: <reader.process()> -[CALLS]-> <reader.process>
    // Expect edge: <reader.process> -[READS_FROM]-> <reader>
    void code;
  });

  test('modern-es::modern-symbol-toprimitive', () => {
    const code = "class Money {\n  constructor(amount, currency) {\n    this.amount = amount;\n    this.currency = currency;\n  }\n\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return this.amount;\n    if (hint === 'string') return `${this.amount} ${this.currency}`;\n    return this.amount;\n  }\n}";
    // Expect edge: <hint === 'number'> -[READS_FROM]-> <hint>
    // Expect edge: <hint === 'number'> -[READS_FROM]-> <'number'>
    // Expect edge: <hint === 'string'> -[READS_FROM]-> <hint>
    // Expect edge: <hint === 'string'> -[READS_FROM]-> <'string'>
    // Expect edge: <`${this.amount} ${this.currency}`> -[READS_FROM]-> <this.amount>
    // Expect edge: <`${this.amount} ${this.currency}`> -[READS_FROM]-> <this.currency>
    void code;
  });

  test('modern-es::import-attributes-json', () => {
    const code = "// import config from './config.json' with { type: 'json' };";
    // Expect edge: <import-config> -[IMPORTS]-> <config>
    // Expect edge: <import-config> -[IMPORTS_FROM]-> <./config.json>
    void code;
  });

  test('modern-es::modern-iterator-helpers', () => {
    const code = "function iteratorHelpers(arr) {\n  // Iterator.from, .map, .filter, .take, .drop, .flatMap, .reduce, .toArray, .forEach, .some, .every, .find\n  const iter = arr.values();\n  const mapped = iter.map(x => x * 2);\n  const taken = mapped.take(3);\n  return [...taken];\n}\n\n// --- Set methods (ES2025) ---";
    // Expect edge: <arr.values()> -[CALLS_ON]-> <arr>
    // Expect edge: <iter.map(x => x * 2)> -[CALLS_ON]-> <iter>
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    // Expect edge: <mapped.take(3)> -[CALLS_ON]-> <mapped>
    // Expect edge: <[...taken]> -[READS_FROM]-> <taken>
    void code;
  });

  test('builtins::builtin-regex-named-groups', () => {
    const code = "function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---";
    // Expect edge: <dateStr.match(pattern)> -[READS_FROM]-> <dateStr>
    // Expect edge: <match.groups> -[READS_FROM]-> <match>
    // Expect edge: <{ year, month, day }> -[READS_FROM]-> <year>
    // Expect edge: <{ year, month, day }> -[READS_FROM]-> <month>
    // Expect edge: <{ year, month, day }> -[READS_FROM]-> <day>
    void code;
  });

  test('modern-es::modern-regex-indices', () => {
    const code = "function regexIndices(str) {\n  const regex = /(?<word>\\w+)/gd;\n  const match = regex.exec(str);\n  if (!match) return null;\n  const { indices } = match;\n  return { match: match[0], start: indices[0][0], end: indices[0][1], groups: indices.groups };\n}\n\n// --- Top-level await (ES2022) — already in async-generators.js, reference only ---\n\n// --- Logical assignment already in expressions.js (&&=, ||=, ??=) ---\n\n// --- Private class fields / methods already in classes.js ---\n\n// --- Class static block already in classes.js ---\n\n// --- Symbols: well-known symbols ---";
    // Expect edge: <regex.exec(str)> -[CALLS_ON]-> <regex>
    // Expect edge: <if (!match)> -[READS_FROM]-> <match>
    // Expect edge: <match.indices> -[READS_FROM]-> <match>
    // Expect edge: <match[0]> -[READS_FROM]-> <match>
    // Expect edge: <indices[0][0]> -[READS_FROM]-> <indices>
    // Expect edge: <indices[0][1]> -[READS_FROM]-> <indices>
    // Expect edge: <indices.groups> -[READS_FROM]-> <indices>
    void code;
  });

  test('modern-es::import-attributes-reexport', () => {
    const code = "// export { default as schema } from './schema.json' with { type: 'json' };\n\n// --- import.meta.resolve() (ES2025) ---";
    // Expect edge: <import-schema.json> -[IMPORTS]-> <schema>
    // Expect edge: <import-schema.json> -[IMPORTS_FROM]-> <./schema.json>
    // Expect edge: <export-schema> -[DEPENDS_ON]-> <import-schema.json>
    void code;
  });

  test('modern-es::import-attributes-css', () => {
    const code = "// import styles from './app.css' with { type: 'css' };";
    // Expect edge: <import-styles> -[IMPORTS]-> <styles>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./app.css>
    void code;
  });

  test('modern-es::modern-abort-controller', () => {
    const code = "async function fetchWithAbort(url, timeoutMs) {\n  const controller = new AbortController();\n  const { signal } = controller;\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal });\n    return await response.json();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// --- Disposable resources (ES2025) ---";
    // Expect edge: <new AbortController()> -[CALLS]-> AbortController
    // Expect edge: <controller.signal> -[READS_FROM]-> <controller>
    // Expect edge: <setTimeout(...)> -[CALLS]-> setTimeout
    // Expect edge: <controller.abort()> -[CALLS_ON]-> <controller>
    // Expect edge: <fetch(url, { signal })> -[CALLS]-> fetch
    // Expect edge: <{ signal }> -[READS_FROM]-> <signal>
    // Expect edge: <response.json()> -[CALLS_ON]-> <response>
    // Expect edge: <clearTimeout(timeoutId)> -[CALLS]-> clearTimeout
    void code;
  });

  test('modern-es::using-declaration', () => {
    const code = "function usingDeclaration() {\n  function openFile(path) {\n    return {\n      path,\n      read() { return `contents of ${path}`; },\n      [Symbol.dispose]() { console.log(`closed ${path}`); },\n    };\n  }\n  using handle = openFile('/tmp/test');\n  return handle.read();\n}";
    // Expect edge: <path-property> -[READS_FROM]-> <path>
    // Expect edge: <template-literal> -[READS_FROM]-> <path>
    // Expect edge: <dispose-template> -[READS_FROM]-> <path>
    // Expect edge: <openFile('/tmp/test')> -[CALLS]-> <openFile>
    // Expect edge: <handle.read()> -[READS_FROM]-> <handle>
    // Expect edge: <handle.read()> -[CALLS]-> <read>
    void code;
  });

  test('modern-es::import-attributes-dynamic', () => {
    const code = "// const data = await import('./data.json', { with: { type: 'json' } });";
    // Expect edge: <import('./data.json', { with: { type: 'json' } })> -[IMPORTS_FROM]-> <'./data.json'>
    void code;
  });

  test('modern-es::using-await-declaration', () => {
    const code = "async function usingAwaitDeclaration() {\n  function openStream(url) {\n    return {\n      url,\n      async readAll() { return 'data'; },\n      async [Symbol.asyncDispose]() { console.log(`closed ${url}`); },\n    };\n  }\n  await using stream = await openStream('http://example.com');\n  return stream.readAll();\n}";
    // Expect edge: <openStream('http://example.com')> -[CALLS]-> <openStream>
    // Expect edge: <stream.readAll()> -[READS_FROM]-> <stream>
    // Expect edge: <stream.readAll()> -[CALLS]-> <readAll>
    void code;
  });

  test('modules-helpers::export-as-default', () => {
    const code = "// Alternative syntax for default export:\n// export { someFunction as default };\n// Semantically equivalent to export default, but uses named export syntax";
    // Expect edge: <someFunction> -[ALIASES]-> <default>
    void code;
  });

  test('modules-reexport::reexport-named', () => {
    const code = "export { helperFunction } from './modules-helpers.js';";
    // Expect edge: <export-helperFunction> -[IMPORTS_FROM]-> <./modules-helpers.js>
    // Expect edge: <module> -[DEPENDS_ON]-> <./modules-helpers.js>
    void code;
  });

  test('modules-reexport::reexport-aliased', () => {
    const code = "export { HELPER_CONST as RENAMED_CONST } from './modules-helpers.js';";
    // Expect edge: <module> -[IMPORTS_FROM]-> <./modules-helpers.js>
    // Expect edge: <reexport-aliased> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('modern-es::finalization-registry', () => {
    const code = "const cleanupRegistry = new FinalizationRegistry((key) => {\n  console.log(`Object for key \"${key}\" was garbage collected`);\n});\n\nfunction trackObject(key, obj) {\n  cleanupRegistry.register(obj, key);\n}";
    // Expect edge: <template-literal> -[READS_FROM]-> <key>
    // Expect edge: <cleanupRegistry.register> -[CALLS_ON]-> <cleanupRegistry>
    void code;
  });

  test('modules-reexport::reexport-default-as-named', () => {
    const code = "export { default as defaultFn } from './modules-helpers.js';";
    // Expect edge: <export-default-as-named> -[IMPORTS_FROM]-> <./modules-helpers.js>
    // Expect edge: <defaultFn> -[ALIASES]-> <./modules-helpers.js:default>
    void code;
  });

  test('modules-reexport::reexport-star', () => {
    const code = "export * from './declarations.js';";
    // Expect edge: <export-star> -[IMPORTS_FROM]-> <./declarations.js>
    // Expect edge: <module> -[DEPENDS_ON]-> <./declarations.js>
    void code;
  });

  test('modules-reexport::reexport-namespace', () => {
    const code = "export * as helpers from './modules-helpers.js';\n\n// --- Multi-file module patterns (construct references only) ---";
    // Expect edge: <import-all> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('modern-es::weakref-cache', () => {
    const code = "function createWeakCache() {\n  const cache = new Map();\n  return {\n    get(key, factory) {\n      const ref = cache.get(key);\n      const cached = ref?.deref();\n      if (cached) return cached;\n      const fresh = factory();\n      cache.set(key, new WeakRef(fresh));\n      return fresh;\n    },\n  };\n}";
    // Expect edge: <cache.get(key)> -[READS_FROM]-> <cache>
    // Expect edge: <ref?.deref()> -[READS_FROM]-> <ref>
    // Expect edge: <factory()> -[CALLS]-> <factory>
    void code;
  });

  test('patterns::obj-destructuring-nested', () => {
    const code = "function objectDestructuringNested() {\n  const data = { outer: { inner: { deep: 42 } } };\n  const { outer: { inner: { deep } } } = data;\n  return deep;\n}";
    // Expect edge: <{ outer: { inner: { deep } } }> -[READS_FROM]-> <data>
    void code;
  });

  test('modules-reexport::star-import-namespace', () => {
    const code = "// import * as utils from './modules-helpers.js';\n// utils.helperFunction();          // method on namespace object\n// const { helperFunction } = utils; // destructured from namespace\n// const fn = utils['helperFunction']; // bracket access on namespace";
    // Expect edge: <import-utils> -[IMPORTS]-> <utils>
    // Expect edge: <import-utils> -[IMPORTS_FROM]-> <./modules-helpers.js>
    // Expect edge: <utils.helperFunction()> -[CALLS]-> <utils.helperFunction>
    // Expect edge: <utils.helperFunction> -[READS_FROM]-> <utils>
    // Expect edge: <utils['helperFunction']> -[READS_FROM]-> <utils>
    void code;
  });

  test('patterns::param-destructuring-object', () => {
    const code = "function withObjectParam({ name, age, role = 'guest' }) {\n  return `${name} (${age}) - ${role}`;\n}";
    // Expect edge: <template-literal> -[READS_FROM]-> <name>
    // Expect edge: <template-literal> -[READS_FROM]-> <age>
    // Expect edge: <template-literal> -[READS_FROM]-> <role>
    void code;
  });

  test('patterns::array-destructuring-swap', () => {
    const code = "function arrayDestructuringSwap() {\n  let left = 'left';\n  let right = 'right';\n  [left, right] = [right, left];\n  return { left, right };\n}";
    // Expect edge: <[right, left]> -[READS_FROM]-> <right>
    // Expect edge: <[right, left]> -[READS_FROM]-> <left>
    // Expect edge: <{ left, right }> -[READS_FROM]-> <left>
    // Expect edge: <{ left, right }> -[READS_FROM]-> <right>
    void code;
  });

  test('modules-reexport::circular-import-live-binding', () => {
    const code = "// File A: export let count = 0; export function inc() { count++; }\n// File B: import { count, inc } from './a.js'; inc(); console.log(count); // 1 — live binding!\n// Graph impact: imported let is NOT a copy — mutations in source module visible to importers";
    // Expect edge: <import-a> -[IMPORTS]-> <count:imported>
    // Expect edge: <import-a> -[IMPORTS]-> <inc:imported>
    // Expect edge: <fileB> -[IMPORTS_FROM]-> <fileA>
    // Expect edge: <count:imported> -[ALIASES]-> <count>
    // Expect edge: <inc:imported> -[ALIASES]-> <inc>
    // Expect edge: <inc()> -[CALLS]-> <inc:imported>
    // Expect edge: <console.log(count)> -[READS_FROM]-> <count:imported>
    void code;
  });

  test('patterns::param-destructuring-array', () => {
    const code = "function withArrayParam([first, second, ...rest]) {\n  return { first, second, rest };\n}";
    // Expect edge: <{ first, second, rest }> -[READS_FROM]-> <first>
    // Expect edge: <{ first, second, rest }> -[READS_FROM]-> <second>
    // Expect edge: <{ first, second, rest }> -[READS_FROM]-> <rest>
    void code;
  });

  test('modules-reexport::star-reexport-collision', () => {
    const code = "// a.js: export const x = 1;\n// b.js: export const x = 2;\n// barrel.js: export * from './a'; export * from './b'; // x is ambiguous!\n// Explicit re-export wins: export * from './a'; export { x } from './b';";
    // Expect edge: <star-export-a> -[IMPORTS_FROM]-> <a.js>
    // Expect edge: <star-export-b> -[IMPORTS_FROM]-> <b.js>
    // Expect edge: <explicit-x-export> -[IMPORTS_FROM]-> <b.js>
    void code;
  });

  test('patterns::param-destructuring-nested', () => {
    const code = "function withNestedParam({ user: { name }, settings: { theme = 'light' } }) {\n  return { name, theme };\n}";
    // Expect edge: <{ name, theme }> -[READS_FROM]-> <name>
    // Expect edge: <{ name, theme }> -[READS_FROM]-> <theme>
    void code;
  });

  test('modules-reexport::import-meta-url', () => {
    const code = "// const __filename = new URL(import.meta.url).pathname;\n// const __dirname = new URL('.', import.meta.url).pathname;\n// const workerUrl = new URL('./worker.js', import.meta.url); // implicit file dependency";
    // Expect edge: <new URL(import.meta.url).pathname> -[READS_FROM]-> <new URL(import.meta.url)>
    // Expect edge: <new URL('.', import.meta.url).pathname> -[READS_FROM]-> <new URL('.', import.meta.url)>
    // Expect edge: <./worker.js> -[RESOLVES_TO]-> <'./worker.js'>
    void code;
  });

  test('patterns::spread-calls', () => {
    const code = "function spreadInCalls() {\n  const args = [1, 2, 3];\n  const max = Math.max(...args);\n  return max;\n}";
    // Expect edge: <Math.max(...args)> -[CALLS]-> <Math.max>
    void code;
  });

  test('patterns::destructure-assign-nested-target', () => {
    const code = "function destructureAssignNestedTarget() {\n  const state = { user: { name: 'old' } };\n  let name;\n  ({ user: { name } } = state);\n  return name;\n}";
    // Expect edge: <{ user: { name } } = state> -[READS_FROM]-> <state>
    // Expect edge: <{ user: { name } } = state> -[READS_FROM]-> <state.user.name>
    void code;
  });

  test('patterns::spread-objects', () => {
    const code = "function spreadInObjects() {\n  const base = { a: 1, b: 2 };\n  const extended = { ...base, c: 3, b: 'overridden' };\n  const clone = { ...base };\n  return { extended, clone };\n}";
    // Expect edge: <{ extended, clone }> -[READS_FROM]-> <extended>
    // Expect edge: <{ extended, clone }> -[READS_FROM]-> <clone>
    void code;
  });

  test('patterns::destructure-empty', () => {
    const code = "function destructureEmpty(obj, iter) {\n  const {} = obj;        // valid — no vars, triggers toString/valueOf\n  const [] = iter;       // valid — consumes iterator, creates nothing\n}";
    // Expect edge: <{} = obj> -[READS_FROM]-> <obj>
    // Expect edge: <[] = iter> -[READS_FROM]-> <iter>
    void code;
  });

  test('patterns::destructure-computed-key', () => {
    const code = "function destructureComputedKey() {\n  const key = 'name';\n  const { [key]: value } = { name: 'Alice' };\n  return value;\n}";
    // Expect edge: <{ [key]: value }> -[READS_FROM]-> <key>
    void code;
  });

  test('patterns::destructure-nested-defaults-combined', () => {
    const code = "function destructureNestedDefaults() {\n  const { a: { b = 10 } = {} } = {};\n  return b; // 10 — default for inner AND outer\n}";
    // Expect edge: <return b> -[READS_FROM]-> <b>
    void code;
  });

  test('patterns::destructure-assign-to-properties', () => {
    const code = "function destructureAssignToProperties() {\n  const obj = {};\n  ({ a: obj.x, b: obj.y } = { a: 1, b: 2 });\n  return obj; // { x: 1, y: 2 }\n}";
    // Expect edge: <destructure-assign> -[READS_FROM]-> <{ a: 1, b: 2 }>
    void code;
  });

  test('patterns::spread-duplicate-key-override', () => {
    const code = "function spreadDuplicateKeyOverride(overrides) {\n  // Key 'debug' at positions (1) and (3) with spread between — (3) always wins\n  const config = {\n    debug: false,       // (1) explicit default\n    ...overrides,       // (2) user overrides — may set debug\n    debug: true,        // (3) THIS ALWAYS WINS — overrides the override\n    timestamp: Date.now(),\n  };\n  return config;\n}";
    // Expect edge: <Date.now()> -[CALLS]-> <Date.now>
    void code;
  });

  test('patterns::destructure-computed-default-rename', () => {
    const code = "function destructureComputedDefaultRename() {\n  const key = 'name';\n  const { [key]: renamed = 'anonymous' } = { name: 'Alice' };\n  const { [key]: missing = 'anonymous' } = {};\n  return { renamed, missing };\n}";
    // Expect edge: <destructure1> -[READS_FROM]-> <key>
    // Expect edge: <destructure1> -[READS_FROM]-> <{ name: 'Alice' }>
    // Expect edge: <destructure2> -[READS_FROM]-> <key>
    // Expect edge: <destructure2> -[READS_FROM]-> <{}>
    // Expect edge: <{ renamed, missing }> -[READS_FROM]-> <renamed>
    // Expect edge: <{ renamed, missing }> -[READS_FROM]-> <missing>
    void code;
  });

  test('patterns::destructure-nested-rest', () => {
    const code = "function destructureNestedRest() {\n  const [first, ...[second, ...deep]] = [1, 2, 3, 4, 5];\n  // first=1, second=2, deep=[3,4,5]\n  return { first, second, deep };\n}";
    // Expect edge: <{ first, second, deep }> -[READS_FROM]-> <first>
    // Expect edge: <{ first, second, deep }> -[READS_FROM]-> <second>
    // Expect edge: <{ first, second, deep }> -[READS_FROM]-> <deep>
    void code;
  });

  test('property-access::prop-dot-notation', () => {
    const code = "function dotAccess(obj) {\n  const a = obj.name;\n  const b = obj.nested.deep.value;\n  return { a, b };\n}";
    // Expect edge: <obj.name> -[READS_FROM]-> <obj>
    // Expect edge: <obj.nested> -[READS_FROM]-> <obj>
    // Expect edge: <obj.nested.deep> -[READS_FROM]-> <obj.nested>
    // Expect edge: <obj.nested.deep.value> -[READS_FROM]-> <obj.nested.deep>
    // Expect edge: <{ a, b }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b }> -[READS_FROM]-> <b>
    void code;
  });

  test('property-access::prop-deep-chain', () => {
    const code = "function deepChain(root) {\n  return root.level1.level2.level3.value;\n}";
    // Expect edge: <root.level1> -[READS_FROM]-> <root>
    void code;
  });

  test('property-access::prop-dynamic-access', () => {
    const code = "function dynamicAccess(obj, keys) {\n  const results = {};\n  for (const key of keys) {\n    results[key] = obj[key];\n  }\n  return results;\n}\n\n// --- Property chain ---";
    // Expect edge: <obj[key]> -[READS_FROM]-> <obj>
    void code;
  });

  test('property-access::prop-bracket-notation', () => {
    const code = "function bracketAccess(obj, key) {\n  const a = obj['name'];\n  const b = obj[key];\n  const c = obj['complex-key'];\n  return { a, b, c };\n}";
    // Expect edge: <obj['name']> -[READS_FROM]-> <obj>
    // Expect edge: <obj[key]> -[READS_FROM]-> <obj>
    // Expect edge: <obj['complex-key']> -[READS_FROM]-> <obj>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <b>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <c>
    void code;
  });

  test('property-access::prop-object-from-entries', () => {
    const code = "function fromEntries(entries) {\n  return Object.fromEntries(entries);\n}\n\n// --- Object.assign ---";
    // Expect edge: <Object.fromEntries(entries)> -[CALLS]-> <Object.fromEntries>
    // Expect edge: <Object.fromEntries> -[READS_FROM]-> <Object>
    void code;
  });

  test('property-access::prop-bracket-assign', () => {
    const code = "function bracketAssign(obj, key, value) {\n  obj[key] = value;\n  obj['fixed-key'] = 'fixed';\n  return obj;\n}";
    // Expect edge: <obj[key]> -[READS_FROM]-> <obj>
    // Expect edge: <obj[key]> -[READS_FROM]-> <key>
    // Expect edge: <obj['fixed-key']> -[READS_FROM]-> <obj>
    void code;
  });

  test('patterns::destructure-rest-own-only', () => {
    const code = "function destructureRestOwnOnly() {\n  const proto = { inherited: 1 };\n  const child = Object.create(proto);\n  child.own = 2;\n  child.also = 3;\n\n  const { own, ...rest } = child;\n  // rest === { also: 3 } — inherited NOT included in rest\n  // But:\n  const { inherited } = child; // 1 — named destructuring DOES access prototype\n  return { own, rest, inherited };\n}";
    // Expect edge: <{ own, ...rest }> -[READS_FROM]-> <child>
    // Expect edge: <{ inherited }> -[READS_FROM]-> <child>
    // Expect edge: <{ own, rest, inherited }> -[READS_FROM]-> <own>
    // Expect edge: <{ own, rest, inherited }> -[READS_FROM]-> <rest>
    // Expect edge: <{ own, rest, inherited }> -[READS_FROM]-> <inherited>
    void code;
  });

  test('property-access::prop-object-keys', () => {
    const code = "function objectEnumeration(obj) {\n  const keys = Object.keys(obj);\n  const values = Object.values(obj);\n  const entries = Object.entries(obj);\n  return { keys, values, entries };\n}";
    // Expect edge: <Object.keys(obj)> -[CALLS]-> <Object.keys>
    // Expect edge: <Object.values(obj)> -[CALLS]-> <Object.values>
    // Expect edge: <Object.entries(obj)> -[CALLS]-> <Object.entries>
    // Expect edge: <{ keys, values, entries }> -[READS_FROM]-> <keys>
    // Expect edge: <{ keys, values, entries }> -[READS_FROM]-> <values>
    // Expect edge: <{ keys, values, entries }> -[READS_FROM]-> <entries>
    void code;
  });

  test('property-access::prop-freeze', () => {
    const code = "function frozen() {\n  const obj = { a: 1, b: { c: 2 } };\n  Object.freeze(obj);\n  obj.a = 999;       // silently fails (or throws in strict)\n  obj.b.c = 999;     // succeeds — shallow freeze\n  return obj;\n}";
    // Expect edge: <obj.a> -[READS_FROM]-> <obj>
    // Expect edge: <obj.b.c> -[READS_FROM]-> <obj>
    void code;
  });

  test('property-access::prop-structured-clone', () => {
    const code = "function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Getter/setter side effects ---";
    // Expect edge: <structuredClone(obj)> -[CALLS]-> <structuredClone>
    void code;
  });

  test('property-access::prop-optional-chain-mixed', () => {
    const code = "function optionalChainMixed(obj) {\n  const a = obj?.level1?.level2;\n  const b = obj?.['dynamic-key']?.value;\n  const c = obj?.method?.();\n  const d = obj?.arr?.[0]?.name;\n  return { a, b, c, d };\n}\n\n// --- Property assignment patterns ---";
    // Expect edge: <obj?.level1?.level2> -[READS_FROM]-> <obj>
    // Expect edge: <obj?.['dynamic-key']?.value> -[READS_FROM]-> <obj>
    // Expect edge: <obj?.method?.()> -[READS_FROM]-> <obj>
    // Expect edge: <obj?.arr?.[0]?.name> -[READS_FROM]-> <obj>
    // Expect edge: <{ a, b, c, d }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b, c, d }> -[READS_FROM]-> <b>
    // Expect edge: <{ a, b, c, d }> -[READS_FROM]-> <c>
    // Expect edge: <{ a, b, c, d }> -[READS_FROM]-> <d>
    void code;
  });

  test('property-access::prop-seal', () => {
    const code = "function sealed() {\n  const obj = { a: 1 };\n  Object.seal(obj);\n  obj.a = 2;         // allowed — existing property\n  obj.b = 3;         // silently fails — no new properties\n  delete obj.a;      // silently fails — cannot delete\n  return obj;\n}";
    // Expect edge: <delete obj.a> -[READS_FROM]-> <obj.a>
    void code;
  });

  test('property-access::prop-delete', () => {
    const code = "function propertyDeletion(obj) {\n  const hadKey = 'key' in obj;\n  delete obj.key;\n  const hasKey = 'key' in obj;\n  return { hadKey, hasKey };\n}\n\n// --- Property enumeration order ---";
    // Expect edge: <'key' in obj> -[READS_FROM]-> <'key'>
    // Expect edge: <'key' in obj> -[READS_FROM]-> <obj>
    // Expect edge: <obj.key> -[READS_FROM]-> <obj>
    // Expect edge: <'key' in obj_2> -[READS_FROM]-> <'key'_2>
    // Expect edge: <'key' in obj_2> -[READS_FROM]-> <obj>
    // Expect edge: <{ hadKey, hasKey }> -[READS_FROM]-> <hadKey>
    // Expect edge: <{ hadKey, hasKey }> -[READS_FROM]-> <hasKey>
    void code;
  });

  test('property-access::prop-prevent-extensions', () => {
    const code = "function preventExtensions() {\n  const obj = { a: 1 };\n  Object.preventExtensions(obj);\n  obj.b = 2;         // silently fails\n  obj.a = 99;        // allowed\n  delete obj.a;      // allowed\n  return obj;\n}\n\n// --- Property existence checks ---";
    // Expect edge: <Object.preventExtensions(obj)> -[CALLS]-> <Object.preventExtensions>
    // Expect edge: <delete obj.a> -[READS_FROM]-> <obj.a>
    void code;
  });

  test('property-access::prop-compound-assign', () => {
    const code = "function compoundPropertyAssign(obj) {\n  obj.count += 1;\n  obj.total -= 5;\n  obj.name += ' suffix';\n  obj.flags |= 0x04;\n  obj.mask &= 0xff;\n  return obj;\n}\n\n// --- Object.keys / values / entries ---";
    // Expect edge: <obj.count += 1> -[READS_FROM]-> <obj.count>
    // Expect edge: <obj.count += 1> -[READS_FROM]-> <1>
    // Expect edge: <obj.total -= 5> -[READS_FROM]-> <obj.total>
    // Expect edge: <obj.total -= 5> -[READS_FROM]-> <5>
    // Expect edge: <obj.name += ' suffix'> -[READS_FROM]-> <obj.name>
    // Expect edge: <obj.name += ' suffix'> -[READS_FROM]-> <' suffix'>
    // Expect edge: <obj.flags |= 0x04> -[READS_FROM]-> <obj.flags>
    // Expect edge: <obj.flags |= 0x04> -[READS_FROM]-> <0x04>
    // Expect edge: <obj.mask &= 0xff> -[READS_FROM]-> <obj.mask>
    // Expect edge: <obj.mask &= 0xff> -[READS_FROM]-> <0xff>
    void code;
  });

  test('property-access::prop-circular-object', () => {
    const code = "function circularObject() {\n  const a = {};\n  const b = { ref: a };\n  a.ref = b;\n  return a;\n}";
    // Expect edge: <{ ref: a }> -[READS_FROM]-> <a>
    void code;
  });

  test('property-access::prop-object-assign', () => {
    const code = "function objectAssign() {\n  const target = { a: 1 };\n  const source1 = { b: 2 };\n  const source2 = { c: 3, a: 'overridden' };\n  return Object.assign(target, source1, source2);\n}\n\n// --- Object.freeze / seal / preventExtensions ---";
    // Expect edge: <Object.assign(target, source1, source2)> -[CALLS]-> <Object.assign>
    void code;
  });

  test('property-access::prop-proto-direct', () => {
    const code = "function protoDirectAssign() {\n  const obj = {};\n  obj.__proto__ = { inherited: true };\n  return obj.inherited;\n}\n\n// --- Null-prototype dictionary ---";
    // Expect edge: <protoDirectAssign> -[READS_FROM]-> <obj.inherited>
    void code;
  });

  test('builtins::builtin-globalthis', () => {
    const code = "function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---";
    // Expect edge: <'console' in globalThis> -[READS_FROM]-> <'console'>
    // Expect edge: <'console' in globalThis> -[READS_FROM]-> <globalThis>
    // Expect edge: <{ g, hasConsole }> -[READS_FROM]-> <g>
    // Expect edge: <{ g, hasConsole }> -[READS_FROM]-> <hasConsole>
    void code;
  });

  test('property-access::prop-enumeration-order', () => {
    const code = "function enumerationOrder() {\n  const obj = {};\n  obj.b = 1;\n  obj.a = 2;\n  obj[1] = 3;\n  obj[0] = 4;\n  obj.c = 5;\n  // Integer keys first (sorted), then string keys (insertion order)\n  return Object.keys(obj); // ['0', '1', 'b', 'a', 'c']\n}\n\n// --- Getter/setter via Object.defineProperty ---";
    // Expect edge: <Object.keys(obj)> -[CALLS]-> <Object.keys>
    void code;
  });

  test('property-access::prop-symbol-key', () => {
    const code = "function symbolKey() {\n  const sym = Symbol('myKey');\n  const obj = { [sym]: 'symbol value' };\n  return obj[sym];\n}\n\n// --- __proto__ direct assignment ---";
    // Expect edge: <[sym]> -[READS_FROM]-> <sym>
    // Expect edge: <obj[sym]> -[READS_FROM]-> <obj>
    // Expect edge: <obj[sym]> -[READS_FROM]-> <sym>
    void code;
  });

  test('property-access::prop-define-accessor', () => {
    const code = "function defineAccessor() {\n  const obj = { _value: 0 };\n  Object.defineProperty(obj, 'value', {\n    get() { return this._value; },\n    set(v) { this._value = Math.max(0, v); },\n    enumerable: true,\n  });\n  return obj;\n}\n\n// --- Object.is ---";
    // Expect edge: <Object.defineProperty(obj, 'value', {...})> -[CALLS]-> <Object.defineProperty>
    // Expect edge: <Math.max(0, v)> -[CALLS]-> <Math.max>
    void code;
  });

  test('property-access::prop-object-is', () => {
    const code = "function objectIsComparison() {\n  const a = Object.is(NaN, NaN);       // true (unlike ===)\n  const b = Object.is(0, -0);          // false (unlike ===)\n  const c = Object.is(1, 1);           // true\n  return { a, b, c };\n}\n\n// --- structuredClone ---";
    // Expect edge: <Object.is(NaN, NaN)> -[CALLS]-> <Object.is>
    // Expect edge: <Object.is(0, -0)> -[CALLS]-> <Object.is>
    // Expect edge: <Object.is(1, 1)> -[CALLS]-> <Object.is>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <b>
    // Expect edge: <{ a, b, c }> -[READS_FROM]-> <c>
    void code;
  });

  test('property-access::optional-chaining-delete', () => {
    const code = "function optionalChainingDelete(obj) {\n  const result = delete obj?.prop; // true if obj is nullish (no-op), normal delete otherwise\n  return result;\n}\n\n// --- Getter side effects in destructuring and spread ---";
    // Expect edge: <obj?.prop> -[READS_FROM]-> <obj>
    void code;
  });

  test('property-access::prop-circular-class', () => {
    const code = "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n}\n\n// --- Symbol as property key ---";
    // Expect edge: <this.children.push(child)> -[CALLS]-> <this.children.push>
    // Expect edge: <this.children.push> -[READS_FROM]-> <this.children>
    void code;
  });

  test('property-access::prop-null-proto-dict', () => {
    const code = "function nullPrototypeDict() {\n  const dict = Object.create(null);\n  dict['key with spaces'] = 1;\n  dict['another-key'] = 2;\n  return dict;\n}\n\n// --- Proxy handler traps (full set) ---";
    // Expect edge: <Object.create(null)> -[CALLS]-> <Object.create>
    // Expect edge: <dict['key with spaces']> -[READS_FROM]-> <dict>
    // Expect edge: <dict['another-key']> -[READS_FROM]-> <dict>
    void code;
  });

  test('property-access::prop-getter-only-no-setter', () => {
    const code = "function getterOnlyNoSetter() {\n  const obj = {\n    get value() { return 42; },\n  };\n  obj.value = 99; // silently fails in sloppy, throws in strict\n  return obj.value; // still 42\n}";
    // Expect edge: <obj.value-write> -[READS_FROM]-> <obj>
    // Expect edge: <obj.value-read> -[READS_FROM]-> <obj>
    // Expect edge: <obj.value-read> -[INVOKES]-> <value-getter>
    void code;
  });

  test('property-access::delete-array-hole', () => {
    const code = "function deleteArrayHole(arr) {\n  delete arr[1];                 // creates a HOLE — arr.length unchanged\n  return arr;                    // [1, empty, 3] if arr was [1, 2, 3]\n}";
    // Expect edge: <arr[1]> -[READS_FROM]-> <arr>
    void code;
  });

  test('property-access::prop-getter-side-effect', () => {
    const code = "function getterSideEffect() {\n  let callCount = 0;\n  const obj = {\n    get value() {\n      callCount++;\n      return 42;\n    },\n    set value(v) {\n      console.log('set to', v);\n    },\n  };\n  const x = obj.value;   // triggers getter — side effect\n  obj.value = 10;         // triggers setter — side effect\n  return { x, callCount };\n}\n\n// --- Circular references ---";
    // Expect edge: <obj.value:read> -[READS_FROM]-> <obj>
    // Expect edge: <obj.value:read> -[INVOKES]-> <obj.value:getter>
    // Expect edge: <obj.value:write> -[INVOKES]-> <obj.value:setter>
    void code;
  });

  test('prototypes::proto-static-method', () => {
    const code = "Person.create = function (name, age) {\n  return new Person(name, age);\n};\n\n// --- Prototypal inheritance ---";
    // Expect edge: <new Person(name, age)> -[CALLS]-> <Person>
    void code;
  });

  test('property-access::delete-computed-property', () => {
    const code = "function deleteComputed(obj, key) {\n  delete obj[key];               // computed delete — property name unknown at parse time\n  delete obj[key.toUpperCase()]; // delete with expression in key\n}";
    // Expect edge: <obj[key]> -[READS_FROM]-> <obj>
    // Expect edge: <obj[key]> -[READS_FROM]-> <key>
    // Expect edge: <obj[key.toUpperCase()]> -[READS_FROM]-> <obj>
    // Expect edge: <obj[key.toUpperCase()]> -[READS_FROM]-> <key.toUpperCase()>
    // Expect edge: <key.toUpperCase()> -[CALLS]-> <key.toUpperCase>
    // Expect edge: <key.toUpperCase> -[READS_FROM]-> <key>
    void code;
  });

  test('prototypes::proto-object-create-null', () => {
    const code = "const nullProto = Object.create(null);\nnullProto.key = 'value';\n\n// --- Prototype chain inspection ---";
    // Expect edge: <Object.create(null)> -[CALLS]-> <Object.create>
    void code;
  });

  test('prototypes::proto-constructor-function', () => {
    const code = "function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function () {\n  return `Hi, I'm ${this.name}`;\n};\n\nPerson.prototype.toString = function () {\n  return `Person(${this.name}, ${this.age})`;\n};";
    // Expect edge: <`Hi, I'm ${this.name}`> -[READS_FROM]-> <this.name>
    // Expect edge: <`Person(${this.name}, ${this.age})`> -[READS_FROM]-> <this.name>
    // Expect edge: <`Person(${this.name}, ${this.age})`> -[READS_FROM]-> <this.age>
    void code;
  });

  test('property-access::getter-throws-in-destructuring', () => {
    const code = "function getterThrowsInDestructuring() {\n  const dangerous = {\n    get boom() { throw new Error('trap!'); },\n    safe: 1,\n  };\n  try {\n    const { boom } = dangerous; // throws during destructuring\n  } catch (e) {\n    return e.message;\n  }\n}\n\n// --- Proxy wrapping a class constructor ---";
    // Expect edge: <{ boom } = dangerous> -[READS_FROM]-> <dangerous>
    // Expect edge: <{ boom } = dangerous> -[INVOKES]-> <boom:getter>
    // Expect edge: <e.message> -[READS_FROM]-> <e>
    void code;
  });

  test('property-access::getter-destructuring-side-effect', () => {
    const code = "function getterInDestructuring() {\n  let callCount = 0;\n  const sneaky = {\n    get value() { callCount++; return callCount; },\n  };\n  const { value } = sneaky;        // getter fires — callCount incremented\n  const copy = { ...sneaky };      // spread triggers ALL getters\n  return { value, copy, callCount };\n}";
    // Expect edge: <callCount++> -[READS_FROM]-> <callCount>
    // Expect edge: <{ value }> -[READS_FROM]-> <sneaky>
    // Expect edge: <{ value }> -[INVOKES]-> <sneaky.value>
    // Expect edge: <...sneaky> -[INVOKES]-> <sneaky.value>
    void code;
  });

  test('property-access::prop-proxy-revocable', () => {
    const code = "function proxyRevocable() {\n  const { proxy, revoke } = Proxy.revocable({}, {\n    get(t, prop) { return prop in t ? t[prop] : 'default'; },\n  });\n  proxy.x = 1;\n  const val = proxy.x;\n  revoke();\n  return val;\n}";
    // Expect edge: <prop in t> -[READS_FROM]-> <prop>
    // Expect edge: <prop in t> -[READS_FROM]-> <t>
    // Expect edge: <t[prop]> -[READS_FROM]-> <t>
    // Expect edge: <t[prop]> -[READS_FROM]-> <prop>
    // Expect edge: <proxy.x> -[READS_FROM]-> <proxy>
    // Expect edge: <proxy.x:read> -[READS_FROM]-> <proxy>
    void code;
  });

  test('prototypes::proto-set-prototype', () => {
    const code = "function reparent(obj, newParent) {\n  Object.setPrototypeOf(obj, newParent);\n  return obj;\n}\n\n// --- Mixin pattern ---";
    // Expect edge: <Object.setPrototypeOf(obj, newParent)> -[CALLS]-> <Object.setPrototypeOf>
    void code;
  });

  test('property-access::getter-computed-destructuring', () => {
    const code = "function getterComputedDestructuring() {\n  let fired = false;\n  const obj = {\n    get secret() { fired = true; return 42; },\n  };\n  const key = 'secret';\n  const { [key]: extracted } = obj; // getter via computed key\n  return { extracted, fired };\n}";
    // Expect edge: <obj.secret> -[FLOWS_INTO]-> <true>
    // Expect edge: <destructure-obj> -[READS_FROM]-> <obj>
    // Expect edge: <destructure-obj> -[FLOWS_INTO]-> <extracted>
    // Expect edge: <obj[key]> -[READS_FROM]-> <key>
    // Expect edge: <obj[key]> -[CALLS]-> <obj.secret>
    void code;
  });

  test('prototypes::proto-mixin-applied', () => {
    const code = "function Widget(name) {\n  this.name = name;\n}\napplyMixins(Widget, Serializable, EventEmitterMixin);\n\n// --- Property descriptors ---";
    // Expect edge: <applyMixins(Widget, Serializable, EventEmitterMixin)> -[CALLS]-> <applyMixins>
    // Expect edge: <Widget> -[DEPENDS_ON]-> <Serializable>
    // Expect edge: <Widget> -[DEPENDS_ON]-> <EventEmitterMixin>
    void code;
  });

  test('property-access::proxy-class-constructor', () => {
    const code = "class OriginalClass {\n  constructor(name) { this.name = name; }\n  greet() { return `Hi, ${this.name}`; }\n}\n\nconst TrackedClass = new Proxy(OriginalClass, {\n  construct(target, args, newTarget) {\n    return Reflect.construct(target, args, newTarget);\n  },\n});\n\nconst trackedInstance = new TrackedClass('Alice');\n\n// --- delete on computed properties ---";
    // Expect edge: <`Hi, ${this.name}`> -[READS_FROM]-> <this.name>
    // Expect edge: <new TrackedClass('Alice')> -[CALLS]-> <TrackedClass>
    void code;
  });

  test('prototypes::proto-define-property', () => {
    const code = "function createReadonly(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  });\n  return obj;\n}";
    // Expect edge: <Object.defineProperty(obj, prop, {...})> -[CALLS]-> <Object.defineProperty>
    void code;
  });

  test('prototypes::proto-property-descriptor-read', () => {
    const code = "function getDescriptor(obj, prop) {\n  return Object.getOwnPropertyDescriptor(obj, prop);\n}\n\nfunction getAllDescriptors(obj) {\n  return Object.getOwnPropertyDescriptors(obj);\n}\n\n// --- instanceof with Symbol.hasInstance ---";
    // Expect edge: <Object.getOwnPropertyDescriptor(obj, prop)> -[CALLS]-> <Object.getOwnPropertyDescriptor>
    // Expect edge: <Object.getOwnPropertyDescriptors(obj)> -[CALLS]-> <Object.getOwnPropertyDescriptors>
    void code;
  });

  test('prototypes::proto-object-create', () => {
    const code = "const baseProto = {\n  type: 'base',\n  identify() {\n    return this.type;\n  },\n};\n\nconst derived = Object.create(baseProto);\nderived.type = 'derived';\nderived.extra = function () {\n  return 'extra';\n};";
    // Expect edge: <baseProto.identify> -[READS_FROM]-> <this.type>
    // Expect edge: <derived> -[EXTENDS]-> <baseProto>
    void code;
  });

  test('prototypes::monkey-patch-builtin', () => {
    const code = "Array.prototype.last = function () {\n  return this[this.length - 1];\n};\n[1, 2, 3].last();";
    // Expect edge: <this[this.length - 1]> -[READS_FROM]-> <this.length - 1>
    // Expect edge: <this.length - 1> -[READS_FROM]-> <this.length>
    // Expect edge: <this.length - 1> -[READS_FROM]-> <1>
    // Expect edge: <[1, 2, 3].last()> -[CALLS]-> <last:fn>
    // Expect edge: <[1, 2, 3].last()> -[READS_FROM]-> <[1, 2, 3]>
    void code;
  });

  test('prototypes::proto-inheritance-chain', () => {
    const code = "function Employee(name, age, role) {\n  Person.call(this, name, age);\n  this.role = role;\n}\n\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\nEmployee.prototype.describe = function () {\n  return `${this.greet()}, I'm a ${this.role}`;\n};\n\n// --- Object.create ---";
    // Expect edge: <Employee.prototype> -[EXTENDS]-> <Person.prototype>
    // Expect edge: <template-literal> -[READS_FROM]-> <this.greet()>
    // Expect edge: <template-literal> -[READS_FROM]-> <this.role>
    // Expect edge: <this.greet()> -[CALLS_ON]-> <this>
    void code;
  });

  test('prototypes::proto-symbol-hasinstance', () => {
    const code = "class EvenNumber {\n  static [Symbol.hasInstance](instance) {\n    return typeof instance === 'number' && instance % 2 === 0;\n  }\n}\n\n// --- Monkey-patching ---";
    // Expect edge: <typeof instance === 'number' && instance % 2 === 0> -[READS_FROM]-> <instance>
    // Expect edge: <typeof instance === 'number' && instance % 2 === 0> -[READS_FROM]-> <'number'>
    // Expect edge: <typeof instance === 'number' && instance % 2 === 0> -[READS_FROM]-> <2>
    // Expect edge: <typeof instance === 'number' && instance % 2 === 0> -[READS_FROM]-> <0>
    void code;
  });

  test('prototypes::proto-define-getter-setter', () => {
    const code = "function withComputedProp(obj) {\n  let _internal = 0;\n  Object.defineProperty(obj, 'computed', {\n    get() { return _internal * 2; },\n    set(v) { _internal = v; },\n    enumerable: true,\n    configurable: true,\n  });\n  return obj;\n}";
    // Expect edge: <_internal * 2> -[READS_FROM]-> <_internal>
    // Expect edge: <_internal * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('prototypes::proto-chain-inspection', () => {
    const code = "function inspectPrototype(obj) {\n  const proto = Object.getPrototypeOf(obj);\n  const hasOwn = obj.hasOwnProperty('name');\n  const hasOwn2 = Object.hasOwn(obj, 'name');\n  const inChain = 'toString' in obj;\n  return { proto, hasOwn, hasOwn2, inChain };\n}\n\n// --- Object.setPrototypeOf ---";
    // Expect edge: <Object.getPrototypeOf(obj)> -[CALLS]-> <Object.getPrototypeOf>
    // Expect edge: <obj.hasOwnProperty('name')> -[CALLS]-> <obj.hasOwnProperty>
    // Expect edge: <Object.hasOwn(obj, 'name')> -[CALLS]-> <Object.hasOwn>
    // Expect edge: <'toString' in obj> -[READS_FROM]-> <'toString'>
    // Expect edge: <'toString' in obj> -[READS_FROM]-> <obj>
    // Expect edge: <{ proto, hasOwn, hasOwn2, inChain }> -[READS_FROM]-> <proto>
    // Expect edge: <{ proto, hasOwn, hasOwn2, inChain }> -[READS_FROM]-> <hasOwn>
    // Expect edge: <{ proto, hasOwn, hasOwn2, inChain }> -[READS_FROM]-> <hasOwn2>
    // Expect edge: <{ proto, hasOwn, hasOwn2, inChain }> -[READS_FROM]-> <inChain>
    void code;
  });

  test('prototypes::monkey-patch-third-party', () => {
    const code = "function patchRouter(router) {\n  const originalGet = router.get;\n  router.get = function (path, handler) {\n    console.log(`GET ${path}`);\n    return originalGet.call(this, path, handler);\n  };\n}";
    // Expect edge: <router.get> -[READS_FROM]-> <router>
    // Expect edge: <`GET ${path}`> -[READS_FROM]-> <path>
    // Expect edge: <originalGet.call> -[CALLS]-> <originalGet>
    void code;
  });

  test('prototypes::super-in-object-literal', () => {
    const code = "const parentObj = {\n  greet() { return 'hello from parent'; },\n};\n\nconst childObj = {\n  __proto__: parentObj,\n  greet() {\n    return super.greet() + ' and child';\n  },\n};";
    // Expect edge: <childObj:obj> -[EXTENDS]-> <parentObj:obj>
    // Expect edge: <super.greet()> -[CALLS]-> <parentObj.greet>
    // Expect edge: <super.greet() + ' and child'> -[READS_FROM]-> <super.greet()>
    // Expect edge: <super.greet() + ' and child'> -[READS_FROM]-> <' and child'>
    void code;
  });

  test('runtime-apis::runtime-message-channel', () => {
    const code = "function messageChannelPattern() {\n  const { port1, port2 } = new MessageChannel();\n  port1.onmessage = (e) => console.log(e.data);\n  port2.postMessage('hello');\n}";
    // Expect edge: <new MessageChannel()> -[CALLS]-> <MessageChannel>
    // Expect edge: <console.log(e.data)> -[CALLS]-> <console.log>
    // Expect edge: <e.data> -[READS_FROM]-> <e>
    // Expect edge: <port2.postMessage('hello')> -[CALLS]-> <port2.postMessage>
    void code;
  });

  test('runtime-apis::runtime-atomics-wait-notify', () => {
    const code = "function atomicsSynchronization(view) {\n  // Atomics.wait(view, 0, 0);     // blocks thread (worker only)\n  Atomics.notify(view, 0, 1);      // wake one waiting thread\n  Atomics.waitAsync(view, 0, 0);   // non-blocking, returns Promise\n}\n\n// --- Worker Communication (Plugin: workers) ---";
    // Expect edge: <Atomics.notify(view, 0, 1)> -[CALLS]-> <Atomics.notify>
    // Expect edge: <Atomics.waitAsync(view, 0, 0)> -[CALLS]-> <Atomics.waitAsync>
    void code;
  });

  test('runtime-apis::runtime-transfer-ownership', () => {
    const code = "function transferOwnership(worker) {\n  const buffer = new ArrayBuffer(1024);\n  worker.postMessage(buffer, [buffer]); // buffer neutered in sender\n}\n\n// --- import.meta Extensions (Plugin: node-modules) ---";
    // Expect edge: <worker.postMessage(buffer, [buffer])> -[CALLS]-> <worker.postMessage>
    // Expect edge: <worker.postMessage> -[READS_FROM]-> <worker>
    void code;
  });

  test('prototypes::proto-define-properties', () => {
    const code = "function defineMultiple(obj) {\n  Object.defineProperties(obj, {\n    x: { value: 10, writable: true, enumerable: true },\n    y: { value: 20, writable: true, enumerable: true },\n    sum: {\n      get() { return this.x + this.y; },\n      enumerable: true,\n    },\n  });\n  return obj;\n}";
    // Expect edge: <this.x + this.y> -[READS_FROM]-> <this.x>
    // Expect edge: <this.x + this.y> -[READS_FROM]-> <this.y>
    void code;
  });

  test('prototypes::method-vs-function-property-super', () => {
    const code = "const superParent = {\n  greet() { return 'parent'; },\n};\n\nconst superChild = {\n  __proto__: superParent,\n\n  // Method shorthand — HAS [[HomeObject]], super works\n  shorthand() {\n    return super.greet(); // 'parent' ✓\n  },\n\n  // Function property — NO [[HomeObject]], super is SyntaxError\n  funcProp: function() {\n    // super.greet(); // Would be SyntaxError: 'super' keyword unexpected here\n    return 'no super access';\n  },\n\n  // Arrow property — NO own [[HomeObject]], inherits from defining scope\n  arrowProp: () => {\n    // super.greet(); // Would use enclosing scope's super, not this object's\n    return 'arrow has no own super';\n  },\n};";
    // Expect edge: <super.greet()> -[CALLS]-> <superParent.greet>
    void code;
  });

  test('runtime-apis::runtime-broadcast-channel', () => {
    const code = "function broadcastChannelPattern() {\n  const bc = new BroadcastChannel('updates');\n  bc.postMessage({ type: 'refresh' });\n  bc.onmessage = (e) => console.log(e.data);\n  bc.close();\n}";
    // Expect edge: <bc.postMessage({ type: 'refresh' })> -[CALLS_ON]-> <bc>
    // Expect edge: <e.data> -[READS_FROM]-> <e>
    // Expect edge: <bc.close()> -[CALLS_ON]-> <bc>
    void code;
  });

  test('statements::if-else', () => {
    const code = "function ifElseStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  } else {\n    return 'non-positive';\n  }\n}";
    // Expect edge: <x > 0> -[READS_FROM]-> <x>
    // Expect edge: <x > 0> -[READS_FROM]-> <0>
    void code;
  });

  test('runtime-apis::runtime-import-meta-resolve', () => {
    const code = "function importMetaExtensions() {\n  const depPath = import.meta.resolve('lodash');\n  const localPath = import.meta.resolve('./utils.js');\n  // Node.js 21+:\n  // const dir = import.meta.dirname;   // replaces __dirname\n  // const file = import.meta.filename; // replaces __filename\n  return { depPath, localPath };\n}\n\n// --- Global Error Sinks (Plugin: error-flow) ---\n// These create implicit edges from ANY uncaught throw/reject to handler.";
    // Expect edge: <import.meta.resolve('lodash')> -[CALLS]-> <import.meta.resolve>
    // Expect edge: <import.meta.resolve('./utils.js')> -[CALLS]-> <import.meta.resolve2>
    // Expect edge: <{ depPath, localPath }> -[READS_FROM]-> <depPath>
    // Expect edge: <{ depPath, localPath }> -[READS_FROM]-> <localPath>
    void code;
  });

  test('builtins::string-raw-template', () => {
    const code = "const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file' — no escape processing";
    // Expect edge: <String.raw`C:\Users\name\file`> -[CALLS]-> <String.raw>
    // Expect edge: <String.raw> -[READS_FROM]-> <String>
    void code;
  });

  test('statements::if-basic', () => {
    const code = "function ifStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  }\n  return 'non-positive';\n}";
    // Expect edge: <x > 0> -[READS_FROM]-> <x>
    // Expect edge: <x > 0> -[READS_FROM]-> <0>
    void code;
  });

  test('runtime-apis::runtime-promise-try', () => {
    const code = "// const result = await Promise.try(() => {\n//   if (cached) return cachedValue;    // sync return → wrapped in Promise\n//   return fetchFromNetwork();          // async return\n// });";
    // Expect edge: <Promise.try:callback> -[READS_FROM]-> <cached>
    // Expect edge: <Promise.try:callback> -[READS_FROM]-> <cachedValue>
    // Expect edge: <fetchFromNetwork()> -[CALLS]-> fetchFromNetwork
    void code;
  });

  test('statements::for-in', () => {
    const code = "function forIn(obj) {\n  const keys = [];\n  for (const key in obj) {\n    keys.push(key);\n  }\n  return keys;\n}";
    // Expect edge: <keys.push(key)> -[CALLS_ON]-> <keys>
    void code;
  });

  test('runtime-apis::runtime-worker-postmessage', () => {
    const code = "function workerCommunication() {\n  const worker = new Worker('./task.js');\n  worker.postMessage({ type: 'start', payload: 'data' });\n  worker.onmessage = (e) => console.log(e.data);\n  worker.onerror = (err) => console.error(err);\n  worker.terminate();\n}";
    // Expect edge: <e.data> -[READS_FROM]-> <e>
    void code;
  });

  test('statements::do-while', () => {
    const code = "function doWhileLoop() {\n  let attempts = 0;\n  do {\n    attempts++;\n  } while (attempts < 3);\n  return attempts;\n}";
    // Expect edge: <attempts < 3> -[READS_FROM]-> <attempts>
    // Expect edge: <attempts < 3> -[READS_FROM]-> <3>
    void code;
  });

  test('statements::while', () => {
    const code = "function whileLoop() {\n  let count = 0;\n  while (count < 5) {\n    count++;\n  }\n  return count;\n}";
    // Expect edge: <count < 5> -[READS_FROM]-> <count>
    // Expect edge: <count < 5> -[READS_FROM]-> <5>
    void code;
  });

  test('statements::for-classic', () => {
    const code = "function classicFor() {\n  const results = [];\n  for (let i = 0; i < 10; i++) {\n    results.push(i);\n  }\n  return results;\n}";
    // Expect edge: <i < 10> -[READS_FROM]-> <i>
    // Expect edge: <i < 10> -[READS_FROM]-> <10>
    // Expect edge: <results.push(i)> -[CALLS]-> <results.push>
    // Expect edge: <results.push> -[READS_FROM]-> <results>
    void code;
  });

  test('statements::for-of', () => {
    const code = "function forOf(iterable) {\n  const values = [];\n  for (const item of iterable) {\n    values.push(item);\n  }\n  return values;\n}";
    // Expect edge: <values.push(item)> -[CALLS]-> <values.push>
    // Expect edge: <values.push> -[READS_FROM]-> <values>
    void code;
  });

  test('statements::if-else-if-chain', () => {
    const code = "function ifElseIfChain(x) {\n  if (x > 0) {\n    return 'positive';\n  } else if (x < 0) {\n    return 'negative';\n  } else {\n    return 'zero';\n  }\n}";
    // Expect edge: <x > 0> -[READS_FROM]-> <x>
    // Expect edge: <x > 0> -[READS_FROM]-> <0-first>
    // Expect edge: <x < 0> -[READS_FROM]-> <x>
    // Expect edge: <x < 0> -[READS_FROM]-> <0-second>
    void code;
  });

  test('runtime-apis::runtime-promise-withresolvers-deferred', () => {
    const code = "function deferredPromise() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  // resolve/reject passed to different scopes as callbacks\n  setTimeout(() => reject(new Error('timeout')), 5000);\n  return { promise, resolve, reject };\n}";
    // Expect edge: <Promise.withResolvers()> -[FLOWS_INTO]-> <promise>
    // Expect edge: <Promise.withResolvers()> -[FLOWS_INTO]-> <resolve>
    // Expect edge: <Promise.withResolvers()> -[FLOWS_INTO]-> <reject>
    // Expect edge: <return-object> -[READS_FROM]-> <promise>
    // Expect edge: <return-object> -[READS_FROM]-> <resolve>
    // Expect edge: <return-object> -[READS_FROM]-> <reject>
    void code;
  });

  test('statements::for-of-destructuring', () => {
    const code = "function forOfDestructuring(entries) {\n  const result = {};\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}";
    // Expect edge: <result[key] = value> -[READS_FROM]-> <value>
    // Expect edge: <result[key]> -[READS_FROM]-> <result>
    // Expect edge: <result[key]> -[READS_FROM]-> <key>
    void code;
  });

  test('statements::try-finally', () => {
    const code = "function tryFinally() {\n  try {\n    doSomething();\n  } finally {\n    alwaysRun();\n  }\n}";
    // Expect edge: <try-block> -[FLOWS_INTO]-> <finally-block>
    // Expect edge: <doSomething()> -[CALLS]-> <doSomething>
    // Expect edge: <alwaysRun()> -[CALLS]-> <alwaysRun>
    void code;
  });

  test('statements::switch-return-fallthrough', () => {
    const code = "function switchWithReturn(action) {\n  switch (action) {\n    case 'start':\n      return 'starting';\n    case 'stop':\n      return 'stopping';\n    case 'pause':\n    case 'suspend':\n      return 'pausing';\n    default:\n      return 'unknown';\n  }\n}";
    // Expect edge: <case-pause> -[FLOWS_INTO]-> <case-suspend>
    void code;
  });

  test('statements::try-catch', () => {
    const code = "function tryCatch() {\n  try {\n    JSON.parse('invalid');\n  } catch (error) {\n    console.error(error.message);\n  }\n}";
    // Expect edge: <JSON.parse('invalid')> -[CALLS]-> <JSON.parse>
    // Expect edge: <console.error(error.message)> -[CALLS]-> <console.error>
    // Expect edge: <error.message> -[READS_FROM]-> <error>
    void code;
  });

  test('statements::catch-no-binding', () => {
    const code = "function catchWithoutBinding() {\n  try {\n    JSON.parse('{}');\n  } catch {\n    console.error('parse failed');\n  }\n}";
    // Expect edge: <JSON.parse('{}')> -[CALLS]-> <JSON.parse>
    // Expect edge: <console.error('parse failed')> -[CALLS]-> <console.error>
    void code;
  });

  test('statements::labeled-block', () => {
    const code = "function labeledBlock() {\n  block: {\n    if (true) break block;\n    unreachable();\n  }\n}";
    // Expect edge: <unreachable()> -[CALLS]-> <unreachable>
    void code;
  });

  test('statements::empty-statement', () => {
    const code = "function emptyStatements() {\n  ;\n  for (let i = 0; i < 0; i++);\n}";
    // Expect edge: <i < 0> -[READS_FROM]-> <i>
    // Expect edge: <i < 0> -[READS_FROM]-> <0-condition>
    void code;
  });

  test('statements::try-nested', () => {
    const code = "function nestedTryCatch() {\n  try {\n    try {\n      riskyOperation();\n    } catch (innerError) {\n      fallback(innerError);\n    }\n  } catch (outerError) {\n    lastResort(outerError);\n  }\n}";
    // Expect edge: <riskyOperation()> -[CALLS]-> <riskyOperation>
    // Expect edge: <fallback(innerError)> -[CALLS]-> <fallback>
    // Expect edge: <lastResort(outerError)> -[CALLS]-> <lastResort>
    void code;
  });

  test('builtins::array-from-mapfn', () => {
    const code = "function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---";
    // Expect edge: <Array.from({ length: 5 }, (_, i) => i)> -[CALLS]-> <Array.from>
    void code;
  });

  test('statements::for-of-no-declaration', () => {
    const code = "function forOfNoDeclaration(items) {\n  let item;\n  for (item of items) {           // REASSIGNS existing var, not declaration\n    console.log(item);\n  }\n  return item; // last item — outer var mutated\n}";
    // Expect edge: <console.log(item)> -[CALLS]-> <console.log>
    void code;
  });

  test('statements::destructure-catch-clause', () => {
    const code = "function destructureCatchClause() {\n  try {\n    throw { code: 'ENOENT', message: 'not found' };\n  } catch ({ code, message }) {\n    return { code, message };\n  }\n}";
    // Expect edge: <{ code, message }> -[READS_FROM]-> <code>
    // Expect edge: <{ code, message }> -[READS_FROM]-> <message>
    void code;
  });

  test('statements::throw', () => {
    const code = "function throwError(type) {\n  if (type === 'error') {\n    throw new Error('Something went wrong');\n  }\n  if (type === 'custom') {\n    throw { code: 'CUSTOM', message: 'Custom error' };\n  }\n  if (type === 'string') {\n    throw 'simple string error';\n  }\n}";
    // Expect edge: <type === 'error'> -[READS_FROM]-> <type>
    // Expect edge: <type === 'error'> -[READS_FROM]-> <'error'>
    // Expect edge: <type === 'custom'> -[READS_FROM]-> <type>
    // Expect edge: <type === 'custom'> -[READS_FROM]-> <'custom'>
    // Expect edge: <type === 'string'> -[READS_FROM]-> <type>
    // Expect edge: <type === 'string'> -[READS_FROM]-> <'string'>
    void code;
  });

  test('statements::labeled-continue', () => {
    const code = "function labeledContinue() {\n  const results = [];\n  loop: for (let i = 0; i < 5; i++) {\n    if (i === 3) continue loop;\n    results.push(i);\n  }\n  return results;\n}";
    // Expect edge: <i < 5> -[READS_FROM]-> <i>
    // Expect edge: <i < 5> -[READS_FROM]-> <5>
    // Expect edge: <i === 3> -[READS_FROM]-> <i>
    // Expect edge: <i === 3> -[READS_FROM]-> <3>
    // Expect edge: <continue-loop> -[FLOWS_INTO]-> <loop>
    // Expect edge: <results.push(i)> -[CALLS]-> <results.push>
    // Expect edge: <results.push> -[READS_FROM]-> <results>
    void code;
  });

  test('statements::for-in-no-declaration', () => {
    const code = "function forInNoDeclaration(obj) {\n  let key;\n  for (key in obj) {              // REASSIGNS existing var\n    console.log(key);\n  }\n  return key; // last key — outer var mutated\n}";
    // Expect edge: <console.log(key)> -[CALLS]-> <console.log>
    void code;
  });

  test('builtins::sparse-array', () => {
    const code = "function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false — hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}";
    // Expect edge: <sparse.length> -[READS_FROM]-> <sparse>
    // Expect edge: <1 in sparse> -[READS_FROM]-> <1-key>
    // Expect edge: <1 in sparse> -[READS_FROM]-> <sparse>
    // Expect edge: <sparse.map(x => x * 2)> -[CALLS_ON]-> <sparse>
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('statements::switch-true-pattern', () => {
    const code = "function switchTruePattern(x) {\n  switch (true) {\n    case x > 100: return 'high';\n    case x > 50:  return 'medium';\n    case x > 0:   return 'low';\n    default:       return 'none';\n  }\n}";
    // Expect edge: <x > 100> -[READS_FROM]-> <x>
    // Expect edge: <x > 100> -[READS_FROM]-> <100>
    // Expect edge: <x > 50> -[READS_FROM]-> <x>
    // Expect edge: <x > 50> -[READS_FROM]-> <50>
    // Expect edge: <x > 0> -[READS_FROM]-> <x>
    // Expect edge: <x > 0> -[READS_FROM]-> <0>
    void code;
  });

  test('statements::for-of-destructure-assign', () => {
    const code = "function forOfDestructureAssign(pairs) {\n  let a, b;\n  for ([a, b] of pairs) {        // destructuring assignment in for-of head\n    console.log(a, b);\n  }\n  return { a, b }; // last pair values\n}";
    // Expect edge: <console.log(a, b)> -[CALLS]-> <console.log>
    // Expect edge: <{ a, b }> -[READS_FROM]-> <a>
    // Expect edge: <{ a, b }> -[READS_FROM]-> <b>
    void code;
  });

  test('statements::for-of-destructuring-object', () => {
    const code = "function forOfDestructuringObject() {\n  const points = [{ x: 1, y: 2 }, { x: 3, y: 4 }];\n  const results = [];\n  for (const { x, y } of points) {\n    results.push(x + y);\n  }\n  return results;\n}";
    // Expect edge: <results.push(x + y)> -[CALLS_ON]-> <results>
    // Expect edge: <x + y> -[READS_FROM]-> <x>
    // Expect edge: <x + y> -[READS_FROM]-> <y>
    void code;
  });

  test('statements::for-in-destructuring', () => {
    const code = "function forInDestructuring() {\n  const results = [];\n  for (const { length } in { abc: 1, de: 2, f: 3 }) {\n    results.push(length); // 3, 2, 1 — destructures the string KEY, not value\n  }\n  return results;\n}";
    // Expect edge: <results.push(length)> -[CALLS]-> <results.push>
    // Expect edge: <results.push> -[READS_FROM]-> <results>
    void code;
  });

  test('ts-specific::ts-typed-function', () => {
    const code = "function typedFunction(name: string, age: number): string {\n  return `${name} is ${age}`;\n}";
    // Expect edge: <name> -[HAS_TYPE]-> <string>
    // Expect edge: <age> -[HAS_TYPE]-> <number>
    // Expect edge: <${name}> -[READS_FROM]-> <name>
    // Expect edge: <${age}> -[READS_FROM]-> <age>
    void code;
  });

  test('statements::destructure-catch-nested', () => {
    const code = "function destructureCatchNested() {\n  try {\n    throw { errors: [{ code: 'E1', path: '/api' }], status: 500 };\n  } catch ({ errors: [{ code, path }], status }) {\n    return { code, path, status };\n  }\n}";
    // Expect edge: <{ code, path, status }> -[READS_FROM]-> <code>
    // Expect edge: <{ code, path, status }> -[READS_FROM]-> <path>
    // Expect edge: <{ code, path, status }> -[READS_FROM]-> <status>
    void code;
  });

  test('ts-specific::interface-extends', () => {
    const code = "interface Admin extends User, Printable {\n  role: string;\n  permissions: string[];\n}";
    // Expect edge: <Admin> -[EXTENDS]-> <User>
    // Expect edge: <Admin> -[EXTENDS]-> <Printable>
    void code;
  });

  test('ts-specific::ts-typed-arrow', () => {
    const code = "const typedArrow = (x: number): number => x * 2;";
    // Expect edge: <x> -[HAS_TYPE]-> <number:param>
    // Expect edge: <x * 2> -[READS_FROM]-> <x>
    // Expect edge: <x * 2> -[READS_FROM]-> <2>
    void code;
  });

  test('ts-specific::interface-construct-signature', () => {
    const code = "interface Constructor {\n  new (name: string): User;\n}";
    // Expect edge: <name> -[HAS_TYPE]-> <string>
    void code;
  });

  test('ts-specific::type-alias-tuple', () => {
    const code = "type Pair<A, B> = [A, B];";
    // Expect edge: <Pair> -[ALIASES]-> <[A, B]>
    void code;
  });

  test('ts-specific::type-alias-generic', () => {
    const code = "type Nullable<T> = T | null;";
    // Expect edge: <T:ref> -[RESOLVES_TO]-> <T>
    void code;
  });

  test('ts-specific::type-alias-function', () => {
    const code = "type Callback = (error: Error | null, result?: unknown) => void;";
    // Expect edge: <error> -[HAS_TYPE]-> <Error | null>
    // Expect edge: <result> -[HAS_TYPE]-> <unknown>
    void code;
  });

  test('statements::for-comma-update', () => {
    const code = "function forCommaUpdate() {\n  const arr = [1, 2, 3, 4, 5];\n\n  // Two-pointer technique — comma in both init and update\n  for (let lo = 0, hi = arr.length - 1; lo < hi; lo++, hi--) {\n    [arr[lo], arr[hi]] = [arr[hi], arr[lo]]; // swap\n  }\n\n  // Side effect in update clause\n  let processed = 0;\n  for (let i = 0; i < 3; i++, processed++) {\n    // comma separates two update expressions\n  }\n\n  return { arr, processed };\n}";
    // Expect edge: <arr.length - 1> -[READS_FROM]-> <arr>
    // Expect edge: <lo < hi> -[READS_FROM]-> <lo>
    // Expect edge: <lo < hi> -[READS_FROM]-> <hi>
    // Expect edge: <[arr[lo], arr[hi]] = [arr[hi], arr[lo]]> -[READS_FROM]-> <lo>
    // Expect edge: <[arr[lo], arr[hi]] = [arr[hi], arr[lo]]> -[READS_FROM]-> <hi>
    // Expect edge: <i < 3> -[READS_FROM]-> <i>
    // Expect edge: <i < 3> -[READS_FROM]-> <3>
    // Expect edge: <{ arr, processed }> -[READS_FROM]-> <arr>
    // Expect edge: <{ arr, processed }> -[READS_FROM]-> <processed>
    void code;
  });

  test('statements::in-operator-type-guard', () => {
    const code = "function inOperatorTypeGuard(input) {\n  // 'prop' in obj as conditional guard — narrows type inside branch\n  if ('name' in input) {\n    return input.name.toUpperCase(); // safe — guarded by 'in' check\n  }\n\n  // Compound in-check — multiple property guards\n  if ('items' in input && 'count' in input) {\n    return input.items.slice(0, input.count);\n  }\n\n  // Negated in-check\n  if (!('error' in input)) {\n    return input;\n  }\n\n  return null;\n}";
    // Expect edge: <'name' in input> -[READS_FROM]-> <'name'>
    // Expect edge: <'name' in input> -[READS_FROM]-> <input>
    // Expect edge: <input.name.toUpperCase()> -[CALLS]-> <input.name>
    // Expect edge: <input.name> -[READS_FROM]-> <input>
    // Expect edge: <'items' in input && 'count' in input> -[READS_FROM]-> <'items' in input>
    // Expect edge: <'items' in input && 'count' in input> -[READS_FROM]-> <'count' in input>
    // Expect edge: <'items' in input> -[READS_FROM]-> <'items'>
    // Expect edge: <'items' in input> -[READS_FROM]-> <input>
    // Expect edge: <'count' in input> -[READS_FROM]-> <'count'>
    // Expect edge: <'count' in input> -[READS_FROM]-> <input>
    // Expect edge: <input.items.slice(0, input.count)> -[CALLS]-> <input.items>
    // Expect edge: <input.items> -[READS_FROM]-> <input>
    // Expect edge: <input.count> -[READS_FROM]-> <input>
    // Expect edge: <!('error' in input)> -[READS_FROM]-> <'error' in input>
    // Expect edge: <'error' in input> -[READS_FROM]-> <'error'>
    // Expect edge: <'error' in input> -[READS_FROM]-> <input>
    void code;
  });

  test('ts-specific::generic-function', () => {
    const code = "function identity<T>(value: T): T {\n  return value;\n}";
    // Expect edge: <value> -[HAS_TYPE]-> <T:param>
    // Expect edge: <T:param> -[HAS_TYPE]-> <T>
    // Expect edge: <T:return> -[HAS_TYPE]-> <T>
    void code;
  });

  test('ts-specific::generic-function-multi', () => {
    const code = "function merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}";
    // Expect edge: <obj1> -[HAS_TYPE]-> <T>
    // Expect edge: <obj2> -[HAS_TYPE]-> <U>
    void code;
  });

  test('ts-specific::generic-constraint', () => {
    const code = "function getLength<T extends { length: number }>(item: T): number {\n  return item.length;\n}";
    // Expect edge: <item> -[HAS_TYPE]-> <T:param>
    // Expect edge: <item.length> -[READS_FROM]-> <item>
    void code;
  });

  test('ts-specific::generic-default', () => {
    const code = "function createArray<T = string>(length: number, fill: T): T[] {\n  return Array(length).fill(fill);\n}";
    // Expect edge: <fill> -[HAS_TYPE]-> <T>
    // Expect edge: <Array(length)> -[CALLS]-> <Array>
    // Expect edge: <Array(length).fill(fill)> -[CALLS]-> <Array(length)>
    void code;
  });

  test('ts-specific::generic-interface', () => {
    const code = "interface Repository<T> {\n  find(id: string): Promise<T>;\n  save(item: T): Promise<void>;\n  delete(id: string): Promise<boolean>;\n}";
    // Expect edge: <item> -[HAS_TYPE]-> <T>
    void code;
  });

  test('ts-specific::satisfies', () => {
    const code = "const theme = {\n  primary: '#007bff',\n  secondary: '#6c757d',\n} satisfies Record<string, string>;";
    // Expect edge: <{primary: '#007bff', secondary: '#6c757d'}> -[HAS_TYPE]-> <Record<string, string>>
    void code;
  });

  test('ts-specific::type-assertion-as', () => {
    const code = "function typeAssertions(value: unknown) {\n  const asString = value as string;\n  const angleBracket = <number>value;\n  return { asString, angleBracket };\n}";
    // Expect edge: <value as string> -[HAS_TYPE]-> <value>
    // Expect edge: <<number>value> -[HAS_TYPE]-> <value>
    // Expect edge: <{ asString, angleBracket }> -[READS_FROM]-> <asString>
    // Expect edge: <{ asString, angleBracket }> -[READS_FROM]-> <angleBracket>
    void code;
  });

  test('ts-specific::non-null-assertion', () => {
    const code = "function nonNullAssertion(map: Map<string, string>) {\n  const value = map.get('key')!;\n  return value.toUpperCase();\n}";
    // Expect edge: <map.get('key')> -[CALLS]-> <map>
    // Expect edge: <map.get('key')!> -[HAS_TYPE]-> <map.get('key')>
    // Expect edge: <value.toUpperCase()> -[CALLS]-> <value>
    void code;
  });

  test('ts-specific::generic-class', () => {
    const code = "class Container<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n\n  map<U>(fn: (value: T) => U): Container<U> {\n    return new Container(fn(this.value));\n  }\n}";
    // Expect edge: <Container.value> -[HAS_TYPE]-> <T>
    // Expect edge: <constructor.value> -[HAS_TYPE]-> <T>
    // Expect edge: <Container.getValue> -[READS_FROM]-> <this.value>
    // Expect edge: <map.fn> -[HAS_TYPE]-> <T>
    // Expect edge: <new Container(fn(this.value))> -[CALLS]-> <Container>
    // Expect edge: <fn(this.value)> -[CALLS]-> <map.fn>
    // Expect edge: <fn(this.value)> -[READS_FROM]-> <this.value>
    void code;
  });

  test('ts-specific::decorator-class', () => {
    const code = "function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}";
    // Expect edge: <Object.seal(constructor)> -[CALLS]-> <Object.seal>
    // Expect edge: <Object.seal(constructor.prototype)> -[CALLS]-> <Object.seal>
    // Expect edge: <constructor.prototype> -[READS_FROM]-> <constructor>
    void code;
  });

  test('ts-specific::as-const', () => {
    const code = "const config = {\n  api: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n} as const;\n\nconst directions = ['up', 'down', 'left', 'right'] as const;";
    // Expect edge: <config:as-const> -[HAS_TYPE]-> <config:object>
    // Expect edge: <directions:as-const> -[HAS_TYPE]-> <directions:array>
    void code;
  });

  test('ts-specific::decorator-usage', () => {
    const code = "@sealed\nclass DecoratedClass {\n  @log\n  method() {\n    return 42;\n  }\n}";
    // Expect edge: <@sealed> -[CALLS]-> <sealed>
    // Expect edge: <@log> -[CALLS]-> <log>
    void code;
  });

  test('ts-specific::conditional-type', () => {
    const code = "type IsString<T> = T extends string ? true : false;";
    // Expect edge: <T extends string ? true : false> -[EXTENDS]-> <string>
    void code;
  });

  test('ts-specific::decorator-method', () => {
    const code = "function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey}`);\n    return original.apply(this, args);\n  };\n}";
    // Expect edge: <descriptor.value> -[READS_FROM]-> <descriptor>
    // Expect edge: <template-literal> -[READS_FROM]-> <propertyKey>
    // Expect edge: <original.apply> -[CALLS]-> <original>
    void code;
  });

  test('ts-specific::conditional-type-infer', () => {
    const code = "type UnpackPromise<T> = T extends Promise<infer U> ? U : T;";
    // Expect edge: <T extends Promise<infer U>> -[EXTENDS]-> <Promise<infer U>>
    // Expect edge: <Promise<infer U>> -[HAS_TYPE]-> <infer U>
    // Expect edge: <U:true-branch> -[READS_FROM]-> <U>
    // Expect edge: <T:false-branch> -[READS_FROM]-> <T>
    void code;
  });

  test('ts-specific::mapped-type-readonly', () => {
    const code = "type ReadonlyAll<T> = { readonly [K in keyof T]: T[K] };";
    // Expect edge: <keyof T> -[READS_FROM]-> <T>
    // Expect edge: <ReadonlyAll:mapped> -[DERIVES_FROM]-> <T[K]>
    // Expect edge: <T[K]> -[READS_FROM]-> <T>
    // Expect edge: <T[K]> -[READS_FROM]-> <K>
    void code;
  });

  test('ts-specific::abstract-class', () => {
    const code = "abstract class Shape {\n  abstract area(): number;\n  abstract perimeter(): number;\n\n  describe(): string {\n    return `Area: ${this.area()}, Perimeter: ${this.perimeter()}`;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(private radius: number) {\n    super();\n  }\n\n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n\n  perimeter(): number {\n    return 2 * Math.PI * this.radius;\n  }\n}";
    // Expect edge: <this.area()> -[CALLS]-> <Shape.area>
    // Expect edge: <this.perimeter()> -[CALLS]-> <Shape.perimeter>
    // Expect edge: <Circle> -[EXTENDS]-> <Shape>
    // Expect edge: <super()> -[CALLS]-> <Shape>
    // Expect edge: <Circle.area> -[IMPLEMENTS]-> <Shape.area>
    // Expect edge: <Math.PI * this.radius ** 2> -[READS_FROM]-> <Math.PI>
    // Expect edge: <Math.PI * this.radius ** 2> -[READS_FROM]-> <this.radius>
    // Expect edge: <this.radius> -[READS_FROM]-> <radius>
    // Expect edge: <Circle.perimeter> -[IMPLEMENTS]-> <Shape.perimeter>
    // Expect edge: <2 * Math.PI * this.radius> -[READS_FROM]-> <2>
    // Expect edge: <2 * Math.PI * this.radius> -[READS_FROM]-> <Math.PI>
    // Expect edge: <2 * Math.PI * this.radius> -[READS_FROM]-> <this.radius>
    void code;
  });

  test('ts-specific::mapped-type-mutable', () => {
    const code = "type Mutable<T> = { -readonly [K in keyof T]: T[K] };";
    // Expect edge: <keyof T> -[READS_FROM]-> <T>
    // Expect edge: <Mutable:mapped> -[DERIVES_FROM]-> <T[K]>
    // Expect edge: <T[K]> -[READS_FROM]-> <T>
    // Expect edge: <T[K]> -[READS_FROM]-> <K>
    void code;
  });

  test('ts-specific::mapped-type-optional', () => {
    const code = "type Optional<T> = { [K in keyof T]?: T[K] };";
    // Expect edge: <keyof T> -[READS_FROM]-> <T>
    // Expect edge: <Optional:mapped> -[DERIVES_FROM]-> <T[K]>
    // Expect edge: <T[K]> -[READS_FROM]-> <T>
    // Expect edge: <T[K]> -[READS_FROM]-> <K>
    void code;
  });

  test('ts-specific::template-literal-type', () => {
    const code = "type EventName = 'click' | 'focus' | 'blur';\ntype OnEvent = `on${Capitalize<EventName>}`;\ntype CSSProperty = `${string}-${string}`;";
    // Expect edge: <Capitalize<EventName>> -[DERIVES_FROM]-> <EventName>
    void code;
  });

  test('ts-specific::union-intersection', () => {
    const code = "type StringOrNumber = string | number;\ntype ObjA = { a: string };\ntype ObjB = { b: number };\ntype Combined = ObjA & ObjB;";
    // Expect edge: <a: string> -[HAS_TYPE]-> <string>
    // Expect edge: <b: number> -[HAS_TYPE]-> <number>
    void code;
  });

  test('ts-specific::type-guard-is', () => {
    const code = "function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}";
    // Expect edge: <isString> -[HAS_TYPE]-> <value is string>
    // Expect edge: <typeof value === 'string'> -[READS_FROM]-> <typeof value>
    // Expect edge: <typeof value === 'string'> -[READS_FROM]-> <'string'>
    // Expect edge: <typeof value> -[READS_FROM]-> <value>
    // Expect edge: <value is string> -[HAS_TYPE]-> <value>
    void code;
  });

  test('ts-specific::discriminated-union', () => {
    const code = "type Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: Error };";
    // Expect edge: <Result> -[RESOLVES_TO]-> <Result:union>
    // Expect edge: <success-case.success> -[HAS_TYPE]-> <true>
    // Expect edge: <success-case.data> -[HAS_TYPE]-> <T>
    // Expect edge: <error-case.success> -[HAS_TYPE]-> <false>
    // Expect edge: <error-case.error> -[HAS_TYPE]-> <Error>
    void code;
  });

  test('ts-specific::keyof-typeof', () => {
    const code = "type UserKeys = keyof User;\nconst sampleUser = { name: 'Alice', age: 30 };\ntype InferredUser = typeof sampleUser;";
    // Expect edge: <keyof User> -[READS_FROM]-> <User>
    // Expect edge: <typeof sampleUser> -[READS_FROM]-> <sampleUser>
    void code;
  });

  test('ts-specific::index-access-type', () => {
    const code = "type UserName = User['name'];\ntype UserNameOrAge = User['name' | 'age'];";
    // Expect edge: <User['name']> -[READS_FROM]-> <User>
    // Expect edge: <User['name']> -[READS_FROM]-> <'name'>
    // Expect edge: <User['name' | 'age']> -[READS_FROM]-> <User>
    // Expect edge: <User['name' | 'age']> -[READS_FROM]-> <'name' | 'age'>
    void code;
  });

  test('ts-specific::type-guard-assertion', () => {
    const code = "function hasName(obj: unknown): obj is { name: string } {\n  return typeof obj === 'object' && obj !== null && 'name' in obj;\n}";
    // Expect edge: <hasName> -[HAS_TYPE]-> <obj is { name: string }>
    // Expect edge: <typeof obj === 'object'> -[READS_FROM]-> <obj>
    // Expect edge: <typeof obj === 'object'> -[READS_FROM]-> <'object'>
    // Expect edge: <obj !== null> -[READS_FROM]-> <obj>
    // Expect edge: <obj !== null> -[READS_FROM]-> <null>
    // Expect edge: <'name' in obj> -[READS_FROM]-> <'name'>
    // Expect edge: <'name' in obj> -[READS_FROM]-> <obj>
    // Expect edge: <obj is { name: string }> -[HAS_TYPE]-> <obj>
    void code;
  });

  test('ts-specific::function-overloads', () => {
    const code = "function processInput(input: string): string;\nfunction processInput(input: number): number;\nfunction processInput(input: string | number): string | number {\n  return input;\n}";
    // Expect edge: <processInput> -[IMPLEMENTS_OVERLOAD]-> <processInput:overload1>
    // Expect edge: <processInput> -[IMPLEMENTS_OVERLOAD]-> <processInput:overload2>
    void code;
  });

  test('ts-specific::tuple-types', () => {
    const code = "type Point2D = [number, number];\ntype Point3D = [number, number, number];\ntype NamedTuple = [name: string, age: number];\ntype RestTuple = [string, ...number[]];";
    // Expect edge: <name> -[HAS_TYPE]-> <string:named>
    // Expect edge: <age> -[HAS_TYPE]-> <number:named>
    void code;
  });

  test('ts-specific::ts-declare-function', () => {
    const code = "declare function require(id: string): any;";
    // Expect edge: <id> -[HAS_TYPE]-> <string>
    void code;
  });

  test('ts-specific::class-implements', () => {
    const code = "class UserImpl implements User, Printable {\n  constructor(\n    public name: string,\n    public age: number,\n    public readonly id: number,\n  ) {}\n\n  print(): void {\n    console.log(this.name);\n  }\n}";
    // Expect edge: <UserImpl> -[IMPLEMENTS]-> <User>
    // Expect edge: <UserImpl> -[IMPLEMENTS]-> <Printable>
    // Expect edge: <console.log(this.name)> -[CALLS]-> <console.log>
    // Expect edge: <this.name> -[READS_FROM]-> <name>
    void code;
  });

  test('ts-specific::ts-declare-module', () => {
    const code = "declare module '*.css' {\n  const content: Record<string, string>;\n  export default content;\n}";
    // Expect edge: <content> -[HAS_TYPE]-> <Record<string, string>>
    void code;
  });

  test('ts-specific::ts-declare-namespace', () => {
    const code = "declare namespace NodeJS {\n  interface ProcessEnv {\n    NODE_ENV: 'development' | 'production';\n  }\n}";
    // Expect edge: <NODE_ENV> -[HAS_TYPE]-> <'development' | 'production'>
    void code;
  });

  test('ts-specific::ts-override', () => {
    const code = "class BaseWithMethod {\n  greet() { return 'hello'; }\n}\nclass DerivedWithOverride extends BaseWithMethod {\n  override greet() { return 'hi'; }\n}";
    // Expect edge: <DerivedWithOverride> -[EXTENDS]-> <BaseWithMethod>
    // Expect edge: <DerivedWithOverride.greet> -[OVERRIDES]-> <BaseWithMethod.greet>
    void code;
  });

  test('ts-specific::utility-types', () => {
    const code = "type PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype PickedUser = Pick<User, 'name' | 'age'>;\ntype OmittedUser = Omit<User, 'email'>;\ntype UserRecord = Record<string, User>;\ntype ExtractedType = Extract<string | number | boolean, string | boolean>;\ntype ExcludedType = Exclude<string | number | boolean, boolean>;";
    // Expect edge: <Partial<User>> -[DERIVES_FROM]-> <User>
    // Expect edge: <Required<User>> -[DERIVES_FROM]-> <User>
    // Expect edge: <Pick<User, 'name' | 'age'>> -[DERIVES_FROM]-> <User>
    // Expect edge: <Pick<User, 'name' | 'age'>> -[READS_FROM]-> <'name'>
    // Expect edge: <Pick<User, 'name' | 'age'>> -[READS_FROM]-> <'age'>
    // Expect edge: <Omit<User, 'email'>> -[DERIVES_FROM]-> <User>
    // Expect edge: <Record<string, User>> -[DERIVES_FROM]-> <User>
    // Expect edge: <Extract<string | number | boolean, string | boolean>> -[READS_FROM]-> <string | number | boolean>
    void code;
  });

  test('ts-specific::ts-module-augmentation', () => {
    const code = "declare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}";
    // Expect edge: <user> -[HAS_TYPE]-> <user-type>
    // Expect edge: <express-augmentation> -[MERGES_WITH]-> express
    void code;
  });

  test('ts-specific::ts-recursive-type', () => {
    const code = "type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };";
    // Expect edge: <[key: string]: JSONValue> -[HAS_TYPE]-> <string>
    // Expect edge: <[key: string]: JSONValue> -[HAS_TYPE]-> <JSONValue>
    // Expect edge: <JSONValue> -[ALIASES]-> <JSONValue>
    void code;
  });

  test('ts-specific::ts-const-type-param', () => {
    const code = "function literal<const T>(value: T): T {\n  return value;\n}\nconst literalResult = literal({ x: 1, y: [2, 3] } as const);";
    // Expect edge: <value> -[HAS_TYPE]-> <T>
    // Expect edge: <literal({ x: 1, y: [2, 3] } as const)> -[CALLS]-> <literal>
    void code;
  });

  test('ts-specific::ts-variance-in-out', () => {
    const code = "interface Producer<out T> {\n  produce(): T;\n}\ninterface Consumer<in T> {\n  consume(value: T): void;\n}\ninterface Transformer<in T, out U> {\n  transform(input: T): U;\n}";
    // Expect edge: <Consumer.consume.value> -[HAS_TYPE]-> <Consumer.T>
    // Expect edge: <Transformer.transform.input> -[HAS_TYPE]-> <Transformer.T>
    void code;
  });

  test('ts-specific::ts-asserts-guard', () => {
    const code = "function assertDefined<T>(val: T | undefined): asserts val is T {\n  if (val === undefined) throw new Error('undefined');\n}";
    // Expect edge: <val> -[HAS_TYPE]-> <T | undefined>
    // Expect edge: <asserts val is T> -[HAS_TYPE]-> <val>
    // Expect edge: <asserts val is T> -[HAS_TYPE]-> <T>
    // Expect edge: <val === undefined> -[READS_FROM]-> <val>
    // Expect edge: <val === undefined> -[READS_FROM]-> <undefined>
    // Expect edge: <new Error('undefined')> -[CALLS]-> <Error>
    void code;
  });

  test('ts-specific::ts-recursive-type-tree', () => {
    const code = "type TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};";
    // Expect edge: <TreeNode> -[RESOLVES_TO]-> <TreeNode:objectType>
    // Expect edge: <value> -[HAS_TYPE]-> <T>
    // Expect edge: <children> -[HAS_TYPE]-> <TreeNode<T>[]>
    // Expect edge: <TreeNode<T>:ref> -[HAS_TYPE]-> <TreeNode>
    // Expect edge: <TreeNode<T>:ref> -[HAS_TYPE]-> <T>
    void code;
  });

  test('ts-specific::ts-noinfer', () => {
    const code = "function createFSM<S extends string>(config: {\n  initial: NoInfer<S>;\n  states: Record<S, object>;\n}) {\n  return config;\n}";
    // Expect edge: <S> -[EXTENDS]-> string
    // Expect edge: <config> -[HAS_TYPE]-> <config:type>
    // Expect edge: <initial> -[HAS_TYPE]-> <NoInfer<S>>
    // Expect edge: <states> -[HAS_TYPE]-> <Record<S, object>>
    // Expect edge: <Record<S, object>> -[HAS_TYPE]-> <S>
    void code;
  });

  test('ts-specific::ts-template-literal-infer', () => {
    const code = "type ParseRoute<T extends string> =\n  T extends `/${infer Segment}/${infer Rest}`\n    ? [Segment, ...ParseRoute<`/${Rest}`>]\n    : T extends `/${infer Segment}`\n      ? [Segment]\n      : [];";
    // Expect edge: <[Segment, ...ParseRoute<`/${Rest}`>]> -[READS_FROM]-> <infer Segment>
    // Expect edge: <ParseRoute<`/${Rest}`>> -[CALLS]-> <ParseRoute>
    // Expect edge: <`/${Rest}`> -[READS_FROM]-> <infer Rest>
    // Expect edge: <[Segment]> -[READS_FROM]-> <infer Segment-2>
    void code;
  });

  test('ts-specific::ts-explicit-this-param', () => {
    const code = "function onActivate(this: { name: string }, greeting: string): string {\n  return `${greeting}, ${this.name}`;\n}";
    // Expect edge: <template-literal> -[READS_FROM]-> <greeting>
    // Expect edge: <template-literal> -[READS_FROM]-> <this.name>
    // Expect edge: <this.name> -[READS_FROM]-> <this>
    void code;
  });

  test('ts-specific::ts-exhaustive-never', () => {
    const code = "type ShapeUnion = { kind: 'circle'; radius: number } | { kind: 'square'; side: number };\n\nfunction shapeArea(shape: ShapeUnion): number {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n    default: {\n      const _exhaustive: never = shape;\n      throw new Error(`Unknown shape: ${_exhaustive}`);\n    }\n  }\n}";
    // Expect edge: <shape> -[HAS_TYPE]-> <ShapeUnion>
    // Expect edge: <switch-shape.kind> -[READS_FROM]-> <shape>
    // Expect edge: <Math.PI * shape.radius ** 2> -[READS_FROM]-> <shape>
    // Expect edge: <shape.side ** 2> -[READS_FROM]-> <shape>
    // Expect edge: <throw new Error> -[READS_FROM]-> <_exhaustive>
    void code;
  });

  test('ts-specific::ts-this-type', () => {
    const code = "class Builder {\n  private builderValue = 0;\n\n  add(n: number): this {\n    this.builderValue += n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.builderValue *= n;\n    return this;\n  }\n}\n\nclass AdvancedBuilder extends Builder {\n  negate(): this {\n    return this;\n  }\n}";
    // Expect edge: <this.builderValue += n> -[READS_FROM]-> <n>
    // Expect edge: <this.builderValue *= n> -[READS_FROM]-> <n2>
    // Expect edge: <AdvancedBuilder> -[EXTENDS]-> <Builder>
    void code;
  });

  test('ts-specific::ts-branded-type', () => {
    const code = "type UserId = string & { readonly __brand: unique symbol };\ntype OrderId = string & { readonly __brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction createOrderId(id: string): OrderId {\n  return id as OrderId;\n}";
    // Expect edge: <__brand> -[HAS_TYPE]-> <unique symbol>
    // Expect edge: <__brand#2> -[HAS_TYPE]-> <unique symbol#2>
    // Expect edge: <id> -[HAS_TYPE]-> <string>
    // Expect edge: <id as UserId> -[HAS_TYPE]-> <id>
    // Expect edge: <id as UserId> -[HAS_TYPE]-> <UserId>
    // Expect edge: <id#2> -[HAS_TYPE]-> <string>
    // Expect edge: <id as OrderId> -[HAS_TYPE]-> <id#2>
    // Expect edge: <id as OrderId> -[HAS_TYPE]-> <OrderId>
    void code;
  });

  test('ts-specific::ts-abstract-construct', () => {
    const code = "type AbstractConstructor<T> = abstract new (...args: any[]) => T;\n\nfunction withMixin<T extends AbstractConstructor<{}>>(Base: T) {\n  abstract class Mixed extends Base {\n    abstract doThing(): void;\n  }\n  return Mixed;\n}";
    // Expect edge: <AbstractConstructor> -[RESOLVES_TO]-> <abstract new (...args: any[]) => T>
    // Expect edge: <Mixed> -[EXTENDS]-> <Base>
    void code;
  });

  test('ts-specific::ts-declaration-merging', () => {
    const code = "class Box { x = 0; }\ninterface Box { y: number; }\n// Box now has both x (from class) and y (from interface)";
    // Expect edge: <Box.y> -[HAS_TYPE]-> <number>
    // Expect edge: <Box> -[MERGES_WITH]-> <Box:interface>
    // Expect edge: <Box:interface> -[MERGES_WITH]-> <Box>
    void code;
  });

  test('ts-specific::ts-const-enum-computed', () => {
    const code = "const enum BitFlags {\n  Read = 1 << 0,\n  Write = 1 << 1,\n  Execute = 1 << 2,\n  ReadWrite = Read | Write,\n}";
    // Expect edge: <1 << 0> -[READS_FROM]-> <1>
    // Expect edge: <1 << 0> -[READS_FROM]-> <0>
    // Expect edge: <1 << 1> -[READS_FROM]-> <1_2>
    // Expect edge: <1 << 1> -[READS_FROM]-> <1_literal>
    // Expect edge: <1 << 2> -[READS_FROM]-> <1_3>
    // Expect edge: <1 << 2> -[READS_FROM]-> <2>
    // Expect edge: <Read | Write> -[READS_FROM]-> <BitFlags.Read>
    // Expect edge: <Read | Write> -[READS_FROM]-> <BitFlags.Write>
    void code;
  });

  test('ts-specific::ts-class-method-overloads', () => {
    const code = "class Parser {\n  parse(input: string): string;\n  parse(input: number): number;\n  parse(input: string | number): string | number {\n    return input;\n  }\n}";
    // Expect edge: <Parser.parse> -[HAS_OVERLOAD]-> <Parser.parse:overload1>
    // Expect edge: <Parser.parse> -[HAS_OVERLOAD]-> <Parser.parse:overload2>
    // Expect edge: <Parser.parse> -[IMPLEMENTS_OVERLOAD]-> <Parser.parse:implementation>
    // Expect edge: <input:overload1> -[HAS_TYPE]-> <string>
    // Expect edge: <input:overload2> -[HAS_TYPE]-> <number>
    // Expect edge: <input:implementation> -[HAS_TYPE]-> <string | number>
    void code;
  });

  test('ts-specific::ts-unique-symbol', () => {
    const code = "declare const uniqueSym: unique symbol;\ntype WithSymKey = { [uniqueSym]: string };";
    // Expect edge: <uniqueSym> -[HAS_TYPE]-> <unique symbol>
    // Expect edge: <WithSymKey:[uniqueSym]> -[READS_FROM]-> <uniqueSym>
    // Expect edge: <WithSymKey:[uniqueSym]> -[HAS_TYPE]-> <string>
    void code;
  });

  test('ts-specific::ts-enum-namespace-merge', () => {
    const code = "enum Color { Red, Green, Blue }\nnamespace Color {\n  export function parse(s: string): Color { return Color[s as keyof typeof Color]; }\n}";
    // Expect edge: <Color[s]> -[READS_FROM]-> <Color>
    // Expect edge: <Color[s]> -[READS_FROM]-> <s as keyof typeof Color>
    // Expect edge: <s as keyof typeof Color> -[DERIVES_FROM]-> <s>
    // Expect edge: <Color:namespace> -[MERGES_WITH]-> <Color>
    void code;
  });

  test('ts-specific::ts-parameter-decorators', () => {
    const code = "// Common in NestJS/Angular — parameter decorators\nfunction Inject(token: string) {\n  return function(target: any, propertyKey: string | symbol, parameterIndex: number) {};\n}\n\nclass AppController {\n  constructor(@Inject('DB') private db: any) {}\n}";
    // Expect edge: <@Inject('DB')> -[CALLS]-> <Inject>
    void code;
  });

  test('ts-specific::ts-constructor-overloads', () => {
    const code = "class Point {\n  x: number;\n  y: number;\n  constructor(x: number, y: number);\n  constructor(coords: [number, number]);\n  constructor(xOrCoords: number | [number, number], y?: number) {\n    if (Array.isArray(xOrCoords)) {\n      this.x = xOrCoords[0];\n      this.y = xOrCoords[1];\n    } else {\n      this.x = xOrCoords;\n      this.y = y!;\n    }\n  }\n}";
    // Expect edge: <Point.constructor> -[IMPLEMENTS_OVERLOAD]-> <Point.constructor:overload1>
    // Expect edge: <Point.constructor> -[IMPLEMENTS_OVERLOAD]-> <Point.constructor:overload2>
    // Expect edge: <Array.isArray(xOrCoords)> -[READS_FROM]-> <xOrCoords>
    // Expect edge: <xOrCoords[0]> -[READS_FROM]-> <xOrCoords>
    // Expect edge: <xOrCoords[1]> -[READS_FROM]-> <xOrCoords>
    // Expect edge: <y!> -[READS_FROM]-> <y>
    void code;
  });

  test('ts-specific::ts-mapped-type-as-clause', () => {
    const code = "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\ntype RemoveKind<T> = {\n  [K in keyof T as Exclude<K, 'kind'>]: T[K]\n};";
    // Expect edge: <Getters:mapped> -[DERIVES_FROM]-> <get${Capitalize<string & K>}>
    // Expect edge: <Getters:mapped> -[DERIVES_FROM]-> <() => T[K]>
    // Expect edge: <get${Capitalize<string & K>}> -[READS_FROM]-> <K>
    // Expect edge: <() => T[K]> -[READS_FROM]-> <T>
    // Expect edge: <() => T[K]> -[READS_FROM]-> <K>
    // Expect edge: <RemoveKind:mapped> -[DERIVES_FROM]-> <Exclude<K, 'kind'>>
    // Expect edge: <RemoveKind:mapped> -[DERIVES_FROM]-> <T2>
    // Expect edge: <Exclude<K, 'kind'>> -[READS_FROM]-> <K2>
    // Expect edge: <Exclude<K, 'kind'>> -[READS_FROM]-> <'kind'>
    void code;
  });

  test('ts-specific::ts-this-type-guard', () => {
    const code = "class FSNode {\n  isFile(): this is FSFileNode { return this instanceof FSFileNode; }\n  isDir(): this is FSDirNode { return this instanceof FSDirNode; }\n}\n\nclass FSFileNode extends FSNode {\n  content: string = '';\n}\n\nclass FSDirNode extends FSNode {\n  children: FSNode[] = [];\n}";
    // Expect edge: <this instanceof FSFileNode> -[READS_FROM]-> <FSFileNode>
    // Expect edge: <this instanceof FSDirNode> -[READS_FROM]-> <FSDirNode>
    // Expect edge: <FSFileNode> -[EXTENDS]-> <FSNode>
    // Expect edge: <FSDirNode> -[EXTENDS]-> <FSNode>
    void code;
  });

  test('ts-specific::ts-distributive-conditional', () => {
    const code = "type ToArray<T> = T extends any ? T[] : never;\ntype DistResult = ToArray<string | number>; // string[] | number[]\n\ntype ToArrayND<T> = [T] extends [any] ? T[] : never;\ntype NonDistResult = ToArrayND<string | number>; // (string | number)[]";
    // Expect edge: <ToArray> -[RESOLVES_TO]-> <T extends any ? T[] : never>
    // Expect edge: <DistResult> -[RESOLVES_TO]-> <ToArray<string | number>>
    // Expect edge: <ToArray<string | number>> -[CALLS]-> <ToArray>
    // Expect edge: <ToArray<string | number>> -[HAS_TYPE]-> <string | number>
    // Expect edge: <ToArrayND> -[RESOLVES_TO]-> <[T] extends [any] ? T[] : never>
    // Expect edge: <NonDistResult> -[RESOLVES_TO]-> <ToArrayND<string | number>>
    // Expect edge: <ToArrayND<string | number>> -[CALLS]-> <ToArrayND>
    // Expect edge: <ToArrayND<string | number>> -[HAS_TYPE]-> <string | number_nd>
    void code;
  });

  test('ts-specific::ts-function-type-intersection', () => {
    const code = "type StringHandler = (input: string) => string;\ntype NumberHandler = (input: number) => number;\ntype BothHandler = StringHandler & NumberHandler;";
    // Expect edge: <StringHandler:input> -[HAS_TYPE]-> <string1>
    // Expect edge: <NumberHandler:input> -[HAS_TYPE]-> <number1>
    void code;
  });

  test('ts-specific::ts-variadic-tuple', () => {
    const code = "type Concat<A extends unknown[], B extends unknown[]> = [...A, ...B];\ntype HeadOf<T extends unknown[]> = T extends [infer H, ...unknown[]] ? H : never;\ntype TailOf<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;\ntype LastOf<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;";
    // Expect edge: <Concat> -[RESOLVES_TO]-> <[...A, ...B]>
    // Expect edge: <HeadOf> -[RESOLVES_TO]-> <T extends [infer H, ...unknown[]] ? H : never>
    // Expect edge: <TailOf> -[RESOLVES_TO]-> <T extends [unknown, ...infer R] ? R : never>
    // Expect edge: <LastOf> -[RESOLVES_TO]-> <T extends [...unknown[], infer L] ? L : never>
    void code;
  });

  test('ts-specific::ts-import-type-inline', () => {
    const code = "// Type-level import() — resolves types without runtime import\ntype InlineImported = import('./modules-helpers.js').default;\n// In function signatures: function handle(req: import('express').Request): void {}\n\n// --- TypeScript using with type annotations ---";
    // Expect edge: <import('./modules-helpers.js').default> -[READS_FROM]-> <import('./modules-helpers.js')>
    // Expect edge: <import('./modules-helpers.js')> -[IMPORTS_FROM]-> <./modules-helpers.js>
    void code;
  });

  test('ts-specific::ts-typeof-class', () => {
    const code = "class ExampleForTypeof {\n  static create() { return new ExampleForTypeof(); }\n  method() { return 1; }\n}\n\ntype ExampleInstance = ExampleForTypeof;            // instance type — has method()\ntype ExampleConstructor = typeof ExampleForTypeof;  // constructor type — has create()\n\nfunction classFactory(Cls: typeof ExampleForTypeof): ExampleForTypeof {\n  return Cls.create();\n}";
    // Expect edge: <new ExampleForTypeof()> -[CALLS]-> <ExampleForTypeof>
    // Expect edge: <ExampleInstance> -[ALIASES]-> <ExampleForTypeof:instance-type>
    // Expect edge: <ExampleForTypeof:instance-type> -[HAS_TYPE]-> <ExampleForTypeof>
    // Expect edge: <ExampleConstructor> -[ALIASES]-> <typeof ExampleForTypeof>
    // Expect edge: <typeof ExampleForTypeof> -[HAS_TYPE]-> <ExampleForTypeof>
    // Expect edge: <Cls> -[HAS_TYPE]-> <typeof ExampleForTypeof:param-type>
    // Expect edge: <typeof ExampleForTypeof:param-type> -[HAS_TYPE]-> <ExampleForTypeof>
    // Expect edge: <ExampleForTypeof:return-type> -[HAS_TYPE]-> <ExampleForTypeof>
    // Expect edge: <Cls.create()> -[CALLS_ON]-> <Cls>
    // Expect edge: <Cls.create()> -[CALLS]-> <ExampleForTypeof.create>
    void code;
  });

  test('ts-specific::ts-enum-reverse-mapping', () => {
    const code = "enum HttpStatus {\n  OK = 200,\n  NotFound = 404,\n  ServerError = 500,\n}\nconst statusName = HttpStatus[200];           // 'OK' — reverse mapping\nconst statusCode = HttpStatus.OK;             // 200 — forward mapping\n// String enums do NOT have reverse mapping";
    // Expect edge: <HttpStatus[200]> -[READS_FROM]-> <HttpStatus>
    // Expect edge: <HttpStatus[200]> -[READS_FROM]-> <200>
    // Expect edge: <HttpStatus.OK> -[READS_FROM]-> <HttpStatus>
    void code;
  });

  test('ts-specific::ts-generic-keyof-constraint', () => {
    const code = "function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nfunction pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {\n  return items.map(item => item[key]);\n}";
    // Expect edge: <keyof T> -[DEPENDS_ON]-> <T>
    // Expect edge: <obj> -[HAS_TYPE]-> <T>
    // Expect edge: <key> -[HAS_TYPE]-> <K>
    // Expect edge: <T[K]> -[DEPENDS_ON]-> <T>
    // Expect edge: <T[K]> -[DEPENDS_ON]-> <K>
    // Expect edge: <obj[key]> -[READS_FROM]-> <obj>
    // Expect edge: <obj[key]> -[READS_FROM]-> <key>
    // Expect edge: <keyof T2> -[DEPENDS_ON]-> <T2>
    // Expect edge: <items> -[HAS_TYPE]-> <T2>
    // Expect edge: <key2> -[HAS_TYPE]-> <K2>
    // Expect edge: <T[K][]> -[DEPENDS_ON]-> <T2>
    // Expect edge: <T[K][]> -[DEPENDS_ON]-> <K2>
    // Expect edge: <items.map(...)> -[CALLS]-> <items>
    // Expect edge: <item[key]> -[READS_FROM]-> <item>
    // Expect edge: <item[key]> -[READS_FROM]-> <key2>
    void code;
  });

  test('ts-specific::ts-import-equals-require', () => {
    const code = "// CJS-style import — emits: const CjsLib = require('./module')\n// import CjsLib = require('./module');\n// const instance = new CjsLib();\n// (commented out: requires actual CJS module; syntax is ExportAssignment / ImportEqualsDeclaration)\n\n// --- Getter and setter with different types (TS 4.3+) ---";
    // Expect edge: <import-equals> -[IMPORTS]-> <CjsLib>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./module>
    // Expect edge: <new CjsLib()> -[CALLS]-> <CjsLib>
    void code;
  });

  test('ts-specific::ts-export-equals', () => {
    const code = "// CJS-style export assignment — emits: module.exports = CjsLibrary\nclass CjsLibrary {\n  static VERSION = '1.0';\n  process(data: string): string { return data.toUpperCase(); }\n}\n// export = CjsLibrary;\n// (commented out: only one module export mode per file; shown for AST coverage)";
    // Expect edge: <data.toUpperCase()> -[CALLS_ON]-> <data>
    void code;
  });

  test('ts-specific::ts-generic-default-prior-ref', () => {
    const code = "function createGenericStore<\n  S extends object,\n  A extends object = {},\n  G extends Record<string, (state: S) => unknown> = {},\n>(config: { state: S; actions?: A; getters?: G }) {\n  return config;\n}\n\nfunction wrapInArray<T, R = T[]>(value: T): R {\n  return [value] as unknown as R;         // R defaults to T[]\n}\n\n// --- infer with constraints (TS 4.7+) ---";
    // Expect edge: <G> -[HAS_TYPE]-> <S>
    // Expect edge: <config> -[HAS_TYPE]-> <S>
    // Expect edge: <config> -[HAS_TYPE]-> <A>
    // Expect edge: <config> -[HAS_TYPE]-> <G>
    // Expect edge: <R> -[HAS_TYPE]-> <T>
    // Expect edge: <value> -[HAS_TYPE]-> <T>
    // Expect edge: <[value] as unknown as R> -[DERIVES_FROM]-> <[value]>
    // Expect edge: <[value]> -[READS_FROM]-> <value>
    // Expect edge: <[value] as unknown as R> -[DERIVES_FROM]-> <R>
    void code;
  });

  test('ts-specific::ts-getter-setter-different-types', () => {
    const code = "class SmartField {\n  #raw: string = '';\n\n  get value(): string {\n    return this.#raw;\n  }\n\n  // Setter accepts wider type than getter returns\n  set value(input: string | number) {\n    this.#raw = String(input);\n  }\n}\n\n// --- Inline type modifier on import/export specifiers (TS 4.5+) ---";
    // Expect edge: <SmartField.value:getter> -[READS_FROM]-> <SmartField.#raw>
    // Expect edge: <String(input)> -[CALLS]-> <String>
    void code;
  });

  test('ts-specific::ts-using-typed', () => {
    const code = "// using with type annotations (TS extension of ES2025 Explicit Resource Management)\n// using handle: FileHandle = openFile('/tmp/data');\n// await using conn: DBConnection = await pool.connect();\n// for (using reader: Reader of getReaders()) { reader.process(); }\n\n// --- satisfies + as const combo ---";
    // Expect edge: <handle> -[HAS_TYPE]-> <FileHandle>
    // Expect edge: <openFile('/tmp/data')> -[CALLS]-> <openFile>
    // Expect edge: <conn> -[HAS_TYPE]-> <DBConnection>
    // Expect edge: <pool.connect()> -[CALLS]-> <pool.connect>
    // Expect edge: <reader> -[HAS_TYPE]-> <Reader>
    // Expect edge: <getReaders()> -[CALLS]-> <getReaders>
    // Expect edge: <reader.process()> -[CALLS]-> <reader.process>
    // Expect edge: <reader.process()> -[READS_FROM]-> <reader>
    void code;
  });

  test('ts-specific::ts-inline-type-modifier', () => {
    const code = "// Mixed value + type in single import:\n// import { Component, type Props, type State } from './ui';\n// Component → runtime import (IMPORTS_FROM edge)\n// Props, State → type-only (erased, NO runtime dependency)\n\n// Mixed value + type in single re-export:\n// export { handler, type HandlerConfig } from './handlers';\n\n// Contrast with import type (entire statement is type-only):\n// import type { OnlyTypes } from './types';\n\n// --- this parameter combined with destructuring ---";
    // Expect edge: <import-ui> -[IMPORTS]-> <Component>
    // Expect edge: <import-ui> -[IMPORTS]-> <Props>
    // Expect edge: <import-ui> -[IMPORTS]-> <State>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./ui>
    // Expect edge: <module> -[IMPORTS_FROM]-> <./handlers>
    // Expect edge: <import-types> -[IMPORTS]-> <OnlyTypes>
    void code;
  });

  test('ts-specific::ts-satisfies-as-const', () => {
    const code = "const routes = {\n  home: '/',\n  about: '/about',\n  user: '/user/:id',\n} as const satisfies Record<string, string>;\n\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n} satisfies Record<string, string | number[]>;\n\n// --- TS CJS interop: export = / import = require() ---";
    // Expect edge: <routes:obj> -[HAS_TYPE]-> <Record<string, string>>
    // Expect edge: <palette:obj> -[HAS_TYPE]-> <Record<string, string | number[]>>
    void code;
  });

  test('ts-specific::ts-infer-constrained', () => {
    const code = "type FirstString<T> = T extends [infer S extends string, ...unknown[]] ? S : never;\ntype NumericKeys<T> = { [K in keyof T as K extends `${infer N extends number}` ? K : never]: T[K] };\ntype ParsePair<T> = T extends `${infer A extends number},${infer B extends number}` ? [A, B] : never;\n\n// --- Inline import() type expressions ---";
    // Expect edge: <FirstString:conditional> -[EXTENDS]-> <[infer S extends string, ...unknown[]]>
    // Expect edge: <NumericKeys:mapped> -[DERIVES_FROM]-> <NumericKeys:remapping>
    // Expect edge: <NumericKeys:remapping> -[EXTENDS]-> <${infer N extends number}>
    // Expect edge: <ParsePair:conditional> -[EXTENDS]-> <${infer A extends number},${infer B extends number}>
    void code;
  });
});
