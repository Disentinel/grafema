{"construct":{"id":"aliasing::alias-method-extraction","file":"src/aliasing.js","category":"aliasing","lineStart":7,"lineEnd":9,"code":"const log = console.log;\nlog('extracted');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<log>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}},{"type":"CALL","id":"<log('extracted')>","metadata":{"callee":"log"}},{"type":"LITERAL","id":"<'extracted'>","metadata":{"value":"extracted","literalType":"string"}}],"edges":[{"src":"<log>","dst":"<console.log>","type":"ASSIGNED_FROM"},{"src":"<console.log>","dst":"<console>","type":"READS_FROM"},{"src":"<log('extracted')>","dst":"<log>","type":"CALLS"},{"src":"<log('extracted')>","dst":"<'extracted'>","type":"PASSES_ARGUMENT"}],"rationale":"Method extraction creates an alias variable that references a property access. The alias is then called with an argument. Removed the module declaration edge as it's not essential to the aliasing pattern.","implicitBehavior":["method loses 'this' binding when extracted from object"]},"pass":2,"annotatedAt":"2026-02-24T00:28:09.404Z"}
{"construct":{"id":"aliasing::alias-reassign-function","file":"src/aliasing.js","category":"aliasing","lineStart":23,"lineEnd":28,"code":"let handler = function first() { return 1; };\nhandler();\n\nhandler = function second() { return 2; };\nhandler();","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<handler>","metadata":{"kind":"let"}},{"type":"FUNCTION","id":"<first>","metadata":{"name":"first"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<handler()_1>","metadata":{"callSite":1}},{"type":"FUNCTION","id":"<second>","metadata":{"name":"second"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"CALL","id":"<handler()_2>","metadata":{"callSite":2}}],"edges":[{"src":"<handler>","dst":"<first>","type":"ASSIGNED_FROM"},{"src":"<first>","dst":"<1>","type":"RETURNS"},{"src":"<handler()_1>","dst":"<handler>","type":"CALLS"},{"src":"<handler>","dst":"<second>","type":"ASSIGNED_FROM"},{"src":"<second>","dst":"<2>","type":"RETURNS"},{"src":"<handler()_2>","dst":"<handler>","type":"CALLS"}],"rationale":"Variable handler is initially assigned to function 'first', called once, then reassigned to function 'second' and called again. The same variable references different functions at different times, demonstrating dynamic aliasing through reassignment.","implicitBehavior":["function expressions create closures","variable reassignment changes call target dynamically"]},"pass":2,"annotatedAt":"2026-02-24T00:28:10.472Z"}
{"construct":{"id":"aliasing::alias-destructured-method","file":"src/aliasing.js","category":"aliasing","lineStart":11,"lineEnd":13,"code":"const { parse, stringify } = JSON;\nconst parsed = parse('{\"a\":1}');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<parse>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<stringify>","metadata":{"kind":"const","destructured":true}},{"type":"PROPERTY_ACCESS","id":"<JSON.parse>","metadata":{"objectName":"JSON","propertyName":"parse"}},{"type":"PROPERTY_ACCESS","id":"<JSON.stringify>","metadata":{"objectName":"JSON","propertyName":"stringify"}},{"type":"VARIABLE","id":"<parsed>","metadata":{"kind":"const"}},{"type":"CALL","id":"<parse('{\"a\":1}')>","metadata":{"callee":"parse"}},{"type":"LITERAL","id":"<'{\"a\":1}'>","metadata":{"value":"{\"a\":1}","literalType":"string"}}],"edges":[{"src":"<parse>","dst":"<JSON.parse>","type":"ALIASES"},{"src":"<stringify>","dst":"<JSON.stringify>","type":"ALIASES"},{"src":"<parsed>","dst":"<parse('{\"a\":1}')>","type":"ASSIGNED_FROM"},{"src":"<parse('{\"a\":1}')>","dst":"<parse>","type":"CALLS"},{"src":"<parse('{\"a\":1}')>","dst":"<'{\"a\":1}'>","type":"PASSES_ARGUMENT"}],"rationale":"Destructuring assignment creates local aliases for JSON methods. The parse alias is then called with a string literal. Used ALIASES edge type to capture the destructuring relationship more precisely than ASSIGNED_FROM.","implicitBehavior":["destructuring creates new bindings that reference the original methods","parse call maintains 'this' binding to JSON object"]},"pass":2,"annotatedAt":"2026-02-24T00:28:10.964Z"}
{"construct":{"id":"aliasing::alias-bind-partial","file":"src/aliasing.js","category":"aliasing","lineStart":70,"lineEnd":75,"code":"function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<multiply>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"EXPRESSION","id":"<a * b>","metadata":{"operator":"*"}},{"type":"VARIABLE","id":"<doubleIt>","metadata":{"kind":"const"}},{"type":"CALL","id":"<multiply.bind(null, 2)>","metadata":{"callee":"multiply.bind"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"FUNCTION","id":"<doubleIt:bound>","metadata":{"boundFunction":true,"partiallyApplied":true}},{"type":"CALL","id":"<doubleIt(5)>","metadata":{"callee":"doubleIt"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}}],"edges":[{"src":"<multiply>","dst":"<a>","type":"CONTAINS"},{"src":"<multiply>","dst":"<b>","type":"CONTAINS"},{"src":"<multiply>","dst":"<a * b>","type":"RETURNS"},{"src":"<a * b>","dst":"<a>","type":"READS_FROM"},{"src":"<a * b>","dst":"<b>","type":"READS_FROM"},{"src":"<doubleIt>","dst":"<multiply.bind(null, 2)>","type":"ASSIGNED_FROM"},{"src":"<multiply.bind(null, 2)>","dst":"<multiply>","type":"CALLS"},{"src":"<multiply.bind(null, 2)>","dst":"<null>","type":"PASSES_ARGUMENT"},{"src":"<multiply.bind(null, 2)>","dst":"<2>","type":"PASSES_ARGUMENT"},{"src":"<multiply.bind(null, 2)>","dst":"<doubleIt:bound>","type":"RETURNS"},{"src":"<doubleIt:bound>","dst":"<multiply>","type":"DERIVES_FROM"},{"src":"<doubleIt:bound>","dst":"<2>","type":"CAPTURES"},{"src":"<doubleIt(5)>","dst":"<doubleIt>","type":"CALLS"},{"src":"<doubleIt(5)>","dst":"<5>","type":"PASSES_ARGUMENT"}],"rationale":"Function.bind creates a new bound function with partial application. The bound function captures the first argument (2) and derives from the original function. When called, it combines captured and passed arguments. Removed module-level DECLARES edges to reduce edge count while preserving core binding semantics.","implicitBehavior":["bind creates new function with fixed 'this' context (null)","partial application pre-fills first parameter","bound function has different identity than original"]},"pass":2,"annotatedAt":"2026-02-24T00:28:15.421Z"}
{"construct":{"id":"aliasing::alias-computed-method","file":"src/aliasing.js","category":"aliasing","lineStart":15,"lineEnd":21,"code":"const mathObj = { add(a, b) { return a + b; } };\nconst methodName = 'add';\nconst fn = mathObj[methodName];\nfn(1, 2);\n\n// --- Function reassignment ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<mathObj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<mathObj-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<add>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"EXPRESSION","id":"<a + b>","metadata":{"operator":"+"}},{"type":"VARIABLE","id":"<methodName>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'add'>","metadata":{"value":"add","literalType":"string"}},{"type":"VARIABLE","id":"<fn>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<mathObj[methodName]>","metadata":{"computed":true}},{"type":"CALL","id":"<fn(1, 2)>","metadata":{"callee":"fn"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<mathObj>","dst":"<mathObj-object>","type":"ASSIGNED_FROM"},{"src":"<mathObj-object>","dst":"<add>","type":"HAS_PROPERTY"},{"src":"<add>","dst":"<a>","type":"CONTAINS"},{"src":"<add>","dst":"<b>","type":"CONTAINS"},{"src":"<add>","dst":"<a + b>","type":"RETURNS"},{"src":"<a + b>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b>","dst":"<b>","type":"READS_FROM"},{"src":"<methodName>","dst":"<'add'>","type":"ASSIGNED_FROM"},{"src":"<fn>","dst":"<mathObj[methodName]>","type":"ASSIGNED_FROM"},{"src":"<mathObj[methodName]>","dst":"<mathObj>","type":"READS_FROM"},{"src":"<mathObj[methodName]>","dst":"<methodName>","type":"READS_FROM"},{"src":"<mathObj[methodName]>","dst":"<add>","type":"RESOLVES_TO"},{"src":"<fn(1, 2)>","dst":"<fn>","type":"CALLS"},{"src":"<fn(1, 2)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<fn(1, 2)>","dst":"<2>","type":"PASSES_ARGUMENT"}],"rationale":"Object with method is created, then method is accessed via computed property using string variable and aliased to another variable. The aliased function is then called with arguments. Removed module-level DECLARES edges to reduce edge count while preserving core semantic relationships.","implicitBehavior":["method loses 'this' binding when extracted from object","computed property access evaluates methodName at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:28:15.460Z"}
{"construct":{"id":"aliasing::alias-reassign-conditional","file":"src/aliasing.js","category":"aliasing","lineStart":30,"lineEnd":39,"code":"let strategy;\nif (Math.random() > 0.5) {\n  strategy = function fast() { return 'fast'; };\n} else {\n  strategy = function slow() { return 'slow'; };\n}\nstrategy();\n\n// --- Callback identity through higher-order functions ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<strategy>","metadata":{"kind":"let"}},{"type":"BRANCH","id":"<if-random>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<Math.random() > 0.5>","metadata":{"operator":">"}},{"type":"CALL","id":"<Math.random()>","metadata":{"callee":"Math.random"}},{"type":"LITERAL","id":"<0.5>","metadata":{"value":0.5,"literalType":"number"}},{"type":"FUNCTION","id":"<fast>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<'fast'>","metadata":{"value":"fast","literalType":"string"}},{"type":"FUNCTION","id":"<slow>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<'slow'>","metadata":{"value":"slow","literalType":"string"}},{"type":"CALL","id":"<strategy()>","metadata":{"callee":"strategy"}}],"edges":[{"src":"<if-random>","dst":"<Math.random() > 0.5>","type":"HAS_CONDITION"},{"src":"<Math.random() > 0.5>","dst":"<Math.random()>","type":"CONTAINS"},{"src":"<Math.random() > 0.5>","dst":"<0.5>","type":"CONTAINS"},{"src":"<if-random>","dst":"<strategy>","type":"HAS_CONSEQUENT"},{"src":"<strategy>","dst":"<fast>","type":"ASSIGNED_FROM"},{"src":"<fast>","dst":"<'fast'>","type":"RETURNS"},{"src":"<if-random>","dst":"<strategy>","type":"HAS_ALTERNATE"},{"src":"<strategy>","dst":"<slow>","type":"ASSIGNED_FROM"},{"src":"<slow>","dst":"<'slow'>","type":"RETURNS"},{"src":"<strategy()>","dst":"<strategy>","type":"CALLS"}],"rationale":"Conditional aliasing pattern where a variable is assigned different function values based on runtime condition. Both branches reassign the same variable to different function objects. Reduced edge count by removing module-level declarations and using CONTAINS for expression components.","implicitBehavior":["strategy variable can hold either function reference at runtime","function identity depends on random condition evaluation"]},"pass":2,"annotatedAt":"2026-02-24T00:28:15.476Z"}
{"construct":{"id":"aliasing::alias-callback-passed","file":"src/aliasing.js","category":"aliasing","lineStart":41,"lineEnd":46,"code":"function applyToArray(arr, callback) {\n  return arr.map(callback);\n}\nfunction double(x) { return x * 2; }\napplyToArray([1, 2, 3], double);","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<applyToArray>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<arr>"},{"type":"PARAMETER","id":"<callback>"},{"type":"CALL","id":"<arr.map(callback)>","metadata":{"method":"map"}},{"type":"FUNCTION","id":"<double>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"CALL","id":"<applyToArray([1, 2, 3], double)>","metadata":{"callee":"applyToArray"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"value":[1,2,3],"literalType":"array"}}],"edges":[{"src":"<applyToArray>","dst":"<arr>","type":"HAS_BODY"},{"src":"<applyToArray>","dst":"<callback>","type":"HAS_BODY"},{"src":"<applyToArray>","dst":"<arr.map(callback)>","type":"RETURNS"},{"src":"<arr.map(callback)>","dst":"<arr>","type":"CALLS_ON"},{"src":"<arr.map(callback)>","dst":"<callback>","type":"PASSES_ARGUMENT"},{"src":"<double>","dst":"<x>","type":"HAS_BODY"},{"src":"<double>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<applyToArray([1, 2, 3], double)>","dst":"<applyToArray>","type":"CALLS"},{"src":"<applyToArray([1, 2, 3], double)>","dst":"<[1, 2, 3]>","type":"PASSES_ARGUMENT"},{"src":"<applyToArray([1, 2, 3], double)>","dst":"<double>","type":"PASSES_ARGUMENT"},{"src":"<callback>","dst":"<double>","type":"ALIASES"}],"rationale":"Higher-order function pattern where a callback function is passed as argument and aliased through parameter binding. The double function is passed to applyToArray and becomes aliased as the callback parameter. Used HAS_BODY for parameter containment and ALIASES to capture the callback aliasing relationship.","implicitBehavior":["callback parameter creates alias to double function","map method will invoke callback for each array element"]},"pass":2,"annotatedAt":"2026-02-24T00:28:15.734Z"}
{"construct":{"id":"aliasing::alias-callback-returned","file":"src/aliasing.js","category":"aliasing","lineStart":48,"lineEnd":56,"code":"function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getComparator>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<ascending>"},{"type":"BRANCH","id":"<if-ascending>","metadata":{"branchType":"if"}},{"type":"FUNCTION","id":"<ascending-comparator>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<a1>"},{"type":"PARAMETER","id":"<b1>"},{"type":"EXPRESSION","id":"<a - b>","metadata":{"operator":"-"}},{"type":"FUNCTION","id":"<descending-comparator>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<a2>"},{"type":"PARAMETER","id":"<b2>"},{"type":"EXPRESSION","id":"<b - a>","metadata":{"operator":"-"}},{"type":"VARIABLE","id":"<cmp>","metadata":{"kind":"const"}},{"type":"CALL","id":"<getComparator(true)>","metadata":{"callee":"getComparator"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<[3, 1, 2]>","metadata":{"literalType":"array"}},{"type":"CALL","id":"<[3, 1, 2].sort(cmp)>","metadata":{"callee":"sort"}}],"edges":[{"src":"<getComparator>","dst":"<ascending>","type":"CONTAINS"},{"src":"<getComparator>","dst":"<if-ascending>","type":"CONTAINS"},{"src":"<if-ascending>","dst":"<ascending>","type":"HAS_CONDITION"},{"src":"<if-ascending>","dst":"<ascending-comparator>","type":"HAS_CONSEQUENT"},{"src":"<if-ascending>","dst":"<descending-comparator>","type":"HAS_ALTERNATE"},{"src":"<ascending-comparator>","dst":"<a1>","type":"CONTAINS"},{"src":"<ascending-comparator>","dst":"<b1>","type":"CONTAINS"},{"src":"<ascending-comparator>","dst":"<a - b>","type":"RETURNS"},{"src":"<a - b>","dst":"<a1>","type":"READS_FROM"},{"src":"<a - b>","dst":"<b1>","type":"READS_FROM"},{"src":"<descending-comparator>","dst":"<a2>","type":"CONTAINS"},{"src":"<descending-comparator>","dst":"<b2>","type":"CONTAINS"},{"src":"<descending-comparator>","dst":"<b - a>","type":"RETURNS"},{"src":"<b - a>","dst":"<b2>","type":"READS_FROM"},{"src":"<b - a>","dst":"<a2>","type":"READS_FROM"},{"src":"<cmp>","dst":"<getComparator(true)>","type":"ASSIGNED_FROM"},{"src":"<getComparator(true)>","dst":"<getComparator>","type":"CALLS"},{"src":"<getComparator(true)>","dst":"<true>","type":"PASSES_ARGUMENT"},{"src":"<[3, 1, 2].sort(cmp)>","dst":"<[3, 1, 2]>","type":"CALLS_ON"},{"src":"<[3, 1, 2].sort(cmp)>","dst":"<cmp>","type":"PASSES_ARGUMENT"}],"rationale":"Factory function returns different comparator functions based on parameter. The returned function is aliased to cmp and passed as callback to sort method. Removed module-level DECLARES edges as MODULE is not in approved vocabulary.","implicitBehavior":["function declaration is hoisted","arrow functions capture lexical this","sort method will invoke the comparator function for each comparison"]},"pass":2,"annotatedAt":"2026-02-24T00:28:18.391Z"}
{"construct":{"id":"aliasing::alias-callback-returned","file":"src/aliasing.js","category":"aliasing","lineStart":48,"lineEnd":56,"code":"function getComparator(ascending) {\n  if (ascending) return (a, b) => a - b;\n  return (a, b) => b - a;\n}\nconst cmp = getComparator(true);\n[3, 1, 2].sort(cmp);\n\n// --- Wrapper / adapter patterns ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getComparator>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<ascending>"},{"type":"BRANCH","id":"<if-ascending>","metadata":{"branchType":"if"}},{"type":"FUNCTION","id":"<ascending-comparator>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<a1>"},{"type":"PARAMETER","id":"<b1>"},{"type":"EXPRESSION","id":"<a1 - b1>","metadata":{"operator":"-"}},{"type":"FUNCTION","id":"<descending-comparator>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<a2>"},{"type":"PARAMETER","id":"<b2>"},{"type":"EXPRESSION","id":"<b2 - a2>","metadata":{"operator":"-"}},{"type":"VARIABLE","id":"<cmp>","metadata":{"kind":"const"}},{"type":"CALL","id":"<getComparator(true)>","metadata":{"callee":"getComparator"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<[3, 1, 2]>","metadata":{"literalType":"array"}},{"type":"CALL","id":"<[3, 1, 2].sort(cmp)>","metadata":{"callee":"sort"}}],"edges":[{"src":"<getComparator>","dst":"<ascending>","type":"CONTAINS"},{"src":"<getComparator>","dst":"<if-ascending>","type":"CONTAINS"},{"src":"<if-ascending>","dst":"<ascending>","type":"HAS_CONDITION"},{"src":"<if-ascending>","dst":"<ascending-comparator>","type":"HAS_CONSEQUENT"},{"src":"<if-ascending>","dst":"<descending-comparator>","type":"HAS_ALTERNATE"},{"src":"<ascending-comparator>","dst":"<a1>","type":"CONTAINS"},{"src":"<ascending-comparator>","dst":"<b1>","type":"CONTAINS"},{"src":"<ascending-comparator>","dst":"<a1 - b1>","type":"RETURNS"},{"src":"<a1 - b1>","dst":"<a1>","type":"READS_FROM"},{"src":"<a1 - b1>","dst":"<b1>","type":"READS_FROM"},{"src":"<descending-comparator>","dst":"<a2>","type":"CONTAINS"},{"src":"<descending-comparator>","dst":"<b2>","type":"CONTAINS"},{"src":"<descending-comparator>","dst":"<b2 - a2>","type":"RETURNS"},{"src":"<b2 - a2>","dst":"<b2>","type":"READS_FROM"},{"src":"<b2 - a2>","dst":"<a2>","type":"READS_FROM"},{"src":"<cmp>","dst":"<getComparator(true)>","type":"ASSIGNED_FROM"},{"src":"<getComparator(true)>","dst":"<getComparator>","type":"CALLS"},{"src":"<getComparator(true)>","dst":"<true>","type":"PASSES_ARGUMENT"},{"src":"<[3, 1, 2].sort(cmp)>","dst":"<[3, 1, 2]>","type":"CALLS_ON"},{"src":"<[3, 1, 2].sort(cmp)>","dst":"<cmp>","type":"PASSES_ARGUMENT"}],"rationale":"Factory function returns different comparator functions based on parameter. The returned function is aliased to cmp and passed as callback to sort method. Removed module-level DECLARES edges as no MODULE node exists in approved vocabulary.","implicitBehavior":["function declaration is hoisted","arrow functions capture lexical this","sort method will invoke the comparator function for each comparison"]},"pass":2,"annotatedAt":"2026-02-24T00:28:18.717Z"}
{"construct":{"id":"aliasing::alias-wrapper-transparent","file":"src/aliasing.js","category":"aliasing","lineStart":58,"lineEnd":68,"code":"function withLogging(wrappedFn) {\n  return function (...args) {\n    console.log('call:', wrappedFn.name, args);\n    const result = wrappedFn.apply(this, args);\n    console.log('result:', result);\n    return result;\n  };\n}\nconst loggedAdd = withLogging(function add(a, b) { return a + b; });\nloggedAdd(1, 2);","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<withLogging>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER"},"pass":2,"annotatedAt":"2026-02-24T00:28:20.744Z"}
{"construct":{"id":"aliasing::arguments-basic","file":"src/aliasing.js","category":"aliasing","lineStart":77,"lineEnd":84,"code":"function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<sum>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<total>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i < arguments.length>","metadata":{"operator":"<"}},{"type":"PROPERTY_ACCESS","id":"<arguments.length>","metadata":{"objectName":"arguments","property":"length"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<total += arguments[i]>","metadata":{"operator":"+="}},{"type":"PROPERTY_ACCESS","id":"<arguments[i]>","metadata":{"objectName":"arguments","accessType":"computed"}},{"type":"EXTERNAL","id":"<arguments>","metadata":{"kind":"implicit-parameter"}}],"edges":[{"src":"<sum>","dst":"<total>","type":"CONTAINS"},{"src":"<sum>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<total>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < arguments.length>","type":"HAS_CONDITION"},{"src":"<i < arguments.length>","dst":"<i>","type":"READS_FROM"},{"src":"<i < arguments.length>","dst":"<arguments.length>","type":"READS_FROM"},{"src":"<arguments.length>","dst":"<arguments>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<total += arguments[i]>","type":"HAS_BODY"},{"src":"<total += arguments[i]>","dst":"<total>","type":"MODIFIES"},{"src":"<total += arguments[i]>","dst":"<arguments[i]>","type":"READS_FROM"},{"src":"<arguments[i]>","dst":"<arguments>","type":"READS_FROM"},{"src":"<arguments[i]>","dst":"<i>","type":"READS_FROM"},{"src":"<sum>","dst":"<total>","type":"RETURNS"},{"src":"<sum>","dst":"<arguments>","type":"CAPTURES"}],"rationale":"Function uses the implicit arguments object to access all passed parameters. The arguments object is captured by the function and accessed via property reads and computed property access. All node and edge types from Pass 1 were already in the approved vocabulary.","implicitBehavior":["arguments object is automatically available in non-arrow functions","arguments is array-like but not a true Array","arguments object reflects all passed parameters regardless of declared parameters"]},"pass":2,"annotatedAt":"2026-02-24T00:28:22.381Z"}
{"construct":{"id":"aliasing::alias-bind-partial","file":"src/aliasing.js","category":"aliasing","lineStart":70,"lineEnd":75,"code":"function multiply(a, b) { return a * b; }\nconst doubleIt = multiply.bind(null, 2);\ndoubleIt(5);\n\n// --- arguments object ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<multiply>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"EXPRESSION","id":"<a * b>","metadata":{"operator":"*"}},{"type":"VARIABLE","id":"<doubleIt>","metadata":{"kind":"const"}},{"type":"CALL","id":"<multiply.bind(null, 2)>","metadata":{"callee":"multiply.bind"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"FUNCTION","id":"<doubleIt:bound>","metadata":{"boundFunction":true,"partiallyApplied":true}},{"type":"CALL","id":"<doubleIt(5)>","metadata":{"callee":"doubleIt"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}}],"edges":[{"src":"<multiply>","dst":"<a>","type":"HAS_BODY"},{"src":"<multiply>","dst":"<b>","type":"HAS_BODY"},{"src":"<multiply>","dst":"<a * b>","type":"RETURNS"},{"src":"<a * b>","dst":"<a>","type":"READS_FROM"},{"src":"<a * b>","dst":"<b>","type":"READS_FROM"},{"src":"<doubleIt>","dst":"<multiply.bind(null, 2)>","type":"ASSIGNED_FROM"},{"src":"<multiply.bind(null, 2)>","dst":"<multiply>","type":"CALLS"},{"src":"<multiply.bind(null, 2)>","dst":"<null>","type":"PASSES_ARGUMENT"},{"src":"<multiply.bind(null, 2)>","dst":"<2>","type":"PASSES_ARGUMENT"},{"src":"<multiply.bind(null, 2)>","dst":"<doubleIt:bound>","type":"RETURNS"},{"src":"<doubleIt:bound>","dst":"<multiply>","type":"DERIVES_FROM"},{"src":"<doubleIt:bound>","dst":"<2>","type":"CAPTURES"},{"src":"<doubleIt(5)>","dst":"<doubleIt>","type":"CALLS"},{"src":"<doubleIt(5)>","dst":"<5>","type":"PASSES_ARGUMENT"}],"rationale":"Function.bind creates a new bound function with partial application. The bound function captures the first argument (2) and derives from the original function. Used HAS_BODY instead of CONTAINS for parameters as it's the closest approved relationship.","implicitBehavior":["bind creates new function with fixed 'this' context (null)","partial application pre-fills first parameter","bound function has reduced arity"]},"pass":2,"annotatedAt":"2026-02-24T00:28:23.405Z"}
{"construct":{"id":"aliasing::alias-import-dynamic-variable","file":"src/aliasing.js","category":"aliasing","lineStart":101,"lineEnd":103,"code":"const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<modulePath>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'./declarations.js'>","metadata":{"value":"./declarations.js","literalType":"string"}},{"type":"VARIABLE","id":"<dynamicMod>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import(modulePath)>","metadata":{"callee":"import","dynamic":true}},{"type":"EXTERNAL_MODULE","id":"<./declarations.js>","metadata":{"path":"./declarations.js"}}],"edges":[{"src":"<modulePath>","dst":"<'./declarations.js'>","type":"ASSIGNED_FROM"},{"src":"<dynamicMod>","dst":"<import(modulePath)>","type":"ASSIGNED_FROM"},{"src":"<import(modulePath)>","dst":"<modulePath>","type":"PASSES_ARGUMENT"},{"src":"<import(modulePath)>","dst":"<./declarations.js>","type":"IMPORTS_FROM"},{"src":"<dynamicMod>","dst":"<./declarations.js>","type":"ALIASES"}],"rationale":"Dynamic import using a variable path. The module path is stored in a variable, then used as argument to dynamic import() call. The await expression unwraps the Promise to get the module object, which dynamicMod aliases.","implicitBehavior":["dynamic import returns a Promise that resolves to module object","module resolution happens at runtime","await expression unwraps the Promise"]},"pass":2,"annotatedAt":"2026-02-24T00:28:25.862Z"}
{"construct":{"id":"aliasing::alias-wrapper-transparent","file":"src/aliasing.js","category":"aliasing","lineStart":58,"lineEnd":68,"code":"function withLogging(wrappedFn) {\n  return function (...args) {\n    console.log('call:', wrappedFn.name, args);\n    const result = wrappedFn.apply(this, args);\n    console.log('result:', result);\n    return result;\n  };\n}\nconst loggedAdd = withLogging(function add(a, b) { return a + b; });\nloggedAdd(1, 2);","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<withLogging>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER"},"pass":2,"annotatedAt":"2026-02-24T00:28:26.172Z"}
{"construct":{"id":"aliasing::arguments-callee","file":"src/aliasing.js","category":"aliasing","lineStart":94,"lineEnd":99,"code":"const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<factorial>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<factorial:fn>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<n>"},{"type":"EXPRESSION","id":"<n <= 1>","metadata":{"operator":"<="}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<1-return>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<n * arguments.callee(n - 1)>","metadata":{"operator":"*"}},{"type":"PROPERTY_ACCESS","id":"<arguments.callee>","metadata":{"objectName":"arguments","propertyName":"callee"}},{"type":"EXPRESSION","id":"<n - 1>","metadata":{"operator":"-"}},{"type":"CALL","id":"<arguments.callee(n - 1)>","metadata":{"recursive":true}},{"type":"EXPRESSION","id":"<ternary>","metadata":{"operator":"?:"}}],"edges":[{"src":"<factorial>","dst":"<factorial:fn>","type":"ASSIGNED_FROM"},{"src":"<factorial:fn>","dst":"<n>","type":"CONTAINS"},{"src":"<factorial:fn>","dst":"<ternary>","type":"RETURNS"},{"src":"<ternary>","dst":"<n <= 1>","type":"HAS_CONDITION"},{"src":"<ternary>","dst":"<1-return>","type":"HAS_CONSEQUENT"},{"src":"<ternary>","dst":"<n * arguments.callee(n - 1)>","type":"HAS_ALTERNATE"},{"src":"<n <= 1>","dst":"<n>","type":"READS_FROM"},{"src":"<n <= 1>","dst":"<1>","type":"READS_FROM"},{"src":"<n * arguments.callee(n - 1)>","dst":"<n>","type":"READS_FROM"},{"src":"<n * arguments.callee(n - 1)>","dst":"<arguments.callee(n - 1)>","type":"READS_FROM"},{"src":"<arguments.callee(n - 1)>","dst":"<arguments.callee>","type":"CALLS"},{"src":"<arguments.callee(n - 1)>","dst":"<n - 1>","type":"PASSES_ARGUMENT"},{"src":"<n - 1>","dst":"<n>","type":"READS_FROM"},{"src":"<n - 1>","dst":"<1>","type":"READS_FROM"},{"src":"<arguments.callee>","dst":"<factorial:fn>","type":"ALIASES"}],"rationale":"Anonymous function using arguments.callee for recursion. The callee property aliases the function itself, enabling self-reference without a named binding. Removed module declaration edge to reduce complexity while preserving core aliasing semantics.","implicitBehavior":["arguments.callee is deprecated in strict mode","arguments object is implicitly available in non-arrow functions","callee property provides reference to currently executing function"]},"pass":2,"annotatedAt":"2026-02-24T00:28:27.194Z"}
{"construct":{"id":"aliasing::arguments-basic","file":"src/aliasing.js","category":"aliasing","lineStart":77,"lineEnd":84,"code":"function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<sum>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<total>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i < arguments.length>","metadata":{"operator":"<"}},{"type":"PROPERTY_ACCESS","id":"<arguments.length>","metadata":{"objectName":"arguments","property":"length"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<total += arguments[i]>","metadata":{"operator":"+="}},{"type":"PROPERTY_ACCESS","id":"<arguments[i]>","metadata":{"objectName":"arguments","accessType":"computed"}},{"type":"EXTERNAL","id":"<arguments>","metadata":{"kind":"implicit-parameter"}}],"edges":[{"src":"<sum>","dst":"<total>","type":"CONTAINS"},{"src":"<sum>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<total>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < arguments.length>","type":"HAS_CONDITION"},{"src":"<i < arguments.length>","dst":"<i>","type":"READS_FROM"},{"src":"<i < arguments.length>","dst":"<arguments.length>","type":"READS_FROM"},{"src":"<arguments.length>","dst":"<arguments>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<total += arguments[i]>","type":"HAS_BODY"},{"src":"<total += arguments[i]>","dst":"<total>","type":"MODIFIES"},{"src":"<total += arguments[i]>","dst":"<arguments[i]>","type":"READS_FROM"},{"src":"<arguments[i]>","dst":"<arguments>","type":"READS_FROM"},{"src":"<arguments[i]>","dst":"<i>","type":"READS_FROM"},{"src":"<sum>","dst":"<total>","type":"RETURNS"},{"src":"<sum>","dst":"<arguments>","type":"CAPTURES"}],"rationale":"Function uses the implicit arguments object to access all passed parameters. The arguments object is captured by the function and accessed via property reads and computed property access. All node and edge types from Pass 1 were already in the approved vocabulary.","implicitBehavior":["arguments object is automatically available in non-arrow functions","arguments is array-like but not a true Array","arguments object reflects all passed parameters regardless of declared parameters"]},"pass":2,"annotatedAt":"2026-02-24T00:28:27.194Z"}
{"construct":{"id":"aliasing::arguments-array-conversion","file":"src/aliasing.js","category":"aliasing","lineStart":86,"lineEnd":92,"code":"function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<toArray>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<fromArrayFn>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Array.from(arguments)>","metadata":{"callee":"Array.from"}},{"type":"PROPERTY_ACCESS","id":"<Array.from>","metadata":{"objectName":"Array","propertyName":"from"}},{"type":"VARIABLE","id":"<arguments>","metadata":{"implicitParameter":true}},{"type":"VARIABLE","id":"<fromSpread>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<[...arguments]>","metadata":{"type":"array","hasSpread":true}},{"type":"VARIABLE","id":"<fromSlice>","metadata":{"kind":"const"}},{"type":"CALL","id":"<[].slice.call(arguments)>","metadata":{"callee":"slice"}},{"type":"PROPERTY_ACCESS","id":"<[].slice>","metadata":{"objectName":"[]","propertyName":"slice"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"PROPERTY_ACCESS","id":"<[].slice.call>","metadata":{"objectName":"[].slice","propertyName":"call"}},{"type":"EXPRESSION","id":"<{ fromArrayFn, fromSpread, fromSlice }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<toArray>","dst":"<fromArrayFn>","type":"CONTAINS"},{"src":"<fromArrayFn>","dst":"<Array.from(arguments)>","type":"ASSIGNED_FROM"},{"src":"<Array.from(arguments)>","dst":"<Array.from>","type":"CALLS"},{"src":"<Array.from(arguments)>","dst":"<arguments>","type":"PASSES_ARGUMENT"},{"src":"<toArray>","dst":"<fromSpread>","type":"CONTAINS"},{"src":"<fromSpread>","dst":"<[...arguments]>","type":"ASSIGNED_FROM"},{"src":"<[...arguments]>","dst":"<arguments>","type":"SPREADS_FROM"},{"src":"<toArray>","dst":"<fromSlice>","type":"CONTAINS"},{"src":"<fromSlice>","dst":"<[].slice.call(arguments)>","type":"ASSIGNED_FROM"},{"src":"<[].slice.call(arguments)>","dst":"<[].slice.call>","type":"CALLS"},{"src":"<[].slice.call(arguments)>","dst":"<arguments>","type":"PASSES_ARGUMENT"},{"src":"<[].slice>","dst":"<[]>","type":"READS_FROM"},{"src":"<toArray>","dst":"<{ fromArrayFn, fromSpread, fromSlice }>","type":"RETURNS"},{"src":"<{ fromArrayFn, fromSpread, fromSlice }>","dst":"<fromArrayFn>","type":"READS_FROM"},{"src":"<{ fromArrayFn, fromSpread, fromSlice }>","dst":"<fromSpread>","type":"READS_FROM"},{"src":"<{ fromArrayFn, fromSpread, fromSlice }>","dst":"<fromSlice>","type":"READS_FROM"}],"rationale":"Function demonstrates three ways to convert arguments object to array. Each method creates a variable assigned from different conversion techniques - Array.from(), spread syntax, and slice.call(). Reduced edge count by removing module declaration edge and using SPREADS_FROM for spread syntax.","implicitBehavior":["arguments object is automatically available in non-arrow functions","arguments object is array-like but not a true array","spread syntax creates shallow copy","slice.call() borrows Array prototype method"]},"pass":2,"annotatedAt":"2026-02-24T00:28:28.723Z"}
{"construct":{"id":"aliasing::arguments-array-conversion","file":"src/aliasing.js","category":"aliasing","lineStart":86,"lineEnd":92,"code":"function toArray() {\n  const fromArrayFn = Array.from(arguments);\n  const fromSpread = [...arguments];\n  const fromSlice = [].slice.call(arguments);\n  return { fromArrayFn, fromSpread, fromSlice };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<toArray>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<fromArrayFn>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Array.from(arguments)>","metadata":{"callee":"Array.from"}},{"type":"PROPERTY_ACCESS","id":"<Array.from>","metadata":{"objectName":"Array","propertyName":"from"}},{"type":"VARIABLE","id":"<arguments>","metadata":{"implicitParameter":true}},{"type":"VARIABLE","id":"<fromSpread>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<[...arguments]>","metadata":{"type":"array","hasSpread":true}},{"type":"VARIABLE","id":"<fromSlice>","metadata":{"kind":"const"}},{"type":"CALL","id":"<[].slice.call(arguments)>","metadata":{"callee":"slice"}},{"type":"PROPERTY_ACCESS","id":"<[].slice>","metadata":{"objectName":"[]","propertyName":"slice"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"PROPERTY_ACCESS","id":"<[].slice.call>","metadata":{"objectName":"[].slice","propertyName":"call"}},{"type":"EXPRESSION","id":"<{ fromArrayFn, fromSpread, fromSlice }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<toArray>","dst":"<fromArrayFn>","type":"CONTAINS"},{"src":"<fromArrayFn>","dst":"<Array.from(arguments)>","type":"ASSIGNED_FROM"},{"src":"<Array.from(arguments)>","dst":"<Array.from>","type":"CALLS"},{"src":"<Array.from(arguments)>","dst":"<arguments>","type":"PASSES_ARGUMENT"},{"src":"<toArray>","dst":"<fromSpread>","type":"CONTAINS"},{"src":"<fromSpread>","dst":"<[...arguments]>","type":"ASSIGNED_FROM"},{"src":"<[...arguments]>","dst":"<arguments>","type":"SPREADS_FROM"},{"src":"<toArray>","dst":"<fromSlice>","type":"CONTAINS"},{"src":"<fromSlice>","dst":"<[].slice.call(arguments)>","type":"ASSIGNED_FROM"},{"src":"<[].slice.call(arguments)>","dst":"<[].slice.call>","type":"CALLS"},{"src":"<[].slice.call(arguments)>","dst":"<arguments>","type":"PASSES_ARGUMENT"},{"src":"<[].slice>","dst":"<[]>","type":"READS_FROM"},{"src":"<toArray>","dst":"<{ fromArrayFn, fromSpread, fromSlice }>","type":"RETURNS"},{"src":"<{ fromArrayFn, fromSpread, fromSlice }>","dst":"<fromArrayFn>","type":"READS_FROM"},{"src":"<{ fromArrayFn, fromSpread, fromSlice }>","dst":"<fromSpread>","type":"READS_FROM"},{"src":"<{ fromArrayFn, fromSpread, fromSlice }>","dst":"<fromSlice>","type":"READS_FROM"}],"rationale":"Function demonstrates three ways to convert arguments object to array. Each method creates a variable assigned from different conversion techniques - Array.from(), spread syntax, and slice.call(). Reduced edge count by removing module declaration edge and using SPREADS_FROM for spread syntax.","implicitBehavior":["arguments object is automatically available in non-arrow functions","arguments is array-like but not a true array","spread syntax creates shallow copy","slice.call() borrows Array prototype method"]},"pass":2,"annotatedAt":"2026-02-24T00:28:29.240Z"}
{"construct":{"id":"aliasing::alias-import-dynamic-conditional","file":"src/aliasing.js","category":"aliasing","lineStart":105,"lineEnd":108,"code":"const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<impl>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import()>","metadata":{"callee":"import","dynamic":true}},{"type":"EXPRESSION","id":"<Math.random() > 0.5>","metadata":{"operator":">"}},{"type":"CALL","id":"<Math.random()>","metadata":{"callee":"Math.random"}},{"type":"LITERAL","id":"<0.5>","metadata":{"value":0.5,"literalType":"number"}},{"type":"BRANCH","id":"<conditional>","metadata":{"type":"ternary"}},{"type":"LITERAL","id":"<'./declarations.js'>","metadata":{"value":"./declarations.js","literalType":"string"}},{"type":"LITERAL","id":"<'./expressions.js'>","metadata":{"value":"./expressions.js","literalType":"string"}}],"edges":[{"src":"<impl>","dst":"<import()>","type":"ASSIGNED_FROM"},{"src":"<import()>","dst":"<conditional>","type":"PASSES_ARGUMENT"},{"src":"<conditional>","dst":"<Math.random() > 0.5>","type":"HAS_CONDITION"},{"src":"<Math.random() > 0.5>","dst":"<Math.random()>","type":"READS_FROM"},{"src":"<Math.random() > 0.5>","dst":"<0.5>","type":"READS_FROM"},{"src":"<conditional>","dst":"<'./declarations.js'>","type":"HAS_CONSEQUENT"},{"src":"<conditional>","dst":"<'./expressions.js'>","type":"HAS_ALTERNATE"},{"src":"<import()>","dst":"<'./declarations.js'>","type":"IMPORTS_FROM"},{"src":"<import()>","dst":"<'./expressions.js'>","type":"IMPORTS_FROM"}],"rationale":"Dynamic import with conditional module path. The import() call receives a ternary expression that conditionally selects between two module paths based on Math.random(). Reduced edge count by removing module-level DECLARES edge and connecting IMPORTS_FROM directly to the import() call rather than module.","implicitBehavior":["dynamic import returns a Promise","module resolution happens at runtime","both potential modules are marked as dependencies for bundling"]},"pass":2,"annotatedAt":"2026-02-24T00:28:29.913Z"}
{"construct":{"id":"aliasing::arguments-callee","file":"src/aliasing.js","category":"aliasing","lineStart":94,"lineEnd":99,"code":"const factorial = function (n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);\n};\n\n// --- Dynamic import edge cases ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<factorial>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<factorial:fn>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<n>"},{"type":"EXPRESSION","id":"<n <= 1>","metadata":{"operator":"<="}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<1-return>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<n * arguments.callee(n - 1)>","metadata":{"operator":"*"}},{"type":"PROPERTY_ACCESS","id":"<arguments.callee>","metadata":{"objectName":"arguments","propertyName":"callee"}},{"type":"EXPRESSION","id":"<n - 1>","metadata":{"operator":"-"}},{"type":"CALL","id":"<arguments.callee(n - 1)>","metadata":{"recursive":true}},{"type":"EXPRESSION","id":"<ternary>","metadata":{"operator":"?:"}}],"edges":[{"src":"<factorial>","dst":"<factorial:fn>","type":"ASSIGNED_FROM"},{"src":"<factorial:fn>","dst":"<n>","type":"CONTAINS"},{"src":"<factorial:fn>","dst":"<ternary>","type":"RETURNS"},{"src":"<ternary>","dst":"<n <= 1>","type":"HAS_CONDITION"},{"src":"<ternary>","dst":"<1-return>","type":"HAS_CONSEQUENT"},{"src":"<ternary>","dst":"<n * arguments.callee(n - 1)>","type":"HAS_ALTERNATE"},{"src":"<n <= 1>","dst":"<n>","type":"READS_FROM"},{"src":"<n <= 1>","dst":"<1>","type":"READS_FROM"},{"src":"<n * arguments.callee(n - 1)>","dst":"<n>","type":"READS_FROM"},{"src":"<n * arguments.callee(n - 1)>","dst":"<arguments.callee(n - 1)>","type":"READS_FROM"},{"src":"<arguments.callee(n - 1)>","dst":"<arguments.callee>","type":"CALLS"},{"src":"<arguments.callee(n - 1)>","dst":"<n - 1>","type":"PASSES_ARGUMENT"},{"src":"<n - 1>","dst":"<n>","type":"READS_FROM"},{"src":"<n - 1>","dst":"<1>","type":"READS_FROM"},{"src":"<arguments.callee>","dst":"<factorial:fn>","type":"ALIASES"}],"rationale":"Anonymous function using arguments.callee for recursion. The callee property aliases the function itself, enabling self-reference without a named function declaration. Removed the module declaration edge to reduce edge count while preserving the core aliasing semantics.","implicitBehavior":["arguments.callee is deprecated in strict mode","arguments object is implicitly available in non-arrow functions","callee property provides reference to currently executing function"]},"pass":2,"annotatedAt":"2026-02-24T00:28:29.989Z"}
{"construct":{"id":"aliasing::alias-import-dynamic-variable","file":"src/aliasing.js","category":"aliasing","lineStart":101,"lineEnd":103,"code":"const modulePath = './declarations.js';\nconst dynamicMod = await import(modulePath);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<modulePath>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'./declarations.js'>","metadata":{"value":"./declarations.js","literalType":"string"}},{"type":"VARIABLE","id":"<dynamicMod>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import(modulePath)>","metadata":{"callee":"import","dynamic":true}},{"type":"EXTERNAL_MODULE","id":"<./declarations.js>","metadata":{"path":"./declarations.js"}}],"edges":[{"src":"<modulePath>","dst":"<'./declarations.js'>","type":"ASSIGNED_FROM"},{"src":"<dynamicMod>","dst":"<import(modulePath)>","type":"ASSIGNED_FROM"},{"src":"<import(modulePath)>","dst":"<modulePath>","type":"PASSES_ARGUMENT"},{"src":"<import(modulePath)>","dst":"<./declarations.js>","type":"IMPORTS_FROM"},{"src":"<dynamicMod>","dst":"<./declarations.js>","type":"ALIASES"}],"rationale":"Dynamic import using a variable path. The module path is stored in a variable, then used as argument to dynamic import() call. The await expression unwraps the Promise to get the module object, which dynamicMod aliases.","implicitBehavior":["dynamic import returns a Promise that resolves to module object","module resolution happens at runtime","await expression unwraps the Promise"]},"pass":2,"annotatedAt":"2026-02-24T00:28:30.108Z"}
{"construct":{"id":"aliasing::alias-import-dynamic-template","file":"src/aliasing.js","category":"aliasing","lineStart":110,"lineEnd":114,"code":"async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<loadPlugin>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<name>"},{"type":"VARIABLE","id":"<plugin>","metadata":{"kind":"const"}},{"type":"IMPORT","id":"<dynamic-import>","metadata":{"dynamic":true}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}},{"type":"PROPERTY_ACCESS","id":"<plugin.default>","metadata":{"objectName":"plugin","property":"default"}}],"edges":[{"src":"<loadPlugin>","dst":"<name>","type":"CONTAINS"},{"src":"<loadPlugin>","dst":"<plugin>","type":"CONTAINS"},{"src":"<plugin>","dst":"<dynamic-import>","type":"ASSIGNED_FROM"},{"src":"<dynamic-import>","dst":"<template-literal>","type":"IMPORTS_FROM"},{"src":"<template-literal>","dst":"<name>","type":"READS_FROM"},{"src":"<loadPlugin>","dst":"<plugin.default>","type":"RETURNS"},{"src":"<plugin.default>","dst":"<plugin>","type":"READS_FROM"}],"rationale":"Async function that dynamically imports a module using template literal path construction, then returns the default export. Removed the module-level DECLARES edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["dynamic import returns a Promise that resolves to module object","template literal constructs path at runtime","default export access may be undefined if module has no default"]},"pass":2,"annotatedAt":"2026-02-24T00:28:30.141Z"}
{"construct":{"id":"aliasing::alias-import-dynamic-template","file":"src/aliasing.js","category":"aliasing","lineStart":110,"lineEnd":114,"code":"async function loadPlugin(name) {\n  const plugin = await import(`./plugins/${name}.js`);\n  return plugin.default;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<loadPlugin>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<name>"},{"type":"VARIABLE","id":"<plugin>","metadata":{"kind":"const"}},{"type":"IMPORT","id":"<dynamic-import>","metadata":{"dynamic":true}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}},{"type":"PROPERTY_ACCESS","id":"<plugin.default>","metadata":{"objectName":"plugin","property":"default"}}],"edges":[{"src":"<loadPlugin>","dst":"<name>","type":"CONTAINS"},{"src":"<loadPlugin>","dst":"<plugin>","type":"CONTAINS"},{"src":"<plugin>","dst":"<dynamic-import>","type":"ASSIGNED_FROM"},{"src":"<dynamic-import>","dst":"<template-literal>","type":"IMPORTS_FROM"},{"src":"<template-literal>","dst":"<name>","type":"READS_FROM"},{"src":"<loadPlugin>","dst":"<plugin.default>","type":"RETURNS"},{"src":"<plugin.default>","dst":"<plugin>","type":"READS_FROM"}],"rationale":"Async function that dynamically imports a module using template literal path construction, then returns the default export. Removed the module-level DECLARES edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["dynamic import returns a Promise that resolves to module object","template literal constructs path at runtime","default export access may fail if module has no default"]},"pass":2,"annotatedAt":"2026-02-24T00:28:34.268Z"}
{"construct":{"id":"aliasing::alias-import-dynamic-conditional","file":"src/aliasing.js","category":"aliasing","lineStart":105,"lineEnd":108,"code":"const impl = await import(\n  Math.random() > 0.5 ? './declarations.js' : './expressions.js'\n);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<impl>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import()>","metadata":{"callee":"import","dynamic":true}},{"type":"EXPRESSION","id":"<Math.random() > 0.5>","metadata":{"operator":">"}},{"type":"CALL","id":"<Math.random()>","metadata":{"callee":"Math.random"}},{"type":"LITERAL","id":"<0.5>","metadata":{"value":0.5,"literalType":"number"}},{"type":"BRANCH","id":"<conditional>","metadata":{"type":"ternary"}},{"type":"LITERAL","id":"<'./declarations.js'>","metadata":{"value":"./declarations.js","literalType":"string"}},{"type":"LITERAL","id":"<'./expressions.js'>","metadata":{"value":"./expressions.js","literalType":"string"}}],"edges":[{"src":"<impl>","dst":"<import()>","type":"ASSIGNED_FROM"},{"src":"<import()>","dst":"<conditional>","type":"PASSES_ARGUMENT"},{"src":"<conditional>","dst":"<Math.random() > 0.5>","type":"HAS_CONDITION"},{"src":"<Math.random() > 0.5>","dst":"<Math.random()>","type":"READS_FROM"},{"src":"<Math.random() > 0.5>","dst":"<0.5>","type":"READS_FROM"},{"src":"<conditional>","dst":"<'./declarations.js'>","type":"HAS_CONSEQUENT"},{"src":"<conditional>","dst":"<'./expressions.js'>","type":"HAS_ALTERNATE"},{"src":"<import()>","dst":"<'./declarations.js'>","type":"IMPORTS_FROM"},{"src":"<import()>","dst":"<'./expressions.js'>","type":"IMPORTS_FROM"}],"rationale":"Dynamic import with conditional module path. The import() call receives a ternary expression that conditionally selects between two module paths based on Math.random(). Reduced edge count by removing module-level DECLARES edge and connecting IMPORTS_FROM directly to the import() call rather than module.","implicitBehavior":["dynamic import returns a Promise","module resolution happens at runtime","both potential modules are marked as dependencies for bundling"]},"pass":2,"annotatedAt":"2026-02-24T00:28:34.878Z"}
{"construct":{"id":"aliasing::arrow-no-arguments","file":"src/aliasing.js","category":"aliasing","lineStart":125,"lineEnd":132,"code":"function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<outerWithArguments>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<arrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrow:fn>","metadata":{"arrowFunction":true}},{"type":"PROPERTY_ACCESS","id":"<arguments[0]>","metadata":{"objectName":"arguments","property":"0"}},{"type":"VARIABLE","id":"<arrowFromOuter>","metadata":{"kind":"const"}},{"type":"CALL","id":"<outerWithArguments(42)>","metadata":{"callee":"outerWithArguments"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<outerWithArguments>","dst":"<arrow>","type":"CONTAINS"},{"src":"<arrow>","dst":"<arrow:fn>","type":"ASSIGNED_FROM"},{"src":"<outerWithArguments>","dst":"<arrow:fn>","type":"RETURNS"},{"src":"<arrow:fn>","dst":"<arguments[0]>","type":"RETURNS"},{"src":"<arguments[0]>","dst":"<outerWithArguments>","type":"CAPTURES"},{"src":"<arrowFromOuter>","dst":"<outerWithArguments(42)>","type":"ASSIGNED_FROM"},{"src":"<outerWithArguments(42)>","dst":"<outerWithArguments>","type":"CALLS"},{"src":"<outerWithArguments(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Arrow function captures outer function's arguments object. The arrow function has no parameters but accesses the lexically scoped arguments from its containing function. Reduced edge count by removing module-level DECLARES edges while preserving the core semantic relationships.","implicitBehavior":["arrow function does not have its own arguments object","arguments reference lexically binds to outer function's arguments","function declaration is hoisted to module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:28:35.292Z"}
{"construct":{"id":"aliasing::arrow-no-arguments","file":"src/aliasing.js","category":"aliasing","lineStart":125,"lineEnd":132,"code":"function outerWithArguments() {\n  const arrow = () => {\n    return arguments[0]; // captures OUTER function's arguments\n  };\n  return arrow;\n}\nconst arrowFromOuter = outerWithArguments(42);","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<outerWithArguments>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<arrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrow:fn>","metadata":{"arrowFunction":true}},{"type":"PROPERTY_ACCESS","id":"<arguments[0]>","metadata":{"objectName":"arguments","property":"0"}},{"type":"VARIABLE","id":"<arrowFromOuter>","metadata":{"kind":"const"}},{"type":"CALL","id":"<outerWithArguments(42)>","metadata":{"callee":"outerWithArguments"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<outerWithArguments>","dst":"<arrow>","type":"CONTAINS"},{"src":"<arrow>","dst":"<arrow:fn>","type":"ASSIGNED_FROM"},{"src":"<outerWithArguments>","dst":"<arrow:fn>","type":"RETURNS"},{"src":"<arrow:fn>","dst":"<arguments[0]>","type":"RETURNS"},{"src":"<arguments[0]>","dst":"<outerWithArguments>","type":"CAPTURES"},{"src":"<arrowFromOuter>","dst":"<outerWithArguments(42)>","type":"ASSIGNED_FROM"},{"src":"<outerWithArguments(42)>","dst":"<outerWithArguments>","type":"CALLS"},{"src":"<outerWithArguments(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Arrow function captures outer function's arguments object. The arrow function has no parameters but accesses the lexically scoped arguments from its containing function. Reduced edges by removing module-level declarations to focus on the core aliasing behavior.","implicitBehavior":["arrow function does not have its own arguments object","arguments reference lexically binds to outer function's arguments","arrow function inherits execution context from outer function"]},"pass":2,"annotatedAt":"2026-02-24T00:28:37.724Z"}
{"construct":{"id":"aliasing::arguments-param-aliasing","file":"src/aliasing.js","category":"aliasing","lineStart":116,"lineEnd":123,"code":"function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode  bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<argumentsAliasing>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"VARIABLE","id":"<arguments>","metadata":{"kind":"implicit","arrayLike":true}},{"type":"PROPERTY_ACCESS","id":"<arguments[0]>","metadata":{"objectName":"arguments","property":"0"}},{"type":"LITERAL","id":"<99>","metadata":{"value":99,"literalType":"number"}},{"type":"VARIABLE","id":"<aAfterMutation>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'changed'>","metadata":{"value":"changed","literalType":"string"}},{"type":"VARIABLE","id":"<arg0AfterReassign>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ aAfterMutation, arg0AfterReassign }>","metadata":{"type":"object"}}],"edges":[{"src":"<argumentsAliasing>","dst":"<a>","type":"CONTAINS"},{"src":"<argumentsAliasing>","dst":"<b>","type":"CONTAINS"},{"src":"<argumentsAliasing>","dst":"<arguments>","type":"CONTAINS"},{"src":"<arguments>","dst":"<a>","type":"ALIASES"},{"src":"<arguments>","dst":"<b>","type":"ALIASES"},{"src":"<arguments[0]>","dst":"<99>","type":"ASSIGNED_FROM"},{"src":"<a>","dst":"<arguments[0]>","type":"ALIASES"},{"src":"<argumentsAliasing>","dst":"<aAfterMutation>","type":"DECLARES"},{"src":"<aAfterMutation>","dst":"<a>","type":"ASSIGNED_FROM"},{"src":"<a>","dst":"<'changed'>","type":"ASSIGNED_FROM"},{"src":"<argumentsAliasing>","dst":"<arg0AfterReassign>","type":"DECLARES"},{"src":"<arg0AfterReassign>","dst":"<arguments[0]>","type":"ASSIGNED_FROM"},{"src":"<argumentsAliasing>","dst":"<{ aAfterMutation, arg0AfterReassign }>","type":"RETURNS"},{"src":"<{ aAfterMutation, arg0AfterReassign }>","dst":"<aAfterMutation>","type":"READS_FROM"},{"src":"<{ aAfterMutation, arg0AfterReassign }>","dst":"<arg0AfterReassign>","type":"READS_FROM"}],"rationale":"Function demonstrates bidirectional aliasing between parameters and arguments object in sloppy mode. Mutations to arguments[0] affect parameter a and vice versa. Used ALIASES for bidirectional relationship since approved vocabulary lacks specific bidirectional edge type.","implicitBehavior":["arguments object is implicitly created in non-arrow functions","bidirectional aliasing between parameters and arguments only occurs in sloppy mode","aliasing breaks if parameter is reassigned (strict mode behavior)","arguments object reflects current parameter values in sloppy mode"]},"pass":2,"annotatedAt":"2026-02-24T00:28:38.535Z"}
{"construct":{"id":"aliasing::arguments-param-aliasing","file":"src/aliasing.js","category":"aliasing","lineStart":116,"lineEnd":123,"code":"function argumentsAliasing(a, b) {\n  arguments[0] = 99;\n  const aAfterMutation = a; // 99 in sloppy mode  bidirectional alias\n  a = 'changed';\n  const arg0AfterReassign = arguments[0]; // 'changed' in sloppy mode\n  return { aAfterMutation, arg0AfterReassign };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<argumentsAliasing>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"VARIABLE","id":"<arguments>","metadata":{"kind":"implicit","arrayLike":true}},{"type":"PROPERTY_ACCESS","id":"<arguments[0]>","metadata":{"objectName":"arguments","property":"0"}},{"type":"LITERAL","id":"<99>","metadata":{"value":99,"literalType":"number"}},{"type":"VARIABLE","id":"<aAfterMutation>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'changed'>","metadata":{"value":"changed","literalType":"string"}},{"type":"VARIABLE","id":"<arg0AfterReassign>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ aAfterMutation, arg0AfterReassign }>","metadata":{"type":"object"}}],"edges":[{"src":"<argumentsAliasing>","dst":"<a>","type":"CONTAINS"},{"src":"<argumentsAliasing>","dst":"<b>","type":"CONTAINS"},{"src":"<argumentsAliasing>","dst":"<arguments>","type":"CONTAINS"},{"src":"<arguments>","dst":"<a>","type":"ALIASES"},{"src":"<arguments>","dst":"<b>","type":"ALIASES"},{"src":"<arguments[0]>","dst":"<99>","type":"ASSIGNED_FROM"},{"src":"<a>","dst":"<arguments[0]>","type":"ALIASES"},{"src":"<argumentsAliasing>","dst":"<aAfterMutation>","type":"DECLARES"},{"src":"<aAfterMutation>","dst":"<a>","type":"ASSIGNED_FROM"},{"src":"<a>","dst":"<'changed'>","type":"ASSIGNED_FROM"},{"src":"<argumentsAliasing>","dst":"<arg0AfterReassign>","type":"DECLARES"},{"src":"<arg0AfterReassign>","dst":"<arguments[0]>","type":"ASSIGNED_FROM"},{"src":"<argumentsAliasing>","dst":"<{ aAfterMutation, arg0AfterReassign }>","type":"RETURNS"},{"src":"<{ aAfterMutation, arg0AfterReassign }>","dst":"<aAfterMutation>","type":"READS_FROM"},{"src":"<{ aAfterMutation, arg0AfterReassign }>","dst":"<arg0AfterReassign>","type":"READS_FROM"}],"rationale":"Function demonstrates bidirectional aliasing between parameters and arguments object in sloppy mode. Mutations to arguments[0] affect parameter a and vice versa. Used ALIASES for bidirectional relationship.","implicitBehavior":["arguments object is implicitly created in non-arrow functions","bidirectional aliasing between parameters and arguments only occurs in sloppy mode","aliasing breaks if parameter is reassigned to different value","strict mode eliminates this aliasing behavior"]},"pass":2,"annotatedAt":"2026-02-24T00:28:40.403Z"}
{"construct":{"id":"aliasing::arguments-rest-coexistence","file":"src/aliasing.js","category":"aliasing","lineStart":134,"lineEnd":140,"code":"function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<argumentsWithRest>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<first>"},{"type":"PARAMETER","id":"<rest>","metadata":{"restParameter":true}},{"type":"VARIABLE","id":"<allCount>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<arguments.length>","metadata":{"objectName":"arguments","property":"length"}},{"type":"VARIABLE","id":"<firstFromArgs>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<arguments[0]>","metadata":{"objectName":"arguments","property":"0"}},{"type":"VARIABLE","id":"<restFromArgs>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<arguments[1]>","metadata":{"objectName":"arguments","property":"1"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}},{"type":"EXTERNAL","id":"<arguments>","metadata":{"implicitObject":true}}],"edges":[{"src":"<argumentsWithRest>","dst":"<first>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<rest>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<allCount>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<firstFromArgs>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<restFromArgs>","type":"CONTAINS"},{"src":"<allCount>","dst":"<arguments.length>","type":"ASSIGNED_FROM"},{"src":"<arguments.length>","dst":"<arguments>","type":"READS_FROM"},{"src":"<firstFromArgs>","dst":"<arguments[0]>","type":"ASSIGNED_FROM"},{"src":"<arguments[0]>","dst":"<arguments>","type":"READS_FROM"},{"src":"<restFromArgs>","dst":"<arguments[1]>","type":"ASSIGNED_FROM"},{"src":"<arguments[1]>","dst":"<arguments>","type":"READS_FROM"},{"src":"<argumentsWithRest>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<allCount>","type":"READS_FROM"},{"src":"<return-object>","dst":"<firstFromArgs>","type":"READS_FROM"},{"src":"<return-object>","dst":"<restFromArgs>","type":"READS_FROM"},{"src":"<return-object>","dst":"<rest>","type":"READS_FROM"}],"rationale":"Function with both rest parameter and arguments object access. The arguments object provides access to all parameters while rest parameter collects remaining args into an array. Removed the implicit binding edge as it's not in approved vocabulary.","implicitBehavior":["arguments object is automatically available in non-arrow functions","arguments object contains all passed arguments regardless of parameter declarations","rest parameter collects arguments beyond named parameters into an array","arguments[0] aliases the first parameter, arguments[1] aliases rest[0]","arguments object is implicitly bound to the function scope"]},"pass":2,"annotatedAt":"2026-02-24T00:28:41.482Z"}
{"construct":{"id":"async-generators::async-await-basic","file":"src/async-generators.js","category":"async-generators","lineStart":5,"lineEnd":10,"code":"async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fetchData>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch","awaited":true}},{"type":"EXTERNAL","id":"<fetch>","metadata":{"name":"fetch"}},{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const"}},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","awaited":true}},{"type":"PROPERTY_ACCESS","id":"<response.json>","metadata":{"objectName":"response","propertyName":"json"}}],"edges":[{"src":"<fetchData>","dst":"<url>","type":"CONTAINS"},{"src":"<fetchData>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url)>","dst":"<fetch>","type":"CALLS"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetchData>","dst":"<data>","type":"CONTAINS"},{"src":"<data>","dst":"<response.json()>","type":"ASSIGNED_FROM"},{"src":"<response.json()>","dst":"<response.json>","type":"CALLS"},{"src":"<response.json>","dst":"<response>","type":"READS_FROM"},{"src":"<fetchData>","dst":"<data>","type":"RETURNS"},{"src":"<fetchData>","dst":"<fetch(url)>","type":"AWAITS"},{"src":"<fetchData>","dst":"<response.json()>","type":"AWAITS"}],"rationale":"Async function with two await expressions. The function contains parameters and variables, awaits promise-returning calls, and returns the final result. Added explicit AWAITS edges to capture the async control flow dependencies.","implicitBehavior":["function returns Promise<T>","await expressions suspend execution until promise resolves","error propagation through promise rejection"]},"pass":2,"annotatedAt":"2026-02-24T00:28:41.909Z"}
{"construct":{"id":"aliasing::arguments-rest-coexistence","file":"src/aliasing.js","category":"aliasing","lineStart":134,"lineEnd":140,"code":"function argumentsWithRest(first, ...rest) {\n  const allCount = arguments.length;  // ALL args count (first + rest)\n  const firstFromArgs = arguments[0]; // same as `first`\n  const restFromArgs = arguments[1];  // same as rest[0]\n  return { allCount, firstFromArgs, restFromArgs, rest };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<argumentsWithRest>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<first>"},{"type":"PARAMETER","id":"<rest>","metadata":{"restParameter":true}},{"type":"VARIABLE","id":"<allCount>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<arguments.length>","metadata":{"objectName":"arguments","property":"length"}},{"type":"VARIABLE","id":"<firstFromArgs>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<arguments[0]>","metadata":{"objectName":"arguments","property":"0"}},{"type":"VARIABLE","id":"<restFromArgs>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<arguments[1]>","metadata":{"objectName":"arguments","property":"1"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}},{"type":"EXTERNAL","id":"<arguments>","metadata":{"implicitObject":true}}],"edges":[{"src":"<argumentsWithRest>","dst":"<first>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<rest>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<allCount>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<firstFromArgs>","type":"CONTAINS"},{"src":"<argumentsWithRest>","dst":"<restFromArgs>","type":"CONTAINS"},{"src":"<allCount>","dst":"<arguments.length>","type":"ASSIGNED_FROM"},{"src":"<arguments.length>","dst":"<arguments>","type":"READS_FROM"},{"src":"<firstFromArgs>","dst":"<arguments[0]>","type":"ASSIGNED_FROM"},{"src":"<arguments[0]>","dst":"<arguments>","type":"READS_FROM"},{"src":"<restFromArgs>","dst":"<arguments[1]>","type":"ASSIGNED_FROM"},{"src":"<arguments[1]>","dst":"<arguments>","type":"READS_FROM"},{"src":"<argumentsWithRest>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<allCount>","type":"READS_FROM"},{"src":"<return-object>","dst":"<firstFromArgs>","type":"READS_FROM"},{"src":"<return-object>","dst":"<restFromArgs>","type":"READS_FROM"},{"src":"<return-object>","dst":"<rest>","type":"READS_FROM"}],"rationale":"Function with both rest parameter and arguments object access. The arguments object provides access to all parameters while rest parameter collects remaining args into an array. Removed the implicit binding edge as it's not in approved vocabulary.","implicitBehavior":["arguments object is automatically available in non-arrow functions","arguments object contains all passed arguments regardless of parameter declarations","rest parameter collects arguments beyond named parameters into an array","arguments[0] aliases the first parameter, arguments[1] aliases rest[0]","arguments object is implicitly bound to the function scope"]},"pass":2,"annotatedAt":"2026-02-24T00:28:42.128Z"}
{"construct":{"id":"aliasing::export-named-list","file":"src/aliasing.js","category":"aliasing","lineStart":142,"lineEnd":171,"code":"export {\n  log,\n  parse,\n  stringify,\n  parsed,\n  mathObj,\n  methodName,\n  fn,\n  handler,\n  strategy,\n  applyToArray,\n  double,\n  getComparator,\n  cmp,\n  withLogging,\n  loggedAdd,\n  multiply,\n  doubleIt,\n  sum,\n  toArray,\n  factorial,\n  dynamicMod,\n  impl,\n  loadPlugin,\n  argumentsAliasing,\n  outerWithArguments,\n  arrowFromOuter,\n  argumentsWithRest,\n};","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"EXPORT\",\n      \"id\": \"<export-named-list>\",\n      \"metadata\": {\n        \"exportType\": \"named\"\n      }\n    },\n    {\n      \"type\": \"VARIABLE\",\n      \"id\": \"<l"},"pass":2,"annotatedAt":"2026-02-24T00:28:46.553Z"}
{"construct":{"id":"async-generators::async-await-basic","file":"src/async-generators.js","category":"async-generators","lineStart":5,"lineEnd":10,"code":"async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fetchData>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch","awaited":true}},{"type":"EXTERNAL","id":"<fetch>","metadata":{"name":"fetch"}},{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const"}},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","awaited":true}},{"type":"PROPERTY_ACCESS","id":"<response.json>","metadata":{"objectName":"response","propertyName":"json"}}],"edges":[{"src":"<fetchData>","dst":"<url>","type":"CONTAINS"},{"src":"<fetchData>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url)>","dst":"<fetch>","type":"CALLS"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetchData>","dst":"<data>","type":"CONTAINS"},{"src":"<data>","dst":"<response.json()>","type":"ASSIGNED_FROM"},{"src":"<response.json()>","dst":"<response.json>","type":"CALLS"},{"src":"<response.json>","dst":"<response>","type":"READS_FROM"},{"src":"<fetchData>","dst":"<data>","type":"RETURNS"},{"src":"<fetchData>","dst":"<fetch(url)>","type":"AWAITS"},{"src":"<fetchData>","dst":"<response.json()>","type":"AWAITS"}],"rationale":"Async function with two await expressions. The function contains parameters and variables, awaits promise-returning calls, and returns the final result. Added explicit AWAITS edges to capture the async control flow dependencies.","implicitBehavior":["function returns Promise<T>","await expressions suspend execution until promise resolves","error propagation through promise rejection"]},"pass":2,"annotatedAt":"2026-02-24T00:28:46.553Z"}
{"construct":{"id":"async-generators::async-arrow","file":"src/async-generators.js","category":"async-generators","lineStart":60,"lineEnd":63,"code":"const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncArrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncArrow:fn>","metadata":{"arrowFunction":true,"async":true}},{"type":"EXPRESSION","id":"<await Promise.resolve(42)>","metadata":{"operator":"await"}},{"type":"CALL","id":"<Promise.resolve(42)>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<asyncArrow>","type":"DECLARES"},{"src":"<asyncArrow>","dst":"<asyncArrow:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncArrow:fn>","dst":"<await Promise.resolve(42)>","type":"RETURNS"},{"src":"<await Promise.resolve(42)>","dst":"<Promise.resolve(42)>","type":"AWAITS"},{"src":"<Promise.resolve(42)>","dst":"<Promise>","type":"CALLS"},{"src":"<Promise.resolve(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Async arrow function assigned to const variable. Returns awaited result of Promise.resolve call with numeric literal. Changed READS_FROM to AWAITS to better capture the await relationship.","implicitBehavior":["function returns a Promise due to async","await suspends execution until Promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:28:48.082Z"}
{"construct":{"id":"async-generators::promise-construction","file":"src/async-generators.js","category":"async-generators","lineStart":26,"lineEnd":35,"code":"function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createPromise>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<shouldResolve>"},{"type":"CALL","id":"<new Promise(...)>","metadata":{"constructor":true,"callee":"Promise"}},{"type":"FUNCTION","id":"<executor>","metadata":{"arrowFunction":true,"executorFunction":true}},{"type":"PARAMETER","id":"<resolve>"},{"type":"PARAMETER","id":"<reject>"},{"type":"BRANCH","id":"<if-shouldResolve>","metadata":{"branchType":"if"}},{"type":"CALL","id":"<resolve('success')>","metadata":{"callee":"resolve"}},{"type":"LITERAL","id":"<'success'>","metadata":{"value":"success","literalType":"string"}},{"type":"CALL","id":"<reject(new Error('failure'))>","metadata":{"callee":"reject"}},{"type":"CALL","id":"<new Error('failure')>","metadata":{"constructor":true,"callee":"Error"}},{"type":"LITERAL","id":"<'failure'>","metadata":{"value":"failure","literalType":"string"}}],"edges":[{"src":"<createPromise>","dst":"<shouldResolve>","type":"HAS_BODY"},{"src":"<createPromise>","dst":"<new Promise(...)>","type":"RETURNS"},{"src":"<new Promise(...)>","dst":"<executor>","type":"PASSES_ARGUMENT"},{"src":"<executor>","dst":"<resolve>","type":"HAS_BODY"},{"src":"<executor>","dst":"<reject>","type":"HAS_BODY"},{"src":"<executor>","dst":"<if-shouldResolve>","type":"HAS_BODY"},{"src":"<if-shouldResolve>","dst":"<shouldResolve>","type":"HAS_CONDITION"},{"src":"<if-shouldResolve>","dst":"<resolve('success')>","type":"HAS_CONSEQUENT"},{"src":"<if-shouldResolve>","dst":"<reject(new Error('failure'))>","type":"HAS_ALTERNATE"},{"src":"<resolve('success')>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve('success')>","dst":"<'success'>","type":"PASSES_ARGUMENT"},{"src":"<reject(new Error('failure'))>","dst":"<reject>","type":"CALLS"},{"src":"<reject(new Error('failure'))>","dst":"<new Error('failure')>","type":"PASSES_ARGUMENT"},{"src":"<new Error('failure')>","dst":"<'failure'>","type":"PASSES_ARGUMENT"}],"rationale":"Function that constructs a Promise with an executor function. The executor receives resolve/reject callbacks and conditionally calls one based on the parameter. Used HAS_BODY for containment relationships where CONTAINS was not available.","implicitBehavior":["Promise constructor executes executor synchronously","resolve/reject callbacks are provided by Promise runtime","calling resolve/reject settles the promise asynchronously"]},"pass":2,"annotatedAt":"2026-02-24T00:28:50.439Z"}
{"construct":{"id":"async-generators::async-await-try-catch","file":"src/async-generators.js","category":"async-generators","lineStart":12,"lineEnd":24,"code":"async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fetchWithErrorHandling>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch","awaited":true}},{"type":"EXPRESSION","id":"<!response.ok>","metadata":{"operator":"!"}},{"type":"PROPERTY_ACCESS","id":"<response.ok>"},{"type":"BRANCH","id":"<if-not-ok>"},{"type":"CALL","id":"<new Error>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<`HTTP ${response.status}`>","metadata":{"value":"template","literalType":"template"}},{"type":"PROPERTY_ACCESS","id":"<response.status>"},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","awaited":true}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<error>"},{"type":"CALL","id":"<console.error>","metadata":{"callee":"console.error"}},{"type":"LITERAL","id":"<'Fetch failed:'>","metadata":{"value":"Fetch failed:","literalType":"string"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<fetchWithErrorHandling>","dst":"<url>","type":"CONTAINS"},{"src":"<fetchWithErrorHandling>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<fetchWithErrorHandling>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<try-block>","dst":"<if-not-ok>","type":"CONTAINS"},{"src":"<if-not-ok>","dst":"<!response.ok>","type":"HAS_CONDITION"},{"src":"<!response.ok>","dst":"<response.ok>","type":"READS_FROM"},{"src":"<response.ok>","dst":"<response>","type":"READS_FROM"},{"src":"<if-not-ok>","dst":"<new Error>","type":"THROWS"},{"src":"<new Error>","dst":"<`HTTP ${response.status}`>","type":"PASSES_ARGUMENT"},{"src":"<`HTTP ${response.status}`>","dst":"<response.status>","type":"READS_FROM"},{"src":"<response.status>","dst":"<response>","type":"READS_FROM"},{"src":"<try-block>","dst":"<response.json()>","type":"RETURNS"},{"src":"<response.json()>","dst":"<response>","type":"CALLS_ON"},{"src":"<catch-block>","dst":"<error>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<console.error>","type":"CONTAINS"},{"src":"<console.error>","dst":"<'Fetch failed:'>","type":"PASSES_ARGUMENT"},{"src":"<console.error>","dst":"<error>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<null>","type":"RETURNS"},{"src":"<catch-block>","dst":"<try-block>","type":"CATCHES_FROM"},{"src":"<fetch(url)>","dst":"<fetchWithErrorHandling>","type":"AWAITS"},{"src":"<response.json()>","dst":"<fetchWithErrorHandling>","type":"AWAITS"}],"rationale":"Async function with try-catch error handling. Try block awaits fetch call, checks response status, and returns parsed JSON. Catch block logs error and returns null fallback. Used approved vocabulary throughout - HAS_BODY for function body, CALLS_ON for method calls, AWAITS to show async relationships.","implicitBehavior":["async function returns Promise","await suspends execution until Promise resolves","thrown errors bubble up to catch block","template literal performs string interpolation"]},"pass":2,"annotatedAt":"2026-02-24T00:28:50.955Z"}
{"construct":{"id":"aliasing::export-named-list","file":"src/aliasing.js","category":"aliasing","lineStart":142,"lineEnd":171,"code":"export {\n  log,\n  parse,\n  stringify,\n  parsed,\n  mathObj,\n  methodName,\n  fn,\n  handler,\n  strategy,\n  applyToArray,\n  double,\n  getComparator,\n  cmp,\n  withLogging,\n  loggedAdd,\n  multiply,\n  doubleIt,\n  sum,\n  toArray,\n  factorial,\n  dynamicMod,\n  impl,\n  loadPlugin,\n  argumentsAliasing,\n  outerWithArguments,\n  arrowFromOuter,\n  argumentsWithRest,\n};","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"EXPORT\",\n      \"id\": \"<export-named-list>\",\n      \"metadata\": {\n        \"exportType\": \"named\"\n      }\n    },\n    {\n      \"type\": \"VARIABLE\",\n      \"id\": \"<l"},"pass":2,"annotatedAt":"2026-02-24T00:28:51.375Z"}
{"construct":{"id":"async-generators::promise-construction","file":"src/async-generators.js","category":"async-generators","lineStart":26,"lineEnd":35,"code":"function createPromise(shouldResolve) {\n  return new Promise((resolve, reject) => {\n    if (shouldResolve) {\n      resolve('success');\n    } else {\n      reject(new Error('failure'));\n    }\n  });\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createPromise>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<shouldResolve>"},{"type":"CALL","id":"<new Promise(...)>","metadata":{"constructor":true,"callee":"Promise"}},{"type":"FUNCTION","id":"<executor>","metadata":{"arrowFunction":true,"executorFunction":true}},{"type":"PARAMETER","id":"<resolve>"},{"type":"PARAMETER","id":"<reject>"},{"type":"BRANCH","id":"<if-shouldResolve>","metadata":{"branchType":"if"}},{"type":"CALL","id":"<resolve('success')>","metadata":{"callee":"resolve"}},{"type":"LITERAL","id":"<'success'>","metadata":{"value":"success","literalType":"string"}},{"type":"CALL","id":"<reject(new Error('failure'))>","metadata":{"callee":"reject"}},{"type":"CALL","id":"<new Error('failure')>","metadata":{"constructor":true,"callee":"Error"}},{"type":"LITERAL","id":"<'failure'>","metadata":{"value":"failure","literalType":"string"}}],"edges":[{"src":"<createPromise>","dst":"<shouldResolve>","type":"HAS_BODY"},{"src":"<createPromise>","dst":"<new Promise(...)>","type":"RETURNS"},{"src":"<new Promise(...)>","dst":"<executor>","type":"PASSES_ARGUMENT"},{"src":"<executor>","dst":"<resolve>","type":"HAS_BODY"},{"src":"<executor>","dst":"<reject>","type":"HAS_BODY"},{"src":"<executor>","dst":"<if-shouldResolve>","type":"HAS_BODY"},{"src":"<if-shouldResolve>","dst":"<shouldResolve>","type":"HAS_CONDITION"},{"src":"<if-shouldResolve>","dst":"<resolve('success')>","type":"HAS_CONSEQUENT"},{"src":"<if-shouldResolve>","dst":"<reject(new Error('failure'))>","type":"HAS_ALTERNATE"},{"src":"<resolve('success')>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve('success')>","dst":"<'success'>","type":"PASSES_ARGUMENT"},{"src":"<reject(new Error('failure'))>","dst":"<reject>","type":"CALLS"},{"src":"<reject(new Error('failure'))>","dst":"<new Error('failure')>","type":"PASSES_ARGUMENT"},{"src":"<new Error('failure')>","dst":"<'failure'>","type":"PASSES_ARGUMENT"}],"rationale":"Function that constructs a Promise with an executor function. The executor receives resolve/reject callbacks and conditionally calls one based on the parameter. Used HAS_BODY for containment relationships where CONTAINS was not available.","implicitBehavior":["Promise constructor executes executor synchronously","resolve/reject callbacks are provided by Promise runtime","calling resolve/reject settles the promise asynchronously"]},"pass":2,"annotatedAt":"2026-02-24T00:28:52.806Z"}
{"construct":{"id":"async-generators::async-arrow","file":"src/async-generators.js","category":"async-generators","lineStart":60,"lineEnd":63,"code":"const asyncArrow = async () => {\n  return await Promise.resolve(42);\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncArrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncArrow:fn>","metadata":{"arrowFunction":true,"async":true}},{"type":"EXPRESSION","id":"<await Promise.resolve(42)>","metadata":{"operator":"await"}},{"type":"CALL","id":"<Promise.resolve(42)>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<asyncArrow>","type":"DECLARES"},{"src":"<asyncArrow>","dst":"<asyncArrow:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncArrow:fn>","dst":"<await Promise.resolve(42)>","type":"RETURNS"},{"src":"<await Promise.resolve(42)>","dst":"<Promise.resolve(42)>","type":"AWAITS"},{"src":"<Promise.resolve(42)>","dst":"<Promise>","type":"CALLS"},{"src":"<Promise.resolve(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Async arrow function assigned to const variable. Returns awaited result of Promise.resolve call with numeric literal. Changed READS_FROM to AWAITS to better capture the await relationship.","implicitBehavior":["function returns a Promise due to async","await suspends execution until Promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:28:52.861Z"}
{"construct":{"id":"async-generators::async-await-try-catch","file":"src/async-generators.js","category":"async-generators","lineStart":12,"lineEnd":24,"code":"async function fetchWithErrorHandling(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return null;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fetchWithErrorHandling>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch","awaited":true}},{"type":"EXPRESSION","id":"<!response.ok>","metadata":{"operator":"!"}},{"type":"PROPERTY_ACCESS","id":"<response.ok>"},{"type":"BRANCH","id":"<if-not-ok>"},{"type":"CALL","id":"<new Error>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<`HTTP ${response.status}`>","metadata":{"value":"template","literalType":"template"}},{"type":"PROPERTY_ACCESS","id":"<response.status>"},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","awaited":true}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<error>"},{"type":"CALL","id":"<console.error>","metadata":{"callee":"console.error"}},{"type":"LITERAL","id":"<'Fetch failed:'>","metadata":{"value":"Fetch failed:","literalType":"string"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<fetchWithErrorHandling>","dst":"<url>","type":"CONTAINS"},{"src":"<fetchWithErrorHandling>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<fetchWithErrorHandling>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<try-block>","dst":"<if-not-ok>","type":"CONTAINS"},{"src":"<if-not-ok>","dst":"<!response.ok>","type":"HAS_CONDITION"},{"src":"<!response.ok>","dst":"<response.ok>","type":"READS_FROM"},{"src":"<response.ok>","dst":"<response>","type":"READS_FROM"},{"src":"<if-not-ok>","dst":"<new Error>","type":"THROWS"},{"src":"<new Error>","dst":"<`HTTP ${response.status}`>","type":"PASSES_ARGUMENT"},{"src":"<`HTTP ${response.status}`>","dst":"<response.status>","type":"READS_FROM"},{"src":"<response.status>","dst":"<response>","type":"READS_FROM"},{"src":"<try-block>","dst":"<response.json()>","type":"RETURNS"},{"src":"<response.json()>","dst":"<response>","type":"CALLS_ON"},{"src":"<catch-block>","dst":"<error>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<console.error>","type":"CONTAINS"},{"src":"<console.error>","dst":"<'Fetch failed:'>","type":"PASSES_ARGUMENT"},{"src":"<console.error>","dst":"<error>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<null>","type":"RETURNS"},{"src":"<catch-block>","dst":"<try-block>","type":"CATCHES_FROM"},{"src":"<fetch(url)>","dst":"<fetchWithErrorHandling>","type":"AWAITS"},{"src":"<response.json()>","dst":"<fetchWithErrorHandling>","type":"AWAITS"}],"rationale":"Async function with try-catch error handling. Try block awaits fetch call, checks response status, and returns parsed JSON. Catch block logs error and returns null fallback. Used approved vocabulary throughout - HAS_BODY for function body, CALLS_ON for method calls, AWAITS to show async relationships.","implicitBehavior":["async function returns Promise","await suspends execution until Promise resolves","thrown errors bubble up to catch block","template literal performs string interpolation"]},"pass":2,"annotatedAt":"2026-02-24T00:28:54.637Z"}
{"construct":{"id":"async-generators::async-arrow-with-params","file":"src/async-generators.js","category":"async-generators","lineStart":65,"lineEnd":69,"code":"const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncArrowWithParams>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncArrowWithParams:fn>","metadata":{"arrowFunction":true,"async":true}},{"type":"PARAMETER","id":"<url>"},{"type":"PARAMETER","id":"<options>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url, options)>","metadata":{"callee":"fetch","awaited":true}},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","method":true}}],"edges":[{"src":"<asyncArrowWithParams>","dst":"<asyncArrowWithParams:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncArrowWithParams:fn>","dst":"<url>","type":"CONTAINS"},{"src":"<asyncArrowWithParams:fn>","dst":"<options>","type":"CONTAINS"},{"src":"<asyncArrowWithParams:fn>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url, options)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url, options)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetch(url, options)>","dst":"<options>","type":"PASSES_ARGUMENT"},{"src":"<response.json()>","dst":"<response>","type":"CALLS_ON"},{"src":"<asyncArrowWithParams:fn>","dst":"<response.json()>","type":"RETURNS"},{"src":"<asyncArrowWithParams:fn>","dst":"<fetch(url, options)>","type":"AWAITS"}],"rationale":"Async arrow function with parameters. Contains awaited fetch call assigned to const variable, then returns result of method call on that variable. Reduced edge count by removing module declaration edge and using CALLS_ON for method calls and AWAITS for async operations.","implicitBehavior":["function returns Promise due to async","await suspends execution until fetch resolves","response.json() also returns Promise that gets awaited implicitly by return"]},"pass":2,"annotatedAt":"2026-02-24T00:28:55.680Z"}
{"construct":{"id":"async-generators::generator-basic","file":"src/async-generators.js","category":"async-generators","lineStart":71,"lineEnd":76,"code":"function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<counter>","metadata":{"generator":true,"async":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i <= end>","metadata":{"operator":"<="}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<yield i>"}],"edges":[{"src":"<counter>","dst":"<start>","type":"CONTAINS"},{"src":"<counter>","dst":"<end>","type":"CONTAINS"},{"src":"<counter>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<start>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i <= end>","type":"HAS_CONDITION"},{"src":"<i <= end>","dst":"<i>","type":"READS_FROM"},{"src":"<i <= end>","dst":"<end>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<yield i>","type":"HAS_BODY"},{"src":"<yield i>","dst":"<i>","type":"READS_FROM"},{"src":"<counter>","dst":"<yield i>","type":"YIELDS"}],"rationale":"Generator function with for-loop that yields each iteration value. Function contains parameters and loop structure, with yield expression producing values. Removed module declaration edge as no module node was defined.","implicitBehavior":["function declaration is hoisted","generator returns iterator object","yield suspends execution and produces value","loop variable i is block-scoped to for-loop"]},"pass":2,"annotatedAt":"2026-02-24T00:28:56.287Z"}
{"construct":{"id":"async-generators::promise-chaining","file":"src/async-generators.js","category":"async-generators","lineStart":51,"lineEnd":58,"code":"function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<promiseChaining>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch"}},{"type":"CALL","id":"<.then(response => response.json())>","metadata":{"method":"then"}},{"type":"FUNCTION","id":"<response => response.json()>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<response>"},{"type":"CALL","id":"<response.json()>","metadata":{"method":"json"}},{"type":"CALL","id":"<.then(data => data.result)>","metadata":{"method":"then"}},{"type":"FUNCTION","id":"<data => data.result>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<data>"},{"type":"PROPERTY_ACCESS","id":"<data.result>","metadata":{"property":"result"}},{"type":"CALL","id":"<.catch(error => console.error(error))>","metadata":{"method":"catch"}},{"type":"FUNCTION","id":"<error => console.error(error)>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<error>"},{"type":"CALL","id":"<console.error(error)>","metadata":{"callee":"console.error"}},{"type":"CALL","id":"<.finally(() => console.log('done'))>","metadata":{"method":"finally"}},{"type":"FUNCTION","id":"<() => console.log('done')>","metadata":{"arrowFunction":true}},{"type":"CALL","id":"<console.log('done')>","metadata":{"callee":"console.log"}},{"type":"LITERAL","id":"<'done'>","metadata":{"value":"done","literalType":"string"}}],"edges":[{"src":"<promiseChaining>","dst":"<url>","type":"CONTAINS"},{"src":"<promiseChaining>","dst":"<fetch(url)>","type":"RETURNS"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetch(url)>","dst":"<.then(response => response.json())>","type":"CHAINS_FROM"},{"src":"<.then(response => response.json())>","dst":"<response => response.json()>","type":"PASSES_ARGUMENT"},{"src":"<response => response.json()>","dst":"<response>","type":"CONTAINS"},{"src":"<response => response.json()>","dst":"<response.json()>","type":"RETURNS"},{"src":"<response.json()>","dst":"<response>","type":"READS_FROM"},{"src":"<.then(response => response.json())>","dst":"<.then(data => data.result)>","type":"CHAINS_FROM"},{"src":"<.then(data => data.result)>","dst":"<data => data.result>","type":"PASSES_ARGUMENT"},{"src":"<data => data.result>","dst":"<data>","type":"CONTAINS"},{"src":"<data => data.result>","dst":"<data.result>","type":"RETURNS"},{"src":"<data.result>","dst":"<data>","type":"READS_FROM"},{"src":"<.then(data => data.result)>","dst":"<.catch(error => console.error(error))>","type":"CHAINS_FROM"},{"src":"<.catch(error => console.error(error))>","dst":"<error => console.error(error)>","type":"PASSES_ARGUMENT"},{"src":"<error => console.error(error)>","dst":"<error>","type":"CONTAINS"},{"src":"<error => console.error(error)>","dst":"<console.error(error)>","type":"RETURNS"},{"src":"<console.error(error)>","dst":"<error>","type":"PASSES_ARGUMENT"},{"src":"<.catch(error => console.error(error))>","dst":"<.finally(() => console.log('done'))>","type":"CHAINS_FROM"},{"src":"<.finally(() => console.log('done'))>","dst":"<() => console.log('done')>","type":"PASSES_ARGUMENT"},{"src":"<() => console.log('done')>","dst":"<console.log('done')>","type":"RETURNS"},{"src":"<console.log('done')>","dst":"<'done'>","type":"PASSES_ARGUMENT"}],"rationale":"Promise chain with fetch, two then handlers, catch handler, and finally handler. Each method call creates a new promise that chains to the next handler. Used CHAINS_FROM instead of CHAINS_TO to maintain approved vocabulary.","implicitBehavior":["Promise chain creates implicit async execution flow","Each then/catch/finally returns a new Promise","Error propagation through the chain until caught","Finally handler executes regardless of success/failure"]},"pass":2,"annotatedAt":"2026-02-24T00:28:59.197Z"}
{"construct":{"id":"async-generators::async-arrow-with-params","file":"src/async-generators.js","category":"async-generators","lineStart":65,"lineEnd":69,"code":"const asyncArrowWithParams = async (url, options) => {\n  const response = await fetch(url, options);\n  return response.json();\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncArrowWithParams>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncArrowWithParams:fn>","metadata":{"arrowFunction":true,"async":true}},{"type":"PARAMETER","id":"<url>"},{"type":"PARAMETER","id":"<options>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url, options)>","metadata":{"callee":"fetch","awaited":true}},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","method":true}}],"edges":[{"src":"<asyncArrowWithParams>","dst":"<asyncArrowWithParams:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncArrowWithParams:fn>","dst":"<url>","type":"CONTAINS"},{"src":"<asyncArrowWithParams:fn>","dst":"<options>","type":"CONTAINS"},{"src":"<asyncArrowWithParams:fn>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url, options)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url, options)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetch(url, options)>","dst":"<options>","type":"PASSES_ARGUMENT"},{"src":"<response.json()>","dst":"<response>","type":"CALLS_ON"},{"src":"<asyncArrowWithParams:fn>","dst":"<response.json()>","type":"RETURNS"},{"src":"<asyncArrowWithParams:fn>","dst":"<fetch(url, options)>","type":"AWAITS"}],"rationale":"Async arrow function with parameters. Contains awaited fetch call assigned to const variable, then returns result of method call on that variable. Reduced edge count by removing module declaration edge and using CALLS_ON for method calls and AWAITS for async operations.","implicitBehavior":["function returns Promise due to async","await suspends execution until fetch resolves","response.json() also returns Promise that gets awaited implicitly by return"]},"pass":2,"annotatedAt":"2026-02-24T00:28:59.742Z"}
{"construct":{"id":"async-generators::generator-basic","file":"src/async-generators.js","category":"async-generators","lineStart":71,"lineEnd":76,"code":"function* counter(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<counter>","metadata":{"generator":true,"async":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i <= end>","metadata":{"operator":"<="}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<yield i>"}],"edges":[{"src":"<counter>","dst":"<start>","type":"CONTAINS"},{"src":"<counter>","dst":"<end>","type":"CONTAINS"},{"src":"<counter>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<start>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i <= end>","type":"HAS_CONDITION"},{"src":"<i <= end>","dst":"<i>","type":"READS_FROM"},{"src":"<i <= end>","dst":"<end>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<yield i>","type":"HAS_BODY"},{"src":"<yield i>","dst":"<i>","type":"READS_FROM"},{"src":"<counter>","dst":"<yield i>","type":"YIELDS"}],"rationale":"Generator function with for-loop that yields each iteration value. Function contains parameters and loop structure, with yield expression producing values. Removed module declaration edge as no module node was defined.","implicitBehavior":["function declaration is hoisted","generator returns iterator object","yield suspends execution and produces value","loop variable i is block-scoped to for-loop"]},"pass":2,"annotatedAt":"2026-02-24T00:28:59.775Z"}
{"construct":{"id":"async-generators::promise-chaining","file":"src/async-generators.js","category":"async-generators","lineStart":51,"lineEnd":58,"code":"function promiseChaining(url) {\n  return fetch(url)\n    .then(response => response.json())\n    .then(data => data.result)\n    .catch(error => console.error(error))\n    .finally(() => console.log('done'));\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<promiseChaining>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch"}},{"type":"CALL","id":"<.then(response => response.json())>","metadata":{"method":"then"}},{"type":"FUNCTION","id":"<response => response.json()>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<response>"},{"type":"CALL","id":"<response.json()>","metadata":{"method":"json"}},{"type":"CALL","id":"<.then(data => data.result)>","metadata":{"method":"then"}},{"type":"FUNCTION","id":"<data => data.result>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<data>"},{"type":"PROPERTY_ACCESS","id":"<data.result>","metadata":{"property":"result"}},{"type":"CALL","id":"<.catch(error => console.error(error))>","metadata":{"method":"catch"}},{"type":"FUNCTION","id":"<error => console.error(error)>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<error>"},{"type":"CALL","id":"<console.error(error)>","metadata":{"callee":"console.error"}},{"type":"CALL","id":"<.finally(() => console.log('done'))>","metadata":{"method":"finally"}},{"type":"FUNCTION","id":"<() => console.log('done')>","metadata":{"arrowFunction":true}},{"type":"CALL","id":"<console.log('done')>","metadata":{"callee":"console.log"}},{"type":"LITERAL","id":"<'done'>","metadata":{"value":"done","literalType":"string"}}],"edges":[{"src":"<promiseChaining>","dst":"<url>","type":"CONTAINS"},{"src":"<promiseChaining>","dst":"<fetch(url)>","type":"RETURNS"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetch(url)>","dst":"<.then(response => response.json())>","type":"CHAINS_FROM"},{"src":"<.then(response => response.json())>","dst":"<response => response.json()>","type":"PASSES_ARGUMENT"},{"src":"<response => response.json()>","dst":"<response>","type":"CONTAINS"},{"src":"<response => response.json()>","dst":"<response.json()>","type":"RETURNS"},{"src":"<response.json()>","dst":"<response>","type":"READS_FROM"},{"src":"<.then(response => response.json())>","dst":"<.then(data => data.result)>","type":"CHAINS_FROM"},{"src":"<.then(data => data.result)>","dst":"<data => data.result>","type":"PASSES_ARGUMENT"},{"src":"<data => data.result>","dst":"<data>","type":"CONTAINS"},{"src":"<data => data.result>","dst":"<data.result>","type":"RETURNS"},{"src":"<data.result>","dst":"<data>","type":"READS_FROM"},{"src":"<.then(data => data.result)>","dst":"<.catch(error => console.error(error))>","type":"CHAINS_FROM"},{"src":"<.catch(error => console.error(error))>","dst":"<error => console.error(error)>","type":"PASSES_ARGUMENT"},{"src":"<error => console.error(error)>","dst":"<error>","type":"CONTAINS"},{"src":"<error => console.error(error)>","dst":"<console.error(error)>","type":"RETURNS"},{"src":"<console.error(error)>","dst":"<error>","type":"PASSES_ARGUMENT"},{"src":"<.catch(error => console.error(error))>","dst":"<.finally(() => console.log('done'))>","type":"CHAINS_FROM"},{"src":"<.finally(() => console.log('done'))>","dst":"<() => console.log('done')>","type":"PASSES_ARGUMENT"},{"src":"<() => console.log('done')>","dst":"<console.log('done')>","type":"RETURNS"},{"src":"<console.log('done')>","dst":"<'done'>","type":"PASSES_ARGUMENT"}],"rationale":"Promise chain with fetch, two then handlers, catch handler, and finally handler. Each method call creates a new promise that chains to the next handler. Used CHAINS_FROM instead of CHAINS_TO to maintain approved vocabulary.","implicitBehavior":["Promise chain creates implicit async execution flow","Each then/catch/finally returns a new Promise","Error propagation through the chain until caught","Finally handler executes regardless of success/failure"]},"pass":2,"annotatedAt":"2026-02-24T00:28:59.789Z"}
{"construct":{"id":"async-generators::generator-delegation","file":"src/async-generators.js","category":"async-generators","lineStart":87,"lineEnd":97,"code":"function* innerGenerator() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* outerGenerator() {\n  yield 1;\n  yield* innerGenerator();\n  yield 2;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<innerGenerator>","metadata":{"generator":true,"async":false}},{"type":"LITERAL","id":"<'a'>","metadata":{"value":"a","literalType":"string"}},{"type":"LITERAL","id":"<'b'>","metadata":{"value":"b","literalType":"string"}},{"type":"FUNCTION","id":"<outerGenerator>","metadata":{"generator":true,"async":false}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<innerGenerator()>","metadata":{"callee":"innerGenerator"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<innerGenerator>","dst":"<'a'>","type":"YIELDS"},{"src":"<innerGenerator>","dst":"<'b'>","type":"YIELDS"},{"src":"<outerGenerator>","dst":"<1>","type":"YIELDS"},{"src":"<outerGenerator>","dst":"<innerGenerator()>","type":"DELEGATES_TO"},{"src":"<innerGenerator()>","dst":"<innerGenerator>","type":"CALLS"},{"src":"<outerGenerator>","dst":"<2>","type":"YIELDS"}],"rationale":"Two generator functions where outerGenerator delegates to innerGenerator using yield*. The delegation passes through all values from the inner generator. Removed module-level DECLARES edges to stay within edge count threshold while preserving the core delegation semantics.","implicitBehavior":["yield* delegates iteration protocol to inner generator","generator function declarations are hoisted","yield* flattens the generator hierarchy for consumers","functions are implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:29:00.473Z"}
{"construct":{"id":"async-generators::top-level-await","file":"src/async-generators.js","category":"async-generators","lineStart":116,"lineEnd":117,"code":"const config = await import('./declarations.js');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<config>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<await import('./declarations.js')>","metadata":{"async":true,"operator":"await"}},{"type":"CALL","id":"<import('./declarations.js')>","metadata":{"callee":"import","dynamic":true}},{"type":"LITERAL","id":"<'./declarations.js'>","metadata":{"value":"./declarations.js","literalType":"string"}},{"type":"EXTERNAL_MODULE","id":"<./declarations.js>","metadata":{"path":"./declarations.js"}}],"edges":[{"src":"<config>","dst":"<await import('./declarations.js')>","type":"ASSIGNED_FROM"},{"src":"<await import('./declarations.js')>","dst":"<import('./declarations.js')>","type":"AWAITS"},{"src":"<import('./declarations.js')>","dst":"<'./declarations.js'>","type":"PASSES_ARGUMENT"},{"src":"<import('./declarations.js')>","dst":"<./declarations.js>","type":"IMPORTS_FROM"}],"rationale":"Top-level await of dynamic import. Variable assigned from awaited promise that resolves to module exports. The EXTERNAL_MODULE node represents the target module being dynamically imported.","implicitBehavior":["top-level await makes module async","dynamic import returns a promise","module loading is deferred until runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:29:00.520Z"}
{"construct":{"id":"async-generators::generator-infinite","file":"src/async-generators.js","category":"async-generators","lineStart":78,"lineEnd":85,"code":"function* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fibonacci>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LOOP","id":"<while-true>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<yield-a>","metadata":{"operator":"yield"}},{"type":"EXPRESSION","id":"<a-plus-b>","metadata":{"operator":"+"}},{"type":"EXPRESSION","id":"<destructure-array>","metadata":{"type":"array"}}],"edges":[{"src":"<fibonacci>","dst":"<a>","type":"CONTAINS"},{"src":"<fibonacci>","dst":"<b>","type":"CONTAINS"},{"src":"<a>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<b>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<fibonacci>","dst":"<while-true>","type":"CONTAINS"},{"src":"<while-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<while-true>","dst":"<yield-a>","type":"CONTAINS"},{"src":"<while-true>","dst":"<destructure-array>","type":"CONTAINS"},{"src":"<yield-a>","dst":"<a>","type":"READS_FROM"},{"src":"<fibonacci>","dst":"<yield-a>","type":"YIELDS"},{"src":"<a-plus-b>","dst":"<a>","type":"READS_FROM"},{"src":"<a-plus-b>","dst":"<b>","type":"READS_FROM"},{"src":"<destructure-array>","dst":"<b>","type":"READS_FROM"},{"src":"<destructure-array>","dst":"<a-plus-b>","type":"READS_FROM"},{"src":"<a>","dst":"<destructure-array>","type":"ASSIGNED_FROM"},{"src":"<b>","dst":"<destructure-array>","type":"ASSIGNED_FROM"}],"rationale":"Generator function with infinite loop that yields Fibonacci sequence values. Uses destructuring assignment for both initialization and updates within the loop. All relationships captured using approved vocabulary.","implicitBehavior":["generator function returns iterator object","yield suspends execution and returns value to caller","infinite loop requires external break/return to terminate","destructuring assignment creates temporary array"]},"pass":2,"annotatedAt":"2026-02-24T00:29:01.543Z"}
{"construct":{"id":"async-generators::async-return-thenable","file":"src/async-generators.js","category":"async-generators","lineStart":151,"lineEnd":158,"code":"async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<returnsThenable>","metadata":{"async":true,"generator":false}},{"type":"EXPRESSION","id":"<thenable-object>","metadata":{"thenable":true,"expressionType":"object_literal"}},{"type":"METHOD","id":"<then>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<resolve>"},{"type":"CALL","id":"<resolve(42)>","metadata":{"callee":"resolve"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<returnsThenable>","dst":"<thenable-object>","type":"RETURNS"},{"src":"<thenable-object>","dst":"<then>","type":"HAS_PROPERTY"},{"src":"<then>","dst":"<resolve>","type":"HAS_BODY"},{"src":"<then>","dst":"<resolve(42)>","type":"HAS_BODY"},{"src":"<resolve(42)>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Async function returns a thenable object with a then method that calls resolve with 42. Used EXPRESSION for object literal and HAS_BODY for method parameter/body containment.","implicitBehavior":["async function wraps return value in Promise","thenable object will be awaited/resolved by Promise machinery","resolve callback fulfills the promise with the passed value"]},"pass":2,"annotatedAt":"2026-02-24T00:29:04.366Z"}
{"construct":{"id":"async-generators::generator-return-throw","file":"src/async-generators.js","category":"async-generators","lineStart":128,"lineEnd":136,"code":"function* generatorReturnThrow() {\n  try {\n    yield 1;\n    yield 2;\n  } finally {\n    yield 'cleanup';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<generatorReturnThrow>","metadata":{"async":false,"generator":true}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"EXPRESSION","id":"<yield 1>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield 2>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield 'cleanup'>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<'cleanup'>","metadata":{"value":"cleanup","literalType":"string"}}],"edges":[{"src":"<generatorReturnThrow>","dst":"<try-block>","type":"CONTAINS"},{"src":"<generatorReturnThrow>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<yield 1>","type":"CONTAINS"},{"src":"<try-block>","dst":"<yield 2>","type":"CONTAINS"},{"src":"<yield 1>","dst":"<1>","type":"RETURNS"},{"src":"<yield 2>","dst":"<2>","type":"RETURNS"},{"src":"<finally-block>","dst":"<yield 'cleanup'>","type":"CONTAINS"},{"src":"<yield 'cleanup'>","dst":"<'cleanup'>","type":"RETURNS"}],"rationale":"Generator function with try-finally structure. Yields values in try block and cleanup value in finally block. Used RETURNS instead of YIELDS as closest approved edge type.","implicitBehavior":["generator function creates iterator object","finally block executes on return/throw","yield expressions suspend execution and produce values"]},"pass":2,"annotatedAt":"2026-02-24T00:29:05.190Z"}
{"construct":{"id":"async-generators::async-generator","file":"src/async-generators.js","category":"async-generators","lineStart":99,"lineEnd":105,"code":"async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<asyncCounter>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i <= end>","metadata":{"operator":"<="}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<await new Promise(resolve => setTimeout(resolve, 100))>"},{"type":"CALL","id":"<new Promise(resolve => setTimeout(resolve, 100))>","metadata":{"callee":"Promise","constructor":true}},{"type":"FUNCTION","id":"<resolve => setTimeout(resolve, 100)>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<resolve>"},{"type":"CALL","id":"<setTimeout(resolve, 100)>","metadata":{"callee":"setTimeout"}},{"type":"LITERAL","id":"<100>","metadata":{"value":100,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield i>"}],"edges":[{"src":"<asyncCounter>","dst":"<start>","type":"CONTAINS"},{"src":"<asyncCounter>","dst":"<end>","type":"CONTAINS"},{"src":"<asyncCounter>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<start>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i <= end>","type":"HAS_CONDITION"},{"src":"<i <= end>","dst":"<i>","type":"READS_FROM"},{"src":"<i <= end>","dst":"<end>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<await new Promise(resolve => setTimeout(resolve, 100))>","type":"HAS_BODY"},{"src":"<for-loop>","dst":"<yield i>","type":"HAS_BODY"},{"src":"<await new Promise(resolve => setTimeout(resolve, 100))>","dst":"<new Promise(resolve => setTimeout(resolve, 100))>","type":"AWAITS"},{"src":"<new Promise(resolve => setTimeout(resolve, 100))>","dst":"<resolve => setTimeout(resolve, 100)>","type":"PASSES_ARGUMENT"},{"src":"<resolve => setTimeout(resolve, 100)>","dst":"<resolve>","type":"CONTAINS"},{"src":"<resolve => setTimeout(resolve, 100)>","dst":"<setTimeout(resolve, 100)>","type":"RETURNS"},{"src":"<setTimeout(resolve, 100)>","dst":"<resolve>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(resolve, 100)>","dst":"<100>","type":"PASSES_ARGUMENT"},{"src":"<yield i>","dst":"<i>","type":"YIELDS"},{"src":"<asyncCounter>","dst":"<yield i>","type":"YIELDS"}],"rationale":"Async generator function that yields values after awaiting promises. Contains for loop with initialization, condition, and update. Yields loop variable after async delay. Changed READS_FROM to AWAITS for the await expression to better capture the async relationship.","implicitBehavior":["function returns AsyncGenerator object","yield suspends execution and returns IteratorResult","await suspends until Promise resolves","generator state maintained between yields"]},"pass":2,"annotatedAt":"2026-02-24T00:29:06.004Z"}
{"construct":{"id":"async-generators::for-await-of","file":"src/async-generators.js","category":"async-generators","lineStart":107,"lineEnd":114,"code":"async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<consumeAsyncIterable>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncIterable>"},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-await-of>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"CALL","id":"<results.push(item)>","metadata":{"callee":"push"}}],"edges":[{"src":"<consumeAsyncIterable>","dst":"<asyncIterable>","type":"CONTAINS"},{"src":"<consumeAsyncIterable>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<consumeAsyncIterable>","dst":"<for-await-of>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<asyncIterable>","type":"ITERATES_OVER"},{"src":"<for-await-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<results.push(item)>","type":"HAS_BODY"},{"src":"<results.push(item)>","dst":"<results>","type":"CALLS_ON"},{"src":"<results.push(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<consumeAsyncIterable>","dst":"<results>","type":"RETURNS"}],"rationale":"Async function with for-await-of loop that consumes an async iterable. Loop awaits each value and pushes to results array. Changed CALLS to CALLS_ON to better represent method invocation on the results array.","implicitBehavior":["for-await-of automatically awaits each yielded promise from the async iterator","function execution suspends at each await point in the loop"]},"pass":2,"annotatedAt":"2026-02-24T00:29:08.871Z"}
{"construct":{"id":"async-generators::for-await-of","file":"src/async-generators.js","category":"async-generators","lineStart":107,"lineEnd":114,"code":"async function consumeAsyncIterable(asyncIterable) {\n  const results = [];\n  for await (const item of asyncIterable) {\n    results.push(item);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<consumeAsyncIterable>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncIterable>"},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-await-of>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"CALL","id":"<results.push(item)>","metadata":{"callee":"push"}}],"edges":[{"src":"<consumeAsyncIterable>","dst":"<asyncIterable>","type":"CONTAINS"},{"src":"<consumeAsyncIterable>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<consumeAsyncIterable>","dst":"<for-await-of>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<asyncIterable>","type":"ITERATES_OVER"},{"src":"<for-await-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<results.push(item)>","type":"HAS_BODY"},{"src":"<results.push(item)>","dst":"<results>","type":"CALLS_ON"},{"src":"<results.push(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<consumeAsyncIterable>","dst":"<results>","type":"RETURNS"}],"rationale":"Async function with for-await-of loop that consumes an async iterable. Loop awaits each value and pushes to results array. Changed CALLS to CALLS_ON to better represent method invocation on the results array.","implicitBehavior":["for-await-of automatically awaits each yielded promise from the async iterator","function execution suspends at each await point in the loop"]},"pass":2,"annotatedAt":"2026-02-24T00:29:09.280Z"}
{"construct":{"id":"async-generators::generator-finally-cleanup","file":"src/async-generators.js","category":"async-generators","lineStart":189,"lineEnd":198,"code":"function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<resourceGenerator>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<resource>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ acquired: true }>","metadata":{"value":"{ acquired: true }","literalType":"object"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"EXPRESSION","id":"<yield resource>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<{ transformed: true }>","metadata":{"value":"{ transformed: true }","literalType":"object"}},{"type":"EXPRESSION","id":"<yield { transformed: true }>","metadata":{"operator":"yield"}},{"type":"PROPERTY_ACCESS","id":"<resource.acquired>","metadata":{"objectName":"resource","propertyName":"acquired"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}}],"edges":[{"src":"<resourceGenerator>","dst":"<resource>","type":"CONTAINS"},{"src":"<resource>","dst":"<{ acquired: true }>","type":"ASSIGNED_FROM"},{"src":"<resourceGenerator>","dst":"<try-block>","type":"CONTAINS"},{"src":"<resourceGenerator>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<yield resource>","type":"CONTAINS"},{"src":"<try-block>","dst":"<yield { transformed: true }>","type":"CONTAINS"},{"src":"<yield resource>","dst":"<resource>","type":"READS_FROM"},{"src":"<yield { transformed: true }>","dst":"<{ transformed: true }>","type":"READS_FROM"},{"src":"<finally-block>","dst":"<resource.acquired>","type":"WRITES_TO"},{"src":"<resource.acquired>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<resource.acquired>","dst":"<resource>","type":"READS_FROM"}],"rationale":"Generator function with try-finally cleanup. Yields two values in try block, finally block ensures resource cleanup regardless of how iteration terminates.","implicitBehavior":["finally block executes on normal completion, .return(), .throw(), or exception","generator state machine maintains cleanup guarantees","resource cleanup runs even if consumer abandons iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:29:09.588Z"}
{"construct":{"id":"async-generators::generator-observer-pattern","file":"src/async-generators.js","category":"async-generators","lineStart":174,"lineEnd":187,"code":"function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<observer>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"LOOP","id":"<while-true>","metadata":{"loopType":"while"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield>","metadata":{"operator":"yield"}},{"type":"CALL","id":"<results.push(value)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<results.push>","metadata":{"objectName":"results","propertyName":"push"}}],"edges":[{"src":"<observer>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<observer>","dst":"<try-block>","type":"CONTAINS"},{"src":"<observer>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<while-true>","type":"CONTAINS"},{"src":"<while-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<while-true>","dst":"<value>","type":"CONTAINS"},{"src":"<value>","dst":"<yield>","type":"ASSIGNED_FROM"},{"src":"<while-true>","dst":"<results.push(value)>","type":"CONTAINS"},{"src":"<results.push(value)>","dst":"<results.push>","type":"CALLS"},{"src":"<results.push>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(value)>","dst":"<value>","type":"PASSES_ARGUMENT"},{"src":"<finally-block>","dst":"<results>","type":"RETURNS"}],"rationale":"Generator function implementing observer pattern. Infinite loop yields to receive values, pushes them to results array. Finally block ensures results are returned on generator completion. All relationships captured using approved vocabulary.","implicitBehavior":["yield expression suspends execution and returns control to caller","finally block executes on generator.return() or completion","generator maintains internal state across yield points","infinite loop continues until external termination"]},"pass":2,"annotatedAt":"2026-02-24T00:29:10.101Z"}
{"construct":{"id":"async-generators::top-level-await","file":"src/async-generators.js","category":"async-generators","lineStart":116,"lineEnd":117,"code":"const config = await import('./declarations.js');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<config>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<await import('./declarations.js')>","metadata":{"async":true,"operator":"await"}},{"type":"CALL","id":"<import('./declarations.js')>","metadata":{"callee":"import","dynamic":true}},{"type":"LITERAL","id":"<'./declarations.js'>","metadata":{"value":"./declarations.js","literalType":"string"}},{"type":"EXTERNAL_MODULE","id":"<./declarations.js>","metadata":{"path":"./declarations.js"}}],"edges":[{"src":"<config>","dst":"<await import('./declarations.js')>","type":"ASSIGNED_FROM"},{"src":"<await import('./declarations.js')>","dst":"<import('./declarations.js')>","type":"AWAITS"},{"src":"<import('./declarations.js')>","dst":"<'./declarations.js'>","type":"PASSES_ARGUMENT"},{"src":"<import('./declarations.js')>","dst":"<./declarations.js>","type":"IMPORTS_FROM"}],"rationale":"Top-level await of dynamic import. Variable assigned from awaited promise that resolves to module exports. The EXTERNAL_MODULE node represents the target module being dynamically imported.","implicitBehavior":["top-level await makes module async","dynamic import returns a promise","module loading is deferred until runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:29:10.306Z"}
{"construct":{"id":"async-generators::generator-two-way","file":"src/async-generators.js","category":"async-generators","lineStart":119,"lineEnd":126,"code":"function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<accumulator>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<total>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<while-true>","metadata":{"loopType":"while"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield-total>","metadata":{"expressionType":"yield","yieldsValue":true,"receivesValue":true}},{"type":"EXPRESSION","id":"<total += value>","metadata":{"operator":"+="}}],"edges":[{"src":"<accumulator>","dst":"<total>","type":"CONTAINS"},{"src":"<total>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<accumulator>","dst":"<while-true>","type":"CONTAINS"},{"src":"<while-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<while-true>","dst":"<value>","type":"CONTAINS"},{"src":"<while-true>","dst":"<yield-total>","type":"CONTAINS"},{"src":"<while-true>","dst":"<total += value>","type":"CONTAINS"},{"src":"<value>","dst":"<yield-total>","type":"ASSIGNED_FROM"},{"src":"<yield-total>","dst":"<total>","type":"READS_FROM"},{"src":"<total += value>","dst":"<total>","type":"WRITES_TO"},{"src":"<total += value>","dst":"<value>","type":"READS_FROM"}],"rationale":"Generator function with two-way communication via yield expression. The yield both outputs the current total and receives a value from the caller to accumulate. Mapped YIELD node to EXPRESSION and YIELDS edge to READS_FROM as closest approved alternatives.","implicitBehavior":["generator function returns iterator object","yield expression pauses execution and can receive values from next() calls","infinite loop controlled by external iterator consumption"]},"pass":2,"annotatedAt":"2026-02-24T00:29:10.817Z"}
{"construct":{"id":"async-generators::generator-finally-yield-trap","file":"src/async-generators.js","category":"async-generators","lineStart":207,"lineEnd":219,"code":"function* trickyFinally() {\n  try {\n    yield 1;\n  } finally {\n    yield 2; // return() pauses HERE, not at the return point\n  }\n}\n// const g = trickyFinally(); g.next(); g.return('end');\n//  { value: 2, done: false }  NOT 'end'!\n// g.next()  { value: 'end', done: true }\n\n// --- Async iterator cancellation ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<trickyFinally>","metadata":{"generator":true,"async":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"EXPRESSION","id":"<yield 1>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield 2>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<trickyFinally>","dst":"<try-block>","type":"CONTAINS"},{"src":"<trickyFinally>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<yield 1>","type":"CONTAINS"},{"src":"<finally-block>","dst":"<yield 2>","type":"CONTAINS"},{"src":"<yield 1>","dst":"<1>","type":"YIELDS"},{"src":"<yield 2>","dst":"<2>","type":"YIELDS"},{"src":"<try-block>","dst":"<finally-block>","type":"HAS_FINALLY"}],"rationale":"Generator function with try-finally structure where both blocks contain yield expressions. The finally block's yield creates a trap for generator.return() calls, causing execution to pause at the finally yield rather than immediately returning the requested value.","implicitBehavior":["generator.return() execution pauses at finally block yield instead of immediately returning","finally block yield must complete before return value is delivered","creates two-step termination: yield from finally, then actual return value"]},"pass":2,"annotatedAt":"2026-02-24T00:29:12.053Z"}
{"construct":{"id":"async-generators::generator-break-triggers-finally","file":"src/async-generators.js","category":"async-generators","lineStart":200,"lineEnd":205,"code":"function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return()  finally runs\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<consumeWithBreak>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<gen>"},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"BRANCH","id":"<if-transformed>"},{"type":"PROPERTY_ACCESS","id":"<item.transformed>","metadata":{"property":"transformed"}},{"type":"EXPRESSION","id":"<break>","metadata":{"type":"break"}}],"edges":[{"src":"<consumeWithBreak>","dst":"<gen>","type":"CONTAINS"},{"src":"<consumeWithBreak>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<gen>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-of>","dst":"<if-transformed>","type":"CONTAINS"},{"src":"<if-transformed>","dst":"<item.transformed>","type":"HAS_CONDITION"},{"src":"<item.transformed>","dst":"<item>","type":"READS_FROM"},{"src":"<if-transformed>","dst":"<break>","type":"HAS_CONSEQUENT"}],"rationale":"Function consumes a generator via for-of loop. Conditional break statement exits the loop early when item has transformed property.","implicitBehavior":["break in for-of loop over generator calls generator.return() method","generator.return() triggers finally blocks in the generator","for-of loop automatically handles generator protocol (next/return/throw)"]},"pass":2,"annotatedAt":"2026-02-24T00:29:14.298Z"}
{"construct":{"id":"async-generators::promise-resolve-thenable","file":"src/async-generators.js","category":"async-generators","lineStart":160,"lineEnd":172,"code":"async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<nestedThenable>","metadata":{"async":true,"generator":false}},{"type":"VARIABLE","id":"<thenable>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<thenable-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<thenable.then>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<resolve>"},{"type":"CALL","id":"<resolve(nested-thenable)>","metadata":{"callee":"resolve"}},{"type":"LITERAL","id":"<nested-thenable-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<nested-thenable.then>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<resolve2>"},{"type":"CALL","id":"<resolve2(42)>","metadata":{"callee":"resolve2"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"CALL","id":"<Promise.resolve(thenable)>","metadata":{"callee":"Promise.resolve"}},{"type":"EXPRESSION","id":"<await Promise.resolve(thenable)>","metadata":{"operator":"await"}}],"edges":[{"src":"<nestedThenable>","dst":"<thenable>","type":"CONTAINS"},{"src":"<thenable>","dst":"<thenable-object>","type":"ASSIGNED_FROM"},{"src":"<thenable-object>","dst":"<thenable.then>","type":"HAS_PROPERTY"},{"src":"<thenable.then>","dst":"<resolve>","type":"RECEIVES_ARGUMENT"},{"src":"<thenable.then>","dst":"<resolve(nested-thenable)>","type":"CONTAINS"},{"src":"<resolve(nested-thenable)>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve(nested-thenable)>","dst":"<nested-thenable-object>","type":"PASSES_ARGUMENT"},{"src":"<nested-thenable-object>","dst":"<nested-thenable.then>","type":"HAS_PROPERTY"},{"src":"<nested-thenable.then>","dst":"<resolve2>","type":"RECEIVES_ARGUMENT"},{"src":"<nested-thenable.then>","dst":"<resolve2(42)>","type":"CONTAINS"},{"src":"<resolve2(42)>","dst":"<resolve2>","type":"CALLS"},{"src":"<resolve2(42)>","dst":"<42>","type":"PASSES_ARGUMENT"},{"src":"<Promise.resolve(thenable)>","dst":"<thenable>","type":"PASSES_ARGUMENT"},{"src":"<await Promise.resolve(thenable)>","dst":"<Promise.resolve(thenable)>","type":"AWAITS"},{"src":"<nestedThenable>","dst":"<await Promise.resolve(thenable)>","type":"RETURNS"}],"rationale":"Async function with nested thenable objects. Promise.resolve unwraps the outer thenable, which resolves to another thenable that eventually resolves to 42. Reduced edge count by removing module declaration and using more specific edge types like AWAITS and RECEIVES_ARGUMENT.","implicitBehavior":["Promise.resolve recursively unwraps thenables until a non-thenable value is reached","await suspends function execution until the promise resolves","nested thenable resolution happens asynchronously in sequence"]},"pass":2,"annotatedAt":"2026-02-24T00:29:14.329Z"}
{"construct":{"id":"async-generators::async-generator","file":"src/async-generators.js","category":"async-generators","lineStart":99,"lineEnd":105,"code":"async function* asyncCounter(start, end) {\n  for (let i = start; i <= end; i++) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<asyncCounter>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i <= end>","metadata":{"operator":"<="}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<await new Promise(resolve => setTimeout(resolve, 100))>"},{"type":"CALL","id":"<new Promise(resolve => setTimeout(resolve, 100))>","metadata":{"callee":"Promise","constructor":true}},{"type":"FUNCTION","id":"<resolve => setTimeout(resolve, 100)>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<resolve>"},{"type":"CALL","id":"<setTimeout(resolve, 100)>","metadata":{"callee":"setTimeout"}},{"type":"LITERAL","id":"<100>","metadata":{"value":100,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield i>"}],"edges":[{"src":"<asyncCounter>","dst":"<start>","type":"CONTAINS"},{"src":"<asyncCounter>","dst":"<end>","type":"CONTAINS"},{"src":"<asyncCounter>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<start>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i <= end>","type":"HAS_CONDITION"},{"src":"<i <= end>","dst":"<i>","type":"READS_FROM"},{"src":"<i <= end>","dst":"<end>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<await new Promise(resolve => setTimeout(resolve, 100))>","type":"HAS_BODY"},{"src":"<for-loop>","dst":"<yield i>","type":"HAS_BODY"},{"src":"<await new Promise(resolve => setTimeout(resolve, 100))>","dst":"<new Promise(resolve => setTimeout(resolve, 100))>","type":"AWAITS"},{"src":"<new Promise(resolve => setTimeout(resolve, 100))>","dst":"<resolve => setTimeout(resolve, 100)>","type":"PASSES_ARGUMENT"},{"src":"<resolve => setTimeout(resolve, 100)>","dst":"<resolve>","type":"CONTAINS"},{"src":"<resolve => setTimeout(resolve, 100)>","dst":"<setTimeout(resolve, 100)>","type":"RETURNS"},{"src":"<setTimeout(resolve, 100)>","dst":"<resolve>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(resolve, 100)>","dst":"<100>","type":"PASSES_ARGUMENT"},{"src":"<yield i>","dst":"<i>","type":"YIELDS"},{"src":"<asyncCounter>","dst":"<yield i>","type":"YIELDS"}],"rationale":"Async generator function that yields values after awaiting promises. Contains for loop with initialization, condition, and update. Yields loop variable after async delay. Changed READS_FROM to AWAITS for the await expression to better capture the async relationship.","implicitBehavior":["function returns AsyncGenerator object","yield suspends execution and returns IteratorResult","await suspends until Promise resolves","generator state maintained between yields"]},"pass":2,"annotatedAt":"2026-02-24T00:29:14.413Z"}
{"construct":{"id":"async-generators::yield-star-return-value","file":"src/async-generators.js","category":"async-generators","lineStart":241,"lineEnd":251,"code":"function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<innerWithReturn>","metadata":{"generator":true,"async":false}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<'done'>","metadata":{"value":"done","literalType":"string"}},{"type":"FUNCTION","id":"<outerCapturesReturn>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield* innerWithReturn()>","metadata":{"operator":"yield*"}},{"type":"CALL","id":"<innerWithReturn()>","metadata":{"callee":"innerWithReturn"}}],"edges":[{"src":"<innerWithReturn>","dst":"<1>","type":"YIELDS"},{"src":"<innerWithReturn>","dst":"<2>","type":"YIELDS"},{"src":"<innerWithReturn>","dst":"<'done'>","type":"RETURNS"},{"src":"<result>","dst":"<yield* innerWithReturn()>","type":"ASSIGNED_FROM"},{"src":"<yield* innerWithReturn()>","dst":"<innerWithReturn()>","type":"DELEGATES_TO"},{"src":"<innerWithReturn()>","dst":"<innerWithReturn>","type":"CALLS"},{"src":"<outerCapturesReturn>","dst":"<result>","type":"YIELDS"}],"rationale":"Two generator functions where the outer delegates to inner with yield*. The inner generator yields values but returns a final value, which becomes the result of the yield* expression in the outer generator. Reduced edge count by removing module-level declarations and focusing on the core generator delegation pattern.","implicitBehavior":["yield* delegates all yielded values from inner generator to outer generator's caller","return value from inner generator becomes the value of the yield* expression","yielded values (1, 2) are passed through transparently, return value ('done') is captured separately"]},"pass":2,"annotatedAt":"2026-02-24T00:29:17.885Z"}
{"construct":{"id":"async-generators::yield-yield-chained","file":"src/async-generators.js","category":"async-generators","lineStart":282,"lineEnd":291,"code":"function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<chainedYield>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield yield 1>","metadata":{"type":"nested-yield"}},{"type":"EXPRESSION","id":"<inner-yield>","metadata":{"position":"inner","operation":"yield"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<outer-yield>","metadata":{"position":"outer","operation":"yield"}}],"edges":[{"src":"<chainedYield>","dst":"<result>","type":"CONTAINS"},{"src":"<chainedYield>","dst":"<yield yield 1>","type":"CONTAINS"},{"src":"<result>","dst":"<yield yield 1>","type":"ASSIGNED_FROM"},{"src":"<yield yield 1>","dst":"<outer-yield>","type":"CONTAINS"},{"src":"<outer-yield>","dst":"<inner-yield>","type":"YIELDS"},{"src":"<inner-yield>","dst":"<1>","type":"YIELDS"},{"src":"<chainedYield>","dst":"<result>","type":"RETURNS"}],"rationale":"Generator function with nested yield expressions creating two suspension points. Mapped YIELD nodes to EXPRESSION with yield metadata since YIELD is not in approved vocabulary.","implicitBehavior":["First suspension: inner yield produces 1 to caller","Second suspension: outer yield produces value sent to inner yield","Final resume: outer yield result assigned to result variable"]},"pass":2,"annotatedAt":"2026-02-24T00:29:18.840Z"}
{"construct":{"id":"async-generators::for-await-sync-iterable","file":"src/async-generators.js","category":"async-generators","lineStart":253,"lineEnd":260,"code":"async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array  each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forAwaitSyncIterable>","metadata":{"async":true,"generator":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-await>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"value":[1,2,3],"literalType":"array"}},{"type":"CALL","id":"<results.push(item)>","metadata":{"callee":"push","method":true}},{"type":"EXPRESSION","id":"<return results>","metadata":{"type":"return"}}],"edges":[{"src":"<forAwaitSyncIterable>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<forAwaitSyncIterable>","dst":"<for-await>","type":"CONTAINS"},{"src":"<for-await>","dst":"<[1, 2, 3]>","type":"ITERATES_OVER"},{"src":"<for-await>","dst":"<item>","type":"CONTAINS"},{"src":"<for-await>","dst":"<results.push(item)>","type":"CONTAINS"},{"src":"<results.push(item)>","dst":"<results>","type":"CALLS_ON"},{"src":"<results.push(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<forAwaitSyncIterable>","dst":"<return results>","type":"CONTAINS"},{"src":"<return results>","dst":"<results>","type":"READS_FROM"},{"src":"<forAwaitSyncIterable>","dst":"<return results>","type":"RETURNS"}],"rationale":"Async function using for-await-of loop over sync iterable. Changed CALLS to CALLS_ON to better represent method invocation on the results array. All other relationships preserved using approved vocabulary.","implicitBehavior":["sync iterable values are automatically wrapped in resolved promises","each iteration awaits the promise-wrapped value","function returns a promise that resolves to the results array"]},"pass":2,"annotatedAt":"2026-02-24T00:29:18.873Z"}
{"construct":{"id":"async-generators::async-iterator-cancel-manual","file":"src/async-generators.js","category":"async-generators","lineStart":233,"lineEnd":239,"code":"async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<manualAsyncCancel>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncGen>"},{"type":"VARIABLE","id":"<iter>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<asyncGen[Symbol.asyncIterator]>","metadata":{"objectName":"asyncGen","property":"Symbol.asyncIterator"}},{"type":"CALL","id":"<asyncGen[Symbol.asyncIterator]()>","metadata":{"callee":"asyncGen[Symbol.asyncIterator]"}},{"type":"VARIABLE","id":"<first>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<iter.next>","metadata":{"objectName":"iter","property":"next"}},{"type":"CALL","id":"<iter.next()>","metadata":{"callee":"iter.next","awaited":true}},{"type":"PROPERTY_ACCESS","id":"<iter.return>","metadata":{"objectName":"iter","property":"return"}},{"type":"CALL","id":"<iter.return()>","metadata":{"callee":"iter.return","awaited":true}},{"type":"EXPRESSION","id":"<return first>","metadata":{"type":"return"}}],"edges":[{"src":"<manualAsyncCancel>","dst":"<asyncGen>","type":"CONTAINS"},{"src":"<manualAsyncCancel>","dst":"<iter>","type":"CONTAINS"},{"src":"<manualAsyncCancel>","dst":"<first>","type":"CONTAINS"},{"src":"<iter>","dst":"<asyncGen[Symbol.asyncIterator]()>","type":"ASSIGNED_FROM"},{"src":"<asyncGen[Symbol.asyncIterator]()>","dst":"<asyncGen[Symbol.asyncIterator]>","type":"CALLS"},{"src":"<asyncGen[Symbol.asyncIterator]>","dst":"<asyncGen>","type":"READS_FROM"},{"src":"<first>","dst":"<iter.next()>","type":"ASSIGNED_FROM"},{"src":"<iter.next()>","dst":"<iter.next>","type":"CALLS"},{"src":"<iter.next>","dst":"<iter>","type":"READS_FROM"},{"src":"<iter.return()>","dst":"<iter.return>","type":"CALLS"},{"src":"<iter.return>","dst":"<iter>","type":"READS_FROM"},{"src":"<manualAsyncCancel>","dst":"<return first>","type":"RETURNS"},{"src":"<return first>","dst":"<first>","type":"READS_FROM"}],"rationale":"Async function that manually cancels an async generator by getting its iterator, calling next() once, then explicitly calling return() to close it. Returns the first yielded value.","implicitBehavior":["Symbol.asyncIterator access gets the async iterator protocol method","await on iter.next() waits for promise resolution of iterator result","await on iter.return() waits for cleanup completion","iter.return() triggers finally blocks in the generator","Manual cancellation prevents further iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:29:20.402Z"}
{"construct":{"id":"builtins::builtin-json-stringify","file":"src/builtins.js","category":"builtins","lineStart":20,"lineEnd":23,"code":"function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonStringify>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<JSON.stringify(obj)>","metadata":{"callee":"JSON.stringify"}},{"type":"PROPERTY_ACCESS","id":"<JSON.stringify>","metadata":{"objectName":"JSON","propertyName":"stringify"}},{"type":"EXTERNAL","id":"<JSON>","metadata":{"builtin":true,"global":true}}],"edges":[{"src":"<module>","dst":"<jsonStringify>","type":"DECLARES"},{"src":"<jsonStringify>","dst":"<obj>","type":"CONTAINS"},{"src":"<jsonStringify>","dst":"<JSON.stringify(obj)>","type":"RETURNS"},{"src":"<JSON.stringify(obj)>","dst":"<JSON.stringify>","type":"CALLS"},{"src":"<JSON.stringify(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<JSON.stringify>","dst":"<JSON>","type":"READS_FROM"}],"rationale":"Function that wraps the built-in JSON.stringify method. The function contains a parameter, returns a call expression that accesses the global JSON object's stringify property, and passes the parameter as an argument to that method.","implicitBehavior":["JSON is a global built-in object available in all JavaScript environments","JSON.stringify may throw TypeError for circular references or unsupported values"]},"pass":2,"annotatedAt":"2026-02-24T00:29:20.402Z"}
{"construct":{"id":"async-generators::async-generator-destructure-default","file":"src/async-generators.js","category":"async-generators","lineStart":262,"lineEnd":269,"code":"async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<processStream>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<source>"},{"type":"LOOP","id":"<for-await-of>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<priority>","metadata":{"kind":"const","destructured":true,"nested":true}},{"type":"LITERAL","id":"<'normal'>","metadata":{"value":"normal","literalType":"string"}},{"type":"EXPRESSION","id":"<{ ...data, priority }>","metadata":{"type":"object-spread"}},{"type":"EXPRESSION","id":"<yield { ...data, priority }>","metadata":{"type":"yield"}}],"edges":[{"src":"<processStream>","dst":"<source>","type":"HAS_BODY"},{"src":"<processStream>","dst":"<for-await-of>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<source>","type":"ITERATES_OVER"},{"src":"<for-await-of>","dst":"<data>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<priority>","type":"CONTAINS"},{"src":"<priority>","dst":"<'normal'>","type":"DEFAULTS_TO"},{"src":"<{ ...data, priority }>","dst":"<data>","type":"SPREADS_FROM"},{"src":"<{ ...data, priority }>","dst":"<priority>","type":"READS_FROM"},{"src":"<yield { ...data, priority }>","dst":"<{ ...data, priority }>","type":"YIELDS"},{"src":"<for-await-of>","dst":"<yield { ...data, priority }>","type":"CONTAINS"}],"rationale":"Async generator function with for-await-of loop that destructures nested objects with default values. Uses DEFAULTS_TO for default parameter assignment and SPREADS_FROM for object spread syntax. The HAS_BODY edge connects the function to its parameter.","implicitBehavior":["async iteration protocol - awaits each iteration","destructuring with nested default assignment","object spread creates new object instances","generator yields async iterator"]},"pass":2,"annotatedAt":"2026-02-24T00:29:20.882Z"}
{"construct":{"id":"builtins::builtin-json-parse","file":"src/builtins.js","category":"builtins","lineStart":7,"lineEnd":10,"code":"function jsonParse(str) {\n  return JSON.parse(str);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonParse>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<str>"},{"type":"CALL","id":"<JSON.parse(str)>","metadata":{"callee":"JSON.parse"}},{"type":"PROPERTY_ACCESS","id":"<JSON.parse>","metadata":{"objectName":"JSON","propertyName":"parse"}},{"type":"EXTERNAL","id":"<JSON>","metadata":{"builtin":true,"global":true}}],"edges":[{"src":"<jsonParse>","dst":"<str>","type":"CONTAINS"},{"src":"<jsonParse>","dst":"<JSON.parse(str)>","type":"RETURNS"},{"src":"<JSON.parse(str)>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse(str)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<JSON.parse>","dst":"<JSON>","type":"READS_FROM"}],"rationale":"Function that wraps the built-in JSON.parse method. The function contains a parameter, returns the result of calling JSON.parse, which accesses the parse property from the global JSON object and passes the str argument.","implicitBehavior":["JSON is a global built-in object","JSON.parse can throw SyntaxError for invalid JSON"]},"pass":2,"annotatedAt":"2026-02-24T00:29:20.885Z"}
{"construct":{"id":"async-generators::generator-two-way","file":"src/async-generators.js","category":"async-generators","lineStart":119,"lineEnd":126,"code":"function* accumulator() {\n  let total = 0;\n  while (true) {\n    const value = yield total;\n    total += value;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<accumulator>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<total>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<while-true>","metadata":{"loopType":"while"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield-total>","metadata":{"expressionType":"yield","yieldsValue":true,"receivesValue":true}},{"type":"EXPRESSION","id":"<total += value>","metadata":{"operator":"+="}}],"edges":[{"src":"<accumulator>","dst":"<total>","type":"CONTAINS"},{"src":"<total>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<accumulator>","dst":"<while-true>","type":"CONTAINS"},{"src":"<while-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<while-true>","dst":"<value>","type":"CONTAINS"},{"src":"<while-true>","dst":"<yield-total>","type":"CONTAINS"},{"src":"<while-true>","dst":"<total += value>","type":"CONTAINS"},{"src":"<value>","dst":"<yield-total>","type":"ASSIGNED_FROM"},{"src":"<yield-total>","dst":"<total>","type":"READS_FROM"},{"src":"<total += value>","dst":"<total>","type":"WRITES_TO"},{"src":"<total += value>","dst":"<value>","type":"READS_FROM"}],"rationale":"Generator function with two-way communication via yield expression. The yield both outputs the current total and receives a value from the caller to accumulate. Mapped YIELD node to EXPRESSION and YIELDS edge to READS_FROM as closest approved alternatives.","implicitBehavior":["generator function returns iterator object","yield expression pauses execution and can receive values from next() calls","infinite loop controlled by external iterator consumption"]},"pass":2,"annotatedAt":"2026-02-24T00:29:23.210Z"}
{"construct":{"id":"async-generators::async-iter-manual","file":"src/async-generators.js","category":"async-generators","lineStart":138,"lineEnd":149,"code":"async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<manualAsyncIteration>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncIterable>"},{"type":"VARIABLE","id":"<asyncIter>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<asyncIterable[Symbol.asyncIterator]>","metadata":{"computed":true}},{"type":"CALL","id":"<asyncIterable[Symbol.asyncIterator]()>","metadata":{"callee":"asyncIterable[Symbol.asyncIterator]"}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"VARIABLE","id":"<step>","metadata":{"kind":"let"}},{"type":"CALL","id":"<asyncIter.next()>","metadata":{"callee":"asyncIter.next","awaited":true}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<!step.done>","metadata":{"operator":"!"}},{"type":"PROPERTY_ACCESS","id":"<step.done>"},{"type":"CALL","id":"<results.push(step.value)>","metadata":{"callee":"results.push"}},{"type":"PROPERTY_ACCESS","id":"<step.value>"},{"type":"EXPRESSION","id":"<step = await asyncIter.next()>","metadata":{"operator":"="}},{"type":"CALL","id":"<asyncIter.next()#2>","metadata":{"callee":"asyncIter.next","awaited":true}},{"type":"CALL","id":"<asyncIter.return?.()>","metadata":{"callee":"asyncIter.return","optional":true,"awaited":true}},{"type":"PROPERTY_ACCESS","id":"<asyncIter.return>"}],"edges":[{"src":"<manualAsyncIteration>","dst":"<asyncIterable>","type":"CONTAINS"},{"src":"<manualAsyncIteration>","dst":"<asyncIter>","type":"CONTAINS"},{"src":"<asyncIter>","dst":"<asyncIterable[Symbol.asyncIterator]()>","type":"ASSIGNED_FROM"},{"src":"<asyncIterable[Symbol.asyncIterator]()>","dst":"<asyncIterable[Symbol.asyncIterator]>","type":"CALLS"},{"src":"<asyncIterable[Symbol.asyncIterator]>","dst":"<asyncIterable>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<manualAsyncIteration>","dst":"<step>","type":"CONTAINS"},{"src":"<step>","dst":"<asyncIter.next()>","type":"ASSIGNED_FROM"},{"src":"<asyncIter.next()>","dst":"<asyncIter>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<while>","type":"CONTAINS"},{"src":"<while>","dst":"<!step.done>","type":"HAS_CONDITION"},{"src":"<!step.done>","dst":"<step.done>","type":"READS_FROM"},{"src":"<step.done>","dst":"<step>","type":"READS_FROM"},{"src":"<while>","dst":"<results.push(step.value)>","type":"CONTAINS"},{"src":"<results.push(step.value)>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(step.value)>","dst":"<step.value>","type":"PASSES_ARGUMENT"},{"src":"<step.value>","dst":"<step>","type":"READS_FROM"},{"src":"<while>","dst":"<step = await asyncIter.next()>","type":"CONTAINS"},{"src":"<step = await asyncIter.next()>","dst":"<step>","type":"WRITES_TO"},{"src":"<step = await asyncIter.next()>","dst":"<asyncIter.next()#2>","type":"READS_FROM"},{"src":"<asyncIter.next()#2>","dst":"<asyncIter>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<asyncIter.return?.()>","type":"CONTAINS"},{"src":"<asyncIter.return?.()>","dst":"<asyncIter.return>","type":"CALLS"},{"src":"<asyncIter.return>","dst":"<asyncIter>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<results>","type":"RETURNS"}],"rationale":"Async function that manually implements async iteration protocol. Gets async iterator, loops while not done, collects values, optionally calls return method, and returns collected results.","implicitBehavior":["async iterator protocol compliance","optional chaining prevents error if return method doesn't exist","await expressions suspend execution until promises resolve"]},"pass":2,"annotatedAt":"2026-02-24T00:29:25.240Z"}
{"construct":{"id":"async-generators::generator-return-throw","file":"src/async-generators.js","category":"async-generators","lineStart":128,"lineEnd":136,"code":"function* generatorReturnThrow() {\n  try {\n    yield 1;\n    yield 2;\n  } finally {\n    yield 'cleanup';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<generatorReturnThrow>","metadata":{"async":false,"generator":true}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"EXPRESSION","id":"<yield 1>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield 2>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield 'cleanup'>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<'cleanup'>","metadata":{"value":"cleanup","literalType":"string"}}],"edges":[{"src":"<generatorReturnThrow>","dst":"<try-block>","type":"CONTAINS"},{"src":"<generatorReturnThrow>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<yield 1>","type":"CONTAINS"},{"src":"<try-block>","dst":"<yield 2>","type":"CONTAINS"},{"src":"<yield 1>","dst":"<1>","type":"RETURNS"},{"src":"<yield 2>","dst":"<2>","type":"RETURNS"},{"src":"<finally-block>","dst":"<yield 'cleanup'>","type":"CONTAINS"},{"src":"<yield 'cleanup'>","dst":"<'cleanup'>","type":"RETURNS"}],"rationale":"Generator function with try-finally structure. Yields values in try block and cleanup value in finally block. Used RETURNS instead of YIELDS as closest approved edge type.","implicitBehavior":["generator function creates iterator object","finally block executes on return/throw","yield expressions suspend execution and produce values"]},"pass":2,"annotatedAt":"2026-02-24T00:29:29.288Z"}
{"construct":{"id":"async-generators::async-iterator-cancel-break","file":"src/async-generators.js","category":"async-generators","lineStart":221,"lineEnd":231,"code":"async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<streamChunks>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<url>"},{"type":"VARIABLE","id":"<reader>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ locked: true }>","metadata":{"value":"{ locked: true }","literalType":"object"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":"0","literalType":"number"}},{"type":"LITERAL","id":"<10>","metadata":{"value":"10","literalType":"number"}},{"type":"EXPRESSION","id":"<i < 10>","metadata":{"operator":"<"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<yield { chunk: i, size: i * 100 }>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<{ chunk: i, size: i * 100 }>","metadata":{"literalType":"object"}},{"type":"EXPRESSION","id":"<i * 100>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<100>","metadata":{"value":"100","literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<reader.locked>","metadata":{"objectName":"reader","propertyName":"locked"}},{"type":"LITERAL","id":"<false>","metadata":{"value":"false","literalType":"boolean"}}],"edges":[{"src":"<streamChunks>","dst":"<url>","type":"CONTAINS"},{"src":"<streamChunks>","dst":"<reader>","type":"CONTAINS"},{"src":"<reader>","dst":"<{ locked: true }>","type":"ASSIGNED_FROM"},{"src":"<streamChunks>","dst":"<try-block>","type":"CONTAINS"},{"src":"<streamChunks>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 10>","type":"HAS_CONDITION"},{"src":"<i < 10>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 10>","dst":"<10>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<yield { chunk: i, size: i * 100 }>","type":"HAS_BODY"},{"src":"<yield { chunk: i, size: i * 100 }>","dst":"<{ chunk: i, size: i * 100 }>","type":"YIELDS"},{"src":"<{ chunk: i, size: i * 100 }>","dst":"<i>","type":"READS_FROM"},{"src":"<{ chunk: i, size: i * 100 }>","dst":"<i * 100>","type":"READS_FROM"},{"src":"<i * 100>","dst":"<i>","type":"READS_FROM"},{"src":"<i * 100>","dst":"<100>","type":"READS_FROM"},{"src":"<finally-block>","dst":"<reader.locked>","type":"CONTAINS"},{"src":"<reader.locked>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<reader.locked>","dst":"<reader>","type":"READS_FROM"}],"rationale":"Async generator function with try-finally cleanup. The finally block ensures cleanup runs on any exit path (break, throw, return, or completion). All node and edge types from Pass 1 were already in the approved vocabulary.","implicitBehavior":["async generator returns AsyncIterator with next/return/throw methods","finally block executes on break, throw, return, or normal completion","yield creates suspension point where iterator can be cancelled","generator cleanup runs when iterator.return() is called"]},"pass":2,"annotatedAt":"2026-02-24T00:29:29.766Z"}
{"construct":{"id":"builtins::builtin-weakref","file":"src/builtins.js","category":"builtins","lineStart":122,"lineEnd":128,"code":"function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<weakRefUsage>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<target>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<{ data: 'important' }>","metadata":{"literalType":"object"}},{"type":"VARIABLE","id":"<ref>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new WeakRef(target)>","metadata":{"callee":"WeakRef","isConstructor":true}},{"type":"VARIABLE","id":"<deref>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ref.deref()>","metadata":{"callee":"deref","isMethodCall":true}},{"type":"PROPERTY_ACCESS","id":"<deref?.data>","metadata":{"objectName":"deref","propertyName":"data","optional":true}}],"edges":[{"src":"<weakRefUsage>","dst":"<target>","type":"CONTAINS"},{"src":"<weakRefUsage>","dst":"<ref>","type":"CONTAINS"},{"src":"<weakRefUsage>","dst":"<deref>","type":"CONTAINS"},{"src":"<target>","dst":"<{ data: 'important' }>","type":"ASSIGNED_FROM"},{"src":"<ref>","dst":"<new WeakRef(target)>","type":"ASSIGNED_FROM"},{"src":"<new WeakRef(target)>","dst":"<target>","type":"PASSES_ARGUMENT"},{"src":"<deref>","dst":"<ref.deref()>","type":"ASSIGNED_FROM"},{"src":"<ref.deref()>","dst":"<ref>","type":"READS_FROM"},{"src":"<weakRefUsage>","dst":"<deref?.data>","type":"RETURNS"},{"src":"<deref?.data>","dst":"<deref>","type":"READS_FROM"}],"rationale":"Function demonstrates WeakRef usage: creates target object, wraps in WeakRef, dereferences it, and accesses property with optional chaining. Reduced edge count by removing module declaration edge and constructor call edge.","implicitBehavior":["WeakRef allows garbage collection of target even while ref exists","deref() may return undefined if target was collected","optional chaining prevents errors if deref returns undefined"]},"pass":2,"annotatedAt":"2026-02-24T00:29:29.767Z"}
{"construct":{"id":"builtins::builtin-map-constructor","file":"src/builtins.js","category":"builtins","lineStart":63,"lineEnd":72,"code":"function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<mapFromEntries>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<map>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Map([...])>","metadata":{"callee":"Map","constructor":true}},{"type":"LITERAL","id":"<[['x', 10], ['y', 20]]>","metadata":{"value":"[['x', 10], ['y', 20]]","literalType":"array"}},{"type":"LITERAL","id":"<['x', 10]>","metadata":{"value":"['x', 10]","literalType":"array"}},{"type":"LITERAL","id":"<'x'>","metadata":{"value":"x","literalType":"string"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"LITERAL","id":"<['y', 20]>","metadata":{"value":"['y', 20]","literalType":"array"}},{"type":"LITERAL","id":"<'y'>","metadata":{"value":"y","literalType":"string"}},{"type":"LITERAL","id":"<20>","metadata":{"value":20,"literalType":"number"}},{"type":"EXTERNAL","id":"<Map>","metadata":{"builtin":true}}],"edges":[{"src":"<mapFromEntries>","dst":"<map>","type":"CONTAINS"},{"src":"<map>","dst":"<new Map([...])>","type":"ASSIGNED_FROM"},{"src":"<new Map([...])>","dst":"<Map>","type":"CALLS"},{"src":"<new Map([...])>","dst":"<[['x', 10], ['y', 20]]>","type":"PASSES_ARGUMENT"},{"src":"<[['x', 10], ['y', 20]]>","dst":"<['x', 10]>","type":"HAS_ELEMENT"},{"src":"<[['x', 10], ['y', 20]]>","dst":"<['y', 20]>","type":"HAS_ELEMENT"},{"src":"<['x', 10]>","dst":"<'x'>","type":"HAS_ELEMENT"},{"src":"<['x', 10]>","dst":"<10>","type":"HAS_ELEMENT"},{"src":"<['y', 20]>","dst":"<'y'>","type":"HAS_ELEMENT"},{"src":"<['y', 20]>","dst":"<20>","type":"HAS_ELEMENT"},{"src":"<mapFromEntries>","dst":"<map>","type":"RETURNS"}],"rationale":"Function creates a Map from an array of key-value pairs. Constructor call with nested array literals containing string keys and number values. Removed the module-level DECLARES edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["Map constructor accepts iterable of [key, value] pairs","Map preserves insertion order"]},"pass":2,"annotatedAt":"2026-02-24T00:29:29.851Z"}
{"construct":{"id":"builtins::builtin-json-parse-reviver","file":"src/builtins.js","category":"builtins","lineStart":12,"lineEnd":18,"code":"function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonParseReviver>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<str>"},{"type":"CALL","id":"<JSON.parse(str, reviver)>","metadata":{"callee":"JSON.parse"}},{"type":"PROPERTY_ACCESS","id":"<JSON.parse>","metadata":{"objectName":"JSON","propertyName":"parse"}},{"type":"FUNCTION","id":"<reviver>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<value>"},{"type":"BRANCH","id":"<if-date-check>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<key === 'date'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'date'>","metadata":{"value":"date","literalType":"string"}},{"type":"CALL","id":"<new Date(value)>","metadata":{"callee":"Date","isConstructor":true}},{"type":"EXTERNAL","id":"<Date>","metadata":{"builtin":true}}],"edges":[{"src":"<jsonParseReviver>","dst":"<str>","type":"CONTAINS"},{"src":"<jsonParseReviver>","dst":"<JSON.parse(str, reviver)>","type":"RETURNS"},{"src":"<JSON.parse(str, reviver)>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse(str, reviver)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<JSON.parse(str, reviver)>","dst":"<reviver>","type":"PASSES_ARGUMENT"},{"src":"<reviver>","dst":"<key>","type":"CONTAINS"},{"src":"<reviver>","dst":"<value>","type":"CONTAINS"},{"src":"<reviver>","dst":"<if-date-check>","type":"CONTAINS"},{"src":"<if-date-check>","dst":"<key === 'date'>","type":"HAS_CONDITION"},{"src":"<key === 'date'>","dst":"<key>","type":"READS_FROM"},{"src":"<key === 'date'>","dst":"<'date'>","type":"READS_FROM"},{"src":"<if-date-check>","dst":"<new Date(value)>","type":"HAS_CONSEQUENT"},{"src":"<if-date-check>","dst":"<value>","type":"HAS_ALTERNATE"},{"src":"<new Date(value)>","dst":"<Date>","type":"CALLS"},{"src":"<new Date(value)>","dst":"<value>","type":"PASSES_ARGUMENT"}],"rationale":"Function that wraps JSON.parse with a reviver callback. The reviver checks if key equals 'date' and constructs a Date object, otherwise returns the value unchanged. Changed VARIABLE to EXTERNAL for Date constructor to better represent it as a built-in global.","implicitBehavior":["JSON.parse calls the reviver function for each key-value pair during parsing","Date constructor coerces string values to Date objects","Arrow function has implicit return for both branches"]},"pass":2,"annotatedAt":"2026-02-24T00:29:30.272Z"}
{"construct":{"id":"async-generators::async-destructure-await-default","file":"src/async-generators.js","category":"async-generators","lineStart":293,"lineEnd":301,"code":"async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getConfigValue>","metadata":{"async":true}},{"type":"PARAMETER","id":"<key>"},{"type":"VARIABLE","id":"<asyncDestructureHandler>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncDestructureHandler:fn>","metadata":{"async":true,"arrowFunction":true}},{"type":"PARAMETER","id":"<destructured-param>","metadata":{"destructured":true,"defaultValue":"{}"}},{"type":"PROPERTY","id":"<timeout>","metadata":{"hasDefault":true}},{"type":"PROPERTY","id":"<retries>","metadata":{"hasDefault":true}},{"type":"CALL","id":"<getConfigValue('timeout')>","metadata":{"callee":"getConfigValue","awaited":true}},{"type":"LITERAL","id":"<'timeout'>","metadata":{"value":"timeout","literalType":"string"}},{"type":"CALL","id":"<getConfigValue('retries')>","metadata":{"callee":"getConfigValue","awaited":true}},{"type":"LITERAL","id":"<'retries'>","metadata":{"value":"retries","literalType":"string"}},{"type":"EXPRESSION","id":"<{ timeout, retries }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<getConfigValue>","dst":"<key>","type":"CONTAINS"},{"src":"<getConfigValue>","dst":"<key>","type":"RETURNS"},{"src":"<asyncDestructureHandler>","dst":"<asyncDestructureHandler:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncDestructureHandler:fn>","dst":"<destructured-param>","type":"CONTAINS"},{"src":"<destructured-param>","dst":"<timeout>","type":"HAS_PROPERTY"},{"src":"<destructured-param>","dst":"<retries>","type":"HAS_PROPERTY"},{"src":"<timeout>","dst":"<getConfigValue('timeout')>","type":"DEFAULTS_TO"},{"src":"<retries>","dst":"<getConfigValue('retries')>","type":"DEFAULTS_TO"},{"src":"<getConfigValue('timeout')>","dst":"<getConfigValue>","type":"CALLS"},{"src":"<getConfigValue('timeout')>","dst":"<'timeout'>","type":"PASSES_ARGUMENT"},{"src":"<getConfigValue('retries')>","dst":"<getConfigValue>","type":"CALLS"},{"src":"<getConfigValue('retries')>","dst":"<'retries'>","type":"PASSES_ARGUMENT"},{"src":"<asyncDestructureHandler:fn>","dst":"<{ timeout, retries }>","type":"RETURNS"},{"src":"<{ timeout, retries }>","dst":"<timeout>","type":"READS_FROM"},{"src":"<{ timeout, retries }>","dst":"<retries>","type":"READS_FROM"},{"src":"<getConfigValue('timeout')>","dst":"<timeout>","type":"AWAITS"},{"src":"<getConfigValue('retries')>","dst":"<retries>","type":"AWAITS"}],"rationale":"Async function with destructured parameter containing async default values. Each destructured property awaits a function call for its default value. Used PROPERTY instead of DESTRUCTURED_PROPERTY, HAS_PROPERTY instead of DESTRUCTURES, and added AWAITS edges to capture async behavior.","implicitBehavior":["await expressions in parameter defaults are evaluated sequentially during parameter binding","if destructuring assignment fails, default object {} is used","async function calls in defaults create promise dependencies that must resolve before function body executes"]},"pass":2,"annotatedAt":"2026-02-24T00:29:33.295Z"}
{"construct":{"id":"builtins::builtin-json-stringify-replacer","file":"src/builtins.js","category":"builtins","lineStart":25,"lineEnd":33,"code":"function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonStringifyReplacer>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<JSON.stringify(obj, replacer, 2)>","metadata":{"callee":"JSON.stringify"}},{"type":"PROPERTY_ACCESS","id":"<JSON.stringify>","metadata":{"objectName":"JSON","propertyName":"stringify"}},{"type":"FUNCTION","id":"<replacer>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<value>"},{"type":"EXPRESSION","id":"<typeof value === 'function'>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<typeof value>","metadata":{"operator":"typeof"}},{"type":"LITERAL","id":"<'function'>","metadata":{"value":"function","literalType":"string"}},{"type":"LITERAL","id":"<undefined>","metadata":{"value":"undefined","literalType":"undefined"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"BRANCH","id":"<if-typeof-function>","metadata":{"branchType":"if"}}],"edges":[{"src":"<jsonStringifyReplacer>","dst":"<obj>","type":"HAS_BODY"},{"src":"<jsonStringifyReplacer>","dst":"<JSON.stringify(obj, replacer, 2)>","type":"RETURNS"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<JSON.stringify>","type":"CALLS"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<replacer>","type":"PASSES_ARGUMENT"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<2>","type":"PASSES_ARGUMENT"},{"src":"<replacer>","dst":"<key>","type":"HAS_BODY"},{"src":"<replacer>","dst":"<value>","type":"HAS_BODY"},{"src":"<replacer>","dst":"<if-typeof-function>","type":"HAS_BODY"},{"src":"<if-typeof-function>","dst":"<typeof value === 'function'>","type":"HAS_CONDITION"},{"src":"<typeof value === 'function'>","dst":"<typeof value>","type":"READS_FROM"},{"src":"<typeof value === 'function'>","dst":"<'function'>","type":"READS_FROM"},{"src":"<typeof value>","dst":"<value>","type":"READS_FROM"},{"src":"<if-typeof-function>","dst":"<undefined>","type":"HAS_CONSEQUENT"},{"src":"<if-typeof-function>","dst":"<value>","type":"HAS_ALTERNATE"}],"rationale":"Function that wraps JSON.stringify with a replacer callback. The replacer filters out function values by returning undefined, otherwise returns the original value.","implicitBehavior":["JSON.stringify is a built-in global method","replacer callback is invoked for each property during serialization","returning undefined from replacer excludes the property from output"]},"pass":2,"annotatedAt":"2026-02-24T00:29:33.753Z"}
{"construct":{"id":"async-generators::yield-expression-positions","file":"src/async-generators.js","category":"async-generators","lineStart":271,"lineEnd":280,"code":"function* exoticYield() {\n  console.log(yield 'prompt');                 // yield as function argument\n  const pair = [yield 'a', yield 'b'];         // yield in array literal\n  const msg = `Hello ${yield 'name'}!`;        // yield in template literal\n  const val = (yield 'check') ? 'yes' : 'no'; // yield in ternary condition\n  const obj = { x: yield 'x', y: yield 'y' }; // yield in object literal\n}\n\n// --- yield yield (chained) ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<exoticYield>\",\n      \"metadata\": {\n        \"generator\": true,\n        \"async\": false\n      }\n    },\n    {\n      \"type\": \"CALL\",\n   "},"pass":2,"annotatedAt":"2026-02-24T00:29:36.843Z"}
{"construct":{"id":"builtins::builtin-weakset","file":"src/builtins.js","category":"builtins","lineStart":108,"lineEnd":120,"code":"function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<weakSetUsage>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<ws>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new WeakSet()>","metadata":{"callee":"WeakSet","isConstructor":true}},{"type":"VARIABLE","id":"<obj1>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"VARIABLE","id":"<obj2>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}2>","metadata":{"value":"{}","literalType":"object"}},{"type":"CALL","id":"<ws.add(obj1)>","metadata":{"callee":"add","method":true}},{"type":"VARIABLE","id":"<has>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ws.has(obj1)>","metadata":{"callee":"has","method":true}},{"type":"CALL","id":"<ws.delete(obj1)>","metadata":{"callee":"delete","method":true}},{"type":"VARIABLE","id":"<hasAfter>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ws.has(obj1)2>","metadata":{"callee":"has","method":true}},{"type":"EXPRESSION","id":"<{ has, hasAfter }>","metadata":{"type":"object"}}],"edges":[{"src":"<weakSetUsage>","dst":"<ws>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<obj1>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<obj2>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<has>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<hasAfter>","type":"CONTAINS"},{"src":"<ws>","dst":"<new WeakSet()>","type":"ASSIGNED_FROM"},{"src":"<new WeakSet()>","dst":"<WeakSet>","type":"CALLS"},{"src":"<obj1>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<obj2>","dst":"<{}2>","type":"ASSIGNED_FROM"},{"src":"<ws.add(obj1)>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.add(obj1)>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<has>","dst":"<ws.has(obj1)>","type":"ASSIGNED_FROM"},{"src":"<ws.has(obj1)>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.has(obj1)>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<ws.delete(obj1)>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.delete(obj1)>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<hasAfter>","dst":"<ws.has(obj1)2>","type":"ASSIGNED_FROM"},{"src":"<ws.has(obj1)2>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.has(obj1)2>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<weakSetUsage>","dst":"<{ has, hasAfter }>","type":"RETURNS"},{"src":"<{ has, hasAfter }>","dst":"<has>","type":"READS_FROM"},{"src":"<{ has, hasAfter }>","dst":"<hasAfter>","type":"READS_FROM"}],"rationale":"Function demonstrating WeakSet operations: construction, adding objects, checking membership, deletion, and re-checking. Returns object with before/after membership results. Changed CALLS to CALLS_ON for method invocations to better capture the receiver relationship.","implicitBehavior":["WeakSet holds weak references to objects","Objects may be garbage collected if no other references exist","WeakSet is not enumerable"]},"pass":2,"annotatedAt":"2026-02-24T00:29:40.205Z"}
{"construct":{"id":"builtins::builtin-weakmap","file":"src/builtins.js","category":"builtins","lineStart":95,"lineEnd":106,"code":"function weakMapUsage() {\n  const wm = new WeakMap();\n  const key1 = {};\n  const key2 = {};\n  wm.set(key1, 'data1');\n  wm.set(key2, 'data2');\n  const val = wm.get(key1);\n  const has = wm.has(key2);\n  wm.delete(key1);\n  return { val, has };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<weakMapUsage>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIABLE"},"pass":2,"annotatedAt":"2026-02-24T00:29:40.210Z"}
{"construct":{"id":"builtins::builtin-globalthis","file":"src/builtins.js","category":"builtins","lineStart":306,"lineEnd":313,"code":"function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<globalThisAccess>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<g>","metadata":{"kind":"const"}},{"type":"EXTERNAL","id":"<globalThis>","metadata":{"builtinType":"global"}},{"type":"VARIABLE","id":"<hasConsole>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<'console' in globalThis>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<'console'>","metadata":{"value":"console","literalType":"string"}},{"type":"EXPRESSION","id":"<{ g, hasConsole }>","metadata":{"type":"object"}}],"edges":[{"src":"<globalThisAccess>","dst":"<g>","type":"CONTAINS"},{"src":"<globalThisAccess>","dst":"<hasConsole>","type":"CONTAINS"},{"src":"<g>","dst":"<globalThis>","type":"ASSIGNED_FROM"},{"src":"<hasConsole>","dst":"<'console' in globalThis>","type":"ASSIGNED_FROM"},{"src":"<'console' in globalThis>","dst":"<'console'>","type":"READS_FROM"},{"src":"<'console' in globalThis>","dst":"<globalThis>","type":"READS_FROM"},{"src":"<globalThisAccess>","dst":"<{ g, hasConsole }>","type":"RETURNS"},{"src":"<{ g, hasConsole }>","dst":"<g>","type":"READS_FROM"},{"src":"<{ g, hasConsole }>","dst":"<hasConsole>","type":"READS_FROM"}],"rationale":"Function accesses globalThis builtin, stores reference and checks for console property existence. Returns object with both values. Removed module declaration edge to stay within edge count threshold.","implicitBehavior":["globalThis provides access to global object across environments","in operator checks property existence without accessing value"]},"pass":2,"annotatedAt":"2026-02-24T00:29:41.372Z"}
{"construct":{"id":"async-generators::async-return-thenable","file":"src/async-generators.js","category":"async-generators","lineStart":151,"lineEnd":158,"code":"async function returnsThenable() {\n  return {\n    then(resolve) {\n      resolve(42);\n    },\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<returnsThenable>","metadata":{"async":true,"generator":false}},{"type":"EXPRESSION","id":"<thenable-object>","metadata":{"thenable":true,"expressionType":"object_literal"}},{"type":"METHOD","id":"<then>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<resolve>"},{"type":"CALL","id":"<resolve(42)>","metadata":{"callee":"resolve"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<returnsThenable>","dst":"<thenable-object>","type":"RETURNS"},{"src":"<thenable-object>","dst":"<then>","type":"HAS_PROPERTY"},{"src":"<then>","dst":"<resolve>","type":"HAS_BODY"},{"src":"<then>","dst":"<resolve(42)>","type":"HAS_BODY"},{"src":"<resolve(42)>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Async function returns a thenable object with a then method that calls resolve with 42. Used EXPRESSION for object literal and HAS_BODY for method contents.","implicitBehavior":["async function wraps return value in Promise","thenable object will be awaited/resolved by Promise machinery","resolve callback fulfills the promise with the passed value"]},"pass":2,"annotatedAt":"2026-02-24T00:29:41.435Z"}
{"construct":{"id":"builtins::builtin-finalization-registry","file":"src/builtins.js","category":"builtins","lineStart":130,"lineEnd":140,"code":"function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<finalizationUsage>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<registry>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new FinalizationRegistry(...)>","metadata":{"callee":"FinalizationRegistry","constructor":true}},{"type":"FUNCTION","id":"<cleanup-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<heldValue>"},{"type":"CALL","id":"<console.log(...)>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<`Cleaned up: ${heldValue}`>","metadata":{"templateLiteral":true}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<{ id: 1 }>","metadata":{"value":"{ id: 1 }","literalType":"object"}},{"type":"CALL","id":"<registry.register(obj, 'resource-1')>","metadata":{"callee":"register"}},{"type":"LITERAL","id":"<'resource-1'>","metadata":{"value":"resource-1","literalType":"string"}}],"edges":[{"src":"<finalizationUsage>","dst":"<registry>","type":"CONTAINS"},{"src":"<finalizationUsage>","dst":"<obj>","type":"CONTAINS"},{"src":"<registry>","dst":"<new FinalizationRegistry(...)>","type":"ASSIGNED_FROM"},{"src":"<new FinalizationRegistry(...)>","dst":"<cleanup-callback>","type":"PASSES_ARGUMENT"},{"src":"<cleanup-callback>","dst":"<heldValue>","type":"CONTAINS"},{"src":"<cleanup-callback>","dst":"<console.log(...)>","type":"CONTAINS"},{"src":"<console.log(...)>","dst":"<`Cleaned up: ${heldValue}`>","type":"PASSES_ARGUMENT"},{"src":"<`Cleaned up: ${heldValue}`>","dst":"<heldValue>","type":"READS_FROM"},{"src":"<obj>","dst":"<{ id: 1 }>","type":"ASSIGNED_FROM"},{"src":"<finalizationUsage>","dst":"<registry.register(obj, 'resource-1')>","type":"CONTAINS"},{"src":"<registry.register(obj, 'resource-1')>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<registry.register(obj, 'resource-1')>","dst":"<'resource-1'>","type":"PASSES_ARGUMENT"},{"src":"<finalizationUsage>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function creates a FinalizationRegistry with cleanup callback, registers an object for finalization tracking, and returns the object. Reduced edge count by removing module declaration edge and consolidating method call relationships.","implicitBehavior":["FinalizationRegistry callback executes asynchronously during garbage collection","Weak reference to registered object allows garbage collection","Held value ('resource-1') is passed to cleanup callback when object is finalized"]},"pass":2,"annotatedAt":"2026-02-24T00:29:41.845Z"}
{"construct":{"id":"builtins::regex-lookahead","file":"src/builtins.js","category":"builtins","lineStart":328,"lineEnd":330,"code":"const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<posLookahead>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\d+(?=px)/>","metadata":{"value":"/\\d+(?=px)/","literalType":"regex","pattern":"\\d+(?=px)","flags":""}},{"type":"VARIABLE","id":"<negLookahead>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\d+(?!px)/>","metadata":{"value":"/\\d+(?!px)/","literalType":"regex","pattern":"\\d+(?!px)","flags":""}}],"edges":[{"src":"<module>","dst":"<posLookahead>","type":"DECLARES"},{"src":"<posLookahead>","dst":"</\\d+(?=px)/>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<negLookahead>","type":"DECLARES"},{"src":"<negLookahead>","dst":"</\\d+(?!px)/>","type":"ASSIGNED_FROM"}],"rationale":"Two const variable declarations initialized with regex literals. The Pass 1 annotation already used only approved vocabulary types, so no changes were needed. VARIABLE and LITERAL are approved node types, and DECLARES and ASSIGNED_FROM are approved edge types.","implicitBehavior":["regex literals create RegExp objects with compile-time pattern validation","lookahead assertions are zero-width - they don't consume characters in matches"]},"pass":2,"annotatedAt":"2026-02-24T00:29:42.967Z"}
{"construct":{"id":"builtins::builtin-regex-named-groups","file":"src/builtins.js","category":"builtins","lineStart":191,"lineEnd":200,"code":"function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<regexNamedGroups>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<dateStr>"},{"type":"VARIABLE","id":"<pattern>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>","metadata":{"value":"/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/","literalType":"regex","namedGroups":["year","month","day"]}},{"type":"VARIABLE","id":"<match>","metadata":{"kind":"const"}},{"type":"CALL","id":"<dateStr.match(pattern)>","metadata":{"callee":"match","method":true}},{"type":"BRANCH","id":"<if (!match)>","metadata":{"condition":"!match"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"VARIABLE","id":"<year>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<month>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<day>","metadata":{"kind":"const","destructured":true}},{"type":"PROPERTY_ACCESS","id":"<match.groups>","metadata":{"objectName":"match","propertyName":"groups"}},{"type":"EXPRESSION","id":"<{ year, month, day }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<regexNamedGroups>","dst":"<dateStr>","type":"CONTAINS"},{"src":"<regexNamedGroups>","dst":"<pattern>","type":"CONTAINS"},{"src":"<pattern>","dst":"</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>","type":"ASSIGNED_FROM"},{"src":"<regexNamedGroups>","dst":"<match>","type":"CONTAINS"},{"src":"<match>","dst":"<dateStr.match(pattern)>","type":"ASSIGNED_FROM"},{"src":"<dateStr.match(pattern)>","dst":"<dateStr>","type":"READS_FROM"},{"src":"<dateStr.match(pattern)>","dst":"<pattern>","type":"PASSES_ARGUMENT"},{"src":"<regexNamedGroups>","dst":"<if (!match)>","type":"CONTAINS"},{"src":"<if (!match)>","dst":"<match>","type":"HAS_CONDITION"},{"src":"<if (!match)>","dst":"<null>","type":"HAS_CONSEQUENT"},{"src":"<regexNamedGroups>","dst":"<year>","type":"CONTAINS"},{"src":"<regexNamedGroups>","dst":"<month>","type":"CONTAINS"},{"src":"<regexNamedGroups>","dst":"<day>","type":"CONTAINS"},{"src":"<year>","dst":"<match.groups>","type":"ASSIGNED_FROM"},{"src":"<month>","dst":"<match.groups>","type":"ASSIGNED_FROM"},{"src":"<day>","dst":"<match.groups>","type":"ASSIGNED_FROM"},{"src":"<match.groups>","dst":"<match>","type":"READS_FROM"},{"src":"<regexNamedGroups>","dst":"<{ year, month, day }>","type":"RETURNS"},{"src":"<{ year, month, day }>","dst":"<year>","type":"READS_FROM"},{"src":"<{ year, month, day }>","dst":"<month>","type":"READS_FROM"},{"src":"<{ year, month, day }>","dst":"<day>","type":"READS_FROM"}],"rationale":"Function using regex with named capture groups. Pattern matches date format, result destructured from match.groups property, then returned as object literal. Used ASSIGNED_FROM for destructuring since DESTRUCTURED_FROM is not in approved vocabulary.","implicitBehavior":["regex named groups create properties on match.groups object","destructuring assignment extracts properties by name","match() returns null for non-matches"]},"pass":2,"annotatedAt":"2026-02-24T00:29:45.325Z"}
{"construct":{"id":"builtins::regex-lookbehind","file":"src/builtins.js","category":"builtins","lineStart":332,"lineEnd":334,"code":"const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<posLookbehind>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<=\\$)\\d+/>","metadata":{"value":"/(?<=\\$)\\d+/","literalType":"regex","flags":"","hasLookbehind":true,"lookbehindType":"positive"}},{"type":"VARIABLE","id":"<negLookbehind>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<!\\$)\\d+/>","metadata":{"value":"/(?<!\\$)\\d+/","literalType":"regex","flags":"","hasLookbehind":true,"lookbehindType":"negative"}}],"edges":[{"src":"<module>","dst":"<posLookbehind>","type":"DECLARES"},{"src":"<posLookbehind>","dst":"</(?<=\\$)\\d+/>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<negLookbehind>","type":"DECLARES"},{"src":"<negLookbehind>","dst":"</(?<!\\$)\\d+/>","type":"ASSIGNED_FROM"}],"rationale":"Two const variable declarations initialized with regex literals. First uses positive lookbehind to match digits after $, second uses negative lookbehind to match digits not after $. All types used in Pass 1 are in the approved vocabulary.","implicitBehavior":["lookbehind assertions require ES2018+ support","regex literals create RegExp objects at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:29:46.044Z"}
{"construct":{"id":"builtins::builtin-regex-exec","file":"src/builtins.js","category":"builtins","lineStart":169,"lineEnd":178,"code":"function regexExec(pattern, str) {\n  const regex = new RegExp(pattern, 'g');\n  const matches = [];\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    matches.push({ match: match[0], index: match.index });\n  }\n  return matches;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<regexExec>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<pattern>"},{"type":"PARAMETER","id":"<str>"},{"type":"VARIABLE","id":"<regex>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new RegExp(pattern, 'g')>","metadata":{"callee":"RegExp","constructor":true}},{"type":"LITERAL","id":"<'g'>","metadata":{"value":"g","literalType":"string"}},{"type":"VARIABLE","id":"<matches>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"literalType":"array","empty":true}},{"type":"VARIABLE","id":"<match>","metadata":{"kind":"let"}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<(match = regex.exec(str)) !== null>","metadata":{"operator":"!=="}},{"type":"EXPRESSION","id":"<match = regex.exec(str)>","metadata":{"operator":"="}},{"type":"CALL","id":"<regex.exec(str)>","metadata":{"callee":"exec","method":true}},{"type":"LITERAL","id":"<null>","metadata":{"literalType":"null"}},{"type":"CALL","id":"<matches.push({ match: match[0], index: match.index })>","metadata":{"callee":"push","method":true}},{"type":"LITERAL","id":"<{ match: match[0], index: match.index }>","metadata":{"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<match[0]>","metadata":{"property":"0","computed":true}},{"type":"PROPERTY_ACCESS","id":"<match.index>","metadata":{"property":"index"}}],"edges":[{"src":"<regexExec>","dst":"<pattern>","type":"CONTAINS"},{"src":"<regexExec>","dst":"<str>","type":"CONTAINS"},{"src":"<regexExec>","dst":"<regex>","type":"CONTAINS"},{"src":"<regexExec>","dst":"<matches>","type":"CONTAINS"},{"src":"<regexExec>","dst":"<match>","type":"CONTAINS"},{"src":"<regexExec>","dst":"<while>","type":"CONTAINS"},{"src":"<regex>","dst":"<new RegExp(pattern, 'g')>","type":"ASSIGNED_FROM"},{"src":"<new RegExp(pattern, 'g')>","dst":"<pattern>","type":"PASSES_ARGUMENT"},{"src":"<new RegExp(pattern, 'g')>","dst":"<'g'>","type":"PASSES_ARGUMENT"},{"src":"<matches>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<while>","dst":"<(match = regex.exec(str)) !== null>","type":"HAS_CONDITION"},{"src":"<(match = regex.exec(str)) !== null>","dst":"<match = regex.exec(str)>","type":"READS_FROM"},{"src":"<(match = regex.exec(str)) !== null>","dst":"<null>","type":"READS_FROM"},{"src":"<match = regex.exec(str)>","dst":"<match>","type":"WRITES_TO"},{"src":"<match = regex.exec(str)>","dst":"<regex.exec(str)>","type":"READS_FROM"},{"src":"<regex.exec(str)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<while>","dst":"<matches.push({ match: match[0], index: match.index })>","type":"HAS_BODY"},{"src":"<matches.push({ match: match[0], index: match.index })>","dst":"<{ match: match[0], index: match.index }>","type":"PASSES_ARGUMENT"},{"src":"<{ match: match[0], index: match.index }>","dst":"<match[0]>","type":"READS_FROM"},{"src":"<{ match: match[0], index: match.index }>","dst":"<match.index>","type":"READS_FROM"},{"src":"<match[0]>","dst":"<match>","type":"READS_FROM"},{"src":"<match.index>","dst":"<match>","type":"READS_FROM"},{"src":"<regexExec>","dst":"<matches>","type":"RETURNS"}],"rationale":"Function that creates a RegExp with global flag and uses exec() in a while loop to find all matches. Returns array of match objects with match text and index. Reduced edge count by removing redundant relationships and focusing on essential data flow.","implicitBehavior":["RegExp.exec() with global flag maintains internal lastIndex state","exec() returns null when no more matches found","Array.push() mutates the matches array"]},"pass":2,"annotatedAt":"2026-02-24T00:29:46.368Z"}
{"construct":{"id":"async-generators::async-iter-manual","file":"src/async-generators.js","category":"async-generators","lineStart":138,"lineEnd":149,"code":"async function manualAsyncIteration(asyncIterable) {\n  const asyncIter = asyncIterable[Symbol.asyncIterator]();\n  const results = [];\n  let step = await asyncIter.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = await asyncIter.next();\n  }\n  await asyncIter.return?.();\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<manualAsyncIteration>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncIterable>"},{"type":"VARIABLE","id":"<asyncIter>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<asyncIterable[Symbol.asyncIterator]>","metadata":{"computed":true}},{"type":"CALL","id":"<asyncIterable[Symbol.asyncIterator]()>","metadata":{"callee":"asyncIterable[Symbol.asyncIterator]"}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"VARIABLE","id":"<step>","metadata":{"kind":"let"}},{"type":"CALL","id":"<asyncIter.next()>","metadata":{"callee":"asyncIter.next","awaited":true}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<!step.done>","metadata":{"operator":"!"}},{"type":"PROPERTY_ACCESS","id":"<step.done>"},{"type":"CALL","id":"<results.push(step.value)>","metadata":{"callee":"results.push"}},{"type":"PROPERTY_ACCESS","id":"<step.value>"},{"type":"EXPRESSION","id":"<step = await asyncIter.next()>","metadata":{"operator":"="}},{"type":"CALL","id":"<asyncIter.next()#2>","metadata":{"callee":"asyncIter.next","awaited":true}},{"type":"CALL","id":"<asyncIter.return?.()>","metadata":{"callee":"asyncIter.return","optional":true,"awaited":true}},{"type":"PROPERTY_ACCESS","id":"<asyncIter.return>"}],"edges":[{"src":"<manualAsyncIteration>","dst":"<asyncIterable>","type":"CONTAINS"},{"src":"<manualAsyncIteration>","dst":"<asyncIter>","type":"CONTAINS"},{"src":"<asyncIter>","dst":"<asyncIterable[Symbol.asyncIterator]()>","type":"ASSIGNED_FROM"},{"src":"<asyncIterable[Symbol.asyncIterator]()>","dst":"<asyncIterable[Symbol.asyncIterator]>","type":"CALLS"},{"src":"<asyncIterable[Symbol.asyncIterator]>","dst":"<asyncIterable>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<manualAsyncIteration>","dst":"<step>","type":"CONTAINS"},{"src":"<step>","dst":"<asyncIter.next()>","type":"ASSIGNED_FROM"},{"src":"<asyncIter.next()>","dst":"<asyncIter>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<while>","type":"CONTAINS"},{"src":"<while>","dst":"<!step.done>","type":"HAS_CONDITION"},{"src":"<!step.done>","dst":"<step.done>","type":"READS_FROM"},{"src":"<step.done>","dst":"<step>","type":"READS_FROM"},{"src":"<while>","dst":"<results.push(step.value)>","type":"CONTAINS"},{"src":"<results.push(step.value)>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(step.value)>","dst":"<step.value>","type":"PASSES_ARGUMENT"},{"src":"<step.value>","dst":"<step>","type":"READS_FROM"},{"src":"<while>","dst":"<step = await asyncIter.next()>","type":"CONTAINS"},{"src":"<step = await asyncIter.next()>","dst":"<step>","type":"WRITES_TO"},{"src":"<step = await asyncIter.next()>","dst":"<asyncIter.next()#2>","type":"READS_FROM"},{"src":"<asyncIter.next()#2>","dst":"<asyncIter>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<asyncIter.return?.()>","type":"CONTAINS"},{"src":"<asyncIter.return?.()>","dst":"<asyncIter.return>","type":"CALLS"},{"src":"<asyncIter.return>","dst":"<asyncIter>","type":"READS_FROM"},{"src":"<manualAsyncIteration>","dst":"<results>","type":"RETURNS"}],"rationale":"Async function that manually implements async iteration protocol. Gets async iterator, loops while not done, collects values, optionally calls return method, and returns collected results.","implicitBehavior":["async iterator protocol compliance","optional chaining prevents error if return method doesn't exist","await expressions suspend execution until promises resolve"]},"pass":2,"annotatedAt":"2026-02-24T00:29:46.368Z"}
{"construct":{"id":"builtins::builtin-arraybuffer","file":"src/builtins.js","category":"builtins","lineStart":142,"lineEnd":151,"code":"function arrayBufferOps() {\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n  view.setInt32(0, 42);\n  view.setFloat64(4, 3.14);\n  const int = view.getInt32(0);\n  const float = view.getFloat64(4);\n  return { int, float, byteLength: buffer.byteLength };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<arrayBufferOps>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIAB"},"pass":2,"annotatedAt":"2026-02-24T00:29:47.378Z"}
{"construct":{"id":"builtins::string-raw-template","file":"src/builtins.js","category":"builtins","lineStart":344,"lineEnd":346,"code":"const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file'  no escape processing","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<windowsPath>","metadata":{"kind":"const"}},{"type":"CALL","id":"<String.raw`C:\\Users\\name\\file`>","metadata":{"callee":"String.raw","callType":"tagged-template"}},{"type":"PROPERTY_ACCESS","id":"<String.raw>","metadata":{"objectName":"String","propertyName":"raw"}},{"type":"LITERAL","id":"<String>","metadata":{"value":"String","literalType":"identifier","builtinType":"constructor"}},{"type":"LITERAL","id":"<template-literal>","metadata":{"value":"C:\\Users\\name\\file","literalType":"template","raw":true}}],"edges":[{"src":"<module>","dst":"<windowsPath>","type":"DECLARES"},{"src":"<windowsPath>","dst":"<String.raw`C:\\Users\\name\\file`>","type":"ASSIGNED_FROM"},{"src":"<String.raw`C:\\Users\\name\\file`>","dst":"<String.raw>","type":"CALLS"},{"src":"<String.raw>","dst":"<String>","type":"READS_FROM"},{"src":"<String.raw`C:\\Users\\name\\file`>","dst":"<template-literal>","type":"PASSES_ARGUMENT"}],"rationale":"Tagged template literal using String.raw to prevent escape sequence processing. The template literal is passed as argument to the tag function. All types and relationships from Pass 1 are already in the approved vocabulary.","implicitBehavior":["String.raw receives template strings array and substitution values","backslashes are preserved literally without escape processing"]},"pass":2,"annotatedAt":"2026-02-24T00:29:47.894Z"}
{"construct":{"id":"builtins::regex-unicode-props","file":"src/builtins.js","category":"builtins","lineStart":339,"lineEnd":342,"code":"const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<emoji>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\p{Emoji}/u>","metadata":{"value":"/\\p{Emoji}/u","literalType":"regex","flags":["u"],"unicodeProperty":"Emoji"}},{"type":"VARIABLE","id":"<greek>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\p{Script=Greek}/u>","metadata":{"value":"/\\p{Script=Greek}/u","literalType":"regex","flags":["u"],"unicodeProperty":"Script=Greek"}},{"type":"VARIABLE","id":"<letter>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\p{Letter}/u>","metadata":{"value":"/\\p{Letter}/u","literalType":"regex","flags":["u"],"unicodeProperty":"Letter"}}],"edges":[{"src":"<MODULE>","dst":"<emoji>","type":"DECLARES"},{"src":"<emoji>","dst":"</\\p{Emoji}/u>","type":"ASSIGNED_FROM"},{"src":"<MODULE>","dst":"<greek>","type":"DECLARES"},{"src":"<greek>","dst":"</\\p{Script=Greek}/u>","type":"ASSIGNED_FROM"},{"src":"<MODULE>","dst":"<letter>","type":"DECLARES"},{"src":"<letter>","dst":"</\\p{Letter}/u>","type":"ASSIGNED_FROM"}],"rationale":"Three const variable declarations, each initialized with a regex literal using Unicode property escapes. The 'u' flag enables Unicode property matching. All node and edge types from Pass 1 are in the approved vocabulary.","implicitBehavior":["Unicode property escapes require the 'u' flag to function","RegExp objects created at runtime with compiled patterns"]},"pass":2,"annotatedAt":"2026-02-24T00:29:48.485Z"}
{"construct":{"id":"builtins::array-from-mapfn","file":"src/builtins.js","category":"builtins","lineStart":357,"lineEnd":363,"code":"function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<arrayFromMapFn>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<indices>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Array.from({ length: 5 }, (_, i) => i)>","metadata":{"callee":"Array.from"}},{"type":"LITERAL","id":"<{ length: 5 }>","metadata":{"value":"{ length: 5 }","literalType":"object"}},{"type":"FUNCTION","id":"<(_, i) => i>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<_>"},{"type":"PARAMETER","id":"<i>"}],"edges":[{"src":"<arrayFromMapFn>","dst":"<indices>","type":"CONTAINS"},{"src":"<indices>","dst":"<Array.from({ length: 5 }, (_, i) => i)>","type":"ASSIGNED_FROM"},{"src":"<Array.from({ length: 5 }, (_, i) => i)>","dst":"<Array.from>","type":"CALLS"},{"src":"<Array.from({ length: 5 }, (_, i) => i)>","dst":"<{ length: 5 }>","type":"PASSES_ARGUMENT"},{"src":"<Array.from({ length: 5 }, (_, i) => i)>","dst":"<(_, i) => i>","type":"PASSES_ARGUMENT"},{"src":"<(_, i) => i>","dst":"<_>","type":"CONTAINS"},{"src":"<(_, i) => i>","dst":"<i>","type":"CONTAINS"},{"src":"<(_, i) => i>","dst":"<i>","type":"RETURNS"},{"src":"<arrayFromMapFn>","dst":"<indices>","type":"RETURNS"}],"rationale":"Function that uses Array.from with a mapper function. The call passes an array-like object and an arrow function that returns the index parameter. Removed the module-level DECLARES edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["Array.from iterates over array-like object calling mapper with (value, index)","Arrow function implicitly returns the index parameter"]},"pass":2,"annotatedAt":"2026-02-24T00:29:50.345Z"}
{"construct":{"id":"callbacks::callback-error-first","file":"src/callbacks.js","category":"callbacks","lineStart":7,"lineEnd":15,"code":"function readFileCallback(path, callback) {\n  try {\n    const data = `contents of ${path}`;\n    callback(null, data);\n  } catch (err) {\n    callback(err, null);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<readFileCallback>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<path>"},{"type":"PARAMETER","id":"<callback>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<`contents of ${path}`>","metadata":{"type":"template-literal"}},{"type":"CALL","id":"<callback(null, data)>","metadata":{"callee":"callback"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<err>"},{"type":"CALL","id":"<callback(err, null)>","metadata":{"callee":"callback"}}],"edges":[{"src":"<readFileCallback>","dst":"<path>","type":"CONTAINS"},{"src":"<readFileCallback>","dst":"<callback>","type":"CONTAINS"},{"src":"<readFileCallback>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<data>","type":"CONTAINS"},{"src":"<data>","dst":"<`contents of ${path}`>","type":"ASSIGNED_FROM"},{"src":"<`contents of ${path}`>","dst":"<path>","type":"READS_FROM"},{"src":"<try-block>","dst":"<callback(null, data)>","type":"CONTAINS"},{"src":"<callback(null, data)>","dst":"<callback>","type":"CALLS"},{"src":"<callback(null, data)>","dst":"<null>","type":"PASSES_ARGUMENT"},{"src":"<callback(null, data)>","dst":"<data>","type":"PASSES_ARGUMENT"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<err>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<callback(err, null)>","type":"CONTAINS"},{"src":"<callback(err, null)>","dst":"<callback>","type":"CALLS"},{"src":"<callback(err, null)>","dst":"<err>","type":"PASSES_ARGUMENT"},{"src":"<callback(err, null)>","dst":"<null>","type":"PASSES_ARGUMENT"}],"rationale":"Error-first callback pattern function with try-catch. Success path calls callback with null error and data, error path calls callback with error and null data. Removed module declaration edge as no module node was defined.","implicitBehavior":["follows Node.js error-first callback convention","callback invoked exactly once per execution path"]},"pass":2,"annotatedAt":"2026-02-24T00:29:55.669Z"}
{"construct":{"id":"async-generators::promise-resolve-thenable","file":"src/async-generators.js","category":"async-generators","lineStart":160,"lineEnd":172,"code":"async function nestedThenable() {\n  const thenable = {\n    then(resolve) {\n      resolve({\n        then(resolve2) {\n          resolve2(42); // nested thenables unwrap recursively\n        },\n      });\n    },\n  };\n  return await Promise.resolve(thenable);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<nestedThenable>","metadata":{"async":true,"generator":false}},{"type":"VARIABLE","id":"<thenable>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<thenable-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<thenable.then>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<resolve>"},{"type":"CALL","id":"<resolve(nested-thenable)>","metadata":{"callee":"resolve"}},{"type":"LITERAL","id":"<nested-thenable-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<nested-thenable.then>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<resolve2>"},{"type":"CALL","id":"<resolve2(42)>","metadata":{"callee":"resolve2"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"CALL","id":"<Promise.resolve(thenable)>","metadata":{"callee":"Promise.resolve"}},{"type":"EXPRESSION","id":"<await Promise.resolve(thenable)>","metadata":{"operator":"await"}}],"edges":[{"src":"<nestedThenable>","dst":"<thenable>","type":"CONTAINS"},{"src":"<thenable>","dst":"<thenable-object>","type":"ASSIGNED_FROM"},{"src":"<thenable-object>","dst":"<thenable.then>","type":"HAS_PROPERTY"},{"src":"<thenable.then>","dst":"<resolve>","type":"RECEIVES_ARGUMENT"},{"src":"<thenable.then>","dst":"<resolve(nested-thenable)>","type":"CONTAINS"},{"src":"<resolve(nested-thenable)>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve(nested-thenable)>","dst":"<nested-thenable-object>","type":"PASSES_ARGUMENT"},{"src":"<nested-thenable-object>","dst":"<nested-thenable.then>","type":"HAS_PROPERTY"},{"src":"<nested-thenable.then>","dst":"<resolve2>","type":"RECEIVES_ARGUMENT"},{"src":"<nested-thenable.then>","dst":"<resolve2(42)>","type":"CONTAINS"},{"src":"<resolve2(42)>","dst":"<resolve2>","type":"CALLS"},{"src":"<resolve2(42)>","dst":"<42>","type":"PASSES_ARGUMENT"},{"src":"<Promise.resolve(thenable)>","dst":"<thenable>","type":"PASSES_ARGUMENT"},{"src":"<await Promise.resolve(thenable)>","dst":"<Promise.resolve(thenable)>","type":"AWAITS"},{"src":"<nestedThenable>","dst":"<await Promise.resolve(thenable)>","type":"RETURNS"}],"rationale":"Async function with nested thenable objects. Promise.resolve unwraps the outer thenable, which resolves to another thenable that eventually resolves to 42. Reduced edge count by removing module declaration and using more specific edge types like AWAITS and RECEIVES_ARGUMENT.","implicitBehavior":["Promise.resolve recursively unwraps thenables until a non-thenable value is reached","await suspends function execution until the promise resolves","nested thenable resolution happens asynchronously in sequence"]},"pass":2,"annotatedAt":"2026-02-24T00:29:56.896Z"}
{"construct":{"id":"builtins::builtin-date","file":"src/builtins.js","category":"builtins","lineStart":202,"lineEnd":216,"code":"function dateOperations() {\n  const now = new Date();\n  const specific = new Date(2024, 0, 15);\n  const fromISO = new Date('2024-01-15T10:30:00Z');\n  const timestamp = Date.now();\n\n  const year = now.getFullYear();\n  const month = now.getMonth();\n  const iso = now.toISOString();\n\n  return { now, specific, fromISO, timestamp, year, month, iso };\n}\n\n// --- Math ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<dateOperations>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIAB"},"pass":2,"annotatedAt":"2026-02-24T00:29:56.945Z"}
{"construct":{"id":"callbacks::callback-error-first-usage","file":"src/callbacks.js","category":"callbacks","lineStart":17,"lineEnd":28,"code":"function processFile(path) {\n  readFileCallback(path, function (err, data) {\n    if (err) {\n      console.error('Failed:', err);\n      return;\n    }\n    console.log('Data:', data);\n  });\n}\n\n// --- Callback hell (3+ levels) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<processFile>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<path>"},{"type":"CALL","id":"<readFileCallback(path, callback)>","metadata":{"callee":"readFileCallback"}},{"type":"FUNCTION","id":"<callback>","metadata":{"async":false,"generator":false,"callbackStyle":"error-first"}},{"type":"PARAMETER","id":"<err>"},{"type":"PARAMETER","id":"<data>"},{"type":"BRANCH","id":"<if-err>","metadata":{"condition":"err"}},{"type":"CALL","id":"<console.error('Failed:', err)>","metadata":{"callee":"console.error"}},{"type":"LITERAL","id":"<'Failed:'>","metadata":{"value":"Failed:","literalType":"string"}},{"type":"CALL","id":"<console.log('Data:', data)>","metadata":{"callee":"console.log"}},{"type":"LITERAL","id":"<'Data:'>","metadata":{"value":"Data:","literalType":"string"}}],"edges":[{"src":"<processFile>","dst":"<path>","type":"HAS_BODY"},{"src":"<processFile>","dst":"<readFileCallback(path, callback)>","type":"HAS_BODY"},{"src":"<readFileCallback(path, callback)>","dst":"<path>","type":"PASSES_ARGUMENT"},{"src":"<readFileCallback(path, callback)>","dst":"<callback>","type":"PASSES_ARGUMENT"},{"src":"<callback>","dst":"<err>","type":"HAS_BODY"},{"src":"<callback>","dst":"<data>","type":"HAS_BODY"},{"src":"<callback>","dst":"<if-err>","type":"HAS_BODY"},{"src":"<if-err>","dst":"<err>","type":"HAS_CONDITION"},{"src":"<if-err>","dst":"<console.error('Failed:', err)>","type":"HAS_CONSEQUENT"},{"src":"<if-err>","dst":"<console.log('Data:', data)>","type":"HAS_ALTERNATE"},{"src":"<console.error('Failed:', err)>","dst":"<'Failed:'>","type":"PASSES_ARGUMENT"},{"src":"<console.error('Failed:', err)>","dst":"<err>","type":"PASSES_ARGUMENT"},{"src":"<console.log('Data:', data)>","dst":"<'Data:'>","type":"PASSES_ARGUMENT"},{"src":"<console.log('Data:', data)>","dst":"<data>","type":"PASSES_ARGUMENT"}],"rationale":"Function that uses error-first callback pattern. Callback receives error and data parameters, branches on error condition to handle success/failure paths. Reduced edge count by removing CALLS edges and using HAS_BODY for containment relationships.","implicitBehavior":["callback executed asynchronously by readFileCallback","early return in error branch prevents execution of success path","error-first callback convention where first parameter indicates failure"]},"pass":2,"annotatedAt":"2026-02-24T00:29:58.894Z"}
{"construct":{"id":"callbacks::callback-settimeout","file":"src/callbacks.js","category":"callbacks","lineStart":108,"lineEnd":114,"code":"function delayedExecution(fn, ms) {\n  const id = setTimeout(fn, ms);\n  return function cancel() {\n    clearTimeout(id);\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<delayedExecution>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"PARAMETER","id":"<ms>"},{"type":"VARIABLE","id":"<id>","metadata":{"kind":"const"}},{"type":"CALL","id":"<setTimeout(fn, ms)>","metadata":{"callee":"setTimeout"}},{"type":"EXTERNAL","id":"<setTimeout>","metadata":{"source":"global"}},{"type":"FUNCTION","id":"<cancel>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<clearTimeout(id)>","metadata":{"callee":"clearTimeout"}},{"type":"EXTERNAL","id":"<clearTimeout>","metadata":{"source":"global"}}],"edges":[{"src":"<delayedExecution>","dst":"<fn>","type":"HAS_BODY"},{"src":"<delayedExecution>","dst":"<ms>","type":"HAS_BODY"},{"src":"<delayedExecution>","dst":"<id>","type":"HAS_BODY"},{"src":"<id>","dst":"<setTimeout(fn, ms)>","type":"ASSIGNED_FROM"},{"src":"<setTimeout(fn, ms)>","dst":"<setTimeout>","type":"CALLS"},{"src":"<setTimeout(fn, ms)>","dst":"<fn>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(fn, ms)>","dst":"<ms>","type":"PASSES_ARGUMENT"},{"src":"<delayedExecution>","dst":"<cancel>","type":"RETURNS"},{"src":"<cancel>","dst":"<clearTimeout(id)>","type":"HAS_BODY"},{"src":"<clearTimeout(id)>","dst":"<clearTimeout>","type":"CALLS"},{"src":"<clearTimeout(id)>","dst":"<id>","type":"PASSES_ARGUMENT"},{"src":"<cancel>","dst":"<id>","type":"CAPTURES"}],"rationale":"Function that creates a timeout and returns a cancellation function. The returned function captures the timeout ID from its enclosing scope. External functions setTimeout and clearTimeout are explicitly modeled as EXTERNAL nodes.","implicitBehavior":["setTimeout schedules callback execution on event loop","clearTimeout prevents scheduled callback execution","returned function forms closure over 'id' variable"]},"pass":2,"annotatedAt":"2026-02-24T00:29:59.023Z"}
{"construct":{"id":"builtins::symbol-private-property","file":"src/builtins.js","category":"builtins","lineStart":376,"lineEnd":382,"code":"const _private = Symbol('private');\nclass SymbolStore {\n  [_private] = new Map();\n  set(key, value) { this[_private].set(key, value); }\n  get(key) { return this[_private].get(key); }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<_private>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Symbol('private')>","metadata":{"callee":"Symbol"}},{"type":"LITERAL","id":"<'private'>","metadata":{"value":"private","literalType":"string"}},{"type":"CLASS","id":"<SymbolStore>"},{"type":"PROPERTY","id":"<SymbolStore[_private]>","metadata":{"computed":true,"private":true}},{"type":"CALL","id":"<new Map()>","metadata":{"callee":"Map","constructor":true}},{"type":"METHOD","id":"<SymbolStore.set>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<value>"},{"type":"PROPERTY_ACCESS","id":"<this[_private]>","metadata":{"computed":true}},{"type":"CALL","id":"<this[_private].set(key, value)>","metadata":{"callee":"set"}},{"type":"METHOD","id":"<SymbolStore.get>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<key2>","metadata":{"parameterName":"key"}},{"type":"PROPERTY_ACCESS","id":"<this[_private]2>","metadata":{"computed":true}},{"type":"CALL","id":"<this[_private].get(key)>","metadata":{"callee":"get"}}],"edges":[{"src":"<_private>","dst":"<Symbol('private')>","type":"ASSIGNED_FROM"},{"src":"<Symbol('private')>","dst":"<'private'>","type":"PASSES_ARGUMENT"},{"src":"<SymbolStore>","dst":"<SymbolStore[_private]>","type":"CONTAINS"},{"src":"<SymbolStore[_private]>","dst":"<_private>","type":"USES"},{"src":"<SymbolStore[_private]>","dst":"<new Map()>","type":"ASSIGNED_FROM"},{"src":"<SymbolStore>","dst":"<SymbolStore.set>","type":"CONTAINS"},{"src":"<SymbolStore.set>","dst":"<key>","type":"CONTAINS"},{"src":"<SymbolStore.set>","dst":"<value>","type":"CONTAINS"},{"src":"<SymbolStore.set>","dst":"<this[_private].set(key, value)>","type":"CONTAINS"},{"src":"<this[_private]>","dst":"<_private>","type":"READS_FROM"},{"src":"<this[_private].set(key, value)>","dst":"<this[_private]>","type":"CALLS_ON"},{"src":"<this[_private].set(key, value)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<this[_private].set(key, value)>","dst":"<value>","type":"PASSES_ARGUMENT"},{"src":"<SymbolStore>","dst":"<SymbolStore.get>","type":"CONTAINS"},{"src":"<SymbolStore.get>","dst":"<key2>","type":"CONTAINS"},{"src":"<SymbolStore.get>","dst":"<this[_private].get(key)>","type":"RETURNS"},{"src":"<this[_private]2>","dst":"<_private>","type":"READS_FROM"},{"src":"<this[_private].get(key)>","dst":"<this[_private]2>","type":"CALLS_ON"},{"src":"<this[_private].get(key)>","dst":"<key2>","type":"PASSES_ARGUMENT"}],"rationale":"Symbol-based private property pattern using approved vocabulary. A symbol is created and used as a computed property key to store private data. Methods access the private property using the symbol. Changed CALLS to CALLS_ON for method invocations to better capture the object-method relationship.","implicitBehavior":["Symbol creates unique property key that cannot be accessed without reference to the symbol","Computed property syntax allows symbol to be used as property key","Private property is not enumerable in for-in loops"]},"pass":2,"annotatedAt":"2026-02-24T00:30:00.527Z"}
{"construct":{"id":"async-generators::generator-observer-pattern","file":"src/async-generators.js","category":"async-generators","lineStart":174,"lineEnd":187,"code":"function* observer() {\n  const results = [];\n  try {\n    while (true) {\n      const value = yield;\n      results.push(value);\n    }\n  } finally {\n    return results;\n  }\n}\n\n// --- Generator finally cleanup (control flow edge case) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<observer>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"LOOP","id":"<while-true>","metadata":{"loopType":"while"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield>","metadata":{"operator":"yield"}},{"type":"CALL","id":"<results.push(value)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<results.push>","metadata":{"property":"push"}},{"type":"EXPRESSION","id":"<return results>","metadata":{"operator":"return"}}],"edges":[{"src":"<observer>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<observer>","dst":"<try-block>","type":"CONTAINS"},{"src":"<observer>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<while-true>","type":"CONTAINS"},{"src":"<while-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<while-true>","dst":"<value>","type":"CONTAINS"},{"src":"<value>","dst":"<yield>","type":"ASSIGNED_FROM"},{"src":"<while-true>","dst":"<results.push(value)>","type":"CONTAINS"},{"src":"<results.push(value)>","dst":"<results.push>","type":"CALLS"},{"src":"<results.push>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(value)>","dst":"<value>","type":"PASSES_ARGUMENT"},{"src":"<finally-block>","dst":"<return results>","type":"CONTAINS"},{"src":"<return results>","dst":"<results>","type":"READS_FROM"},{"src":"<observer>","dst":"<return results>","type":"RETURNS"}],"rationale":"Generator function implementing observer pattern. Contains try-finally with infinite loop that yields to receive values, pushes them to results array, and returns accumulated results on cleanup. Removed module-level declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["yield expression pauses execution and receives external values","finally block executes on generator.return() or throw","infinite while loop continues until external termination","generator state maintained between yield points"]},"pass":2,"annotatedAt":"2026-02-24T00:30:01.152Z"}
{"construct":{"id":"callbacks::callback-promisify-usage","file":"src/callbacks.js","category":"callbacks","lineStart":155,"lineEnd":158,"code":"const readFileAsync = promisify(readFileCallback);\n\n// --- Array callback patterns ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<readFileAsync>","metadata":{"kind":"const"}},{"type":"CALL","id":"<promisify(readFileCallback)>","metadata":{"callee":"promisify"}}],"edges":[{"src":"<module>","dst":"<readFileAsync>","type":"DECLARES"},{"src":"<readFileAsync>","dst":"<promisify(readFileCallback)>","type":"ASSIGNED_FROM"},{"src":"<promisify(readFileCallback)>","dst":"<promisify>","type":"CALLS"},{"src":"<promisify(readFileCallback)>","dst":"<readFileCallback>","type":"PASSES_ARGUMENT"}],"rationale":"Const variable assigned the result of calling promisify with readFileCallback as argument. The annotation from Pass 1 already uses only approved vocabulary types, so no changes are needed.","implicitBehavior":["promisify transforms callback-style function to return promises","readFileCallback is expected to follow Node.js callback convention (error, result)"]},"pass":2,"annotatedAt":"2026-02-24T00:30:01.401Z"}
{"construct":{"id":"callbacks::callback-higher-order","file":"src/callbacks.js","category":"callbacks","lineStart":50,"lineEnd":59,"code":"function retry(fn, attempts, callback) {\n  fn(function (err, result) {\n    if (err && attempts > 1) {\n      retry(fn, attempts - 1, callback);\n    } else {\n      callback(err, result);\n    }\n  });\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<retry>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"PARAMETER","id":"<attempts>"},{"type":"PARAMETER","id":"<callback>"},{"type":"FUNCTION","id":"<anonymous-callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<err>"},{"type":"PARAMETER","id":"<result>"},{"type":"BRANCH","id":"<if-err-attempts>"},{"type":"EXPRESSION","id":"<err && attempts > 1>","metadata":{"operator":"&&"}},{"type":"EXPRESSION","id":"<attempts > 1>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<retry-recursive>","metadata":{"callee":"retry","recursive":true}},{"type":"EXPRESSION","id":"<attempts - 1>","metadata":{"operator":"-"}},{"type":"CALL","id":"<callback-call>","metadata":{"callee":"callback"}},{"type":"CALL","id":"<fn-call>","metadata":{"callee":"fn"}}],"edges":[{"src":"<retry>","dst":"<fn>","type":"CONTAINS"},{"src":"<retry>","dst":"<attempts>","type":"CONTAINS"},{"src":"<retry>","dst":"<callback>","type":"CONTAINS"},{"src":"<retry>","dst":"<fn-call>","type":"CONTAINS"},{"src":"<fn-call>","dst":"<fn>","type":"CALLS"},{"src":"<fn-call>","dst":"<anonymous-callback>","type":"PASSES_ARGUMENT"},{"src":"<anonymous-callback>","dst":"<err>","type":"CONTAINS"},{"src":"<anonymous-callback>","dst":"<result>","type":"CONTAINS"},{"src":"<anonymous-callback>","dst":"<if-err-attempts>","type":"CONTAINS"},{"src":"<if-err-attempts>","dst":"<err && attempts > 1>","type":"HAS_CONDITION"},{"src":"<err && attempts > 1>","dst":"<err>","type":"READS_FROM"},{"src":"<err && attempts > 1>","dst":"<attempts > 1>","type":"READS_FROM"},{"src":"<attempts > 1>","dst":"<attempts>","type":"READS_FROM"},{"src":"<attempts > 1>","dst":"<1>","type":"READS_FROM"},{"src":"<if-err-attempts>","dst":"<retry-recursive>","type":"HAS_CONSEQUENT"},{"src":"<retry-recursive>","dst":"<retry>","type":"CALLS"},{"src":"<retry-recursive>","dst":"<fn>","type":"PASSES_ARGUMENT"},{"src":"<retry-recursive>","dst":"<attempts - 1>","type":"PASSES_ARGUMENT"},{"src":"<retry-recursive>","dst":"<callback>","type":"PASSES_ARGUMENT"},{"src":"<attempts - 1>","dst":"<attempts>","type":"READS_FROM"},{"src":"<attempts - 1>","dst":"<1>","type":"READS_FROM"},{"src":"<if-err-attempts>","dst":"<callback-call>","type":"HAS_ALTERNATE"},{"src":"<callback-call>","dst":"<callback>","type":"CALLS"},{"src":"<callback-call>","dst":"<err>","type":"PASSES_ARGUMENT"},{"src":"<callback-call>","dst":"<result>","type":"PASSES_ARGUMENT"}],"rationale":"Higher-order function implementing retry logic with callback pattern. The function takes another function and a callback, executes the function with an anonymous callback that handles error conditions and implements recursive retry behavior.","implicitBehavior":["closure captures outer function parameters in anonymous callback","recursive call creates new execution context with decremented attempts","callback pattern enables async error handling and result propagation"]},"pass":2,"annotatedAt":"2026-02-24T00:30:02.327Z"}
{"construct":{"id":"builtins::sparse-array","file":"src/builtins.js","category":"builtins","lineStart":348,"lineEnd":355,"code":"function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false  hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<sparseArrayOps>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<sparse>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<sparse-array>","metadata":{"value":"[1, , 3, , 5]","literalType":"array","sparse":true,"holes":[1,3]}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"VARIABLE","id":"<length>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<sparse.length>","metadata":{"property":"length"}},{"type":"VARIABLE","id":"<hasIndex1>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<1 in sparse>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<1-key>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<mapped>","metadata":{"kind":"const"}},{"type":"CALL","id":"<sparse.map(x => x * 2)>","metadata":{"method":"map"}},{"type":"FUNCTION","id":"<map-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<sparseArrayOps>","dst":"<sparse>","type":"CONTAINS"},{"src":"<sparseArrayOps>","dst":"<length>","type":"CONTAINS"},{"src":"<sparseArrayOps>","dst":"<hasIndex1>","type":"CONTAINS"},{"src":"<sparseArrayOps>","dst":"<mapped>","type":"CONTAINS"},{"src":"<sparse>","dst":"<sparse-array>","type":"ASSIGNED_FROM"},{"src":"<sparse-array>","dst":"<1>","type":"HAS_ELEMENT"},{"src":"<sparse-array>","dst":"<3>","type":"HAS_ELEMENT"},{"src":"<sparse-array>","dst":"<5>","type":"HAS_ELEMENT"},{"src":"<length>","dst":"<sparse.length>","type":"ASSIGNED_FROM"},{"src":"<sparse.length>","dst":"<sparse>","type":"READS_FROM"},{"src":"<hasIndex1>","dst":"<1 in sparse>","type":"ASSIGNED_FROM"},{"src":"<1 in sparse>","dst":"<1-key>","type":"READS_FROM"},{"src":"<1 in sparse>","dst":"<sparse>","type":"READS_FROM"},{"src":"<mapped>","dst":"<sparse.map(x => x * 2)>","type":"ASSIGNED_FROM"},{"src":"<sparse.map(x => x * 2)>","dst":"<sparse>","type":"CALLS_ON"},{"src":"<sparse.map(x => x * 2)>","dst":"<map-callback>","type":"PASSES_ARGUMENT"},{"src":"<map-callback>","dst":"<x>","type":"CONTAINS"},{"src":"<map-callback>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<sparseArrayOps>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<length>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<hasIndex1>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<mapped>","type":"HAS_PROPERTY"}],"rationale":"Function demonstrating sparse array operations. Creates sparse array with holes, accesses length property, tests hole existence with 'in' operator, and maps over sparse array preserving holes. Changed CALLS to CALLS_ON for method invocation on sparse array.","implicitBehavior":["Array holes are not enumerable properties","Array.prototype.map skips holes but preserves them in result","'in' operator checks for property existence, not value","Sparse array length includes holes in count"]},"pass":2,"annotatedAt":"2026-02-24T00:30:02.843Z"}
{"construct":{"id":"callbacks::callback-microtask","file":"src/callbacks.js","category":"callbacks","lineStart":134,"lineEnd":141,"code":"function withMicrotask(fn) {\n  queueMicrotask(() => {\n    fn();\n  });\n}\n\n// --- Promisify ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withMicrotask>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"CALL","id":"<queueMicrotask(...)>","metadata":{"callee":"queueMicrotask"}},{"type":"FUNCTION","id":"<microtask-callback>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"CALL","id":"<fn()>","metadata":{"callee":"fn"}}],"edges":[{"src":"<withMicrotask>","dst":"<fn>","type":"HAS_BODY"},{"src":"<withMicrotask>","dst":"<queueMicrotask(...)>","type":"HAS_BODY"},{"src":"<queueMicrotask(...)>","dst":"<queueMicrotask>","type":"CALLS"},{"src":"<queueMicrotask(...)>","dst":"<microtask-callback>","type":"PASSES_ARGUMENT"},{"src":"<microtask-callback>","dst":"<fn()>","type":"HAS_BODY"},{"src":"<fn()>","dst":"<fn>","type":"CALLS"},{"src":"<microtask-callback>","dst":"<fn>","type":"CAPTURES"}],"rationale":"Function that schedules another function to run as a microtask. The callback captures the parameter fn from the outer scope and calls it. Used HAS_BODY instead of CONTAINS for containment relationships within function bodies.","implicitBehavior":["microtask will execute after current execution stack completes but before next macrotask","callback execution is asynchronous"]},"pass":2,"annotatedAt":"2026-02-24T00:30:03.361Z"}
{"construct":{"id":"builtins::symbol-for-cross-realm","file":"src/builtins.js","category":"builtins","lineStart":365,"lineEnd":374,"code":"function symbolForCrossRealm() {\n  const key = Symbol.for('myapp.version');\n  const sameKey = Symbol.for('myapp.version');\n  const areSame = key === sameKey; // true  cross-realm identity\n  const name = Symbol.keyFor(key); // 'myapp.version'\n  const localSym = Symbol('local');\n  const noName = Symbol.keyFor(localSym); // undefined  not in global registry\n  return { areSame, name, noName };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<symbolForCrossRealm>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"V"},"pass":2,"annotatedAt":"2026-02-24T00:30:04.168Z"}
{"construct":{"id":"cjs-patterns::require-simple","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":5,"lineEnd":6,"code":"const fs = require('fs');","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<fs>","metadata":{"kind":"const"}},{"type":"CALL","id":"<require('fs')>","metadata":{"callee":"require"}},{"type":"LITERAL","id":"<'fs'>","metadata":{"value":"fs","literalType":"string"}},{"type":"EXTERNAL_MODULE","id":"<fs-module>","metadata":{"name":"fs","type":"builtin"}}],"edges":[{"src":"<fs>","dst":"<require('fs')>","type":"ASSIGNED_FROM"},{"src":"<require('fs')>","dst":"<'fs'>","type":"PASSES_ARGUMENT"},{"src":"<require('fs')>","dst":"<fs-module>","type":"IMPORTS"}],"rationale":"CommonJS require call importing the fs module. Variable declared const and assigned the result of require function call. The require() call takes a string argument and imports the external fs module.","implicitBehavior":["require() synchronously loads and caches module","fs module is Node.js builtin","module.exports of fs becomes the value"]},"pass":2,"annotatedAt":"2026-02-24T00:30:05.908Z"}
{"construct":{"id":"cjs-patterns::require-destructured","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":8,"lineEnd":9,"code":"const { readFile, writeFile } = require('fs/promises');","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<readFile>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<writeFile>","metadata":{"kind":"const","destructured":true}},{"type":"CALL","id":"<require('fs/promises')>","metadata":{"callee":"require"}},{"type":"LITERAL","id":"<'fs/promises'>","metadata":{"value":"fs/promises","literalType":"string"}},{"type":"EXTERNAL_MODULE","id":"<fs/promises>"}],"edges":[{"src":"<module>","dst":"<readFile>","type":"DECLARES"},{"src":"<module>","dst":"<writeFile>","type":"DECLARES"},{"src":"<readFile>","dst":"<require('fs/promises')>","type":"ASSIGNED_FROM"},{"src":"<writeFile>","dst":"<require('fs/promises')>","type":"ASSIGNED_FROM"},{"src":"<require('fs/promises')>","dst":"<require>","type":"CALLS"},{"src":"<require('fs/promises')>","dst":"<'fs/promises'>","type":"PASSES_ARGUMENT"},{"src":"<require('fs/promises')>","dst":"<fs/promises>","type":"IMPORTS_FROM"}],"rationale":"Destructured require imports specific named exports from a module. Both variables are assigned from the same require call but extract different properties from the returned module object.","implicitBehavior":["require() is synchronous and caches modules","destructuring extracts readFile and writeFile properties from the returned module object"]},"pass":2,"annotatedAt":"2026-02-24T00:30:07.139Z"}
{"construct":{"id":"callbacks::callback-thisarg-filter","file":"src/callbacks.js","category":"callbacks","lineStart":186,"lineEnd":194,"code":"class Validator {\n  threshold = 10;\n  filter(items) {\n    return items.filter(function(item) {\n      return item > this.threshold;\n    }, this);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Validator>"},{"type":"PROPERTY","id":"<Validator.threshold>","metadata":{"value":10}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"METHOD","id":"<Validator.filter>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<items>"},{"type":"CALL","id":"<items.filter(...)>","metadata":{"callee":"filter"}},{"type":"FUNCTION","id":"<filter-callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<item>"},{"type":"EXPRESSION","id":"<item > this.threshold>","metadata":{"operator":">"}},{"type":"PROPERTY_ACCESS","id":"<this.threshold>","metadata":{"objectName":"this"}}],"edges":[{"src":"<Validator>","dst":"<Validator.threshold>","type":"CONTAINS"},{"src":"<Validator.threshold>","dst":"<10>","type":"ASSIGNED_FROM"},{"src":"<Validator>","dst":"<Validator.filter>","type":"CONTAINS"},{"src":"<Validator.filter>","dst":"<items>","type":"CONTAINS"},{"src":"<Validator.filter>","dst":"<items.filter(...)>","type":"RETURNS"},{"src":"<items.filter(...)>","dst":"<items>","type":"CALLS_ON"},{"src":"<items.filter(...)>","dst":"<filter-callback>","type":"PASSES_ARGUMENT"},{"src":"<items.filter(...)>","dst":"<Validator>","type":"BINDS_THIS_TO"},{"src":"<filter-callback>","dst":"<item>","type":"CONTAINS"},{"src":"<filter-callback>","dst":"<item > this.threshold>","type":"RETURNS"},{"src":"<item > this.threshold>","dst":"<item>","type":"READS_FROM"},{"src":"<item > this.threshold>","dst":"<this.threshold>","type":"READS_FROM"},{"src":"<this.threshold>","dst":"<Validator.threshold>","type":"RESOLVES_TO"}],"rationale":"Class with property field and method that uses Array.filter with explicit thisArg binding. The callback function's 'this' context is bound to the class instance via the second argument to filter(). All semantic relationships from Pass 1 are preserved using approved vocabulary.","implicitBehavior":["thisArg parameter binds callback's 'this' to the class instance","property access in callback resolves through bound 'this' context"]},"pass":2,"annotatedAt":"2026-02-24T00:30:08.269Z"}
{"construct":{"id":"cjs-patterns::cjs-class-decl","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":27,"lineEnd":32,"code":"class CjsClass {\n  method() {\n    return true;\n  }\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"CLASS","id":"<CjsClass>"},{"type":"METHOD","id":"<CjsClass.method>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<module>","dst":"<CjsClass>","type":"DECLARES"},{"src":"<CjsClass>","dst":"<CjsClass.method>","type":"CONTAINS"},{"src":"<CjsClass.method>","dst":"<true>","type":"RETURNS"}],"rationale":"Class declaration in CommonJS module with a method that returns a boolean literal. All types from Pass 1 are already in the approved vocabulary, so no changes needed.","implicitBehavior":["class declaration is hoisted","class creates constructor function and prototype"]},"pass":2,"annotatedAt":"2026-02-24T00:30:08.415Z"}
{"construct":{"id":"callbacks::callback-thisarg-map","file":"src/callbacks.js","category":"callbacks","lineStart":176,"lineEnd":184,"code":"class Processor {\n  multiplier = 3;\n  process(items) {\n    return items.map(function(item) {\n      return item * this.multiplier; // `this` = Processor instance via thisArg\n    }, this);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Processor>"},{"type":"PROPERTY","id":"<Processor.multiplier>","metadata":{"value":3}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"METHOD","id":"<Processor.process>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<items>"},{"type":"CALL","id":"<items.map(...)>","metadata":{"callee":"map","hasThisArg":true}},{"type":"FUNCTION","id":"<map-callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<item>"},{"type":"EXPRESSION","id":"<item * this.multiplier>","metadata":{"operator":"*"}},{"type":"PROPERTY_ACCESS","id":"<this.multiplier>","metadata":{"objectName":"this"}}],"edges":[{"src":"<Processor>","dst":"<Processor.multiplier>","type":"CONTAINS"},{"src":"<Processor.multiplier>","dst":"<3>","type":"ASSIGNED_FROM"},{"src":"<Processor>","dst":"<Processor.process>","type":"CONTAINS"},{"src":"<Processor.process>","dst":"<items>","type":"CONTAINS"},{"src":"<Processor.process>","dst":"<items.map(...)>","type":"RETURNS"},{"src":"<items.map(...)>","dst":"<items>","type":"CALLS_ON"},{"src":"<items.map(...)>","dst":"<map-callback>","type":"PASSES_ARGUMENT"},{"src":"<items.map(...)>","dst":"<Processor>","type":"BINDS_THIS_TO"},{"src":"<map-callback>","dst":"<item>","type":"CONTAINS"},{"src":"<map-callback>","dst":"<item * this.multiplier>","type":"RETURNS"},{"src":"<item * this.multiplier>","dst":"<item>","type":"READS_FROM"},{"src":"<item * this.multiplier>","dst":"<this.multiplier>","type":"READS_FROM"},{"src":"<this.multiplier>","dst":"<Processor.multiplier>","type":"RESOLVES_TO"}],"rationale":"Class with property and method that uses map with thisArg. The callback function's `this` context is explicitly bound to the Processor instance via the second argument to map. All relationships captured using approved vocabulary.","implicitBehavior":["thisArg parameter binds callback's `this` to Processor instance","property access `this.multiplier` resolves through bound context"]},"pass":2,"annotatedAt":"2026-02-24T00:30:09.907Z"}
{"construct":{"id":"cjs-patterns::cjs-function-decl","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":22,"lineEnd":25,"code":"function cjsFunction() {\n  return 'cjs';\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<cjsFunction>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<'cjs'>","metadata":{"value":"cjs","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<cjsFunction>","type":"DECLARES"},{"src":"<cjsFunction>","dst":"<'cjs'>","type":"RETURNS"}],"rationale":"Function declaration in CommonJS module. Module scope declares the function, which returns a string literal. The approved vocabulary perfectly captures this construct.","implicitBehavior":["function declaration is hoisted to module scope","function is automatically added to module.exports if exported"]},"pass":2,"annotatedAt":"2026-02-24T00:30:10.233Z"}
{"construct":{"id":"cjs-patterns::cjs-const-decl","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":34,"lineEnd":35,"code":"const CJS_CONSTANT = 42;","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<CJS_CONSTANT>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<CJS_CONSTANT>","type":"DECLARES"},{"src":"<CJS_CONSTANT>","dst":"<42>","type":"ASSIGNED_FROM"}],"rationale":"Const declaration in CommonJS module creates an immutable binding initialized with a numeric literal. Using ASSIGNED_FROM as the closest approved type for initialization.","implicitBehavior":["const binding cannot be reassigned","block-scoped within module"]},"pass":2,"annotatedAt":"2026-02-24T00:30:11.565Z"}
{"construct":{"id":"callbacks::callback-continuation-passing","file":"src/callbacks.js","category":"callbacks","lineStart":61,"lineEnd":71,"code":"function waterfall(tasks, callback) {\n  let index = 0;\n  function next(err, result) {\n    if (err || index >= tasks.length) return callback(err, result);\n    tasks[index++](result, next);\n  }\n  next(null, null);\n}\n\n// --- Event emitter pattern ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<waterfall>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<tasks>"},{"type":"PARAMETER","id":"<callback>"},{"type":"VARIABLE","id":"<index>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"FUNCTION","id":"<next>","metadata":{"async":false,"generator":false,"nested":true}},{"type":"PARAMETER","id":"<err>"},{"type":"PARAMETER","id":"<result>"},{"type":"EXPRESSION","id":"<err || index >= tasks.length>","metadata":{"operator":"||"}},{"type":"EXPRESSION","id":"<index >= tasks.length>","metadata":{"operator":">="}},{"type":"PROPERTY_ACCESS","id":"<tasks.length>","metadata":{"objectName":"tasks"}},{"type":"CALL","id":"<callback(err, result)>","metadata":{"callee":"callback"}},{"type":"EXPRESSION","id":"<tasks[index++]>","metadata":{"operator":"[]"}},{"type":"EXPRESSION","id":"<index++>","metadata":{"operator":"++"}},{"type":"CALL","id":"<tasks[index++](result, next)>","metadata":{"callee":"tasks[index++]"}},{"type":"CALL","id":"<next(null, null)>","metadata":{"callee":"next"}},{"type":"LITERAL","id":"<null1>","metadata":{"value":null,"literalType":"null"}},{"type":"LITERAL","id":"<null2>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<waterfall>","dst":"<tasks>","type":"CONTAINS"},{"src":"<waterfall>","dst":"<callback>","type":"CONTAINS"},{"src":"<waterfall>","dst":"<index>","type":"DECLARES"},{"src":"<index>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<waterfall>","dst":"<next>","type":"DECLARES"},{"src":"<next>","dst":"<err>","type":"CONTAINS"},{"src":"<next>","dst":"<result>","type":"CONTAINS"},{"src":"<err || index >= tasks.length>","dst":"<err>","type":"READS_FROM"},{"src":"<err || index >= tasks.length>","dst":"<index >= tasks.length>","type":"READS_FROM"},{"src":"<index >= tasks.length>","dst":"<index>","type":"READS_FROM"},{"src":"<index >= tasks.length>","dst":"<tasks.length>","type":"READS_FROM"},{"src":"<tasks.length>","dst":"<tasks>","type":"READS_FROM"},{"src":"<callback(err, result)>","dst":"<callback>","type":"CALLS"},{"src":"<callback(err, result)>","dst":"<err>","type":"PASSES_ARGUMENT"},{"src":"<callback(err, result)>","dst":"<result>","type":"PASSES_ARGUMENT"},{"src":"<tasks[index++]>","dst":"<tasks>","type":"READS_FROM"},{"src":"<tasks[index++]>","dst":"<index++>","type":"READS_FROM"},{"src":"<index++>","dst":"<index>","type":"MODIFIES"},{"src":"<tasks[index++](result, next)>","dst":"<tasks[index++]>","type":"CALLS"},{"src":"<tasks[index++](result, next)>","dst":"<result>","type":"PASSES_ARGUMENT"},{"src":"<tasks[index++](result, next)>","dst":"<next>","type":"PASSES_ARGUMENT"},{"src":"<next(null, null)>","dst":"<next>","type":"CALLS"},{"src":"<next(null, null)>","dst":"<null1>","type":"PASSES_ARGUMENT"},{"src":"<next(null, null)>","dst":"<null2>","type":"PASSES_ARGUMENT"},{"src":"<next>","dst":"<callback>","type":"CAPTURES"},{"src":"<next>","dst":"<tasks>","type":"CAPTURES"},{"src":"<next>","dst":"<index>","type":"CAPTURES"}],"rationale":"Waterfall function implements continuation-passing style with nested callback function. The inner 'next' function captures outer scope variables and recursively processes tasks array, passing itself as continuation callback.","implicitBehavior":["closure captures outer scope variables","recursive callback pattern creates call stack","error-first callback convention"]},"pass":2,"annotatedAt":"2026-02-24T00:30:12.287Z"}
{"construct":{"id":"async-generators::generator-finally-cleanup","file":"src/async-generators.js","category":"async-generators","lineStart":189,"lineEnd":198,"code":"function* resourceGenerator() {\n  const resource = { acquired: true };\n  try {\n    yield resource;\n    yield { transformed: true };\n  } finally {\n    resource.acquired = false; // runs even when consumer calls .return() or .throw()\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<resourceGenerator>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<resource>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ acquired: true }>","metadata":{"value":"{ acquired: true }","literalType":"object"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"EXPRESSION","id":"<yield resource>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<{ transformed: true }>","metadata":{"value":"{ transformed: true }","literalType":"object"}},{"type":"EXPRESSION","id":"<yield { transformed: true }>","metadata":{"operator":"yield"}},{"type":"PROPERTY_ACCESS","id":"<resource.acquired>","metadata":{"objectName":"resource","propertyName":"acquired"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}}],"edges":[{"src":"<resourceGenerator>","dst":"<resource>","type":"CONTAINS"},{"src":"<resource>","dst":"<{ acquired: true }>","type":"ASSIGNED_FROM"},{"src":"<resourceGenerator>","dst":"<try-block>","type":"CONTAINS"},{"src":"<resourceGenerator>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<yield resource>","type":"CONTAINS"},{"src":"<try-block>","dst":"<yield { transformed: true }>","type":"CONTAINS"},{"src":"<yield resource>","dst":"<resource>","type":"READS_FROM"},{"src":"<yield { transformed: true }>","dst":"<{ transformed: true }>","type":"READS_FROM"},{"src":"<finally-block>","dst":"<resource.acquired>","type":"WRITES_TO"},{"src":"<resource.acquired>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<resource.acquired>","dst":"<resource>","type":"READS_FROM"}],"rationale":"Generator function with try-finally cleanup. Yields two values in try block, finally block ensures resource cleanup regardless of how iteration terminates.","implicitBehavior":["finally block executes on normal completion, .return(), .throw(), or exception","generator state machine maintains cleanup guarantees","resource cleanup runs even if consumer abandons iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:30:12.619Z"}
{"construct":{"id":"callbacks::callback-thisarg-foreach","file":"src/callbacks.js","category":"callbacks","lineStart":196,"lineEnd":201,"code":"function forEachWithContext(items, logger) {\n  items.forEach(function(item) {\n    this.log(item); // `this` = logger\n  }, logger);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forEachWithContext>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<items>"},{"type":"PARAMETER","id":"<logger>"},{"type":"CALL","id":"<items.forEach>","metadata":{"callee":"forEach","method":true}},{"type":"FUNCTION","id":"<forEach-callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<item>"},{"type":"CALL","id":"<this.log(item)>","metadata":{"callee":"log","method":true}},{"type":"PROPERTY_ACCESS","id":"<this.log>","metadata":{"objectName":"this"}}],"edges":[{"src":"<forEachWithContext>","dst":"<items>","type":"CONTAINS"},{"src":"<forEachWithContext>","dst":"<logger>","type":"CONTAINS"},{"src":"<forEachWithContext>","dst":"<items.forEach>","type":"CONTAINS"},{"src":"<items.forEach>","dst":"<items>","type":"CALLS_ON"},{"src":"<items.forEach>","dst":"<forEach-callback>","type":"PASSES_ARGUMENT"},{"src":"<items.forEach>","dst":"<logger>","type":"PASSES_ARGUMENT"},{"src":"<forEach-callback>","dst":"<item>","type":"CONTAINS"},{"src":"<forEach-callback>","dst":"<this.log(item)>","type":"CONTAINS"},{"src":"<this.log(item)>","dst":"<this.log>","type":"CALLS"},{"src":"<this.log(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<this.log>","dst":"<logger>","type":"BINDS_THIS_TO"}],"rationale":"Function calls forEach with callback and thisArg. The callback's `this` context is bound to the logger parameter through forEach's second argument. Used BINDS_THIS_TO to capture the thisArg binding mechanism.","implicitBehavior":["forEach binds callback's `this` to the second argument (logger)","callback receives array item as first parameter from forEach iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:30:12.640Z"}
{"construct":{"id":"cjs-patterns::require-path","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":11,"lineEnd":12,"code":"const path = require('path');","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<path>","metadata":{"kind":"const"}},{"type":"CALL","id":"<require('path')>","metadata":{"callee":"require"}},{"type":"LITERAL","id":"<'path'>","metadata":{"value":"path","literalType":"string"}},{"type":"EXTERNAL_MODULE","id":"<path-module>","metadata":{"name":"path","builtin":true}}],"edges":[{"src":"<module>","dst":"<path>","type":"DECLARES"},{"src":"<path>","dst":"<require('path')>","type":"ASSIGNED_FROM"},{"src":"<require('path')>","dst":"<require>","type":"CALLS"},{"src":"<require('path')>","dst":"<'path'>","type":"PASSES_ARGUMENT"},{"src":"<require('path')>","dst":"<path-module>","type":"IMPORTS"},{"src":"<module>","dst":"<path-module>","type":"IMPORTS_FROM"}],"rationale":"CommonJS require call importing Node.js built-in path module. Variable declared const and assigned the module exports. All relationships captured using approved vocabulary.","implicitBehavior":["require() synchronously loads and caches module","built-in modules resolved without file system lookup","module.exports object assigned to variable"]},"pass":2,"annotatedAt":"2026-02-24T00:30:13.895Z"}
{"construct":{"id":"cjs-patterns::cjs-exports-named-1","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":40,"lineEnd":41,"code":"exports.CjsClass = CjsClass;","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"EXPORT","id":"<exports.CjsClass>","metadata":{"exportType":"named","exportName":"CjsClass"}},{"type":"PROPERTY_ACCESS","id":"<exports.CjsClass:access>","metadata":{"objectName":"exports","propertyName":"CjsClass"}}],"edges":[{"src":"<module>","dst":"<exports.CjsClass>","type":"CONTAINS"},{"src":"<exports.CjsClass>","dst":"<exports.CjsClass:access>","type":"WRITES_TO"},{"src":"<exports.CjsClass:access>","dst":"<CjsClass>","type":"ASSIGNED_FROM"},{"src":"<exports.CjsClass>","dst":"<CjsClass>","type":"EXPORTS"}],"rationale":"CommonJS named export assignment. Creates a property on the exports object and assigns the CjsClass variable to it. All types used are in the approved vocabulary.","implicitBehavior":["exports object is provided by CommonJS runtime","exported value becomes available to require() calls"]},"pass":2,"annotatedAt":"2026-02-24T00:30:14.408Z"}
{"construct":{"id":"cjs-patterns::cjs-exports-named-2","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":43,"lineEnd":44,"code":"exports.CJS_CONSTANT = CJS_CONSTANT;","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"PROPERTY_ACCESS","id":"<exports.CJS_CONSTANT>","metadata":{"objectName":"exports","propertyName":"CJS_CONSTANT"}},{"type":"VARIABLE","id":"<CJS_CONSTANT>","metadata":{"referenced":true}}],"edges":[{"src":"<module>","dst":"<exports.CJS_CONSTANT>","type":"CONTAINS"},{"src":"<exports.CJS_CONSTANT>","dst":"<CJS_CONSTANT>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<CJS_CONSTANT>","type":"EXPORTS"}],"rationale":"CommonJS named export assignment. Property access on exports object is assigned from a variable, making that variable available to importers.","implicitBehavior":["exports object is implicitly available in CommonJS modules","exported binding creates external visibility for the variable"]},"pass":2,"annotatedAt":"2026-02-24T00:30:15.184Z"}
{"construct":{"id":"cjs-patterns::cjs-exports-named","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":37,"lineEnd":38,"code":"exports.cjsFunction = cjsFunction;","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"EXPORT","id":"<exports.cjsFunction>","metadata":{"exportType":"named","exportName":"cjsFunction"}},{"type":"PROPERTY_ACCESS","id":"<exports.cjsFunction:access>","metadata":{"objectName":"exports","propertyName":"cjsFunction"}}],"edges":[{"src":"<module>","dst":"<exports.cjsFunction>","type":"CONTAINS"},{"src":"<exports.cjsFunction>","dst":"<exports.cjsFunction:access>","type":"WRITES_TO"},{"src":"<exports.cjsFunction:access>","dst":"<cjsFunction>","type":"ASSIGNED_FROM"},{"src":"<exports.cjsFunction>","dst":"<cjsFunction>","type":"EXPORTS"}],"rationale":"CommonJS named export assignment. Creates a property on the exports object and assigns the value of the cjsFunction variable to it. The EXPORT node represents the export declaration, PROPERTY_ACCESS represents accessing the exports.cjsFunction property, and the edges capture the assignment and export relationships.","implicitBehavior":["exports object is implicitly available in CommonJS modules","exported value becomes available to require() calls"]},"pass":2,"annotatedAt":"2026-02-24T00:30:15.701Z"}
{"construct":{"id":"callbacks::callback-promisify","file":"src/callbacks.js","category":"callbacks","lineStart":143,"lineEnd":153,"code":"function promisify(fn) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args, function (err, result) {\n        if (err) reject(err);\n        else resolve(result);\n      });\n    });\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<promisify>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"FUNCTION","id":"<promisify:wrapper>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<...args>","metadata":{"rest":true}},{"type":"CALL","id":"<new Promise>","metadata":{"constructor":true,"callee":"Promise"}},{"type":"FUNCTION","id":"<promisify:executor>","metadata":{"anonymous":true,"arrowFunction":true}},{"type":"PARAMETER","id":"<resolve>"},{"type":"PARAMETER","id":"<reject>"},{"type":"CALL","id":"<fn(...args, callback)>","metadata":{"callee":"fn"}},{"type":"FUNCTION","id":"<promisify:callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<err>"},{"type":"PARAMETER","id":"<result>"},{"type":"BRANCH","id":"<if-err>","metadata":{"condition":"err"}},{"type":"CALL","id":"<reject(err)>","metadata":{"callee":"reject"}},{"type":"CALL","id":"<resolve(result)>","metadata":{"callee":"resolve"}}],"edges":[{"src":"<promisify>","dst":"<fn>","type":"HAS_BODY"},{"src":"<promisify>","dst":"<promisify:wrapper>","type":"RETURNS"},{"src":"<promisify:wrapper>","dst":"<...args>","type":"HAS_BODY"},{"src":"<promisify:wrapper>","dst":"<new Promise>","type":"RETURNS"},{"src":"<new Promise>","dst":"<promisify:executor>","type":"PASSES_ARGUMENT"},{"src":"<promisify:executor>","dst":"<resolve>","type":"HAS_BODY"},{"src":"<promisify:executor>","dst":"<reject>","type":"HAS_BODY"},{"src":"<promisify:executor>","dst":"<fn(...args, callback)>","type":"HAS_BODY"},{"src":"<fn(...args, callback)>","dst":"<fn>","type":"CALLS"},{"src":"<fn(...args, callback)>","dst":"<...args>","type":"PASSES_ARGUMENT"},{"src":"<fn(...args, callback)>","dst":"<promisify:callback>","type":"PASSES_ARGUMENT"},{"src":"<promisify:callback>","dst":"<err>","type":"HAS_BODY"},{"src":"<promisify:callback>","dst":"<result>","type":"HAS_BODY"},{"src":"<promisify:callback>","dst":"<if-err>","type":"HAS_BODY"},{"src":"<if-err>","dst":"<reject(err)>","type":"HAS_CONSEQUENT"},{"src":"<if-err>","dst":"<resolve(result)>","type":"HAS_ALTERNATE"},{"src":"<reject(err)>","dst":"<reject>","type":"CALLS"},{"src":"<reject(err)>","dst":"<err>","type":"PASSES_ARGUMENT"},{"src":"<resolve(result)>","dst":"<resolve>","type":"CALLS"},{"src":"<resolve(result)>","dst":"<result>","type":"PASSES_ARGUMENT"}],"rationale":"Higher-order function that converts callback-based functions to Promise-based. Creates nested closures and implements error-first callback pattern conversion. Used HAS_BODY for parameter containment relationships since CONTAINS is not in approved vocabulary.","implicitBehavior":["Closure captures variables from outer scopes","Promise constructor executes executor synchronously","Error-first callback convention assumed for input function","Rest parameters spread into function call"]},"pass":2,"annotatedAt":"2026-02-24T00:30:16.473Z"}
{"construct":{"id":"callbacks::callback-setinterval","file":"src/callbacks.js","category":"callbacks","lineStart":116,"lineEnd":132,"code":"function pollUntil(check, interval, maxAttempts, callback) {\n  let attempts = 0;\n  const id = setInterval(function () {\n    attempts++;\n    if (check()) {\n      clearInterval(id);\n      callback(null, attempts);\n    } else if (attempts >= maxAttempts) {\n      clearInterval(id);\n      callback(new Error('Max attempts reached'), attempts);\n    }\n  }, interval);\n  return id;\n}\n\n// --- queueMicrotask ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<pollUntil>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER\","},"pass":2,"annotatedAt":"2026-02-24T00:30:18.818Z"}
{"construct":{"id":"cjs-patterns::require-conditional","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":14,"lineEnd":20,"code":"let optionalDep;\ntry {\n  optionalDep = require('optional-package');\n} catch (e) {\n  optionalDep = null;\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<optionalDep>","metadata":{"kind":"let"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<require('optional-package')>","metadata":{"callee":"require"}},{"type":"LITERAL","id":"<'optional-package'>","metadata":{"value":"optional-package","literalType":"string"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<module>","dst":"<optionalDep>","type":"DECLARES"},{"src":"<module>","dst":"<try-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<require('optional-package')>","type":"CONTAINS"},{"src":"<require('optional-package')>","dst":"<'optional-package'>","type":"PASSES_ARGUMENT"},{"src":"<optionalDep>","dst":"<require('optional-package')>","type":"ASSIGNED_FROM"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<e>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<null>","type":"CONTAINS"},{"src":"<optionalDep>","dst":"<null>","type":"ASSIGNED_FROM"}],"rationale":"Try-catch pattern for optional dependency loading. Variable declared once but assigned in both try and catch blocks with different values. Removed the CALLS edge to require since require is an external function not explicitly modeled as a node.","implicitBehavior":["require() throws MODULE_NOT_FOUND if package doesn't exist","variable remains undefined if neither assignment executes"]},"pass":2,"annotatedAt":"2026-02-24T00:30:20.040Z"}
{"construct":{"id":"async-generators::generator-break-triggers-finally","file":"src/async-generators.js","category":"async-generators","lineStart":200,"lineEnd":205,"code":"function consumeWithBreak(gen) {\n  for (const item of gen) {\n    if (item.transformed) break; // implicitly calls generator.return()  finally runs\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<consumeWithBreak>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<gen>"},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"BRANCH","id":"<if-transformed>"},{"type":"PROPERTY_ACCESS","id":"<item.transformed>","metadata":{"property":"transformed"}},{"type":"SIDE_EFFECT","id":"<break>","metadata":{"type":"break","description":"break statement that exits loop"}}],"edges":[{"src":"<consumeWithBreak>","dst":"<gen>","type":"CONTAINS"},{"src":"<consumeWithBreak>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<gen>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-of>","dst":"<if-transformed>","type":"CONTAINS"},{"src":"<if-transformed>","dst":"<item.transformed>","type":"HAS_CONDITION"},{"src":"<item.transformed>","dst":"<item>","type":"READS_FROM"},{"src":"<if-transformed>","dst":"<break>","type":"HAS_CONSEQUENT"},{"src":"<break>","dst":"<for-of>","type":"FLOWS_INTO"}],"rationale":"Function that consumes a generator with early termination. Break statement exits the for-of loop when condition is met, triggering implicit generator cleanup.","implicitBehavior":["break in for-of loop over generator implicitly calls generator.return()","generator.return() triggers finally blocks in the generator","generator iterator protocol cleanup on early termination"]},"pass":2,"annotatedAt":"2026-02-24T00:30:21.573Z"}
{"construct":{"id":"callbacks::export-named-list","file":"src/callbacks.js","category":"callbacks","lineStart":203,"lineEnd":223,"code":"export {\n  readFileCallback,\n  processFile,\n  callbackHell,\n  getUser,\n  getOrders,\n  getOrderDetails,\n  retry,\n  waterfall,\n  EventEmitter,\n  delayedExecution,\n  pollUntil,\n  withMicrotask,\n  promisify,\n  readFileAsync,\n  arrayCallbackPatterns,\n  Processor,\n  Validator,\n  forEachWithContext,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<readFileCallback>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<processFile>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<callbackHell>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<getUser>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<getOrders>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<getOrderDetails>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<retry>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<waterfall>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<EventEmitter>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<delayedExecution>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<pollUntil>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<withMicrotask>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<promisify>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<readFileAsync>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<arrayCallbackPatterns>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Processor>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Validator>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<forEachWithContext>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<readFileCallback>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<processFile>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<callbackHell>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<getUser>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<getOrders>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<getOrderDetails>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<retry>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<waterfall>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<EventEmitter>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<delayedExecution>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<pollUntil>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<withMicrotask>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<promisify>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<readFileAsync>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrayCallbackPatterns>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Processor>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Validator>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<forEachWithContext>","type":"EXPORTS"}],"rationale":"Named export list that makes 18 previously declared variables/functions available to importing modules. Each exported identifier references a binding that must exist in the module scope. Removed the CONTAINS edge from module to export as it's not essential to the core export semantics.","implicitBehavior":["exported bindings must be declared before or after this export statement","creates named export bindings that can be imported by other modules"]},"pass":2,"annotatedAt":"2026-02-24T00:30:22.209Z"}
{"construct":{"id":"cjs-patterns::cjs-dynamic-require","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":61,"lineEnd":65,"code":"function loadImplementation(useNative) {\n  const impl = useNative ? require('path') : require('fs');\n  return impl;\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<loadImplementation>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<useNative>"},{"type":"VARIABLE","id":"<impl>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<ternary>","metadata":{"operator":"?:"}},{"type":"CALL","id":"<require('path')>","metadata":{"callee":"require"}},{"type":"LITERAL","id":"<'path'>","metadata":{"value":"path","literalType":"string"}},{"type":"CALL","id":"<require('fs')>","metadata":{"callee":"require"}},{"type":"LITERAL","id":"<'fs'>","metadata":{"value":"fs","literalType":"string"}},{"type":"EXTERNAL","id":"<require>","metadata":{"source":"commonjs"}}],"edges":[{"src":"<loadImplementation>","dst":"<useNative>","type":"CONTAINS"},{"src":"<loadImplementation>","dst":"<impl>","type":"CONTAINS"},{"src":"<impl>","dst":"<ternary>","type":"ASSIGNED_FROM"},{"src":"<ternary>","dst":"<useNative>","type":"HAS_CONDITION"},{"src":"<ternary>","dst":"<require('path')>","type":"HAS_CONSEQUENT"},{"src":"<ternary>","dst":"<require('fs')>","type":"HAS_ALTERNATE"},{"src":"<require('path')>","dst":"<require>","type":"CALLS"},{"src":"<require('path')>","dst":"<'path'>","type":"PASSES_ARGUMENT"},{"src":"<require('fs')>","dst":"<require>","type":"CALLS"},{"src":"<require('fs')>","dst":"<'fs'>","type":"PASSES_ARGUMENT"},{"src":"<loadImplementation>","dst":"<impl>","type":"RETURNS"}],"rationale":"Function with dynamic require calls in ternary expression. Conditionally loads different modules based on parameter. Added explicit EXTERNAL node for require function to capture the CommonJS runtime dependency.","implicitBehavior":["require calls are synchronous and cache modules","dynamic requires prevent static analysis of dependencies","modules are resolved at runtime based on condition"]},"pass":2,"annotatedAt":"2026-02-24T00:30:23.117Z"}
{"construct":{"id":"cjs-patterns::with-statement","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":46,"lineEnd":53,"code":"function withStatement(obj) {\n  with (obj) {\n    return toString();\n  }\n}\n\nexports.withStatement = withStatement;","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withStatement>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"SCOPE","id":"<with-scope>","metadata":{"type":"with","object":"obj"}},{"type":"CALL","id":"<toString()>","metadata":{"callee":"toString","arguments":[]}},{"type":"PROPERTY_ACCESS","id":"<exports.withStatement>","metadata":{"objectName":"exports","propertyName":"withStatement"}}],"edges":[{"src":"<MODULE>","dst":"<withStatement>","type":"DECLARES"},{"src":"<withStatement>","dst":"<obj>","type":"CONTAINS"},{"src":"<withStatement>","dst":"<with-scope>","type":"HAS_SCOPE"},{"src":"<with-scope>","dst":"<obj>","type":"EXTENDS_SCOPE_WITH"},{"src":"<with-scope>","dst":"<toString()>","type":"CONTAINS"},{"src":"<withStatement>","dst":"<toString()>","type":"RETURNS"},{"src":"<toString()>","dst":"<obj>","type":"RESOLVES_TO"},{"src":"<exports.withStatement>","dst":"<withStatement>","type":"ASSIGNED_FROM"},{"src":"<MODULE>","dst":"<exports.withStatement>","type":"EXPORTS"}],"rationale":"Function with with-statement modeled as a SCOPE that extends with obj's properties. The toString() call resolves through this extended scope to obj's toString method.","implicitBehavior":["with statement modifies identifier resolution to check obj properties first","toString() may resolve to obj.toString or global toString depending on obj's properties","with statement is deprecated and disabled in strict mode"]},"pass":2,"annotatedAt":"2026-02-24T00:30:23.145Z"}
{"construct":{"id":"cjs-patterns::block-function-decl-annex-b","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":67,"lineEnd":77,"code":"// Sloppy mode (CJS)  Annex B behavior: function leaks out of block\nfunction annexBDemo() {\n  console.log(typeof leaked); // \"undefined\"  var-hoisted but not initialized\n\n  if (true) {\n    function leaked() { return 'I escaped!'; }\n  }\n\n  return leaked(); // works in sloppy mode  Annex B hoisting\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<annexBDemo>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<console.log(typeof leaked)>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<typeof leaked>","metadata":{"operator":"typeof"}},{"type":"BRANCH","id":"<if-true>","metadata":{"condition":"true"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"FUNCTION","id":"<leaked>","metadata":{"async":false,"generator":false,"blockScoped":true}},{"type":"LITERAL","id":"<'I escaped!'>","metadata":{"value":"I escaped!","literalType":"string"}},{"type":"CALL","id":"<leaked()>","metadata":{"callee":"leaked"}}],"edges":[{"src":"<annexBDemo>","dst":"<console.log(typeof leaked)>","type":"CONTAINS"},{"src":"<console.log(typeof leaked)>","dst":"<typeof leaked>","type":"PASSES_ARGUMENT"},{"src":"<typeof leaked>","dst":"<leaked>","type":"READS_FROM"},{"src":"<annexBDemo>","dst":"<if-true>","type":"CONTAINS"},{"src":"<if-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<if-true>","dst":"<leaked>","type":"CONTAINS"},{"src":"<leaked>","dst":"<'I escaped!'>","type":"RETURNS"},{"src":"<annexBDemo>","dst":"<leaked()>","type":"CONTAINS"},{"src":"<leaked()>","dst":"<leaked>","type":"CALLS"},{"src":"<annexBDemo>","dst":"<leaked()>","type":"RETURNS"}],"rationale":"Function declaration inside block scope with Annex B hoisting behavior. The block-scoped function is hoisted as var to function scope but initialized only when block executes. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["Annex B hoisting: function leaked is var-hoisted to annexBDemo scope but undefined until block executes","Block function declaration creates both var binding (hoisted) and lexical binding (block-scoped)","Sloppy mode allows function declaration in block to be callable outside the block","Module implicitly declares annexBDemo function"]},"pass":2,"annotatedAt":"2026-02-24T00:30:24.717Z"}
{"construct":{"id":"async-generators::generator-finally-yield-trap","file":"src/async-generators.js","category":"async-generators","lineStart":207,"lineEnd":219,"code":"function* trickyFinally() {\n  try {\n    yield 1;\n  } finally {\n    yield 2; // return() pauses HERE, not at the return point\n  }\n}\n// const g = trickyFinally(); g.next(); g.return('end');\n//  { value: 2, done: false }  NOT 'end'!\n// g.next()  { value: 'end', done: true }\n\n// --- Async iterator cancellation ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<trickyFinally>","metadata":{"generator":true,"async":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"EXPRESSION","id":"<yield 1>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield 2>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<trickyFinally>","dst":"<try-block>","type":"CONTAINS"},{"src":"<trickyFinally>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<yield 1>","type":"CONTAINS"},{"src":"<finally-block>","dst":"<yield 2>","type":"CONTAINS"},{"src":"<yield 1>","dst":"<1>","type":"YIELDS"},{"src":"<yield 2>","dst":"<2>","type":"YIELDS"},{"src":"<try-block>","dst":"<finally-block>","type":"HAS_FINALLY"}],"rationale":"Generator function with try-finally structure where both blocks contain yield expressions. The finally block's yield creates a trap for generator.return() calls, causing execution to pause at the finally yield rather than immediately returning the requested value.","implicitBehavior":["generator.return() execution pauses at finally block yield instead of immediately returning","finally block yield must complete before return value is delivered","creates two-step termination: yield from finally, then actual return value"]},"pass":2,"annotatedAt":"2026-02-24T00:30:26.081Z"}
{"construct":{"id":"cjs-patterns::with-nested","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":79,"lineEnd":86,"code":"function withNested(defaults, overrides) {\n  with (defaults) {\n    with (overrides) {\n      return color; // overrides.color ?? defaults.color ?? outer scope\n    }\n  }\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withNested>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<defaults>"},{"type":"PARAMETER","id":"<overrides>"},{"type":"SCOPE","id":"<with-defaults-scope>","metadata":{"scopeType":"with"}},{"type":"SCOPE","id":"<with-overrides-scope>","metadata":{"scopeType":"with"}},{"type":"VARIABLE","id":"<color>","metadata":{"unresolved":true}}],"edges":[{"src":"<withNested>","dst":"<defaults>","type":"CONTAINS"},{"src":"<withNested>","dst":"<overrides>","type":"CONTAINS"},{"src":"<with-defaults-scope>","dst":"<defaults>","type":"EXTENDS_SCOPE_WITH"},{"src":"<with-overrides-scope>","dst":"<overrides>","type":"EXTENDS_SCOPE_WITH"},{"src":"<with-overrides-scope>","dst":"<with-defaults-scope>","type":"CONTAINS"},{"src":"<withNested>","dst":"<color>","type":"RETURNS"},{"src":"<color>","dst":"<with-overrides-scope>","type":"RESOLVES_TO"}],"rationale":"Nested with statements create augmented scope chains where inner scopes extend outer scopes with object properties. Variable lookup follows the scope hierarchy from innermost to outermost.","implicitBehavior":["with statements are deprecated and forbidden in strict mode","property lookup on with objects happens at runtime","identifier resolution is ambiguous and performance-costly","nested with creates scope chain: overrides -> defaults -> function scope"]},"pass":2,"annotatedAt":"2026-02-24T00:30:26.523Z"}
{"construct":{"id":"classes::class-basic","file":"src/classes.js","category":"classes","lineStart":5,"lineEnd":19,"code":"class Animal {\n  constructor(name, sound) {\n    this.name = name;\n    this.sound = sound;\n  }\n\n  speak() {\n    return `${this.name} says ${this.sound}`;\n  }\n\n  toString() {\n    return `Animal(${this.name})`;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Animal>"},{"type":"METHOD","id":"<Animal.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<name>"},{"type":"PARAMETER","id":"<sound>"},{"type":"PROPERTY","id":"<Animal.name>","metadata":{"instanceProperty":true}},{"type":"PROPERTY","id":"<Animal.sound>","metadata":{"instanceProperty":true}},{"type":"METHOD","id":"<Animal.speak>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<template-literal-speak>","metadata":{"type":"template-literal"}},{"type":"METHOD","id":"<Animal.toString>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<template-literal-toString>","metadata":{"type":"template-literal"}}],"edges":[{"src":"<Animal>","dst":"<Animal.constructor>","type":"CONTAINS"},{"src":"<Animal>","dst":"<Animal.speak>","type":"CONTAINS"},{"src":"<Animal>","dst":"<Animal.toString>","type":"CONTAINS"},{"src":"<Animal>","dst":"<Animal.name>","type":"HAS_PROPERTY"},{"src":"<Animal>","dst":"<Animal.sound>","type":"HAS_PROPERTY"},{"src":"<Animal.constructor>","dst":"<name>","type":"RECEIVES_ARGUMENT"},{"src":"<Animal.constructor>","dst":"<sound>","type":"RECEIVES_ARGUMENT"},{"src":"<Animal.name>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<Animal.sound>","dst":"<sound>","type":"ASSIGNED_FROM"},{"src":"<Animal.speak>","dst":"<template-literal-speak>","type":"RETURNS"},{"src":"<template-literal-speak>","dst":"<Animal.name>","type":"READS_FROM"},{"src":"<template-literal-speak>","dst":"<Animal.sound>","type":"READS_FROM"},{"src":"<Animal.toString>","dst":"<template-literal-toString>","type":"RETURNS"},{"src":"<template-literal-toString>","dst":"<Animal.name>","type":"READS_FROM"}],"rationale":"Class with constructor that initializes two instance properties from parameters, and two methods that read those properties in template literals. Changed PROPERTY_ACCESS nodes to PROPERTY nodes to represent the instance properties themselves rather than access expressions, and used HAS_PROPERTY to show class-property relationship.","implicitBehavior":["class declaration is hoisted","methods are bound to class prototype","constructor creates instance properties","this binding in methods refers to instance"]},"pass":2,"annotatedAt":"2026-02-24T00:30:26.705Z"}
{"construct":{"id":"cjs-patterns::cjs-conditional-exports","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":55,"lineEnd":59,"code":"if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n  exports._testHelper = function () { return 'test-only'; };\n  exports._internal = cjsFunction;\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"BRANCH","id":"<conditional-exports>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<typeof-check>","metadata":{"operator":"!=="}},{"type":"EXPRESSION","id":"<env-check>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<condition>","metadata":{"operator":"&&"}},{"type":"PROPERTY_ACCESS","id":"<exports._testHelper>","metadata":{"objectName":"exports","propertyName":"_testHelper"}},{"type":"FUNCTION","id":"<testHelper:fn>","metadata":{"anonymous":true}},{"type":"LITERAL","id":"<'test-only'>","metadata":{"value":"test-only","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<exports._internal>","metadata":{"objectName":"exports","propertyName":"_internal"}},{"type":"VARIABLE","id":"<cjsFunction>"},{"type":"EXTERNAL","id":"<process>","metadata":{"source":"Node.js runtime"}},{"type":"PROPERTY_ACCESS","id":"<process.env.NODE_ENV>","metadata":{"objectName":"process.env","propertyName":"NODE_ENV"}}],"edges":[{"src":"<conditional-exports>","dst":"<condition>","type":"HAS_CONDITION"},{"src":"<condition>","dst":"<typeof-check>","type":"READS_FROM"},{"src":"<condition>","dst":"<env-check>","type":"READS_FROM"},{"src":"<typeof-check>","dst":"<process>","type":"READS_FROM"},{"src":"<env-check>","dst":"<process.env.NODE_ENV>","type":"READS_FROM"},{"src":"<process.env.NODE_ENV>","dst":"<process>","type":"READS_FROM"},{"src":"<conditional-exports>","dst":"<exports._testHelper>","type":"HAS_CONSEQUENT"},{"src":"<conditional-exports>","dst":"<exports._internal>","type":"HAS_CONSEQUENT"},{"src":"<exports._testHelper>","dst":"<testHelper:fn>","type":"ASSIGNED_FROM"},{"src":"<testHelper:fn>","dst":"<'test-only'>","type":"RETURNS"},{"src":"<exports._internal>","dst":"<cjsFunction>","type":"ASSIGNED_FROM"}],"rationale":"Conditional CommonJS exports based on environment check. The branch conditionally assigns functions to exports properties when NODE_ENV is 'test', creating runtime-dependent module interface.","implicitBehavior":["exports object is implicitly available in CommonJS modules","process global is Node.js runtime specific","conditional exports create runtime-dependent module interface","typeof operator provides safe undefined checks"]},"pass":2,"annotatedAt":"2026-02-24T00:30:27.283Z"}
{"construct":{"id":"classes::class-expr-anonymous","file":"src/classes.js","category":"classes","lineStart":117,"lineEnd":122,"code":"const AnonymousClassExpr = class {\n  run() {\n    return 'running';\n  }\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<AnonymousClassExpr>","metadata":{"kind":"const"}},{"type":"CLASS","id":"<AnonymousClassExpr:class>","metadata":{"anonymous":true}},{"type":"METHOD","id":"<AnonymousClassExpr:class.run>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'running'>","metadata":{"value":"running","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<AnonymousClassExpr>","type":"DECLARES"},{"src":"<AnonymousClassExpr>","dst":"<AnonymousClassExpr:class>","type":"ASSIGNED_FROM"},{"src":"<AnonymousClassExpr:class>","dst":"<AnonymousClassExpr:class.run>","type":"CONTAINS"},{"src":"<AnonymousClassExpr:class.run>","dst":"<'running'>","type":"RETURNS"}],"rationale":"Anonymous class expression assigned to const variable. The class contains a method that returns a string literal. All relationships are captured using approved vocabulary.","implicitBehavior":[]},"pass":2,"annotatedAt":"2026-02-24T00:30:28.128Z"}
{"construct":{"id":"classes::class-static-members","file":"src/classes.js","category":"classes","lineStart":37,"lineEnd":52,"code":"class MathUtils {\n  static PI = 3.14159;\n\n  static add(a, b) {\n    return a + b;\n  }\n\n  static #internalHelper() {\n    return 42;\n  }\n\n  static create() {\n    return new MathUtils();\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<MathUtils>"},{"type":"PROPERTY","id":"<MathUtils.PI>","metadata":{"static":true,"value":3.14159}},{"type":"LITERAL","id":"<3.14159>","metadata":{"value":3.14159,"literalType":"number"}},{"type":"METHOD","id":"<MathUtils.add>","metadata":{"static":true,"kind":"method"}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"EXPRESSION","id":"<a + b>","metadata":{"operator":"+"}},{"type":"METHOD","id":"<MathUtils.#internalHelper>","metadata":{"static":true,"private":true,"kind":"method"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"METHOD","id":"<MathUtils.create>","metadata":{"static":true,"kind":"method"}},{"type":"EXPRESSION","id":"<new MathUtils()>","metadata":{"operator":"new"}}],"edges":[{"src":"<MathUtils>","dst":"<MathUtils.PI>","type":"CONTAINS"},{"src":"<MathUtils.PI>","dst":"<3.14159>","type":"ASSIGNED_FROM"},{"src":"<MathUtils>","dst":"<MathUtils.add>","type":"CONTAINS"},{"src":"<MathUtils.add>","dst":"<a>","type":"CONTAINS"},{"src":"<MathUtils.add>","dst":"<b>","type":"CONTAINS"},{"src":"<MathUtils.add>","dst":"<a + b>","type":"RETURNS"},{"src":"<a + b>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b>","dst":"<b>","type":"READS_FROM"},{"src":"<MathUtils>","dst":"<MathUtils.#internalHelper>","type":"CONTAINS"},{"src":"<MathUtils.#internalHelper>","dst":"<42>","type":"RETURNS"},{"src":"<MathUtils>","dst":"<MathUtils.create>","type":"CONTAINS"},{"src":"<MathUtils.create>","dst":"<new MathUtils()>","type":"RETURNS"},{"src":"<new MathUtils()>","dst":"<MathUtils>","type":"CALLS"}],"rationale":"Class with static members: property, public methods, and private method. Static property initialized with literal, methods contain parameters and return expressions. Removed module declaration edge to reduce edge count while preserving core static member relationships.","implicitBehavior":["static members belong to class constructor, not instances","private method only accessible within class","new expression calls class constructor","class is implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:30:30.652Z"}
{"construct":{"id":"classes::class-expr-named","file":"src/classes.js","category":"classes","lineStart":106,"lineEnd":115,"code":"const NamedClassExpr = class InternalName {\n  constructor(value) {\n    this.value = value;\n  }\n\n  getValue() {\n    return this.value;\n  }\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<NamedClassExpr>","metadata":{"kind":"const"}},{"type":"CLASS","id":"<InternalName>","metadata":{"isExpression":true,"externalName":"NamedClassExpr"}},{"type":"METHOD","id":"<InternalName.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<value>"},{"type":"PROPERTY_ACCESS","id":"<this.value>","metadata":{"objectName":"this"}},{"type":"METHOD","id":"<InternalName.getValue>","metadata":{"kind":"method"}}],"edges":[{"src":"<NamedClassExpr>","dst":"<InternalName>","type":"ASSIGNED_FROM"},{"src":"<InternalName>","dst":"<InternalName.constructor>","type":"CONTAINS"},{"src":"<InternalName>","dst":"<InternalName.getValue>","type":"CONTAINS"},{"src":"<InternalName.constructor>","dst":"<value>","type":"CONTAINS"},{"src":"<this.value>","dst":"<value>","type":"ASSIGNED_FROM"},{"src":"<InternalName.constructor>","dst":"<this.value>","type":"WRITES_TO"},{"src":"<InternalName.getValue>","dst":"<this.value>","type":"READS_FROM"},{"src":"<InternalName.getValue>","dst":"<this.value>","type":"RETURNS"}],"rationale":"Named class expression assigned to const variable. The class has an internal name (InternalName) different from the variable name (NamedClassExpr). Reduced from 9 to 8 edges by removing the module declaration edge since module scope relationships are handled implicitly.","implicitBehavior":["InternalName is only accessible within the class body itself","NamedClassExpr is the external binding in module scope","Module-level declaration of NamedClassExpr is implicit"]},"pass":2,"annotatedAt":"2026-02-24T00:30:32.707Z"}
{"construct":{"id":"cjs-patterns::with-property-fallback","file":"src/cjs-patterns.cjs","category":"cjs-patterns","lineStart":88,"lineEnd":99,"code":"const fallbackColor = 'red';\nfunction withPropertyFallback(config) {\n  with (config) {\n    return fallbackColor; // config.fallbackColor ?? outer fallbackColor  ambiguous\n  }\n}\n\nexports.loadImplementation = loadImplementation;\nexports.annexBDemo = annexBDemo;\nexports.withNested = withNested;\nexports.withPropertyFallback = withPropertyFallback;","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<fallbackColor>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'red'>","metadata":{"value":"red","literalType":"string"}},{"type":"FUNCTION","id":"<withPropertyFallback>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<config>"},{"type":"SCOPE","id":"<with-scope>","metadata":{"type":"with","object":"config"}},{"type":"EXPRESSION","id":"<fallbackColor-ref>","metadata":{"ambiguous":true,"name":"fallbackColor"}},{"type":"EXPORT","id":"<exports.loadImplementation>"},{"type":"EXPORT","id":"<exports.annexBDemo>"},{"type":"EXPORT","id":"<exports.withNested>"},{"type":"EXPORT","id":"<exports.withPropertyFallback>"}],"edges":[{"src":"<fallbackColor>","dst":"<'red'>","type":"ASSIGNED_FROM"},{"src":"<withPropertyFallback>","dst":"<config>","type":"CONTAINS"},{"src":"<withPropertyFallback>","dst":"<with-scope>","type":"HAS_SCOPE"},{"src":"<with-scope>","dst":"<config>","type":"EXTENDS_SCOPE_WITH"},{"src":"<with-scope>","dst":"<fallbackColor-ref>","type":"CONTAINS"},{"src":"<withPropertyFallback>","dst":"<fallbackColor-ref>","type":"RETURNS"},{"src":"<fallbackColor-ref>","dst":"<fallbackColor>","type":"READS_FROM"},{"src":"<fallbackColor-ref>","dst":"<config>","type":"READS_FROM"},{"src":"<exports.loadImplementation>","dst":"<loadImplementation>","type":"EXPORTS"},{"src":"<exports.annexBDemo>","dst":"<annexBDemo>","type":"EXPORTS"},{"src":"<exports.withNested>","dst":"<withNested>","type":"EXPORTS"},{"src":"<exports.withPropertyFallback>","dst":"<withPropertyFallback>","type":"EXPORTS"}],"rationale":"With statement creates ambiguous scope where variable reference could resolve to either config property or outer variable. Multiple CommonJS exports assign functions to module.exports properties. Used SCOPE for with statement and EXPRESSION for ambiguous variable reference.","implicitBehavior":["with statement modifies scope chain at runtime","variable resolution is ambiguous - could be config.fallbackColor or outer fallbackColor","with statement is deprecated and forbidden in strict mode","property lookup on config object happens at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:30:34.176Z"}
{"construct":{"id":"classes::class-inline-new","file":"src/classes.js","category":"classes","lineStart":207,"lineEnd":211,"code":"const inlineInstance = new (class {\n  constructor() { this.x = 1; }\n  getX() { return this.x; }\n})();","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<inlineInstance>","metadata":{"kind":"const"}},{"type":"CLASS","id":"<anonymous-class>","metadata":{"anonymous":true}},{"type":"METHOD","id":"<anonymous-class.constructor>","metadata":{"kind":"constructor"}},{"type":"PROPERTY_ACCESS","id":"<this.x>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"METHOD","id":"<anonymous-class.getX>","metadata":{"kind":"method"}},{"type":"CALL","id":"<new-anonymous-class>","metadata":{"constructor":true}}],"edges":[{"src":"<module>","dst":"<inlineInstance>","type":"DECLARES"},{"src":"<inlineInstance>","dst":"<new-anonymous-class>","type":"ASSIGNED_FROM"},{"src":"<new-anonymous-class>","dst":"<anonymous-class>","type":"CALLS"},{"src":"<anonymous-class>","dst":"<anonymous-class.constructor>","type":"CONTAINS"},{"src":"<anonymous-class>","dst":"<anonymous-class.getX>","type":"CONTAINS"},{"src":"<anonymous-class.constructor>","dst":"<this.x>","type":"WRITES_TO"},{"src":"<this.x>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<anonymous-class.getX>","dst":"<this.x>","type":"READS_FROM"},{"src":"<anonymous-class.getX>","dst":"<this.x>","type":"RETURNS"}],"rationale":"Inline anonymous class instantiation using approved vocabulary. All node and edge types from Pass 1 are already in the approved list, so the annotation remains identical. The construct captures the definition of an anonymous class that is immediately instantiated and assigned to a const variable.","implicitBehavior":["anonymous class has no referenceable name outside this expression","constructor is called immediately after class definition"]},"pass":2,"annotatedAt":"2026-02-24T00:30:35.303Z"}
{"construct":{"id":"classes::class-extends-super","file":"src/classes.js","category":"classes","lineStart":21,"lineEnd":35,"code":"class Dog extends Animal {\n  constructor(name) {\n    super(name, 'woof');\n    this.tricks = [];\n  }\n\n  learn(trick) {\n    this.tricks.push(trick);\n  }\n\n  speak() {\n    return `${super.speak()}!`;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Dog>"},{"type":"METHOD","id":"<Dog.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<name>"},{"type":"CALL","id":"<super(name, 'woof')>","metadata":{"callee":"super","isSuper":true}},{"type":"LITERAL","id":"<'woof'>","metadata":{"value":"woof","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this.tricks>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"METHOD","id":"<Dog.learn>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<trick>"},{"type":"CALL","id":"<this.tricks.push(trick)>","metadata":{"callee":"push"}},{"type":"METHOD","id":"<Dog.speak>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<`${super.speak()}!`>","metadata":{"type":"template-literal"}},{"type":"CALL","id":"<super.speak()>","metadata":{"callee":"speak","isSuper":true}}],"edges":[{"src":"<Dog>","dst":"<Animal>","type":"EXTENDS"},{"src":"<Dog>","dst":"<Dog.constructor>","type":"CONTAINS"},{"src":"<Dog>","dst":"<Dog.learn>","type":"CONTAINS"},{"src":"<Dog>","dst":"<Dog.speak>","type":"CONTAINS"},{"src":"<Dog.constructor>","dst":"<name>","type":"CONTAINS"},{"src":"<Dog.constructor>","dst":"<super(name, 'woof')>","type":"CONTAINS"},{"src":"<super(name, 'woof')>","dst":"<name>","type":"PASSES_ARGUMENT"},{"src":"<super(name, 'woof')>","dst":"<'woof'>","type":"PASSES_ARGUMENT"},{"src":"<this.tricks>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<Dog.learn>","dst":"<trick>","type":"CONTAINS"},{"src":"<Dog.learn>","dst":"<this.tricks.push(trick)>","type":"CONTAINS"},{"src":"<this.tricks.push(trick)>","dst":"<trick>","type":"PASSES_ARGUMENT"},{"src":"<Dog.speak>","dst":"<`${super.speak()}!`>","type":"RETURNS"},{"src":"<`${super.speak()}!`>","dst":"<super.speak()>","type":"READS_FROM"}],"rationale":"Class inheritance with super calls. Dog extends Animal, constructor calls super constructor, speak method calls super method and extends result. Reduced edge count by removing some intermediate relationships while preserving core inheritance and method call semantics.","implicitBehavior":["prototype chain established between Dog and Animal","super calls resolve to parent class methods at runtime","this binding maintained across super calls","super constructor call implicitly targets Animal.constructor","super.speak() call implicitly targets Animal.speak method"]},"pass":2,"annotatedAt":"2026-02-24T00:30:36.402Z"}
{"construct":{"id":"classes::class-static-block","file":"src/classes.js","category":"classes","lineStart":137,"lineEnd":151,"code":"class Config {\n  static defaults;\n\n  static {\n    Config.defaults = {\n      timeout: 5000,\n      retries: 3,\n    };\n  }\n\n  constructor(overrides = {}) {\n    this.settings = { ...Config.defaults, ...overrides };\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Config>"},{"type":"PROPERTY","id":"<Config.defaults>","metadata":{"static":true}},{"type":"STATIC_BLOCK","id":"<Config:static-block>"},{"type":"LITERAL","id":"<{timeout: 5000, retries: 3}>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<5000>","metadata":{"value":5000,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"METHOD","id":"<Config.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<overrides>","metadata":{"defaultValue":"{}"}},{"type":"LITERAL","id":"<{}>","metadata":{"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<this.settings>"},{"type":"EXPRESSION","id":"<{...Config.defaults, ...overrides}>","metadata":{"operator":"spread"}}],"edges":[{"src":"<Config>","dst":"<Config.defaults>","type":"CONTAINS"},{"src":"<Config>","dst":"<Config:static-block>","type":"CONTAINS"},{"src":"<Config>","dst":"<Config.constructor>","type":"CONTAINS"},{"src":"<Config:static-block>","dst":"<Config.defaults>","type":"WRITES_TO"},{"src":"<Config.defaults>","dst":"<{timeout: 5000, retries: 3}>","type":"ASSIGNED_FROM"},{"src":"<{timeout: 5000, retries: 3}>","dst":"<5000>","type":"HAS_PROPERTY"},{"src":"<{timeout: 5000, retries: 3}>","dst":"<3>","type":"HAS_PROPERTY"},{"src":"<Config.constructor>","dst":"<overrides>","type":"CONTAINS"},{"src":"<overrides>","dst":"<{}>","type":"DEFAULTS_TO"},{"src":"<Config.constructor>","dst":"<this.settings>","type":"WRITES_TO"},{"src":"<this.settings>","dst":"<{...Config.defaults, ...overrides}>","type":"ASSIGNED_FROM"},{"src":"<{...Config.defaults, ...overrides}>","dst":"<Config.defaults>","type":"READS_FROM"},{"src":"<{...Config.defaults, ...overrides}>","dst":"<overrides>","type":"READS_FROM"}],"rationale":"Class with static property declaration, static initialization block, and constructor. Static block initializes the static property with an object literal. Constructor merges static defaults with instance overrides using spread syntax. Changed parameter default assignment from ASSIGNED_FROM to DEFAULTS_TO to better capture the default parameter semantics.","implicitBehavior":["static block executes once when class is first evaluated","static property is shared across all instances","spread operator creates shallow copies of objects"]},"pass":2,"annotatedAt":"2026-02-24T00:30:36.735Z"}
{"construct":{"id":"classes::class-computed-methods","file":"src/classes.js","category":"classes","lineStart":124,"lineEnd":135,"code":"const METHOD_KEY = 'dynamicMethod';\n\nclass WithComputedMethods {\n  [METHOD_KEY]() {\n    return 'dynamic';\n  }\n\n  [Symbol.toPrimitive](hint) {\n    return hint === 'number' ? 42 : 'string';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<METHOD_KEY>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'dynamicMethod'>","metadata":{"value":"dynamicMethod","literalType":"string"}},{"type":"CLASS","id":"<WithComputedMethods>"},{"type":"METHOD","id":"<WithComputedMethods.[METHOD_KEY]>","metadata":{"kind":"method","computed":true}},{"type":"LITERAL","id":"<'dynamic'>","metadata":{"value":"dynamic","literalType":"string"}},{"type":"METHOD","id":"<WithComputedMethods.[Symbol.toPrimitive]>","metadata":{"kind":"method","computed":true}},{"type":"PARAMETER","id":"<hint>"},{"type":"EXPRESSION","id":"<hint === 'number'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'number'>","metadata":{"value":"number","literalType":"string"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"LITERAL","id":"<'string'>","metadata":{"value":"string","literalType":"string"}},{"type":"EXPRESSION","id":"<ternary>","metadata":{"operator":"?:"}}],"edges":[{"src":"<METHOD_KEY>","dst":"<'dynamicMethod'>","type":"ASSIGNED_FROM"},{"src":"<WithComputedMethods>","dst":"<WithComputedMethods.[METHOD_KEY]>","type":"CONTAINS"},{"src":"<WithComputedMethods.[METHOD_KEY]>","dst":"<METHOD_KEY>","type":"DEPENDS_ON"},{"src":"<WithComputedMethods.[METHOD_KEY]>","dst":"<'dynamic'>","type":"RETURNS"},{"src":"<WithComputedMethods>","dst":"<WithComputedMethods.[Symbol.toPrimitive]>","type":"CONTAINS"},{"src":"<WithComputedMethods.[Symbol.toPrimitive]>","dst":"<hint>","type":"CONTAINS"},{"src":"<WithComputedMethods.[Symbol.toPrimitive]>","dst":"<ternary>","type":"RETURNS"},{"src":"<ternary>","dst":"<hint === 'number'>","type":"HAS_CONDITION"},{"src":"<ternary>","dst":"<42>","type":"HAS_CONSEQUENT"},{"src":"<ternary>","dst":"<'string'>","type":"HAS_ALTERNATE"},{"src":"<hint === 'number'>","dst":"<hint>","type":"READS_FROM"},{"src":"<hint === 'number'>","dst":"<'number'>","type":"READS_FROM"}],"rationale":"Class with computed method names. First method uses a variable as the computed key, second uses Symbol.toPrimitive. Both methods have computed property names that depend on runtime evaluation.","implicitBehavior":["Symbol.toPrimitive is a well-known symbol that controls type coercion","computed method names are evaluated at class definition time"]},"pass":2,"annotatedAt":"2026-02-24T00:30:38.062Z"}
{"construct":{"id":"classes::class-new-target","file":"src/classes.js","category":"classes","lineStart":176,"lineEnd":189,"code":"class AbstractBase {\n  constructor() {\n    if (new.target === AbstractBase) {\n      throw new Error('Cannot instantiate AbstractBase directly');\n    }\n  }\n}\n\nclass Concrete extends AbstractBase {\n  constructor() {\n    super();\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<AbstractBase>"},{"type":"METHOD","id":"<AbstractBase.constructor>","metadata":{"kind":"constructor"}},{"type":"BRANCH","id":"<if-new.target>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<new.target === AbstractBase>","metadata":{"operator":"==="}},{"type":"META_PROPERTY","id":"<new.target>","metadata":{"property":"target"}},{"type":"CALL","id":"<throw new Error>","metadata":{"callee":"Error","isThrow":true}},{"type":"LITERAL","id":"<'Cannot instantiate AbstractBase directly'>","metadata":{"value":"Cannot instantiate AbstractBase directly","literalType":"string"}},{"type":"CLASS","id":"<Concrete>"},{"type":"METHOD","id":"<Concrete.constructor>","metadata":{"kind":"constructor"}},{"type":"CALL","id":"<super()>","metadata":{"callee":"super"}}],"edges":[{"src":"<AbstractBase>","dst":"<AbstractBase.constructor>","type":"CONTAINS"},{"src":"<AbstractBase.constructor>","dst":"<if-new.target>","type":"CONTAINS"},{"src":"<if-new.target>","dst":"<new.target === AbstractBase>","type":"HAS_CONDITION"},{"src":"<new.target === AbstractBase>","dst":"<new.target>","type":"READS_FROM"},{"src":"<new.target === AbstractBase>","dst":"<AbstractBase>","type":"READS_FROM"},{"src":"<if-new.target>","dst":"<throw new Error>","type":"HAS_CONSEQUENT"},{"src":"<throw new Error>","dst":"<'Cannot instantiate AbstractBase directly'>","type":"PASSES_ARGUMENT"},{"src":"<Concrete>","dst":"<AbstractBase>","type":"EXTENDS"},{"src":"<Concrete>","dst":"<Concrete.constructor>","type":"CONTAINS"},{"src":"<Concrete.constructor>","dst":"<super()>","type":"CONTAINS"},{"src":"<super()>","dst":"<AbstractBase.constructor>","type":"CALLS"}],"rationale":"Abstract base class pattern using new.target meta-property to prevent direct instantiation. Concrete class extends base and calls super constructor. Reduced edge count by removing module-level declarations and Error constructor call.","implicitBehavior":["new.target refers to the constructor that was directly invoked with new","super() call must be first statement in derived constructor","Error thrown will propagate up call stack","Classes are implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:30:39.120Z"}
{"construct":{"id":"classes::class-getters-setters","file":"src/classes.js","category":"classes","lineStart":81,"lineEnd":104,"code":"class Temperature {\n  #celsius;\n\n  constructor(celsius) {\n    this.#celsius = celsius;\n  }\n\n  get fahrenheit() {\n    return this.#celsius * 9 / 5 + 32;\n  }\n\n  set fahrenheit(f) {\n    this.#celsius = (f - 32) * 5 / 9;\n  }\n\n  get celsius() {\n    return this.#celsius;\n  }\n\n  set celsius(c) {\n    this.#celsius = c;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Temperature>"},{"type":"PROPERTY","id":"<#celsius>","metadata":{"private":true}},{"type":"METHOD","id":"<Temperature.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<celsius>"},{"type":"PROPERTY_ACCESS","id":"<this.#celsius>","metadata":{"objectName":"this","private":true}},{"type":"GETTER","id":"<Temperature.fahrenheit:getter>","metadata":{"propertyName":"fahrenheit"}},{"type":"EXPRESSION","id":"<this.#celsius * 9 / 5 + 32>","metadata":{"operator":"arithmetic"}},{"type":"SETTER","id":"<Temperature.fahrenheit:setter>","metadata":{"propertyName":"fahrenheit"}},{"type":"PARAMETER","id":"<f>"},{"type":"EXPRESSION","id":"<(f - 32) * 5 / 9>","metadata":{"operator":"arithmetic"}},{"type":"GETTER","id":"<Temperature.celsius:getter>","metadata":{"propertyName":"celsius"}},{"type":"SETTER","id":"<Temperature.celsius:setter>","metadata":{"propertyName":"celsius"}},{"type":"PARAMETER","id":"<c>"}],"edges":[{"src":"<Temperature>","dst":"<#celsius>","type":"CONTAINS"},{"src":"<Temperature>","dst":"<Temperature.constructor>","type":"CONTAINS"},{"src":"<Temperature>","dst":"<Temperature.fahrenheit:getter>","type":"CONTAINS"},{"src":"<Temperature>","dst":"<Temperature.fahrenheit:setter>","type":"CONTAINS"},{"src":"<Temperature>","dst":"<Temperature.celsius:getter>","type":"CONTAINS"},{"src":"<Temperature>","dst":"<Temperature.celsius:setter>","type":"CONTAINS"},{"src":"<Temperature.constructor>","dst":"<celsius>","type":"CONTAINS"},{"src":"<this.#celsius>","dst":"<celsius>","type":"ASSIGNED_FROM"},{"src":"<Temperature.constructor>","dst":"<this.#celsius>","type":"WRITES_TO"},{"src":"<Temperature.fahrenheit:getter>","dst":"<this.#celsius * 9 / 5 + 32>","type":"RETURNS"},{"src":"<this.#celsius * 9 / 5 + 32>","dst":"<this.#celsius>","type":"READS_FROM"},{"src":"<Temperature.fahrenheit:setter>","dst":"<f>","type":"CONTAINS"},{"src":"<Temperature.fahrenheit:setter>","dst":"<this.#celsius>","type":"WRITES_TO"},{"src":"<this.#celsius>","dst":"<(f - 32) * 5 / 9>","type":"ASSIGNED_FROM"},{"src":"<(f - 32) * 5 / 9>","dst":"<f>","type":"READS_FROM"},{"src":"<Temperature.celsius:getter>","dst":"<this.#celsius>","type":"RETURNS"},{"src":"<Temperature.celsius:setter>","dst":"<c>","type":"CONTAINS"},{"src":"<Temperature.celsius:setter>","dst":"<this.#celsius>","type":"WRITES_TO"},{"src":"<this.#celsius>","dst":"<c>","type":"ASSIGNED_FROM"}],"rationale":"Class with private field and getter/setter pairs. Used GETTER and SETTER node types from approved vocabulary instead of METHOD with metadata. All other relationships remain the same - getters return computed or direct values, setters assign to private field with temperature conversion logic.","implicitBehavior":["private field #celsius is only accessible within class","getters/setters create property-like interface","fahrenheit getter/setter perform temperature conversion"]},"pass":2,"annotatedAt":"2026-02-24T00:30:39.147Z"}
{"construct":{"id":"classes::in-brand-check","file":"src/classes.js","category":"classes","lineStart":218,"lineEnd":224,"code":"class Branded {\n  #secret = true;\n  static isBranded(obj) {\n    return #secret in obj;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Branded>"},{"type":"PROPERTY","id":"<#secret>","metadata":{"private":true,"static":false}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"METHOD","id":"<Branded.isBranded>","metadata":{"static":true,"kind":"method"}},{"type":"PARAMETER","id":"<obj>"},{"type":"EXPRESSION","id":"<#secret in obj>","metadata":{"operator":"in","privateFieldCheck":true}}],"edges":[{"src":"<Branded>","dst":"<#secret>","type":"CONTAINS"},{"src":"<#secret>","dst":"<true>","type":"ASSIGNED_FROM"},{"src":"<Branded>","dst":"<Branded.isBranded>","type":"CONTAINS"},{"src":"<Branded.isBranded>","dst":"<obj>","type":"CONTAINS"},{"src":"<Branded.isBranded>","dst":"<#secret in obj>","type":"RETURNS"},{"src":"<#secret in obj>","dst":"<#secret>","type":"READS_FROM"},{"src":"<#secret in obj>","dst":"<obj>","type":"READS_FROM"}],"rationale":"Class with private field and static method using 'in' operator for brand checking. The private field check expression reads both the private field and the parameter. Removed the module declaration edge to stay within the 7-edge threshold.","implicitBehavior":["private field #secret is only accessible within class scope","brand check pattern allows testing if object is instance of this class"]},"pass":2,"annotatedAt":"2026-02-24T00:30:42.157Z"}
{"construct":{"id":"classes::new-arrow-throws","file":"src/classes.js","category":"classes","lineStart":226,"lineEnd":230,"code":"const ArrowNotConstructable = () => {};\nconst methodShorthandObj = { method() {} };\n// new ArrowNotConstructable(); // TypeError: not a constructor\n// new methodShorthandObj.method(); // TypeError: not a constructor","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<ArrowNotConstructable>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<ArrowNotConstructable:fn>","metadata":{"arrowFunction":true,"constructable":false}},{"type":"VARIABLE","id":"<methodShorthandObj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<methodShorthandObj:obj>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<method>","metadata":{"kind":"method","constructable":false}}],"edges":[{"src":"<module>","dst":"<ArrowNotConstructable>","type":"DECLARES"},{"src":"<ArrowNotConstructable>","dst":"<ArrowNotConstructable:fn>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<methodShorthandObj>","type":"DECLARES"},{"src":"<methodShorthandObj>","dst":"<methodShorthandObj:obj>","type":"ASSIGNED_FROM"},{"src":"<methodShorthandObj:obj>","dst":"<method>","type":"HAS_PROPERTY"}],"rationale":"Arrow function and method shorthand syntax both create non-constructable functions. The commented calls would throw TypeError at runtime.","implicitBehavior":["arrow functions lack [[Construct]] internal method","method shorthand functions are not constructable","new operator would throw TypeError on both"]},"pass":2,"annotatedAt":"2026-02-24T00:30:42.243Z"}
{"construct":{"id":"classes::class-private-fields","file":"src/classes.js","category":"classes","lineStart":54,"lineEnd":79,"code":"class BankAccount {\n  #balance;\n  #owner;\n\n  constructor(owner, initialBalance) {\n    this.#owner = owner;\n    this.#balance = initialBalance;\n  }\n\n  #validate(amount) {\n    return amount > 0 && amount <= this.#balance;\n  }\n\n  withdraw(amount) {\n    if (this.#validate(amount)) {\n      this.#balance -= amount;\n      return true;\n    }\n    return false;\n  }\n\n  get balance() {\n    return this.#balance;\n  }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"CLASS\",\n      \"id\": \"<BankAccount>\"\n    },\n    {\n      \"type\": \"PROPERTY\",\n      \"id\": \"<#balance>\",\n      \"metadata\": {\n        \"private\": true\n      }\n   "},"pass":2,"annotatedAt":"2026-02-24T00:30:42.682Z"}
{"construct":{"id":"classes::mixin-composition","file":"src/classes.js","category":"classes","lineStart":200,"lineEnd":205,"code":"class User extends Serializable(Validatable(class {\n  constructor(name) { this.name = name; }\n})) {\n  greet() { return `Hi, ${this.name}`; }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<User>"},{"type":"CLASS","id":"<anonymous-base>"},{"type":"METHOD","id":"<anonymous-base.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<name>"},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"CALL","id":"<Validatable(anonymous-base)>","metadata":{"callee":"Validatable"}},{"type":"CALL","id":"<Serializable(Validatable-result)>","metadata":{"callee":"Serializable"}},{"type":"METHOD","id":"<User.greet>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'Hi, '>","metadata":{"value":"Hi, ","literalType":"string"}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}},{"type":"PROPERTY_ACCESS","id":"<this.name-read>","metadata":{"objectName":"this"}}],"edges":[{"src":"<User>","dst":"<Serializable(Validatable-result)>","type":"EXTENDS"},{"src":"<User>","dst":"<User.greet>","type":"CONTAINS"},{"src":"<anonymous-base>","dst":"<anonymous-base.constructor>","type":"CONTAINS"},{"src":"<anonymous-base.constructor>","dst":"<name>","type":"RECEIVES_ARGUMENT"},{"src":"<this.name>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<Validatable(anonymous-base)>","dst":"<anonymous-base>","type":"PASSES_ARGUMENT"},{"src":"<Serializable(Validatable-result)>","dst":"<Validatable(anonymous-base)>","type":"PASSES_ARGUMENT"},{"src":"<User.greet>","dst":"<template-literal>","type":"RETURNS"},{"src":"<template-literal>","dst":"<'Hi, '>","type":"HAS_ELEMENT"},{"src":"<template-literal>","dst":"<this.name-read>","type":"READS_FROM"}],"rationale":"Mixin composition pattern where an anonymous base class is wrapped by two higher-order functions (Validatable, Serializable) before being extended by User. Reduced edge count by removing module-level containment relationships and focusing on core semantic relationships.","implicitBehavior":["mixin functions likely add methods/properties to prototype chain","template literal performs string interpolation","this binding inherited through prototype chain"]},"pass":2,"annotatedAt":"2026-02-24T00:30:43.899Z"}
{"construct":{"id":"classes::class-multi-level-inheritance","file":"src/classes.js","category":"classes","lineStart":153,"lineEnd":174,"code":"class Base {\n  baseMethod() {\n    return 'base';\n  }\n}\n\nclass Middle extends Base {\n  middleMethod() {\n    return 'middle';\n  }\n}\n\nclass Derived extends Middle {\n  derivedMethod() {\n    return 'derived';\n  }\n\n  allMethods() {\n    return [this.baseMethod(), this.middleMethod(), this.derivedMethod()];\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Base>"},{"type":"METHOD","id":"<Base.baseMethod>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'base'>","metadata":{"value":"base","literalType":"string"}},{"type":"CLASS","id":"<Middle>"},{"type":"METHOD","id":"<Middle.middleMethod>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'middle'>","metadata":{"value":"middle","literalType":"string"}},{"type":"CLASS","id":"<Derived>"},{"type":"METHOD","id":"<Derived.derivedMethod>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'derived'>","metadata":{"value":"derived","literalType":"string"}},{"type":"METHOD","id":"<Derived.allMethods>","metadata":{"kind":"method"}},{"type":"CALL","id":"<this.baseMethod()>","metadata":{"callee":"baseMethod"}},{"type":"CALL","id":"<this.middleMethod()>","metadata":{"callee":"middleMethod"}},{"type":"CALL","id":"<this.derivedMethod()>","metadata":{"callee":"derivedMethod"}},{"type":"EXPRESSION","id":"<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>","metadata":{"type":"array"}},{"type":"MODULE","id":"<module>"}],"edges":[{"src":"<module>","dst":"<Base>","type":"DECLARES"},{"src":"<Base>","dst":"<Base.baseMethod>","type":"CONTAINS"},{"src":"<Base.baseMethod>","dst":"<'base'>","type":"RETURNS"},{"src":"<module>","dst":"<Middle>","type":"DECLARES"},{"src":"<Middle>","dst":"<Base>","type":"EXTENDS"},{"src":"<Middle>","dst":"<Middle.middleMethod>","type":"CONTAINS"},{"src":"<Middle.middleMethod>","dst":"<'middle'>","type":"RETURNS"},{"src":"<module>","dst":"<Derived>","type":"DECLARES"},{"src":"<Derived>","dst":"<Middle>","type":"EXTENDS"},{"src":"<Derived>","dst":"<Derived.derivedMethod>","type":"CONTAINS"},{"src":"<Derived.derivedMethod>","dst":"<'derived'>","type":"RETURNS"},{"src":"<Derived>","dst":"<Derived.allMethods>","type":"CONTAINS"},{"src":"<Derived.allMethods>","dst":"<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>","type":"RETURNS"},{"src":"<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>","dst":"<this.baseMethod()>","type":"HAS_ELEMENT"},{"src":"<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>","dst":"<this.middleMethod()>","type":"HAS_ELEMENT"},{"src":"<[this.baseMethod(), this.middleMethod(), this.derivedMethod()]>","dst":"<this.derivedMethod()>","type":"HAS_ELEMENT"},{"src":"<this.baseMethod()>","dst":"<Base.baseMethod>","type":"CALLS"},{"src":"<this.middleMethod()>","dst":"<Middle.middleMethod>","type":"CALLS"},{"src":"<this.derivedMethod()>","dst":"<Derived.derivedMethod>","type":"CALLS"}],"rationale":"Multi-level inheritance chain where Derived extends Middle which extends Base. The allMethods method calls inherited methods from all levels of the hierarchy. Added explicit MODULE node to properly represent the declaration context.","implicitBehavior":["prototype chain lookup for inherited methods","method resolution follows inheritance hierarchy","this binding resolves to the Derived instance for all method calls"]},"pass":2,"annotatedAt":"2026-02-24T00:30:44.426Z"}
{"construct":{"id":"classes::mixin-class-expression","file":"src/classes.js","category":"classes","lineStart":191,"lineEnd":198,"code":"const Serializable = (SuperClass) => class extends SuperClass {\n  serialize() { return JSON.stringify(this); }\n};\n\nconst Validatable = (SuperClass) => class extends SuperClass {\n  validate() { return true; }\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<Serializable>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<Serializable:fn>","metadata":{"arrowFunction":true,"mixin":true}},{"type":"PARAMETER","id":"<SuperClass>"},{"type":"CLASS","id":"<Serializable:class>","metadata":{"anonymous":true,"mixin":true}},{"type":"METHOD","id":"<Serializable:class.serialize>","metadata":{"kind":"method"}},{"type":"CALL","id":"<JSON.stringify(this)>","metadata":{"callee":"JSON.stringify"}},{"type":"PROPERTY_ACCESS","id":"<JSON.stringify>","metadata":{"object":"JSON","property":"stringify"}},{"type":"VARIABLE","id":"<this>","metadata":{"kind":"this"}},{"type":"VARIABLE","id":"<Validatable>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<Validatable:fn>","metadata":{"arrowFunction":true,"mixin":true}},{"type":"PARAMETER","id":"<SuperClass2>"},{"type":"CLASS","id":"<Validatable:class>","metadata":{"anonymous":true,"mixin":true}},{"type":"METHOD","id":"<Validatable:class.validate>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<Serializable>","dst":"<Serializable:fn>","type":"ASSIGNED_FROM"},{"src":"<Serializable:fn>","dst":"<SuperClass>","type":"RECEIVES_ARGUMENT"},{"src":"<Serializable:fn>","dst":"<Serializable:class>","type":"RETURNS"},{"src":"<Serializable:class>","dst":"<SuperClass>","type":"EXTENDS"},{"src":"<Serializable:class>","dst":"<Serializable:class.serialize>","type":"CONTAINS"},{"src":"<Serializable:class.serialize>","dst":"<JSON.stringify(this)>","type":"RETURNS"},{"src":"<JSON.stringify(this)>","dst":"<JSON.stringify>","type":"CALLS"},{"src":"<JSON.stringify(this)>","dst":"<this>","type":"PASSES_ARGUMENT"},{"src":"<Validatable>","dst":"<Validatable:fn>","type":"ASSIGNED_FROM"},{"src":"<Validatable:fn>","dst":"<SuperClass2>","type":"RECEIVES_ARGUMENT"},{"src":"<Validatable:fn>","dst":"<Validatable:class>","type":"RETURNS"},{"src":"<Validatable:class>","dst":"<SuperClass2>","type":"EXTENDS"},{"src":"<Validatable:class>","dst":"<Validatable:class.validate>","type":"CONTAINS"},{"src":"<Validatable:class.validate>","dst":"<true>","type":"RETURNS"}],"rationale":"Two mixin factory functions that return anonymous classes extending their parameter. Each adds a method to the extended class. Using approved vocabulary, functions receive arguments rather than contain parameters, and explicit nodes are created for property access and this reference.","implicitBehavior":["mixin pattern allows composition of multiple behaviors","returned classes can be further extended or instantiated","this binding in serialize method refers to instance of final composed class"]},"pass":2,"annotatedAt":"2026-02-24T00:30:46.450Z"}
{"construct":{"id":"classes::class-async-method","file":"src/classes.js","category":"classes","lineStart":255,"lineEnd":259,"code":"class ApiClient {\n  async fetch(url) { return url; }\n  static async create() { return new ApiClient(); }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ApiClient>"},{"type":"METHOD","id":"<ApiClient.fetch>","metadata":{"kind":"method","async":true}},{"type":"PARAMETER","id":"<url>"},{"type":"METHOD","id":"<ApiClient.create>","metadata":{"kind":"static","async":true}},{"type":"EXPRESSION","id":"<new ApiClient()>","metadata":{"type":"constructor-call"}}],"edges":[{"src":"<ApiClient>","dst":"<ApiClient.fetch>","type":"CONTAINS"},{"src":"<ApiClient>","dst":"<ApiClient.create>","type":"CONTAINS"},{"src":"<ApiClient.fetch>","dst":"<url>","type":"RECEIVES_ARGUMENT"},{"src":"<ApiClient.fetch>","dst":"<url>","type":"RETURNS"},{"src":"<ApiClient.create>","dst":"<new ApiClient()>","type":"RETURNS"},{"src":"<new ApiClient()>","dst":"<ApiClient>","type":"CALLS"}],"rationale":"Class with async instance method and async static method. The fetch method receives a url parameter and returns it. The create method returns a new instance via constructor call. Removed module-level declaration edge as no module node exists in approved vocabulary.","implicitBehavior":["async methods return Promise objects","static method accessible without instantiation","constructor call creates new instance"]},"pass":2,"annotatedAt":"2026-02-24T00:30:46.502Z"}
{"construct":{"id":"classes::class-inline-extends","file":"src/classes.js","category":"classes","lineStart":213,"lineEnd":216,"code":"const inlineChild = new (class extends Error {\n  constructor(msg) { super(msg); this.custom = true; }\n})('inline error');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<inlineChild>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new (class extends Error {...})('inline error')>","metadata":{"operator":"new"}},{"type":"CLASS","id":"<anonymous-class>","metadata":{"anonymous":true}},{"type":"METHOD","id":"<anonymous-class.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<msg>"},{"type":"CALL","id":"<super(msg)>","metadata":{"callee":"super"}},{"type":"PROPERTY_ACCESS","id":"<this.custom>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<'inline error'>","metadata":{"value":"inline error","literalType":"string"}}],"edges":[{"src":"<inlineChild>","dst":"<new (class extends Error {...})('inline error')>","type":"ASSIGNED_FROM"},{"src":"<new (class extends Error {...})('inline error')>","dst":"<anonymous-class>","type":"CALLS"},{"src":"<new (class extends Error {...})('inline error')>","dst":"<'inline error'>","type":"PASSES_ARGUMENT"},{"src":"<anonymous-class>","dst":"<anonymous-class.constructor>","type":"CONTAINS"},{"src":"<anonymous-class.constructor>","dst":"<msg>","type":"CONTAINS"},{"src":"<anonymous-class.constructor>","dst":"<super(msg)>","type":"CONTAINS"},{"src":"<super(msg)>","dst":"<msg>","type":"PASSES_ARGUMENT"},{"src":"<anonymous-class.constructor>","dst":"<this.custom>","type":"WRITES_TO"},{"src":"<this.custom>","dst":"<true>","type":"ASSIGNED_FROM"}],"rationale":"Anonymous class extending Error is instantiated inline. Constructor calls super and sets a custom property. The new expression creates an instance with the provided argument.","implicitBehavior":["super() call invokes parent Error constructor","this binding established for new instance","prototype chain links to Error.prototype"]},"pass":2,"annotatedAt":"2026-02-24T00:30:46.973Z"}
{"construct":{"id":"classes::class-constructor-return-non-this","file":"src/classes.js","category":"classes","lineStart":246,"lineEnd":253,"code":"class Singleton {\n  static instance;\n  constructor() {\n    if (Singleton.instance) return Singleton.instance;\n    Singleton.instance = this;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Singleton>"},{"type":"PROPERTY","id":"<Singleton.instance>","metadata":{"static":true}},{"type":"METHOD","id":"<Singleton.constructor>","metadata":{"kind":"constructor"}},{"type":"BRANCH","id":"<if-instance-exists>"},{"type":"PROPERTY_ACCESS","id":"<Singleton.instance-read>","metadata":{"objectName":"Singleton","propertyName":"instance"}},{"type":"PROPERTY_ACCESS","id":"<Singleton.instance-write>","metadata":{"objectName":"Singleton","propertyName":"instance"}},{"type":"LITERAL","id":"<this>","metadata":{"value":"this","literalType":"this"}}],"edges":[{"src":"<Singleton>","dst":"<Singleton.instance>","type":"HAS_PROPERTY"},{"src":"<Singleton>","dst":"<Singleton.constructor>","type":"HAS_PROPERTY"},{"src":"<Singleton.constructor>","dst":"<if-instance-exists>","type":"CONTAINS"},{"src":"<if-instance-exists>","dst":"<Singleton.instance-read>","type":"HAS_CONDITION"},{"src":"<if-instance-exists>","dst":"<Singleton.instance-read>","type":"HAS_CONSEQUENT"},{"src":"<Singleton.constructor>","dst":"<Singleton.instance-read>","type":"RETURNS"},{"src":"<Singleton.instance-read>","dst":"<Singleton.instance>","type":"READS_FROM"},{"src":"<Singleton.instance-write>","dst":"<this>","type":"ASSIGNED_FROM"},{"src":"<Singleton.constructor>","dst":"<Singleton.instance-write>","type":"WRITES_TO"},{"src":"<Singleton.instance-write>","dst":"<Singleton.instance>","type":"WRITES_TO"}],"rationale":"Singleton pattern constructor that conditionally returns existing instance or creates new one. Static property holds the singleton instance, constructor has branching logic. Used HAS_PROPERTY instead of CONTAINS for class members to better reflect the relationship.","implicitBehavior":["constructor can return non-this value, overriding default instance creation","static property persists across all instances"]},"pass":2,"annotatedAt":"2026-02-24T00:30:47.488Z"}
{"construct":{"id":"classes::class-field-no-initializer","file":"src/classes.js","category":"classes","lineStart":284,"lineEnd":290,"code":"class Form {\n  errors;\n  static count;\n}\n\n// --- Dynamic super property access ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Form>"},{"type":"PROPERTY","id":"<Form.errors>","metadata":{"static":false,"hasInitializer":false}},{"type":"PROPERTY","id":"<Form.count>","metadata":{"static":true,"hasInitializer":false}}],"edges":[{"src":"<module>","dst":"<Form>","type":"DECLARES"},{"src":"<Form>","dst":"<Form.errors>","type":"CONTAINS"},{"src":"<Form>","dst":"<Form.count>","type":"CONTAINS"}],"rationale":"Class with two property declarations - one instance property and one static property, both without initializers. Using PROPERTY as the closest approved type for class fields.","implicitBehavior":["fields without initializers are undefined until assigned","static fields belong to the class constructor, not instances"]},"pass":2,"annotatedAt":"2026-02-24T00:30:47.891Z"}
{"construct":{"id":"classes::class-generator-method","file":"src/classes.js","category":"classes","lineStart":261,"lineEnd":266,"code":"class Stream {\n  data = [];\n  *items() { for (const item of this.data) yield item; }\n  async *pages() { yield* this.data; }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Stream>"},{"type":"PROPERTY","id":"<Stream.data>","metadata":{"kind":"field"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"METHOD","id":"<Stream.items>","metadata":{"kind":"generator","async":false}},{"type":"LOOP","id":"<for-of-data>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<this.data>","metadata":{"objectName":"this"}},{"type":"EXPRESSION","id":"<yield item>","metadata":{"operator":"yield"}},{"type":"METHOD","id":"<Stream.pages>","metadata":{"kind":"generator","async":true}},{"type":"EXPRESSION","id":"<yield* this.data>","metadata":{"operator":"yield*"}}],"edges":[{"src":"<Stream>","dst":"<Stream.data>","type":"CONTAINS"},{"src":"<Stream.data>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<Stream>","dst":"<Stream.items>","type":"CONTAINS"},{"src":"<Stream>","dst":"<Stream.pages>","type":"CONTAINS"},{"src":"<Stream.items>","dst":"<for-of-data>","type":"CONTAINS"},{"src":"<for-of-data>","dst":"<this.data>","type":"ITERATES_OVER"},{"src":"<for-of-data>","dst":"<item>","type":"CONTAINS"},{"src":"<Stream.items>","dst":"<yield item>","type":"YIELDS"},{"src":"<yield item>","dst":"<item>","type":"READS_FROM"},{"src":"<Stream.pages>","dst":"<yield* this.data>","type":"DELEGATES_TO"},{"src":"<yield* this.data>","dst":"<this.data>","type":"READS_FROM"}],"rationale":"Class with field initialization and two generator methods. One synchronous generator iterates over data, one async generator delegates to data. All relationships captured using approved vocabulary.","implicitBehavior":["generator methods return iterator objects","yield* delegates to iterable protocol","async generator returns async iterator"]},"pass":2,"annotatedAt":"2026-02-24T00:30:50.873Z"}
{"construct":{"id":"classes::class-static-getter-setter","file":"src/classes.js","category":"classes","lineStart":268,"lineEnd":273,"code":"class Registry {\n  static #store = new Map();\n  static get size() { return this.#store.size; }\n  static set defaultValue(value) { this.#store.set('default', value); }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Registry>"},{"type":"PROPERTY","id":"<Registry.#store>","metadata":{"static":true,"private":true}},{"type":"CALL","id":"<new Map()>","metadata":{"constructor":true,"callee":"Map"}},{"type":"GETTER","id":"<Registry.size>","metadata":{"static":true}},{"type":"PROPERTY_ACCESS","id":"<this.#store.size>","metadata":{"objectName":"this","propertyChain":["#store","size"]}},{"type":"SETTER","id":"<Registry.defaultValue>","metadata":{"static":true}},{"type":"PARAMETER","id":"<value>"},{"type":"CALL","id":"<this.#store.set('default', value)>","metadata":{"callee":"set"}},{"type":"LITERAL","id":"<'default'>","metadata":{"value":"default","literalType":"string"}}],"edges":[{"src":"<Registry>","dst":"<Registry.#store>","type":"CONTAINS"},{"src":"<Registry>","dst":"<Registry.size>","type":"CONTAINS"},{"src":"<Registry>","dst":"<Registry.defaultValue>","type":"CONTAINS"},{"src":"<Registry.#store>","dst":"<new Map()>","type":"ASSIGNED_FROM"},{"src":"<new Map()>","dst":"<Map>","type":"CALLS"},{"src":"<Registry.size>","dst":"<this.#store.size>","type":"RETURNS"},{"src":"<this.#store.size>","dst":"<Registry.#store>","type":"READS_FROM"},{"src":"<Registry.defaultValue>","dst":"<value>","type":"CONTAINS"},{"src":"<Registry.defaultValue>","dst":"<this.#store.set('default', value)>","type":"CONTAINS"},{"src":"<this.#store.set('default', value)>","dst":"<Registry.#store>","type":"CALLS_ON"},{"src":"<this.#store.set('default', value)>","dst":"<'default'>","type":"PASSES_ARGUMENT"},{"src":"<this.#store.set('default', value)>","dst":"<value>","type":"PASSES_ARGUMENT"}],"rationale":"Class with static private field, static getter, and static setter. Used GETTER and SETTER node types instead of METHOD with metadata. Changed method call edge from CALLS to CALLS_ON to better represent calling a method on an object.","implicitBehavior":["private field #store is only accessible within the class","static members belong to the class constructor, not instances","getter/setter create property-like access patterns"]},"pass":2,"annotatedAt":"2026-02-24T00:30:52.705Z"}
{"construct":{"id":"async-generators::async-iterator-cancel-break","file":"src/async-generators.js","category":"async-generators","lineStart":221,"lineEnd":231,"code":"async function* streamChunks(url) {\n  const reader = { locked: true };\n  try {\n    for (let i = 0; i < 10; i++) {\n      yield { chunk: i, size: i * 100 };\n    }\n  } finally {\n    reader.locked = false; // MUST run on break/throw/return\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<streamChunks>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<url>"},{"type":"VARIABLE","id":"<reader>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ locked: true }>","metadata":{"value":"{ locked: true }","literalType":"object"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":"0","literalType":"number"}},{"type":"LITERAL","id":"<10>","metadata":{"value":"10","literalType":"number"}},{"type":"EXPRESSION","id":"<i < 10>","metadata":{"operator":"<"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<yield { chunk: i, size: i * 100 }>","metadata":{"operator":"yield"}},{"type":"LITERAL","id":"<{ chunk: i, size: i * 100 }>","metadata":{"literalType":"object"}},{"type":"EXPRESSION","id":"<i * 100>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<100>","metadata":{"value":"100","literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<reader.locked>","metadata":{"objectName":"reader","propertyName":"locked"}},{"type":"LITERAL","id":"<false>","metadata":{"value":"false","literalType":"boolean"}}],"edges":[{"src":"<streamChunks>","dst":"<url>","type":"CONTAINS"},{"src":"<streamChunks>","dst":"<reader>","type":"CONTAINS"},{"src":"<reader>","dst":"<{ locked: true }>","type":"ASSIGNED_FROM"},{"src":"<streamChunks>","dst":"<try-block>","type":"CONTAINS"},{"src":"<streamChunks>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 10>","type":"HAS_CONDITION"},{"src":"<i < 10>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 10>","dst":"<10>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<yield { chunk: i, size: i * 100 }>","type":"HAS_BODY"},{"src":"<yield { chunk: i, size: i * 100 }>","dst":"<{ chunk: i, size: i * 100 }>","type":"YIELDS"},{"src":"<{ chunk: i, size: i * 100 }>","dst":"<i>","type":"READS_FROM"},{"src":"<{ chunk: i, size: i * 100 }>","dst":"<i * 100>","type":"READS_FROM"},{"src":"<i * 100>","dst":"<i>","type":"READS_FROM"},{"src":"<i * 100>","dst":"<100>","type":"READS_FROM"},{"src":"<finally-block>","dst":"<reader.locked>","type":"CONTAINS"},{"src":"<reader.locked>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<reader.locked>","dst":"<reader>","type":"READS_FROM"}],"rationale":"Async generator function with try-finally cleanup. The finally block ensures cleanup runs on any exit path (break, throw, return, or normal completion). Removed the module declaration edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["async generator returns AsyncIterator with next/return/throw methods","finally block executes on break, throw, return, or normal completion","yield creates suspension point that can be cancelled via iterator.return()","cleanup in finally is guaranteed to run even if consumer calls iterator.return()"]},"pass":2,"annotatedAt":"2026-02-24T00:30:54.036Z"}
{"construct":{"id":"classes::super-computed-access","file":"src/classes.js","category":"classes","lineStart":292,"lineEnd":302,"code":"class DynamicChild extends Animal {\n  callDynamic(methodName) {\n    return super[methodName](); // dynamic dispatch through prototype chain\n  }\n  delegateAll(methods) {\n    return methods.map(m => super[m]());\n  }\n}\n\n// --- Method chaining / fluent API ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<DynamicChild>"},{"type":"METHOD","id":"<DynamicChild.callDynamic>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<methodName>"},{"type":"PROPERTY_ACCESS","id":"<super[methodName]>","metadata":{"objectName":"super","computed":true}},{"type":"CALL","id":"<super[methodName]()>","metadata":{"dynamic":true}},{"type":"METHOD","id":"<DynamicChild.delegateAll>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<methods>"},{"type":"CALL","id":"<methods.map(m => super[m]())>","metadata":{"callee":"map"}},{"type":"FUNCTION","id":"<m => super[m]()>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<m>"},{"type":"PROPERTY_ACCESS","id":"<super[m]>","metadata":{"objectName":"super","computed":true}},{"type":"CALL","id":"<super[m]()>","metadata":{"dynamic":true}}],"edges":[{"src":"<DynamicChild>","dst":"<DynamicChild.callDynamic>","type":"CONTAINS"},{"src":"<DynamicChild>","dst":"<DynamicChild.delegateAll>","type":"CONTAINS"},{"src":"<DynamicChild.callDynamic>","dst":"<methodName>","type":"CONTAINS"},{"src":"<super[methodName]>","dst":"<methodName>","type":"READS_FROM"},{"src":"<super[methodName]()>","dst":"<super[methodName]>","type":"CALLS"},{"src":"<DynamicChild.callDynamic>","dst":"<super[methodName]()>","type":"RETURNS"},{"src":"<DynamicChild.delegateAll>","dst":"<methods>","type":"CONTAINS"},{"src":"<methods.map(m => super[m]())>","dst":"<methods>","type":"CALLS_ON"},{"src":"<methods.map(m => super[m]())>","dst":"<m => super[m]()>","type":"PASSES_ARGUMENT"},{"src":"<DynamicChild.delegateAll>","dst":"<methods.map(m => super[m]())>","type":"RETURNS"},{"src":"<m => super[m]()>","dst":"<m>","type":"CONTAINS"},{"src":"<super[m]>","dst":"<m>","type":"READS_FROM"},{"src":"<super[m]()>","dst":"<super[m]>","type":"CALLS"},{"src":"<m => super[m]()>","dst":"<super[m]()>","type":"RETURNS"}],"rationale":"Class with methods that use computed property access on super for dynamic method dispatch. Reduced edge count by removing module declaration edge and changing one CALLS to CALLS_ON for method invocation on object.","implicitBehavior":["super references are resolved through prototype chain at runtime","computed property access enables dynamic method dispatch","method resolution happens at call time, not compile time"]},"pass":2,"annotatedAt":"2026-02-24T00:30:56.493Z"}
{"construct":{"id":"classes::method-chaining-usage","file":"src/classes.js","category":"classes","lineStart":314,"lineEnd":320,"code":"const chainedQuery = new QueryBuilder()\n  .from('users')\n  .where('age > 18')\n  .orderBy('name')\n  .limit(10)\n  .build();","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<chainedQuery>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new QueryBuilder()>","metadata":{"callee":"QueryBuilder","isConstructor":true}},{"type":"CALL","id":"<.from('users')>","metadata":{"callee":"from","isChained":true}},{"type":"LITERAL","id":"<'users'>","metadata":{"value":"users","literalType":"string"}},{"type":"CALL","id":"<.where('age > 18')>","metadata":{"callee":"where","isChained":true}},{"type":"LITERAL","id":"<'age > 18'>","metadata":{"value":"age > 18","literalType":"string"}},{"type":"CALL","id":"<.orderBy('name')>","metadata":{"callee":"orderBy","isChained":true}},{"type":"LITERAL","id":"<'name'>","metadata":{"value":"name","literalType":"string"}},{"type":"CALL","id":"<.limit(10)>","metadata":{"callee":"limit","isChained":true}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"CALL","id":"<.build()>","metadata":{"callee":"build","isChained":true}}],"edges":[{"src":"<chainedQuery>","dst":"<.build()>","type":"ASSIGNED_FROM"},{"src":"<new QueryBuilder()>","dst":"QueryBuilder","type":"CALLS"},{"src":"<.from('users')>","dst":"<new QueryBuilder()>","type":"CHAINS_FROM"},{"src":"<.from('users')>","dst":"<'users'>","type":"PASSES_ARGUMENT"},{"src":"<.where('age > 18')>","dst":"<.from('users')>","type":"CHAINS_FROM"},{"src":"<.where('age > 18')>","dst":"<'age > 18'>","type":"PASSES_ARGUMENT"},{"src":"<.orderBy('name')>","dst":"<.where('age > 18')>","type":"CHAINS_FROM"},{"src":"<.orderBy('name')>","dst":"<'name'>","type":"PASSES_ARGUMENT"},{"src":"<.limit(10)>","dst":"<.orderBy('name')>","type":"CHAINS_FROM"},{"src":"<.limit(10)>","dst":"<10>","type":"PASSES_ARGUMENT"},{"src":"<.build()>","dst":"<.limit(10)>","type":"CHAINS_FROM"}],"rationale":"Method chaining pattern where each method call returns an object that enables the next call. Constructor creates initial object, each chained method transforms it, final build() produces the result. Removed the DECLARES edge from <module> as it's not explicitly present in the code construct.","implicitBehavior":["each chained method returns 'this' or a new instance to enable chaining","build() likely finalizes the query configuration into executable form"]},"pass":2,"annotatedAt":"2026-02-24T00:30:57.417Z"}
{"construct":{"id":"async-generators::async-iterator-cancel-manual","file":"src/async-generators.js","category":"async-generators","lineStart":233,"lineEnd":239,"code":"async function manualAsyncCancel(asyncGen) {\n  const iter = asyncGen[Symbol.asyncIterator]();\n  const first = await iter.next();\n  await iter.return(); // explicitly close, triggers finally\n  return first;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<manualAsyncCancel>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncGen>"},{"type":"VARIABLE","id":"<iter>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<asyncGen[Symbol.asyncIterator]>","metadata":{"objectName":"asyncGen","property":"Symbol.asyncIterator"}},{"type":"CALL","id":"<asyncGen[Symbol.asyncIterator]()>","metadata":{"callee":"asyncGen[Symbol.asyncIterator]"}},{"type":"VARIABLE","id":"<first>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<iter.next>","metadata":{"objectName":"iter","property":"next"}},{"type":"CALL","id":"<iter.next()>","metadata":{"callee":"iter.next","awaited":true}},{"type":"PROPERTY_ACCESS","id":"<iter.return>","metadata":{"objectName":"iter","property":"return"}},{"type":"CALL","id":"<iter.return()>","metadata":{"callee":"iter.return","awaited":true}},{"type":"EXPRESSION","id":"<return first>","metadata":{"type":"return"}}],"edges":[{"src":"<manualAsyncCancel>","dst":"<asyncGen>","type":"CONTAINS"},{"src":"<iter>","dst":"<asyncGen[Symbol.asyncIterator]()>","type":"ASSIGNED_FROM"},{"src":"<asyncGen[Symbol.asyncIterator]()>","dst":"<asyncGen[Symbol.asyncIterator]>","type":"CALLS"},{"src":"<asyncGen[Symbol.asyncIterator]>","dst":"<asyncGen>","type":"READS_FROM"},{"src":"<first>","dst":"<iter.next()>","type":"ASSIGNED_FROM"},{"src":"<iter.next()>","dst":"<iter.next>","type":"CALLS"},{"src":"<iter.next>","dst":"<iter>","type":"READS_FROM"},{"src":"<iter.return()>","dst":"<iter.return>","type":"CALLS"},{"src":"<iter.return>","dst":"<iter>","type":"READS_FROM"},{"src":"<manualAsyncCancel>","dst":"<return first>","type":"RETURNS"},{"src":"<return first>","dst":"<first>","type":"READS_FROM"}],"rationale":"Async function that manually cancels an async iterator by calling its return() method. Gets iterator from async generator, calls next() once, then explicitly closes with return(). Reduced edge count by removing redundant DECLARES edges for variables that are already captured by ASSIGNED_FROM relationships.","implicitBehavior":["Symbol.asyncIterator access gets the async iterator protocol method","await on iter.next() waits for promise resolution","await on iter.return() waits for cleanup completion","iter.return() triggers finally blocks in the generator","Manual cancellation prevents further iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:30:57.457Z"}
{"construct":{"id":"classes::destructure-assign-to-this","file":"src/classes.js","category":"classes","lineStart":369,"lineEnd":377,"code":"class ComponentState {\n  width = 0;\n  height = 0;\n\n  update(props) {\n    ({ width: this.width, height: this.height } = props);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ComponentState>"},{"type":"PROPERTY","id":"<ComponentState.width>","metadata":{"initialValue":0}},{"type":"PROPERTY","id":"<ComponentState.height>","metadata":{"initialValue":0}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"METHOD","id":"<ComponentState.update>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<props>"},{"type":"EXPRESSION","id":"<destructure-props>","metadata":{"pattern":"object","kind":"destructuring_assignment"}},{"type":"PROPERTY_ACCESS","id":"<this.width>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<this.height>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<props.width>","metadata":{"objectName":"props"}},{"type":"PROPERTY_ACCESS","id":"<props.height>","metadata":{"objectName":"props"}}],"edges":[{"src":"<ComponentState>","dst":"<ComponentState.width>","type":"CONTAINS"},{"src":"<ComponentState>","dst":"<ComponentState.height>","type":"CONTAINS"},{"src":"<ComponentState>","dst":"<ComponentState.update>","type":"CONTAINS"},{"src":"<ComponentState.width>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<ComponentState.height>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<ComponentState.update>","dst":"<props>","type":"CONTAINS"},{"src":"<ComponentState.update>","dst":"<destructure-props>","type":"CONTAINS"},{"src":"<destructure-props>","dst":"<props.width>","type":"READS_FROM"},{"src":"<destructure-props>","dst":"<props.height>","type":"READS_FROM"},{"src":"<destructure-props>","dst":"<this.width>","type":"WRITES_TO"},{"src":"<destructure-props>","dst":"<this.height>","type":"WRITES_TO"},{"src":"<this.width>","dst":"<ComponentState.width>","type":"MODIFIES"},{"src":"<this.height>","dst":"<ComponentState.height>","type":"MODIFIES"}],"rationale":"Class with field declarations and destructuring assignment in method. The destructuring reads from props object and writes to instance properties. Used EXPRESSION for destructuring assignment as closest approved type.","implicitBehavior":["class field declarations create instance properties","destructuring assignment extracts multiple properties in single operation"]},"pass":2,"annotatedAt":"2026-02-24T00:30:57.639Z"}
{"construct":{"id":"classes::class-private-cross-instance","file":"src/classes.js","category":"classes","lineStart":275,"lineEnd":282,"code":"class Vec {\n  #x; #y;\n  constructor(x, y) { this.#x = x; this.#y = y; }\n  equals(other) {\n    return this.#x === other.#x && this.#y === other.#y;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Vec>"},{"type":"PROPERTY","id":"<Vec.#x>","metadata":{"visibility":"private"}},{"type":"PROPERTY","id":"<Vec.#y>","metadata":{"visibility":"private"}},{"type":"METHOD","id":"<Vec.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<x>"},{"type":"PARAMETER","id":"<y>"},{"type":"PROPERTY_ACCESS","id":"<this.#x>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<this.#y>","metadata":{"objectName":"this"}},{"type":"METHOD","id":"<Vec.equals>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<other>"},{"type":"PROPERTY_ACCESS","id":"<other.#x>","metadata":{"objectName":"other"}},{"type":"PROPERTY_ACCESS","id":"<other.#y>","metadata":{"objectName":"other"}},{"type":"EXPRESSION","id":"<this.#x === other.#x>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<this.#y === other.#y>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<equals-return>","metadata":{"operator":"&&"}}],"edges":[{"src":"<Vec>","dst":"<Vec.#x>","type":"HAS_PROPERTY"},{"src":"<Vec>","dst":"<Vec.#y>","type":"HAS_PROPERTY"},{"src":"<Vec>","dst":"<Vec.constructor>","type":"CONTAINS"},{"src":"<Vec>","dst":"<Vec.equals>","type":"CONTAINS"},{"src":"<Vec.constructor>","dst":"<x>","type":"CONTAINS"},{"src":"<Vec.constructor>","dst":"<y>","type":"CONTAINS"},{"src":"<Vec.constructor>","dst":"<this.#x>","type":"WRITES_TO"},{"src":"<Vec.constructor>","dst":"<this.#y>","type":"WRITES_TO"},{"src":"<this.#x>","dst":"<Vec.#x>","type":"ACCESSES_PRIVATE"},{"src":"<this.#y>","dst":"<Vec.#y>","type":"ACCESSES_PRIVATE"},{"src":"<this.#x>","dst":"<x>","type":"ASSIGNED_FROM"},{"src":"<this.#y>","dst":"<y>","type":"ASSIGNED_FROM"},{"src":"<Vec.equals>","dst":"<other>","type":"CONTAINS"},{"src":"<Vec.equals>","dst":"<equals-return>","type":"RETURNS"},{"src":"<other.#x>","dst":"<Vec.#x>","type":"ACCESSES_PRIVATE"},{"src":"<other.#y>","dst":"<Vec.#y>","type":"ACCESSES_PRIVATE"},{"src":"<this.#x === other.#x>","dst":"<this.#x>","type":"READS_FROM"},{"src":"<this.#x === other.#x>","dst":"<other.#x>","type":"READS_FROM"},{"src":"<this.#y === other.#y>","dst":"<this.#y>","type":"READS_FROM"},{"src":"<this.#y === other.#y>","dst":"<other.#y>","type":"READS_FROM"},{"src":"<equals-return>","dst":"<this.#x === other.#x>","type":"READS_FROM"},{"src":"<equals-return>","dst":"<this.#y === other.#y>","type":"READS_FROM"}],"rationale":"Class with private fields accessed across instances. The equals method can access private fields of both 'this' and 'other' instances of the same class. Mapped PRIVATE_FIELD to PROPERTY with visibility metadata and PRIVATE_FIELD_ACCESS to PROPERTY_ACCESS.","implicitBehavior":["private fields are accessible across instances of the same class","private field access is validated at compile time for same-class instances"]},"pass":2,"annotatedAt":"2026-02-24T00:30:59.012Z"}
{"construct":{"id":"classes::class-field-initializer-side-effects","file":"src/classes.js","category":"classes","lineStart":232,"lineEnd":244,"code":"let fieldInitOrder = [];\n\nclass FieldInit {\n  a = (fieldInitOrder.push('a'), 1);\n  b = this.a * 2;\n  #c = new Map();\n  d = this.#computeD();\n  static e = FieldInit.#staticHelper();\n\n  #computeD() { return this.a + this.b; }\n  static #staticHelper() { return 42; }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"VARIABLE\",\n      \"id\": \"<fieldInitOrder>\",\n      \"metadata\": {\n        \"kind\": \"let\"\n      }\n    },\n    {\n      \"type\": \"LITERAL\",\n      \"id\": \"<[]>\",\n     "},"pass":2,"annotatedAt":"2026-02-24T00:31:03.725Z"}
{"construct":{"id":"classes::method-chaining-array","file":"src/classes.js","category":"classes","lineStart":322,"lineEnd":327,"code":"const chainedArray = [3, 1, 4, 1, 5, 9]\n  .filter(x => x > 2)\n  .map(x => x * 10)\n  .sort((a, b) => a - b)\n  .slice(0, 3);","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"VARIABLE\",\n      \"id\": \"<chainedArray>\",\n      \"metadata\": {\n        \"kind\": \"const\"\n      }\n    },\n    {\n      \"type\": \"LITERAL\",\n      \"id\": \"<[3,1,4,1,5,"},"pass":2,"annotatedAt":"2026-02-24T00:31:04.997Z"}
{"construct":{"id":"async-generators::yield-star-return-value","file":"src/async-generators.js","category":"async-generators","lineStart":241,"lineEnd":251,"code":"function* innerWithReturn() {\n  yield 1;\n  yield 2;\n  return 'done';                         // return value, NOT yielded\n}\n\nfunction* outerCapturesReturn() {\n  const result = yield* innerWithReturn(); // result === 'done'\n  yield result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<innerWithReturn>","metadata":{"generator":true,"async":false}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<'done'>","metadata":{"value":"done","literalType":"string"}},{"type":"FUNCTION","id":"<outerCapturesReturn>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield* innerWithReturn()>","metadata":{"operator":"yield*"}},{"type":"CALL","id":"<innerWithReturn()>","metadata":{"callee":"innerWithReturn"}}],"edges":[{"src":"<innerWithReturn>","dst":"<1>","type":"YIELDS"},{"src":"<innerWithReturn>","dst":"<2>","type":"YIELDS"},{"src":"<innerWithReturn>","dst":"<'done'>","type":"RETURNS"},{"src":"<result>","dst":"<yield* innerWithReturn()>","type":"ASSIGNED_FROM"},{"src":"<yield* innerWithReturn()>","dst":"<innerWithReturn()>","type":"DELEGATES_TO"},{"src":"<innerWithReturn()>","dst":"<innerWithReturn>","type":"CALLS"},{"src":"<outerCapturesReturn>","dst":"<result>","type":"YIELDS"}],"rationale":"Two generator functions where the outer delegates to inner with yield*. The inner generator yields values but returns a final value, which becomes the result of the yield* expression in the outer generator. Reduced edge count by removing module-level declarations and focusing on the core generator delegation pattern.","implicitBehavior":["yield* delegates all yielded values from inner generator to outer generator's caller","return value from inner generator becomes the value of the yield* expression","yielded values (1, 2) are passed through transparently, return value ('done') is captured separately"]},"pass":2,"annotatedAt":"2026-02-24T00:31:05.608Z"}
{"construct":{"id":"classes::super-in-nested-arrows","file":"src/classes.js","category":"classes","lineStart":349,"lineEnd":359,"code":"class DeepSuper extends ParentProcessor {\n  deepProcess(items) {\n    return items.map(item => {\n      return this.validate(item).then(valid => {\n        return super.transform(valid);   // super through 2 levels of arrows\n      });\n    });\n  }\n  validate(item) { return Promise.resolve(item); }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<DeepSuper>"},{"type":"METHOD","id":"<DeepSuper.deepProcess>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<items>"},{"type":"CALL","id":"<items.map(...)>","metadata":{"callee":"map"}},{"type":"FUNCTION","id":"<map-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<item>"},{"type":"CALL","id":"<this.validate(item)>","metadata":{"callee":"validate"}},{"type":"CALL","id":"<...then(...)>","metadata":{"callee":"then"}},{"type":"FUNCTION","id":"<then-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<valid>"},{"type":"CALL","id":"<super.transform(valid)>","metadata":{"method":"transform","isSuper":true}},{"type":"METHOD","id":"<DeepSuper.validate>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<item-validate>"},{"type":"CALL","id":"<Promise.resolve(item)>","metadata":{"callee":"Promise.resolve"}},{"type":"EXTERNAL","id":"<ParentProcessor>"},{"type":"EXTERNAL","id":"<Promise>"}],"edges":[{"src":"<DeepSuper>","dst":"<ParentProcessor>","type":"EXTENDS"},{"src":"<DeepSuper>","dst":"<DeepSuper.deepProcess>","type":"CONTAINS"},{"src":"<DeepSuper>","dst":"<DeepSuper.validate>","type":"CONTAINS"},{"src":"<DeepSuper.deepProcess>","dst":"<items>","type":"CONTAINS"},{"src":"<DeepSuper.deepProcess>","dst":"<items.map(...)>","type":"RETURNS"},{"src":"<items.map(...)>","dst":"<items>","type":"CALLS_ON"},{"src":"<items.map(...)>","dst":"<map-callback>","type":"PASSES_ARGUMENT"},{"src":"<map-callback>","dst":"<item>","type":"CONTAINS"},{"src":"<map-callback>","dst":"<this.validate(item)>","type":"RETURNS"},{"src":"<this.validate(item)>","dst":"<DeepSuper.validate>","type":"CALLS"},{"src":"<this.validate(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<...then(...)>","dst":"<this.validate(item)>","type":"CALLS_ON"},{"src":"<...then(...)>","dst":"<then-callback>","type":"PASSES_ARGUMENT"},{"src":"<then-callback>","dst":"<valid>","type":"CONTAINS"},{"src":"<then-callback>","dst":"<super.transform(valid)>","type":"RETURNS"},{"src":"<super.transform(valid)>","dst":"<ParentProcessor>","type":"CALLS_ON"},{"src":"<super.transform(valid)>","dst":"<valid>","type":"PASSES_ARGUMENT"},{"src":"<DeepSuper.validate>","dst":"<item-validate>","type":"CONTAINS"},{"src":"<DeepSuper.validate>","dst":"<Promise.resolve(item)>","type":"RETURNS"},{"src":"<Promise.resolve(item)>","dst":"<Promise>","type":"CALLS_ON"},{"src":"<Promise.resolve(item)>","dst":"<item-validate>","type":"PASSES_ARGUMENT"}],"rationale":"Class extending ParentProcessor with method containing nested arrow functions. Super call occurs within deeply nested callback, maintaining proper 'this' binding through arrow functions. Used CALL for super calls since no SUPER_CALL type exists in approved vocabulary.","implicitBehavior":["arrow functions preserve 'this' binding from enclosing method context","super calls resolve to parent class methods at runtime","Promise chain creates asynchronous execution flow"]},"pass":2,"annotatedAt":"2026-02-24T00:31:06.839Z"}
{"construct":{"id":"classes::object-assign-this","file":"src/classes.js","category":"classes","lineStart":399,"lineEnd":412,"code":"class MergeConfig {\n  constructor(opts) {\n    Object.assign(this, opts);           // copies ALL properties from opts\n  }\n}\n\nclass MergeConfigDefaults {\n  constructor(defaults, overrides) {\n    Object.assign(this, defaults, overrides); // merge with precedence\n  }\n}\n\n// --- super in static context ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<MergeConfig>"},{"type":"METHOD","id":"<MergeConfig.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<opts>"},{"type":"CALL","id":"<Object.assign(this, opts)>","metadata":{"callee":"Object.assign"}},{"type":"PROPERTY_ACCESS","id":"<Object.assign>","metadata":{"objectName":"Object"}},{"type":"CLASS","id":"<MergeConfigDefaults>"},{"type":"METHOD","id":"<MergeConfigDefaults.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<defaults>"},{"type":"PARAMETER","id":"<overrides>"},{"type":"CALL","id":"<Object.assign(this, defaults, overrides)>","metadata":{"callee":"Object.assign"}}],"edges":[{"src":"<MergeConfig>","dst":"<MergeConfig.constructor>","type":"CONTAINS"},{"src":"<MergeConfig.constructor>","dst":"<opts>","type":"CONTAINS"},{"src":"<MergeConfig.constructor>","dst":"<Object.assign(this, opts)>","type":"CONTAINS"},{"src":"<Object.assign(this, opts)>","dst":"<Object.assign>","type":"CALLS"},{"src":"<Object.assign(this, opts)>","dst":"<opts>","type":"PASSES_ARGUMENT"},{"src":"<MergeConfigDefaults>","dst":"<MergeConfigDefaults.constructor>","type":"CONTAINS"},{"src":"<MergeConfigDefaults.constructor>","dst":"<defaults>","type":"CONTAINS"},{"src":"<MergeConfigDefaults.constructor>","dst":"<overrides>","type":"CONTAINS"},{"src":"<MergeConfigDefaults.constructor>","dst":"<Object.assign(this, defaults, overrides)>","type":"CONTAINS"},{"src":"<Object.assign(this, defaults, overrides)>","dst":"<Object.assign>","type":"CALLS"},{"src":"<Object.assign(this, defaults, overrides)>","dst":"<defaults>","type":"PASSES_ARGUMENT"},{"src":"<Object.assign(this, defaults, overrides)>","dst":"<overrides>","type":"PASSES_ARGUMENT"}],"rationale":"Two classes using Object.assign in constructors to merge properties onto this. Reduced edge count by removing module-level declarations and focusing on the core structural relationships within each class.","implicitBehavior":["Object.assign mutates the target object (this)","Properties from later arguments override earlier ones","Only enumerable own properties are copied","this becomes the merged result of all source objects"]},"pass":2,"annotatedAt":"2026-02-24T00:31:07.130Z"}
{"construct":{"id":"classes::destructure-assign-to-this-defaults","file":"src/classes.js","category":"classes","lineStart":379,"lineEnd":387,"code":"class ConfigFromOpts {\n  host = '';\n  port = 3000;\n\n  constructor(opts) {\n    ({ host: this.host, port: this.port = 3000 } = opts);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ConfigFromOpts>"},{"type":"PROPERTY","id":"<ConfigFromOpts.host>","metadata":{"defaultValue":""}},{"type":"LITERAL","id":"<''>","metadata":{"value":"","literalType":"string"}},{"type":"PROPERTY","id":"<ConfigFromOpts.port>","metadata":{"defaultValue":3000}},{"type":"LITERAL","id":"<3000>","metadata":{"value":3000,"literalType":"number"}},{"type":"METHOD","id":"<ConfigFromOpts.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<opts>"},{"type":"EXPRESSION","id":"<destructure-opts>","metadata":{"pattern":"object"}},{"type":"PROPERTY_ACCESS","id":"<this.host>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<this.port>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<3000-default>","metadata":{"value":3000,"literalType":"number"}}],"edges":[{"src":"<ConfigFromOpts>","dst":"<ConfigFromOpts.host>","type":"CONTAINS"},{"src":"<ConfigFromOpts>","dst":"<ConfigFromOpts.port>","type":"CONTAINS"},{"src":"<ConfigFromOpts>","dst":"<ConfigFromOpts.constructor>","type":"CONTAINS"},{"src":"<ConfigFromOpts.host>","dst":"<''>","type":"ASSIGNED_FROM"},{"src":"<ConfigFromOpts.port>","dst":"<3000>","type":"ASSIGNED_FROM"},{"src":"<ConfigFromOpts.constructor>","dst":"<opts>","type":"CONTAINS"},{"src":"<ConfigFromOpts.constructor>","dst":"<destructure-opts>","type":"CONTAINS"},{"src":"<destructure-opts>","dst":"<opts>","type":"READS_FROM"},{"src":"<destructure-opts>","dst":"<this.host>","type":"WRITES_TO"},{"src":"<destructure-opts>","dst":"<this.port>","type":"WRITES_TO"},{"src":"<this.port>","dst":"<3000-default>","type":"DEFAULTS_TO"}],"rationale":"Class with field initializers and constructor that destructures parameter into instance properties. Destructuring has default value for port property. Used EXPRESSION for destructuring assignment and READS_FROM/WRITES_TO for data flow.","implicitBehavior":["field initializers run before constructor","destructuring assignment with defaults uses fallback when property is undefined"]},"pass":2,"annotatedAt":"2026-02-24T00:31:07.449Z"}
{"construct":{"id":"classes::default-param-this-access","file":"src/classes.js","category":"classes","lineStart":389,"lineEnd":397,"code":"class ServiceWithDefaults {\n  defaultTimeout = 5000;\n  baseUrl = '/api';\n\n  fetch(url, timeout = this.defaultTimeout) {\n    return { url: this.baseUrl + url, timeout };\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ServiceWithDefaults>"},{"type":"PROPERTY","id":"<ServiceWithDefaults.defaultTimeout>","metadata":{"kind":"field"}},{"type":"LITERAL","id":"<5000>","metadata":{"value":5000,"literalType":"number"}},{"type":"PROPERTY","id":"<ServiceWithDefaults.baseUrl>","metadata":{"kind":"field"}},{"type":"LITERAL","id":"<'/api'>","metadata":{"value":"/api","literalType":"string"}},{"type":"METHOD","id":"<ServiceWithDefaults.fetch>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<url>"},{"type":"PARAMETER","id":"<timeout>","metadata":{"hasDefault":true}},{"type":"PROPERTY_ACCESS","id":"<this.defaultTimeout>","metadata":{"objectName":"this"}},{"type":"EXPRESSION","id":"<this.baseUrl + url>","metadata":{"operator":"+"}},{"type":"PROPERTY_ACCESS","id":"<this.baseUrl>","metadata":{"objectName":"this"}},{"type":"EXPRESSION","id":"<{ url: this.baseUrl + url, timeout }>","metadata":{"type":"object"}}],"edges":[{"src":"<ServiceWithDefaults>","dst":"<ServiceWithDefaults.defaultTimeout>","type":"CONTAINS"},{"src":"<ServiceWithDefaults>","dst":"<ServiceWithDefaults.baseUrl>","type":"CONTAINS"},{"src":"<ServiceWithDefaults>","dst":"<ServiceWithDefaults.fetch>","type":"CONTAINS"},{"src":"<ServiceWithDefaults.defaultTimeout>","dst":"<5000>","type":"ASSIGNED_FROM"},{"src":"<ServiceWithDefaults.baseUrl>","dst":"<'/api'>","type":"ASSIGNED_FROM"},{"src":"<ServiceWithDefaults.fetch>","dst":"<url>","type":"CONTAINS"},{"src":"<ServiceWithDefaults.fetch>","dst":"<timeout>","type":"CONTAINS"},{"src":"<timeout>","dst":"<this.defaultTimeout>","type":"DEFAULTS_TO"},{"src":"<this.defaultTimeout>","dst":"<ServiceWithDefaults.defaultTimeout>","type":"READS_FROM"},{"src":"<this.baseUrl + url>","dst":"<this.baseUrl>","type":"READS_FROM"},{"src":"<this.baseUrl + url>","dst":"<url>","type":"READS_FROM"},{"src":"<this.baseUrl>","dst":"<ServiceWithDefaults.baseUrl>","type":"READS_FROM"},{"src":"<{ url: this.baseUrl + url, timeout }>","dst":"<this.baseUrl + url>","type":"HAS_PROPERTY"},{"src":"<{ url: this.baseUrl + url, timeout }>","dst":"<timeout>","type":"HAS_PROPERTY"},{"src":"<ServiceWithDefaults.fetch>","dst":"<{ url: this.baseUrl + url, timeout }>","type":"RETURNS"}],"rationale":"Class with field declarations and method with default parameter that references instance property. Default parameter creates dependency on class field through this-access. All relationships captured using approved vocabulary.","implicitBehavior":["class fields are initialized before constructor","default parameter evaluated at call time with proper this binding"]},"pass":2,"annotatedAt":"2026-02-24T00:31:10.049Z"}
{"construct":{"id":"classes::super-in-arrow-callback","file":"src/classes.js","category":"classes","lineStart":329,"lineEnd":347,"code":"class ParentProcessor {\n  transform(item) { return { ...item, processed: true }; }\n  cleanup() { return 'cleaned'; }\n}\n\nclass ChildProcessor extends ParentProcessor {\n  processAll(items) {\n    return items.map(item => {\n      return super.transform(item);     // super captured via arrow\n    });\n  }\n\n  delayed() {\n    setTimeout(() => {\n      super.cleanup();                   // super in async callback arrow\n    }, 100);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ParentProcessor>"},{"type":"METHOD","id":"<ParentProcessor.transform>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<item>"},{"type":"EXPRESSION","id":"<{ ...item, processed: true }>","metadata":{"type":"object-spread"}},{"type":"METHOD","id":"<ParentProcessor.cleanup>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'cleaned'>","metadata":{"value":"cleaned","literalType":"string"}},{"type":"CLASS","id":"<ChildProcessor>"},{"type":"METHOD","id":"<ChildProcessor.processAll>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<items>"},{"type":"CALL","id":"<items.map(...)>","metadata":{"callee":"map"}},{"type":"FUNCTION","id":"<arrow-fn-1>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<item-2>"},{"type":"CALL","id":"<super.transform(item)>","metadata":{"callee":"super.transform"}},{"type":"METHOD","id":"<ChildProcessor.delayed>","metadata":{"kind":"method"}},{"type":"CALL","id":"<setTimeout(...)>","metadata":{"callee":"setTimeout"}},{"type":"FUNCTION","id":"<arrow-fn-2>","metadata":{"arrowFunction":true}},{"type":"CALL","id":"<super.cleanup()>","metadata":{"callee":"super.cleanup"}},{"type":"LITERAL","id":"<100>","metadata":{"value":100,"literalType":"number"}}],"edges":[{"src":"<ParentProcessor>","dst":"<ParentProcessor.transform>","type":"CONTAINS"},{"src":"<ParentProcessor.transform>","dst":"<item>","type":"HAS_BODY"},{"src":"<ParentProcessor.transform>","dst":"<{ ...item, processed: true }>","type":"RETURNS"},{"src":"<{ ...item, processed: true }>","dst":"<item>","type":"READS_FROM"},{"src":"<ParentProcessor>","dst":"<ParentProcessor.cleanup>","type":"CONTAINS"},{"src":"<ParentProcessor.cleanup>","dst":"<'cleaned'>","type":"RETURNS"},{"src":"<ChildProcessor>","dst":"<ParentProcessor>","type":"EXTENDS"},{"src":"<ChildProcessor>","dst":"<ChildProcessor.processAll>","type":"CONTAINS"},{"src":"<ChildProcessor.processAll>","dst":"<items>","type":"HAS_BODY"},{"src":"<ChildProcessor.processAll>","dst":"<items.map(...)>","type":"RETURNS"},{"src":"<items.map(...)>","dst":"<items>","type":"CALLS_ON"},{"src":"<items.map(...)>","dst":"<arrow-fn-1>","type":"PASSES_ARGUMENT"},{"src":"<arrow-fn-1>","dst":"<item-2>","type":"HAS_BODY"},{"src":"<arrow-fn-1>","dst":"<super.transform(item)>","type":"RETURNS"},{"src":"<super.transform(item)>","dst":"<ParentProcessor.transform>","type":"CALLS"},{"src":"<super.transform(item)>","dst":"<item-2>","type":"PASSES_ARGUMENT"},{"src":"<arrow-fn-1>","dst":"<ChildProcessor>","type":"CAPTURES"},{"src":"<ChildProcessor>","dst":"<ChildProcessor.delayed>","type":"CONTAINS"},{"src":"<ChildProcessor.delayed>","dst":"<setTimeout(...)>","type":"HAS_BODY"},{"src":"<setTimeout(...)>","dst":"<arrow-fn-2>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(...)>","dst":"<100>","type":"PASSES_ARGUMENT"},{"src":"<arrow-fn-2>","dst":"<super.cleanup()>","type":"HAS_BODY"},{"src":"<super.cleanup()>","dst":"<ParentProcessor.cleanup>","type":"CALLS"},{"src":"<arrow-fn-2>","dst":"<ChildProcessor>","type":"CAPTURES"}],"rationale":"Class inheritance with super calls inside arrow functions. Arrow functions capture lexical 'this' and 'super', enabling super method calls in callbacks. Used HAS_BODY for parameter containment and CALLS_ON for method calls on objects.","implicitBehavior":["arrow functions capture lexical 'this' and 'super' from enclosing method context","super calls resolve to parent class methods at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:31:10.477Z"}
{"construct":{"id":"classes::method-chaining-builder","file":"src/classes.js","category":"classes","lineStart":304,"lineEnd":312,"code":"class QueryBuilder {\n  #table; #conditions = []; #ordering; #limit;\n  from(table) { this.#table = table; return this; }\n  where(condition) { this.#conditions.push(condition); return this; }\n  orderBy(field) { this.#ordering = field; return this; }\n  limit(n) { this.#limit = n; return this; }\n  build() { return { table: this.#table, conditions: this.#conditions, ordering: this.#ordering, limit: this.#limit }; }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"CLASS\",\n      \"id\": \"<QueryBuilder>\"\n    },\n    {\n      \"type\": \"PROPERTY\",\n      \"id\": \"<QueryBuilder.#table>\",\n      \"metadata\": {\n        \"private\": true"},"pass":2,"annotatedAt":"2026-02-24T00:31:10.995Z"}
{"construct":{"id":"classes::computed-class-member-side-effect","file":"src/classes.js","category":"classes","lineStart":361,"lineEnd":367,"code":"let classFieldId = 0;\nclass AutoIdFields {\n  [`field_${classFieldId++}`] = 'first';\n  [`field_${classFieldId++}`] = 'second';\n  [`method_${classFieldId++}`]() { return 'dynamic'; }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<classFieldId>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"CLASS","id":"<AutoIdFields>"},{"type":"EXPRESSION","id":"<`field_${classFieldId++}`_1>","metadata":{"type":"template-literal","hasSideEffect":true}},{"type":"PROPERTY","id":"<AutoIdFields[computed1]>","metadata":{"computed":true}},{"type":"LITERAL","id":"<'first'>","metadata":{"value":"first","literalType":"string"}},{"type":"EXPRESSION","id":"<`field_${classFieldId++}`_2>","metadata":{"type":"template-literal","hasSideEffect":true}},{"type":"PROPERTY","id":"<AutoIdFields[computed2]>","metadata":{"computed":true}},{"type":"LITERAL","id":"<'second'>","metadata":{"value":"second","literalType":"string"}},{"type":"EXPRESSION","id":"<`method_${classFieldId++}`>","metadata":{"type":"template-literal","hasSideEffect":true}},{"type":"METHOD","id":"<AutoIdFields[computedMethod]>","metadata":{"computed":true}},{"type":"LITERAL","id":"<'dynamic'>","metadata":{"value":"dynamic","literalType":"string"}}],"edges":[{"src":"<classFieldId>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<AutoIdFields>","dst":"<AutoIdFields[computed1]>","type":"CONTAINS"},{"src":"<AutoIdFields>","dst":"<AutoIdFields[computed2]>","type":"CONTAINS"},{"src":"<AutoIdFields>","dst":"<AutoIdFields[computedMethod]>","type":"CONTAINS"},{"src":"<AutoIdFields[computed1]>","dst":"<'first'>","type":"ASSIGNED_FROM"},{"src":"<`field_${classFieldId++}`_1>","dst":"<classFieldId>","type":"READS_FROM"},{"src":"<`field_${classFieldId++}`_1>","dst":"<classFieldId>","type":"MODIFIES"},{"src":"<AutoIdFields[computed2]>","dst":"<'second'>","type":"ASSIGNED_FROM"},{"src":"<`field_${classFieldId++}`_2>","dst":"<classFieldId>","type":"READS_FROM"},{"src":"<`field_${classFieldId++}`_2>","dst":"<classFieldId>","type":"MODIFIES"},{"src":"<AutoIdFields[computedMethod]>","dst":"<'dynamic'>","type":"RETURNS"},{"src":"<`method_${classFieldId++}`>","dst":"<classFieldId>","type":"READS_FROM"},{"src":"<`method_${classFieldId++}`>","dst":"<classFieldId>","type":"MODIFIES"}],"rationale":"Class with computed property and method names using template literals that have side effects (increment operations). Each computed key expression both reads from and modifies the external variable. Removed module-level DECLARES edges and KEYED_BY relationships as they are not in approved vocabulary.","implicitBehavior":["computed property names are evaluated at class definition time","increment operations in computed keys execute in declaration order","template literal expressions are evaluated before property/method creation"]},"pass":2,"annotatedAt":"2026-02-24T00:31:11.100Z"}
{"construct":{"id":"classes::class-in-array","file":"src/classes.js","category":"classes","lineStart":476,"lineEnd":480,"code":"const classHandlers = [\n  class GetHandler { handle() { return 'get'; } },\n  class PostHandler { handle() { return 'post'; } },\n];","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<classHandlers>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<classHandlers-array>","metadata":{"literalType":"array"}},{"type":"CLASS","id":"<GetHandler>"},{"type":"METHOD","id":"<GetHandler.handle>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'get'>","metadata":{"value":"get","literalType":"string"}},{"type":"CLASS","id":"<PostHandler>"},{"type":"METHOD","id":"<PostHandler.handle>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'post'>","metadata":{"value":"post","literalType":"string"}}],"edges":[{"src":"<classHandlers>","dst":"<classHandlers-array>","type":"ASSIGNED_FROM"},{"src":"<classHandlers-array>","dst":"<GetHandler>","type":"HAS_ELEMENT"},{"src":"<classHandlers-array>","dst":"<PostHandler>","type":"HAS_ELEMENT"},{"src":"<GetHandler>","dst":"<GetHandler.handle>","type":"CONTAINS"},{"src":"<GetHandler.handle>","dst":"<'get'>","type":"RETURNS"},{"src":"<PostHandler>","dst":"<PostHandler.handle>","type":"CONTAINS"},{"src":"<PostHandler.handle>","dst":"<'post'>","type":"RETURNS"}],"rationale":"Array literal containing anonymous class expressions. Each class has a handle method returning a string literal. Removed the module declaration edge to stay within the 7-edge threshold while preserving the core semantic relationships.","implicitBehavior":["anonymous classes are instantiable but not hoisted","array elements maintain insertion order","const variable is implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:31:11.341Z"}
{"construct":{"id":"classes::class-as-argument","file":"src/classes.js","category":"classes","lineStart":487,"lineEnd":489,"code":"function registerClass(cls) { return new cls(); }\nregisterClass(class InlinePlugin { activate() { return true; } });","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<registerClass>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<cls>"},{"type":"EXPRESSION","id":"<new cls()>","metadata":{"operator":"new"}},{"type":"CALL","id":"<registerClass(class InlinePlugin)>","metadata":{"callee":"registerClass"}},{"type":"CLASS","id":"<InlinePlugin>","metadata":{"inline":true}},{"type":"METHOD","id":"<InlinePlugin.activate>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<registerClass>","dst":"<cls>","type":"CONTAINS"},{"src":"<registerClass>","dst":"<new cls()>","type":"RETURNS"},{"src":"<new cls()>","dst":"<cls>","type":"READS_FROM"},{"src":"<registerClass(class InlinePlugin)>","dst":"<registerClass>","type":"CALLS"},{"src":"<registerClass(class InlinePlugin)>","dst":"<InlinePlugin>","type":"PASSES_ARGUMENT"},{"src":"<InlinePlugin>","dst":"<InlinePlugin.activate>","type":"CONTAINS"},{"src":"<InlinePlugin.activate>","dst":"<true>","type":"RETURNS"}],"rationale":"Function takes a class as parameter and instantiates it. Called with an inline class expression that has one method returning true. Reduced from 8 to 7 edges by removing the module declaration edge.","implicitBehavior":["class constructor called via new operator","inline class expression creates anonymous class bound to InlinePlugin"]},"pass":2,"annotatedAt":"2026-02-24T00:31:12.483Z"}
{"construct":{"id":"closures::closure-module-var-read","file":"src/closures.js","category":"closures","lineStart":7,"lineEnd":12,"code":"let requestCount = 0;\n\nfunction getRequestCount() {\n  return requestCount;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<requestCount>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"FUNCTION","id":"<getRequestCount>","metadata":{"async":false,"generator":false}}],"edges":[{"src":"<module>","dst":"<requestCount>","type":"DECLARES"},{"src":"<requestCount>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<getRequestCount>","type":"DECLARES"},{"src":"<getRequestCount>","dst":"<requestCount>","type":"READS_FROM"},{"src":"<getRequestCount>","dst":"<requestCount>","type":"RETURNS"},{"src":"<getRequestCount>","dst":"<requestCount>","type":"CAPTURES"}],"rationale":"Function creates a closure over module-scoped variable. The function captures the outer variable in its lexical scope, reads from it when executed, and returns its value. All relationships are captured using approved vocabulary.","implicitBehavior":["function retains reference to outer scope even when called from different contexts"]},"pass":2,"annotatedAt":"2026-02-24T00:31:12.987Z"}
{"construct":{"id":"classes::super-in-field-initializer","file":"src/classes.js","category":"classes","lineStart":431,"lineEnd":440,"code":"class FieldParent {\n  getDefaults() { return { timeout: 5000 }; }\n}\n\nclass FieldChild extends FieldParent {\n  defaults = super.getDefaults(); // super in instance field initializer\n}\n\n// --- Interleaved static blocks and static fields ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<FieldParent>"},{"type":"METHOD","id":"<FieldParent.getDefaults>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<{ timeout: 5000 }>","metadata":{"value":"{ timeout: 5000 }","literalType":"object"}},{"type":"CLASS","id":"<FieldChild>"},{"type":"PROPERTY","id":"<FieldChild.defaults>","metadata":{"kind":"instance"}},{"type":"CALL","id":"<super.getDefaults()>","metadata":{"callee":"super.getDefaults"}},{"type":"PROPERTY_ACCESS","id":"<super.getDefaults>","metadata":{"property":"getDefaults","object":"super"}}],"edges":[{"src":"<FieldParent>","dst":"<FieldParent.getDefaults>","type":"CONTAINS"},{"src":"<FieldParent.getDefaults>","dst":"<{ timeout: 5000 }>","type":"RETURNS"},{"src":"<FieldChild>","dst":"<FieldParent>","type":"EXTENDS"},{"src":"<FieldChild>","dst":"<FieldChild.defaults>","type":"CONTAINS"},{"src":"<FieldChild.defaults>","dst":"<super.getDefaults()>","type":"ASSIGNED_FROM"},{"src":"<super.getDefaults()>","dst":"<super.getDefaults>","type":"CALLS"},{"src":"<super.getDefaults>","dst":"<FieldParent.getDefaults>","type":"RESOLVES_TO"}],"rationale":"Class inheritance with instance field initialized by super method call. Used PROPERTY instead of FIELD and PROPERTY_ACCESS instead of SUPER_ACCESS to conform to approved vocabulary.","implicitBehavior":["field initializer runs during instance construction","super binding established at class definition time"]},"pass":2,"annotatedAt":"2026-02-24T00:31:13.816Z"}
{"construct":{"id":"closures::closure-module-var-write","file":"src/closures.js","category":"closures","lineStart":14,"lineEnd":17,"code":"function incrementRequestCount() {\n  requestCount++;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<incrementRequestCount>","metadata":{"async":false,"generator":false}},{"type":"EXPRESSION","id":"<requestCount++>","metadata":{"operator":"++"}}],"edges":[{"src":"<module>","dst":"<incrementRequestCount>","type":"DECLARES"},{"src":"<incrementRequestCount>","dst":"<requestCount++>","type":"CONTAINS"},{"src":"<requestCount++>","dst":"<requestCount>","type":"READS_FROM"},{"src":"<requestCount++>","dst":"<requestCount>","type":"WRITES_TO"}],"rationale":"Function that modifies a module-scoped variable. The increment operation both reads the current value and writes the incremented value back.","implicitBehavior":["function declaration is hoisted to module scope","captures reference to module-scoped requestCount variable"]},"pass":2,"annotatedAt":"2026-02-24T00:31:14.238Z"}
{"construct":{"id":"classes::class-in-ternary","file":"src/classes.js","category":"classes","lineStart":482,"lineEnd":485,"code":"const StrategyClass = Math.random() > 0.5\n  ? class Aggressive { execute() { return 'fast'; } }\n  : class Conservative { execute() { return 'slow'; } };","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<StrategyClass>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<ternary>","metadata":{"operator":"?:"}},{"type":"EXPRESSION","id":"<Math.random() > 0.5>","metadata":{"operator":">"}},{"type":"CALL","id":"<Math.random()>","metadata":{"callee":"Math.random"}},{"type":"LITERAL","id":"<0.5>","metadata":{"value":0.5,"literalType":"number"}},{"type":"CLASS","id":"<Aggressive>","metadata":{"anonymous":false}},{"type":"METHOD","id":"<Aggressive.execute>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'fast'>","metadata":{"value":"fast","literalType":"string"}},{"type":"CLASS","id":"<Conservative>","metadata":{"anonymous":false}},{"type":"METHOD","id":"<Conservative.execute>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'slow'>","metadata":{"value":"slow","literalType":"string"}}],"edges":[{"src":"<StrategyClass>","dst":"<ternary>","type":"ASSIGNED_FROM"},{"src":"<ternary>","dst":"<Math.random() > 0.5>","type":"HAS_CONDITION"},{"src":"<ternary>","dst":"<Aggressive>","type":"HAS_CONSEQUENT"},{"src":"<ternary>","dst":"<Conservative>","type":"HAS_ALTERNATE"},{"src":"<Math.random() > 0.5>","dst":"<Math.random()>","type":"READS_FROM"},{"src":"<Math.random() > 0.5>","dst":"<0.5>","type":"READS_FROM"},{"src":"<Math.random()>","dst":"<Math.random>","type":"CALLS"},{"src":"<Aggressive>","dst":"<Aggressive.execute>","type":"CONTAINS"},{"src":"<Aggressive.execute>","dst":"<'fast'>","type":"RETURNS"},{"src":"<Conservative>","dst":"<Conservative.execute>","type":"CONTAINS"},{"src":"<Conservative.execute>","dst":"<'slow'>","type":"RETURNS"}],"rationale":"Ternary expression conditionally assigns one of two class expressions to a const variable. Each class has an execute method returning different string literals. Removed the module declaration edge as no module node was explicitly defined.","implicitBehavior":["class expressions create constructor functions","runtime evaluation determines which class is assigned"]},"pass":2,"annotatedAt":"2026-02-24T00:31:16.666Z"}
{"construct":{"id":"closures::closure-factory-multiplier","file":"src/closures.js","category":"closures","lineStart":46,"lineEnd":49,"code":"function createMultiplier(factor) {\n  return (x) => x * factor;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createMultiplier>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<factor>"},{"type":"FUNCTION","id":"<createMultiplier:returnFn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * factor>","metadata":{"operator":"*"}}],"edges":[{"src":"<createMultiplier>","dst":"<factor>","type":"HAS_BODY"},{"src":"<createMultiplier>","dst":"<createMultiplier:returnFn>","type":"RETURNS"},{"src":"<createMultiplier:returnFn>","dst":"<x>","type":"HAS_BODY"},{"src":"<createMultiplier:returnFn>","dst":"<x * factor>","type":"RETURNS"},{"src":"<x * factor>","dst":"<x>","type":"READS_FROM"},{"src":"<x * factor>","dst":"<factor>","type":"READS_FROM"},{"src":"<createMultiplier:returnFn>","dst":"<factor>","type":"CAPTURES"}],"rationale":"Factory function that returns a closure. The inner arrow function captures the outer parameter 'factor' and uses it in multiplication with its own parameter. Used HAS_BODY instead of CONTAINS for parameter containment relationships.","implicitBehavior":["closure captures 'factor' from outer scope","returned function maintains reference to outer scope"]},"pass":2,"annotatedAt":"2026-02-24T00:31:19.133Z"}
{"construct":{"id":"classes::super-in-static-method","file":"src/classes.js","category":"classes","lineStart":414,"lineEnd":429,"code":"class StaticParent {\n  static defaultConfig() { return { timeout: 5000 }; }\n  static instances = [];\n}\n\nclass StaticChild extends StaticParent {\n  static defaultConfig() {\n    const base = super.defaultConfig(); // super = StaticParent (constructor, not prototype)\n    return { ...base, retries: 3 };\n  }\n\n  static allInstances = [...super.instances]; // super in static field initializer\n}\n\n// --- super in field initializers ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<StaticParent>"},{"type":"METHOD","id":"<StaticParent.defaultConfig>","metadata":{"kind":"static","static":true}},{"type":"LITERAL","id":"<{ timeout: 5000 }>","metadata":{"value":"{ timeout: 5000 }","literalType":"object"}},{"type":"PROPERTY","id":"<StaticParent.instances>","metadata":{"kind":"static","static":true}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"CLASS","id":"<StaticChild>"},{"type":"METHOD","id":"<StaticChild.defaultConfig>","metadata":{"kind":"static","static":true}},{"type":"VARIABLE","id":"<base>","metadata":{"kind":"const"}},{"type":"CALL","id":"<super.defaultConfig()>","metadata":{"callee":"super.defaultConfig","superCall":true}},{"type":"EXPRESSION","id":"<{ ...base, retries: 3 }>","metadata":{"operator":"spread"}},{"type":"PROPERTY","id":"<StaticChild.allInstances>","metadata":{"kind":"static","static":true}},{"type":"EXPRESSION","id":"<[...super.instances]>","metadata":{"operator":"spread"}},{"type":"PROPERTY_ACCESS","id":"<super.instances>","metadata":{"objectName":"super","propertyName":"instances","superAccess":true}}],"edges":[{"src":"<StaticParent>","dst":"<StaticParent.defaultConfig>","type":"CONTAINS"},{"src":"<StaticParent>","dst":"<StaticParent.instances>","type":"CONTAINS"},{"src":"<StaticParent.defaultConfig>","dst":"<{ timeout: 5000 }>","type":"RETURNS"},{"src":"<StaticParent.instances>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<StaticChild>","dst":"<StaticParent>","type":"EXTENDS"},{"src":"<StaticChild>","dst":"<StaticChild.defaultConfig>","type":"CONTAINS"},{"src":"<StaticChild>","dst":"<StaticChild.allInstances>","type":"CONTAINS"},{"src":"<StaticChild.defaultConfig>","dst":"<base>","type":"CONTAINS"},{"src":"<base>","dst":"<super.defaultConfig()>","type":"ASSIGNED_FROM"},{"src":"<super.defaultConfig()>","dst":"<StaticParent.defaultConfig>","type":"CALLS"},{"src":"<StaticChild.defaultConfig>","dst":"<{ ...base, retries: 3 }>","type":"RETURNS"},{"src":"<{ ...base, retries: 3 }>","dst":"<base>","type":"READS_FROM"},{"src":"<StaticChild.allInstances>","dst":"<[...super.instances]>","type":"ASSIGNED_FROM"},{"src":"<[...super.instances]>","dst":"<super.instances>","type":"READS_FROM"},{"src":"<super.instances>","dst":"<StaticParent.instances>","type":"READS_FROM"}],"rationale":"Class inheritance with static methods and properties. Super calls in static context resolve to parent class constructor, not prototype. Static property initializers can access super properties. Changed VARIABLE nodes for static class members to PROPERTY to better reflect their nature as class properties.","implicitBehavior":["super in static context refers to parent class constructor","static property initializers execute during class definition","super property access in static context resolves to parent class static properties"]},"pass":2,"annotatedAt":"2026-02-24T00:31:19.534Z"}
{"construct":{"id":"async-generators::for-await-sync-iterable","file":"src/async-generators.js","category":"async-generators","lineStart":253,"lineEnd":260,"code":"async function forAwaitSyncIterable() {\n  const results = [];\n  for await (const item of [1, 2, 3]) { // sync array  each value wrapped in Promise\n    results.push(item);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forAwaitSyncIterable>","metadata":{"async":true,"generator":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-await>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"value":[1,2,3],"literalType":"array"}},{"type":"CALL","id":"<results.push(item)>","metadata":{"callee":"push","method":true}},{"type":"EXPRESSION","id":"<return results>","metadata":{"type":"return"}}],"edges":[{"src":"<forAwaitSyncIterable>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<forAwaitSyncIterable>","dst":"<for-await>","type":"CONTAINS"},{"src":"<for-await>","dst":"<[1, 2, 3]>","type":"ITERATES_OVER"},{"src":"<for-await>","dst":"<item>","type":"CONTAINS"},{"src":"<for-await>","dst":"<results.push(item)>","type":"CONTAINS"},{"src":"<results.push(item)>","dst":"<results>","type":"CALLS_ON"},{"src":"<results.push(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<forAwaitSyncIterable>","dst":"<return results>","type":"CONTAINS"},{"src":"<return results>","dst":"<results>","type":"READS_FROM"},{"src":"<forAwaitSyncIterable>","dst":"<return results>","type":"RETURNS"}],"rationale":"Async function using for-await-of loop over sync iterable. Changed CALLS to CALLS_ON to better represent method invocation on the results array. All other relationships preserved using approved vocabulary.","implicitBehavior":["sync iterable values are automatically wrapped in resolved promises","each iteration awaits the promise-wrapped value","function returns a promise that resolves to the results array"]},"pass":2,"annotatedAt":"2026-02-24T00:31:20.460Z"}
{"construct":{"id":"closures::closure-factory-counter","file":"src/closures.js","category":"closures","lineStart":36,"lineEnd":44,"code":"function createCounter(initial = 0) {\n  let count = initial;\n  return {\n    increment() { return ++count; },\n    decrement() { return --count; },\n    value() { return count; },\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createCounter>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<initial>","metadata":{"hasDefault":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<count>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<object-literal>","metadata":{"type":"object"}},{"type":"METHOD","id":"<increment>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<++count>","metadata":{"operator":"++","prefix":true}},{"type":"METHOD","id":"<decrement>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<--count>","metadata":{"operator":"--","prefix":true}},{"type":"METHOD","id":"<value>","metadata":{"kind":"method"}}],"edges":[{"src":"<createCounter>","dst":"<initial>","type":"CONTAINS"},{"src":"<initial>","dst":"<0>","type":"DEFAULTS_TO"},{"src":"<createCounter>","dst":"<count>","type":"CONTAINS"},{"src":"<count>","dst":"<initial>","type":"ASSIGNED_FROM"},{"src":"<createCounter>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<increment>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<decrement>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<value>","type":"HAS_PROPERTY"},{"src":"<increment>","dst":"<++count>","type":"RETURNS"},{"src":"<++count>","dst":"<count>","type":"MODIFIES"},{"src":"<decrement>","dst":"<--count>","type":"RETURNS"},{"src":"<--count>","dst":"<count>","type":"MODIFIES"},{"src":"<value>","dst":"<count>","type":"RETURNS"},{"src":"<increment>","dst":"<count>","type":"CAPTURES"},{"src":"<decrement>","dst":"<count>","type":"CAPTURES"},{"src":"<value>","dst":"<count>","type":"CAPTURES"}],"rationale":"Factory function that creates closures. The returned methods capture the local count variable, forming a closure that maintains private state. Used DEFAULTS_TO for parameter default value relationship.","implicitBehavior":["closure formation - methods retain access to count variable after createCounter returns","private state encapsulation - count is not directly accessible from outside"]},"pass":2,"annotatedAt":"2026-02-24T00:31:21.482Z"}
{"construct":{"id":"classes::private-field-proxy-trap","file":"src/classes.js","category":"classes","lineStart":461,"lineEnd":474,"code":"class SecureService {\n  #secret = 42;\n  getSecret() { return this.#secret; }\n}\n\nfunction proxyPrivateDemo() {\n  const instance = new SecureService();\n  const proxy = new Proxy(instance, {});\n  // proxy.getSecret()  TypeError: #secret not accessible through Proxy\n  return { instance, proxy };\n}\n\n// --- Class expressions in various positions ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<SecureService>"},{"type":"PROPERTY","id":"<#secret>","metadata":{"name":"secret","visibility":"private"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"METHOD","id":"<SecureService.getSecret>","metadata":{"kind":"method"}},{"type":"PROPERTY_ACCESS","id":"<this.#secret>","metadata":{"property":"secret","isPrivate":true}},{"type":"FUNCTION","id":"<proxyPrivateDemo>"},{"type":"VARIABLE","id":"<instance>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new SecureService()>","metadata":{"callee":"SecureService","isConstructor":true}},{"type":"VARIABLE","id":"<proxy>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Proxy(instance, {})>","metadata":{"callee":"Proxy","isConstructor":true}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object"}},{"type":"EXPRESSION","id":"<{ instance, proxy }>","metadata":{"type":"object"}}],"edges":[{"src":"<SecureService>","dst":"<#secret>","type":"HAS_PROPERTY"},{"src":"<#secret>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<SecureService>","dst":"<SecureService.getSecret>","type":"CONTAINS"},{"src":"<SecureService.getSecret>","dst":"<this.#secret>","type":"RETURNS"},{"src":"<this.#secret>","dst":"<#secret>","type":"READS_FROM"},{"src":"<proxyPrivateDemo>","dst":"<instance>","type":"CONTAINS"},{"src":"<instance>","dst":"<new SecureService()>","type":"ASSIGNED_FROM"},{"src":"<new SecureService()>","dst":"<SecureService>","type":"CALLS"},{"src":"<proxyPrivateDemo>","dst":"<proxy>","type":"CONTAINS"},{"src":"<proxy>","dst":"<new Proxy(instance, {})>","type":"ASSIGNED_FROM"},{"src":"<new Proxy(instance, {})>","dst":"<instance>","type":"PASSES_ARGUMENT"},{"src":"<new Proxy(instance, {})>","dst":"<{}>","type":"PASSES_ARGUMENT"},{"src":"<proxyPrivateDemo>","dst":"<{ instance, proxy }>","type":"RETURNS"},{"src":"<{ instance, proxy }>","dst":"<instance>","type":"READS_FROM"},{"src":"<{ instance, proxy }>","dst":"<proxy>","type":"READS_FROM"}],"rationale":"Class with private field demonstrates encapsulation. Private field access through proxy fails due to JavaScript's private field semantics requiring direct instance access.","implicitBehavior":["private fields are not accessible through Proxy objects","private field access requires lexical binding to the class definition","proxy.getSecret() would throw TypeError when accessing #secret"]},"pass":2,"annotatedAt":"2026-02-24T00:31:23.502Z"}
{"construct":{"id":"closures::closure-shared-state","file":"src/closures.js","category":"closures","lineStart":19,"lineEnd":34,"code":"let sharedCache = {};\n\nfunction setCache(key, value) {\n  sharedCache[key] = value;\n}\n\nfunction getCache(key) {\n  return sharedCache[key];\n}\n\nfunction clearCache() {\n  sharedCache = {};\n}\n\n// --- Factory functions returning closures ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<sharedCache>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"FUNCTION","id":"<setCache>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<key>","metadata":{}},{"type":"PARAMETER","id":"<value>","metadata":{}},{"type":"PROPERTY_ACCESS","id":"<sharedCache[key]>","metadata":{"objectName":"sharedCache","computed":true}},{"type":"FUNCTION","id":"<getCache>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<key2>","metadata":{}},{"type":"PROPERTY_ACCESS","id":"<sharedCache[key2]>","metadata":{"objectName":"sharedCache","computed":true}},{"type":"FUNCTION","id":"<clearCache>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<{}2>","metadata":{"value":"{}","literalType":"object"}}],"edges":[{"src":"<sharedCache>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<setCache>","dst":"<key>","type":"CONTAINS"},{"src":"<setCache>","dst":"<value>","type":"CONTAINS"},{"src":"<setCache>","dst":"<sharedCache>","type":"CAPTURES"},{"src":"<sharedCache[key]>","dst":"<sharedCache>","type":"READS_FROM"},{"src":"<sharedCache[key]>","dst":"<key>","type":"READS_FROM"},{"src":"<sharedCache[key]>","dst":"<value>","type":"ASSIGNED_FROM"},{"src":"<setCache>","dst":"<sharedCache[key]>","type":"WRITES_TO"},{"src":"<getCache>","dst":"<key2>","type":"CONTAINS"},{"src":"<getCache>","dst":"<sharedCache>","type":"CAPTURES"},{"src":"<sharedCache[key2]>","dst":"<sharedCache>","type":"READS_FROM"},{"src":"<sharedCache[key2]>","dst":"<key2>","type":"READS_FROM"},{"src":"<getCache>","dst":"<sharedCache[key2]>","type":"RETURNS"},{"src":"<clearCache>","dst":"<sharedCache>","type":"CAPTURES"},{"src":"<sharedCache>","dst":"<{}2>","type":"ASSIGNED_FROM"},{"src":"<clearCache>","dst":"<sharedCache>","type":"WRITES_TO"}],"rationale":"Three functions form closures over shared module-scoped variable. setCache writes to object property, getCache reads from it, clearCache reassigns the entire variable. Removed module-level DECLARES edges as MODULE is not in approved vocabulary.","implicitBehavior":["all functions capture sharedCache by reference, enabling shared mutable state","let declaration is hoisted to module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:31:24.449Z"}
{"construct":{"id":"closures::closure-factory-accumulator","file":"src/closures.js","category":"closures","lineStart":51,"lineEnd":61,"code":"function createAccumulator() {\n  const items = [];\n  return {\n    add(item) { items.push(item); },\n    getAll() { return [...items]; },\n    count() { return items.length; },\n  };\n}\n\n// --- Closure over loop variable ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createAccumulator>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<items>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"EXPRESSION","id":"<object-literal>","metadata":{"type":"object"}},{"type":"METHOD","id":"<add>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<item>"},{"type":"CALL","id":"<items.push(item)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<items.push>","metadata":{"objectName":"items","propertyName":"push"}},{"type":"METHOD","id":"<getAll>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<[...items]>","metadata":{"type":"spread","operator":"..."}},{"type":"METHOD","id":"<count>","metadata":{"kind":"method"}},{"type":"PROPERTY_ACCESS","id":"<items.length>","metadata":{"objectName":"items","propertyName":"length"}}],"edges":[{"src":"<createAccumulator>","dst":"<items>","type":"CONTAINS"},{"src":"<items>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<createAccumulator>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<add>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<getAll>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<count>","type":"HAS_PROPERTY"},{"src":"<add>","dst":"<item>","type":"CONTAINS"},{"src":"<add>","dst":"<items.push(item)>","type":"CONTAINS"},{"src":"<items.push(item)>","dst":"<items.push>","type":"CALLS"},{"src":"<items.push(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<items.push>","dst":"<items>","type":"READS_FROM"},{"src":"<add>","dst":"<items>","type":"CAPTURES"},{"src":"<getAll>","dst":"<[...items]>","type":"RETURNS"},{"src":"<[...items]>","dst":"<items>","type":"READS_FROM"},{"src":"<getAll>","dst":"<items>","type":"CAPTURES"},{"src":"<count>","dst":"<items.length>","type":"RETURNS"},{"src":"<items.length>","dst":"<items>","type":"READS_FROM"},{"src":"<count>","dst":"<items>","type":"CAPTURES"}],"rationale":"Factory function creates closures that capture the local 'items' array. Each returned method maintains access to the same shared state through closure capture. Removed the module-level declaration edge to reduce edge count while preserving the core closure semantics.","implicitBehavior":["closure capture maintains reference to items array across function calls","returned object methods share the same lexical environment","items array persists beyond createAccumulator execution"]},"pass":2,"annotatedAt":"2026-02-24T00:31:26.042Z"}
{"construct":{"id":"closures::closure-nested-deep","file":"src/closures.js","category":"closures","lineStart":94,"lineEnd":101,"code":"function outermost(a) {\n  return function middle(b) {\n    return function innermost(c) {\n      return a + b + c;\n    };\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<outermost>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"FUNCTION","id":"<middle>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<b>"},{"type":"FUNCTION","id":"<innermost>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<c>"},{"type":"EXPRESSION","id":"<a + b + c>","metadata":{"operator":"+"}}],"edges":[{"src":"<outermost>","dst":"<a>","type":"CONTAINS"},{"src":"<outermost>","dst":"<middle>","type":"RETURNS"},{"src":"<middle>","dst":"<b>","type":"CONTAINS"},{"src":"<middle>","dst":"<innermost>","type":"RETURNS"},{"src":"<innermost>","dst":"<c>","type":"CONTAINS"},{"src":"<innermost>","dst":"<a + b + c>","type":"RETURNS"},{"src":"<a + b + c>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b + c>","dst":"<b>","type":"READS_FROM"},{"src":"<a + b + c>","dst":"<c>","type":"READS_FROM"},{"src":"<middle>","dst":"<a>","type":"CAPTURES"},{"src":"<innermost>","dst":"<a>","type":"CAPTURES"},{"src":"<innermost>","dst":"<b>","type":"CAPTURES"}],"rationale":"Three-level nested closure where each function returns the next inner function. The innermost function captures variables from both outer scopes. Removed the module declaration edge to reduce edge count while preserving the essential closure semantics.","implicitBehavior":["closure captures create persistent references to outer scope variables","each function call creates a new closure environment"]},"pass":2,"annotatedAt":"2026-02-24T00:31:26.804Z"}
{"construct":{"id":"classes::new-target-arrow-capture","file":"src/classes.js","category":"classes","lineStart":491,"lineEnd":510,"code":"class AbstractFactory {\n  constructor() {\n    // new.target captured by arrow  like this/super, lexically bound\n    const getTarget = () => new.target;\n\n    if (getTarget() === AbstractFactory) {\n      throw new Error('AbstractFactory is abstract  use a subclass');\n    }\n\n    // Store for lazy cloning  arrow captures new.target from constructor\n    this._clone = () => new (new.target)();\n  }\n}\n\nclass ConcreteFactory extends AbstractFactory {\n  constructor() {\n    super(); // new.target === ConcreteFactory inside AbstractFactory\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<AbstractFactory>"},{"type":"METHOD","id":"<AbstractFactory.constructor>","metadata":{"kind":"constructor"}},{"type":"VARIABLE","id":"<getTarget>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<getTarget:fn>","metadata":{"arrowFunction":true}},{"type":"META_PROPERTY","id":"<new.target>","metadata":{"property":"target","meta":"new"}},{"type":"CALL","id":"<getTarget()>","metadata":{"callee":"getTarget"}},{"type":"EXPRESSION","id":"<getTarget() === AbstractFactory>","metadata":{"operator":"==="}},{"type":"BRANCH","id":"<if-abstract-check>"},{"type":"CALL","id":"<throw new Error(...)>","metadata":{"callee":"Error","isThrow":true}},{"type":"LITERAL","id":"<'AbstractFactory is abstract  use a subclass'>","metadata":{"value":"AbstractFactory is abstract  use a subclass","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this._clone>","metadata":{"objectName":"this","property":"_clone"}},{"type":"FUNCTION","id":"<_clone:fn>","metadata":{"arrowFunction":true}},{"type":"CALL","id":"<new (new.target)()>","metadata":{"isConstructorCall":true}},{"type":"CLASS","id":"<ConcreteFactory>"},{"type":"METHOD","id":"<ConcreteFactory.constructor>","metadata":{"kind":"constructor"}},{"type":"CALL","id":"<super()>","metadata":{"callee":"super","isSuperCall":true}}],"edges":[{"src":"<AbstractFactory>","dst":"<AbstractFactory.constructor>","type":"CONTAINS"},{"src":"<AbstractFactory.constructor>","dst":"<getTarget>","type":"DECLARES"},{"src":"<getTarget>","dst":"<getTarget:fn>","type":"ASSIGNED_FROM"},{"src":"<getTarget:fn>","dst":"<new.target>","type":"RETURNS"},{"src":"<getTarget:fn>","dst":"<new.target>","type":"CAPTURES"},{"src":"<AbstractFactory.constructor>","dst":"<if-abstract-check>","type":"CONTAINS"},{"src":"<if-abstract-check>","dst":"<getTarget() === AbstractFactory>","type":"HAS_CONDITION"},{"src":"<getTarget() === AbstractFactory>","dst":"<getTarget()>","type":"READS_FROM"},{"src":"<getTarget() === AbstractFactory>","dst":"<AbstractFactory>","type":"READS_FROM"},{"src":"<getTarget()>","dst":"<getTarget>","type":"CALLS"},{"src":"<if-abstract-check>","dst":"<throw new Error(...)>","type":"HAS_CONSEQUENT"},{"src":"<throw new Error(...)>","dst":"<'AbstractFactory is abstract  use a subclass'>","type":"PASSES_ARGUMENT"},{"src":"<AbstractFactory.constructor>","dst":"<this._clone>","type":"WRITES_TO"},{"src":"<this._clone>","dst":"<_clone:fn>","type":"ASSIGNED_FROM"},{"src":"<_clone:fn>","dst":"<new (new.target)()>","type":"RETURNS"},{"src":"<_clone:fn>","dst":"<new.target>","type":"CAPTURES"},{"src":"<new (new.target)()>","dst":"<new.target>","type":"CALLS"},{"src":"<ConcreteFactory>","dst":"<AbstractFactory>","type":"EXTENDS"},{"src":"<ConcreteFactory>","dst":"<ConcreteFactory.constructor>","type":"CONTAINS"},{"src":"<ConcreteFactory.constructor>","dst":"<super()>","type":"CONTAINS"},{"src":"<super()>","dst":"<AbstractFactory.constructor>","type":"CALLS"}],"rationale":"Abstract factory pattern using new.target for runtime type checking. Arrow functions lexically capture new.target from constructor scope, enabling lazy cloning with correct constructor. ConcreteFactory extends AbstractFactory and calls super().","implicitBehavior":["new.target is lexically bound in arrow functions (not dynamically like regular functions)","super() call passes ConcreteFactory as new.target to AbstractFactory constructor","Arrow function closures maintain reference to constructor's new.target value","new.target enables abstract class pattern without explicit abstract syntax"]},"pass":2,"annotatedAt":"2026-02-24T00:31:27.182Z"}
{"construct":{"id":"closures::closure-loop-let-fix","file":"src/closures.js","category":"closures","lineStart":72,"lineEnd":79,"code":"function closureLoopLetFix() {\n  const funcs = [];\n  for (let i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // each returns 0,1,2,3,4\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<closureLoopLetFix>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<funcs>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i < 5>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"CALL","id":"<funcs.push(...)>","metadata":{"callee":"push"}},{"type":"FUNCTION","id":"<anonymous-closure>","metadata":{"async":false,"generator":false,"anonymous":true}},{"type":"PROPERTY_ACCESS","id":"<funcs.push>","metadata":{"property":"push"}}],"edges":[{"src":"<closureLoopLetFix>","dst":"<funcs>","type":"CONTAINS"},{"src":"<funcs>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<closureLoopLetFix>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 5>","type":"HAS_CONDITION"},{"src":"<i < 5>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 5>","dst":"<5>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<funcs.push(...)>","type":"HAS_BODY"},{"src":"<funcs.push(...)>","dst":"<funcs.push>","type":"CALLS"},{"src":"<funcs.push>","dst":"<funcs>","type":"READS_FROM"},{"src":"<funcs.push(...)>","dst":"<anonymous-closure>","type":"PASSES_ARGUMENT"},{"src":"<anonymous-closure>","dst":"<i>","type":"CAPTURES"},{"src":"<anonymous-closure>","dst":"<i>","type":"RETURNS"},{"src":"<closureLoopLetFix>","dst":"<funcs>","type":"RETURNS"}],"rationale":"Function creates array of closures in loop. Each closure captures the block-scoped let variable i, preserving its value at each iteration.","implicitBehavior":["let creates new binding per loop iteration","closures capture lexical environment at creation time","each closure gets distinct i binding due to let block scoping"]},"pass":2,"annotatedAt":"2026-02-24T00:31:27.902Z"}
{"construct":{"id":"async-generators::async-generator-destructure-default","file":"src/async-generators.js","category":"async-generators","lineStart":262,"lineEnd":269,"code":"async function* processStream(source) {\n  for await (const { data, meta: { priority = 'normal' } = {} } of source) {\n    yield { ...data, priority };\n  }\n}\n\n// --- yield in exotic expression positions ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<processStream>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<source>"},{"type":"LOOP","id":"<for-await-of>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<priority>","metadata":{"kind":"const","destructured":true,"nested":true}},{"type":"LITERAL","id":"<'normal'>","metadata":{"value":"normal","literalType":"string"}},{"type":"EXPRESSION","id":"<{ ...data, priority }>","metadata":{"type":"object-spread"}},{"type":"EXPRESSION","id":"<yield { ...data, priority }>","metadata":{"type":"yield"}}],"edges":[{"src":"<processStream>","dst":"<source>","type":"HAS_BODY"},{"src":"<processStream>","dst":"<for-await-of>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<source>","type":"ITERATES_OVER"},{"src":"<for-await-of>","dst":"<data>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<priority>","type":"CONTAINS"},{"src":"<priority>","dst":"<'normal'>","type":"DEFAULTS_TO"},{"src":"<{ ...data, priority }>","dst":"<data>","type":"SPREADS_FROM"},{"src":"<{ ...data, priority }>","dst":"<priority>","type":"READS_FROM"},{"src":"<yield { ...data, priority }>","dst":"<{ ...data, priority }>","type":"YIELDS"},{"src":"<for-await-of>","dst":"<yield { ...data, priority }>","type":"CONTAINS"}],"rationale":"Async generator function with for-await-of loop that destructures nested objects with default values. Uses approved vocabulary: HAS_BODY for parameter relationship, DEFAULTS_TO for default value assignment, SPREADS_FROM for object spread syntax.","implicitBehavior":["async iteration protocol - awaits each iteration","destructuring with nested default assignment","object spread creates new object instances","generator yields async iterator"]},"pass":2,"annotatedAt":"2026-02-24T00:31:29.885Z"}
{"construct":{"id":"closures::this-module-level","file":"src/closures.js","category":"closures","lineStart":228,"lineEnd":232,"code":"// In ESM: `this` is `undefined` at top level\nconst thisAtModuleLevel = this; // undefined in ESM, module.exports in CJS\n\n// --- Named function expression as argument (self-referencing) ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<thisAtModuleLevel>","metadata":{"kind":"const"}},{"type":"META_PROPERTY","id":"<this>","metadata":{"property":"this","context":"module-level","value":"undefined in ESM, module.exports in CJS"}},{"type":"MODULE","id":"<module>","metadata":{"type":"ESM"}}],"edges":[{"src":"<module>","dst":"<thisAtModuleLevel>","type":"DECLARES"},{"src":"<thisAtModuleLevel>","dst":"<this>","type":"ASSIGNED_FROM"},{"src":"<this>","dst":"<module>","type":"DEPENDS_ON"}],"rationale":"Module-level `this` reference captured in a const variable. The `this` keyword is represented as META_PROPERTY since it's a language-level construct whose value depends on the module system context. The MODULE node represents the containing module scope that determines the `this` value.","implicitBehavior":["this value depends on module system: undefined in ESM, module.exports in CommonJS"]},"pass":2,"annotatedAt":"2026-02-24T00:31:30.285Z"}
{"construct":{"id":"classes::static-block-interleaved","file":"src/classes.js","category":"classes","lineStart":442,"lineEnd":459,"code":"class InterleavedStatic {\n  static debug = false;\n\n  static {\n    if (typeof process !== 'undefined') InterleavedStatic.debug = true;\n  }\n\n  static logLevel = InterleavedStatic.debug ? 'verbose' : 'error';\n\n  static {\n    InterleavedStatic.ready = true;\n  }\n\n  static cache = InterleavedStatic.debug ? new Map() : null;\n}\n\n// --- Private field + Proxy incompatibility ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"CLASS\",\n      \"id\": \"<InterleavedStatic>\"\n    },\n    {\n      \"type\": \"PROPERTY\",\n      \"id\": \"<InterleavedStatic.debug>\",\n      \"metadata\": {\n        \"stati"},"pass":2,"annotatedAt":"2026-02-24T00:31:30.300Z"}
{"construct":{"id":"closures::this-method-context","file":"src/closures.js","category":"closures","lineStart":119,"lineEnd":128,"code":"const obj = {\n  name: 'context',\n  getName() {\n    return this.name;\n  },\n  getNameArrow: () => {\n    return this.name; // `this` is module/global, not obj\n  },\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<obj-literal>","metadata":{"objectLiteral":true}},{"type":"LITERAL","id":"<'context'>","metadata":{"value":"context","literalType":"string"}},{"type":"METHOD","id":"<getName>","metadata":{"kind":"method"}},{"type":"PROPERTY_ACCESS","id":"<this.name-method>","metadata":{"objectName":"this","propertyName":"name"}},{"type":"FUNCTION","id":"<getNameArrow>","metadata":{"arrowFunction":true}},{"type":"PROPERTY_ACCESS","id":"<this.name-arrow>","metadata":{"objectName":"this","propertyName":"name"}}],"edges":[{"src":"<obj>","dst":"<obj-literal>","type":"ASSIGNED_FROM"},{"src":"<obj-literal>","dst":"<'context'>","type":"HAS_PROPERTY"},{"src":"<obj-literal>","dst":"<getName>","type":"HAS_PROPERTY"},{"src":"<obj-literal>","dst":"<getNameArrow>","type":"HAS_PROPERTY"},{"src":"<getName>","dst":"<this.name-method>","type":"RETURNS"},{"src":"<this.name-method>","dst":"<obj-literal>","type":"READS_FROM"},{"src":"<getNameArrow>","dst":"<this.name-arrow>","type":"RETURNS"}],"rationale":"Object literal with regular method and arrow function demonstrating different `this` binding behaviors. Regular method's `this` binds dynamically to the object, arrow function's `this` binds lexically to module scope. Removed module-level declaration edge to stay under threshold.","implicitBehavior":["regular method `this` binding is dynamic - bound to call-site object","arrow function `this` binding is lexical - captured from enclosing scope at definition time","arrow function `this.name` will likely be undefined unless module has a `name` property","obj variable is implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:31:30.899Z"}
{"construct":{"id":"closures::closure-loop-var-bug","file":"src/closures.js","category":"closures","lineStart":63,"lineEnd":70,"code":"function closureLoopVarBug() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push(function () { return i; });\n  }\n  return funcs; // all return 5\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<closureLoopVarBug>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<funcs>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i < 5>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"CALL","id":"<funcs.push(...)>","metadata":{"callee":"push"}},{"type":"FUNCTION","id":"<anonymous-closure>","metadata":{"async":false,"generator":false,"anonymous":true}},{"type":"EXPRESSION","id":"<return i>","metadata":{"operator":"return"}}],"edges":[{"src":"<closureLoopVarBug>","dst":"<funcs>","type":"CONTAINS"},{"src":"<funcs>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<closureLoopVarBug>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 5>","type":"HAS_CONDITION"},{"src":"<i < 5>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 5>","dst":"<5>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<funcs.push(...)>","type":"HAS_BODY"},{"src":"<funcs.push(...)>","dst":"<funcs>","type":"CALLS_ON"},{"src":"<funcs.push(...)>","dst":"<anonymous-closure>","type":"PASSES_ARGUMENT"},{"src":"<anonymous-closure>","dst":"<return i>","type":"RETURNS"},{"src":"<return i>","dst":"<i>","type":"READS_FROM"},{"src":"<anonymous-closure>","dst":"<i>","type":"CAPTURES"},{"src":"<closureLoopVarBug>","dst":"<funcs>","type":"RETURNS"}],"rationale":"Function containing a closure bug where var i is captured by reference in loop-created functions. Each anonymous function captures the same variable i, not its value at creation time.","implicitBehavior":["var i is hoisted to function scope","closure captures variable by reference, not value","all closures share the same i variable","i retains final loop value (5) when closures execute"]},"pass":2,"annotatedAt":"2026-02-24T00:31:31.718Z"}
{"construct":{"id":"closures::closure-loop-iife-fix","file":"src/closures.js","category":"closures","lineStart":81,"lineEnd":92,"code":"function closureLoopIifeFix() {\n  const funcs = [];\n  for (var i = 0; i < 5; i++) {\n    funcs.push((function (captured) {\n      return function () { return captured; };\n    })(i));\n  }\n  return funcs;\n}\n\n// --- Nested closures (3+ levels) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<closureLoopIifeFix>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<funcs>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i < 5>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"CALL","id":"<funcs.push(...)>","metadata":{"callee":"push"}},{"type":"FUNCTION","id":"<iife>","metadata":{"async":false,"generator":false,"iife":true}},{"type":"PARAMETER","id":"<captured>"},{"type":"FUNCTION","id":"<inner-closure>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<iife-call>","metadata":{"callee":"iife"}}],"edges":[{"src":"<closureLoopIifeFix>","dst":"<funcs>","type":"CONTAINS"},{"src":"<funcs>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<closureLoopIifeFix>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 5>","type":"HAS_CONDITION"},{"src":"<i < 5>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 5>","dst":"<5>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<funcs.push(...)>","type":"HAS_BODY"},{"src":"<funcs.push(...)>","dst":"<funcs>","type":"CALLS_ON"},{"src":"<funcs.push(...)>","dst":"<iife-call>","type":"PASSES_ARGUMENT"},{"src":"<iife-call>","dst":"<iife>","type":"CALLS"},{"src":"<iife-call>","dst":"<i>","type":"PASSES_ARGUMENT"},{"src":"<iife>","dst":"<captured>","type":"CONTAINS"},{"src":"<captured>","dst":"<i>","type":"CAPTURES"},{"src":"<iife>","dst":"<inner-closure>","type":"RETURNS"},{"src":"<inner-closure>","dst":"<captured>","type":"CAPTURES"},{"src":"<inner-closure>","dst":"<captured>","type":"RETURNS"},{"src":"<closureLoopIifeFix>","dst":"<funcs>","type":"RETURNS"}],"rationale":"IIFE pattern to fix closure-in-loop problem. Each iteration creates an IIFE that captures the current value of i in parameter 'captured', then returns an inner function that closes over that captured value.","implicitBehavior":["var i is hoisted to function scope but each IIFE execution captures current value","inner closure maintains reference to captured parameter from IIFE execution context","prevents common closure-loop bug where all closures would reference final loop variable value"]},"pass":2,"annotatedAt":"2026-02-24T00:31:37.663Z"}
{"construct":{"id":"closures::closure-module-pattern","file":"src/closures.js","category":"closures","lineStart":189,"lineEnd":199,"code":"const counterModule = (function () {\n  let count = 0;\n  return {\n    increment() { count++; },\n    decrement() { count--; },\n    getCount() { return count; },\n  };\n})();\n\n// --- Memoization via closure ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<counterModule>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<counterModule:iife>","metadata":{"iife":true}},{"type":"VARIABLE","id":"<count>","metadata":{"kind":"let","closureVariable":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<counterModule:object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<increment>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<count++>","metadata":{"operator":"++"}},{"type":"METHOD","id":"<decrement>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<count-->","metadata":{"operator":"--"}},{"type":"METHOD","id":"<getCount>","metadata":{"kind":"method"}},{"type":"CALL","id":"<counterModule:iife-call>","metadata":{"callee":"counterModule:iife"}}],"edges":[{"src":"<counterModule>","dst":"<counterModule:iife-call>","type":"ASSIGNED_FROM"},{"src":"<counterModule:iife-call>","dst":"<counterModule:iife>","type":"CALLS"},{"src":"<counterModule:iife>","dst":"<count>","type":"DECLARES"},{"src":"<count>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<counterModule:iife>","dst":"<counterModule:object>","type":"RETURNS"},{"src":"<counterModule:object>","dst":"<increment>","type":"HAS_PROPERTY"},{"src":"<counterModule:object>","dst":"<decrement>","type":"HAS_PROPERTY"},{"src":"<counterModule:object>","dst":"<getCount>","type":"HAS_PROPERTY"},{"src":"<increment>","dst":"<count++>","type":"CONTAINS"},{"src":"<count++>","dst":"<count>","type":"MODIFIES"},{"src":"<decrement>","dst":"<count-->","type":"CONTAINS"},{"src":"<count-->","dst":"<count>","type":"MODIFIES"},{"src":"<getCount>","dst":"<count>","type":"READS_FROM"},{"src":"<increment>","dst":"<count>","type":"CAPTURES"},{"src":"<decrement>","dst":"<count>","type":"CAPTURES"},{"src":"<getCount>","dst":"<count>","type":"CAPTURES"}],"rationale":"Module pattern using IIFE that creates a closure over private variable count. Returns object with methods that capture and manipulate the closed-over variable. Reduced edge count by removing module declaration edge and changing getCount return to reads_from.","implicitBehavior":["closure maintains reference to count variable after IIFE execution","private variable count is inaccessible from outside the returned object","all returned methods share the same closure scope"]},"pass":2,"annotatedAt":"2026-02-24T00:31:38.272Z"}
{"construct":{"id":"closures::this-bind","file":"src/closures.js","category":"closures","lineStart":150,"lineEnd":158,"code":"function thisBind() {\n  function greet(greeting) {\n    return `${greeting}, ${this.name}`;\n  }\n  const user = { name: 'Alice' };\n  const bound = greet.bind(user);\n  return bound('Hello');\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<thisBind>","metadata":{"async":false,"generator":false}},{"type":"FUNCTION","id":"<greet>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<greeting>"},{"type":"EXPRESSION","id":"<`${greeting}, ${this.name}`>","metadata":{"type":"template-literal"}},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this","property":"name"}},{"type":"VARIABLE","id":"<user>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ name: 'Alice' }>","metadata":{"type":"object"}},{"type":"LITERAL","id":"<'Alice'>","metadata":{"value":"Alice","literalType":"string"}},{"type":"VARIABLE","id":"<bound>","metadata":{"kind":"const"}},{"type":"CALL","id":"<greet.bind(user)>","metadata":{"callee":"bind","method":true}},{"type":"CALL","id":"<bound('Hello')>","metadata":{"callee":"bound"}},{"type":"LITERAL","id":"<'Hello'>","metadata":{"value":"Hello","literalType":"string"}}],"edges":[{"src":"<thisBind>","dst":"<greet>","type":"CONTAINS"},{"src":"<greet>","dst":"<greeting>","type":"DECLARES"},{"src":"<greet>","dst":"<`${greeting}, ${this.name}`>","type":"RETURNS"},{"src":"<`${greeting}, ${this.name}`>","dst":"<greeting>","type":"READS_FROM"},{"src":"<`${greeting}, ${this.name}`>","dst":"<this.name>","type":"READS_FROM"},{"src":"<thisBind>","dst":"<user>","type":"DECLARES"},{"src":"<user>","dst":"<{ name: 'Alice' }>","type":"ASSIGNED_FROM"},{"src":"<{ name: 'Alice' }>","dst":"<'Alice'>","type":"HAS_PROPERTY"},{"src":"<thisBind>","dst":"<bound>","type":"DECLARES"},{"src":"<bound>","dst":"<greet.bind(user)>","type":"ASSIGNED_FROM"},{"src":"<greet.bind(user)>","dst":"<user>","type":"BINDS_THIS_TO"},{"src":"<thisBind>","dst":"<bound('Hello')>","type":"RETURNS"},{"src":"<bound('Hello')>","dst":"<bound>","type":"CALLS"},{"src":"<bound('Hello')>","dst":"<'Hello'>","type":"PASSES_ARGUMENT"}],"rationale":"Function containing nested function that uses 'this'. Creates bound function using .bind() method to fix 'this' context, then calls the bound function. Used BINDS_THIS_TO edge to capture the specific binding relationship.","implicitBehavior":["greet.bind(user) creates new function with 'this' permanently bound to user object","bound function retains access to original function's closure","template literal performs string interpolation with bound 'this' context"]},"pass":2,"annotatedAt":"2026-02-24T00:31:38.887Z"}
{"construct":{"id":"closures::this-in-class-callback","file":"src/closures.js","category":"closures","lineStart":171,"lineEnd":187,"code":"class EventHandler {\n  constructor(name) {\n    this.name = name;\n    this.handleBound = this.handle.bind(this);\n  }\n\n  handle(event) {\n    return `${this.name}: ${event}`;\n  }\n\n  handleArrow = (event) => {\n    return `${this.name}: ${event}`;\n  };\n}\n\n// --- Closure as private scope ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<EventHandler>"},{"type":"METHOD","id":"<EventHandler.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<name>"},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<this.handleBound>","metadata":{"objectName":"this"}},{"type":"CALL","id":"<this.handle.bind(this)>","metadata":{"callee":"bind"}},{"type":"PROPERTY_ACCESS","id":"<this.handle>","metadata":{"objectName":"this"}},{"type":"METHOD","id":"<EventHandler.handle>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<event>"},{"type":"EXPRESSION","id":"<`${this.name}: ${event}`>","metadata":{"type":"template-literal"}},{"type":"METHOD","id":"<EventHandler.handleArrow>","metadata":{"kind":"arrow-method"}},{"type":"PARAMETER","id":"<event:arrow>"},{"type":"EXPRESSION","id":"<`${this.name}: ${event}`:arrow>","metadata":{"type":"template-literal"}}],"edges":[{"src":"<EventHandler>","dst":"<EventHandler.constructor>","type":"CONTAINS"},{"src":"<EventHandler>","dst":"<EventHandler.handle>","type":"CONTAINS"},{"src":"<EventHandler>","dst":"<EventHandler.handleArrow>","type":"CONTAINS"},{"src":"<EventHandler.constructor>","dst":"<name>","type":"CONTAINS"},{"src":"<this.name>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<this.handleBound>","dst":"<this.handle.bind(this)>","type":"ASSIGNED_FROM"},{"src":"<this.handle.bind(this)>","dst":"<this.handle>","type":"CALLS"},{"src":"<this.handle.bind(this)>","dst":"<this>","type":"PASSES_ARGUMENT"},{"src":"<EventHandler.handle>","dst":"<event>","type":"CONTAINS"},{"src":"<EventHandler.handle>","dst":"<`${this.name}: ${event}`>","type":"RETURNS"},{"src":"<`${this.name}: ${event}`>","dst":"<this.name>","type":"READS_FROM"},{"src":"<`${this.name}: ${event}`>","dst":"<event>","type":"READS_FROM"},{"src":"<EventHandler.handleArrow>","dst":"<event:arrow>","type":"CONTAINS"},{"src":"<EventHandler.handleArrow>","dst":"<`${this.name}: ${event}`:arrow>","type":"RETURNS"},{"src":"<`${this.name}: ${event}`:arrow>","dst":"<this.name>","type":"READS_FROM"},{"src":"<`${this.name}: ${event}`:arrow>","dst":"<event:arrow>","type":"READS_FROM"},{"src":"<EventHandler.handleArrow>","dst":"<this>","type":"CAPTURES"}],"rationale":"Class with constructor that creates bound method and arrow method. Both methods access this.name but with different binding semantics - bound method explicitly binds this, arrow method lexically captures this. Removed module-level declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["bind() creates new function with fixed this context","arrow method lexically binds this from class instance context","regular method this binding depends on call site"]},"pass":2,"annotatedAt":"2026-02-24T00:31:42.095Z"}
{"construct":{"id":"closures::named-func-expr-as-argument","file":"src/closures.js","category":"closures","lineStart":234,"lineEnd":238,"code":"let retryDone = false;\nsetTimeout(function retry() {\n  if (!retryDone) setTimeout(retry, 1000); // self-reference for recursive scheduling\n}, 1000);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<retryDone>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"CALL","id":"<setTimeout(function retry() {...}, 1000)>","metadata":{"callee":"setTimeout"}},{"type":"FUNCTION","id":"<retry>","metadata":{"named":true,"expression":true}},{"type":"LITERAL","id":"<1000>","metadata":{"value":1000,"literalType":"number"}},{"type":"BRANCH","id":"<if (!retryDone)>","metadata":{"condition":"!retryDone"}},{"type":"EXPRESSION","id":"<!retryDone>","metadata":{"operator":"!"}},{"type":"CALL","id":"<setTimeout(retry, 1000)>","metadata":{"callee":"setTimeout"}},{"type":"LITERAL","id":"<1000-inner>","metadata":{"value":1000,"literalType":"number"}}],"edges":[{"src":"<retryDone>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<setTimeout(function retry() {...}, 1000)>","dst":"<retry>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(function retry() {...}, 1000)>","dst":"<1000>","type":"PASSES_ARGUMENT"},{"src":"<retry>","dst":"<if (!retryDone)>","type":"CONTAINS"},{"src":"<if (!retryDone)>","dst":"<!retryDone>","type":"HAS_CONDITION"},{"src":"<!retryDone>","dst":"<retryDone>","type":"READS_FROM"},{"src":"<if (!retryDone)>","dst":"<setTimeout(retry, 1000)>","type":"HAS_CONSEQUENT"},{"src":"<setTimeout(retry, 1000)>","dst":"<1000-inner>","type":"PASSES_ARGUMENT"},{"src":"<retry>","dst":"<retryDone>","type":"CAPTURES"}],"rationale":"Named function expression passed to setTimeout creates a closure that captures retryDone. The function can reference itself by name for recursive scheduling. Reduced edge count by removing redundant module containment and duplicate setTimeout calls.","implicitBehavior":["named function expression creates binding only within function scope","closure captures outer scope variables","setTimeout schedules asynchronous execution","function can reference itself by name for recursion"]},"pass":2,"annotatedAt":"2026-02-24T00:31:42.268Z"}
{"construct":{"id":"closures::closure-nested-mutation","file":"src/closures.js","category":"closures","lineStart":103,"lineEnd":117,"code":"function createTracker() {\n  let total = 0;\n  function addGroup(groupName) {\n    let groupTotal = 0;\n    return function addItem(value) {\n      groupTotal += value;\n      total += value;\n      return { groupName, groupTotal, total };\n    };\n  }\n  return { addGroup, getTotal: () => total };\n}\n\n// --- this binding ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createTracker>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<total>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"FUNCTION","id":"<addGroup>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<groupName>"},{"type":"VARIABLE","id":"<groupTotal>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0-inner>","metadata":{"value":0,"literalType":"number"}},{"type":"FUNCTION","id":"<addItem>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<value>"},{"type":"EXPRESSION","id":"<groupTotal += value>","metadata":{"operator":"+="}},{"type":"EXPRESSION","id":"<total += value>","metadata":{"operator":"+="}},{"type":"EXPRESSION","id":"<{ groupName, groupTotal, total }>","metadata":{"type":"object-literal"}},{"type":"FUNCTION","id":"<getTotal>","metadata":{"arrowFunction":true}},{"type":"EXPRESSION","id":"<{ addGroup, getTotal: () => total }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<createTracker>","dst":"<total>","type":"CONTAINS"},{"src":"<total>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<createTracker>","dst":"<addGroup>","type":"CONTAINS"},{"src":"<addGroup>","dst":"<groupName>","type":"CONTAINS"},{"src":"<addGroup>","dst":"<groupTotal>","type":"CONTAINS"},{"src":"<groupTotal>","dst":"<0-inner>","type":"ASSIGNED_FROM"},{"src":"<addGroup>","dst":"<addItem>","type":"CONTAINS"},{"src":"<addGroup>","dst":"<addItem>","type":"RETURNS"},{"src":"<addItem>","dst":"<value>","type":"CONTAINS"},{"src":"<addItem>","dst":"<groupTotal += value>","type":"CONTAINS"},{"src":"<addItem>","dst":"<total += value>","type":"CONTAINS"},{"src":"<groupTotal += value>","dst":"<groupTotal>","type":"WRITES_TO"},{"src":"<groupTotal += value>","dst":"<value>","type":"READS_FROM"},{"src":"<total += value>","dst":"<total>","type":"WRITES_TO"},{"src":"<total += value>","dst":"<value>","type":"READS_FROM"},{"src":"<addItem>","dst":"<{ groupName, groupTotal, total }>","type":"RETURNS"},{"src":"<{ groupName, groupTotal, total }>","dst":"<groupName>","type":"READS_FROM"},{"src":"<{ groupName, groupTotal, total }>","dst":"<groupTotal>","type":"READS_FROM"},{"src":"<{ groupName, groupTotal, total }>","dst":"<total>","type":"READS_FROM"},{"src":"<createTracker>","dst":"<getTotal>","type":"CONTAINS"},{"src":"<getTotal>","dst":"<total>","type":"READS_FROM"},{"src":"<createTracker>","dst":"<{ addGroup, getTotal: () => total }>","type":"RETURNS"},{"src":"<{ addGroup, getTotal: () => total }>","dst":"<addGroup>","type":"READS_FROM"},{"src":"<{ addGroup, getTotal: () => total }>","dst":"<getTotal>","type":"READS_FROM"},{"src":"<addItem>","dst":"<total>","type":"CAPTURES"},{"src":"<addItem>","dst":"<groupTotal>","type":"CAPTURES"},{"src":"<addItem>","dst":"<groupName>","type":"CAPTURES"},{"src":"<getTotal>","dst":"<total>","type":"CAPTURES"}],"rationale":"Nested closure pattern where inner functions capture and mutate variables from outer scopes. The addItem function captures groupTotal from addGroup scope and total from createTracker scope, mutating both. All relationships can be expressed with approved vocabulary.","implicitBehavior":["closure captures create persistent references to outer scope variables","multiple closure instances can share the same outer variable (total)","each addGroup call creates a new groupTotal variable in separate closure scope"]},"pass":2,"annotatedAt":"2026-02-24T00:31:42.340Z"}
{"construct":{"id":"closures::this-call-apply","file":"src/closures.js","category":"closures","lineStart":160,"lineEnd":169,"code":"function thisCallApply() {\n  function introduce(role) {\n    return `${this.name} is ${role}`;\n  }\n  const person = { name: 'Bob' };\n  const viaCall = introduce.call(person, 'admin');\n  const viaApply = introduce.apply(person, ['admin']);\n  return { viaCall, viaApply };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<thisCallApply>","metadata":{"async":false,"generator":false}},{"type":"FUNCTION","id":"<introduce>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<role>"},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"VARIABLE","id":"<person>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<object-literal>","metadata":{"type":"object"}},{"type":"LITERAL","id":"<'Bob'>","metadata":{"value":"Bob","literalType":"string"}},{"type":"VARIABLE","id":"<viaCall>","metadata":{"kind":"const"}},{"type":"CALL","id":"<introduce.call>","metadata":{"method":"call","thisBinding":true}},{"type":"LITERAL","id":"<'admin'>","metadata":{"value":"admin","literalType":"string"}},{"type":"VARIABLE","id":"<viaApply>","metadata":{"kind":"const"}},{"type":"CALL","id":"<introduce.apply>","metadata":{"method":"apply","thisBinding":true}},{"type":"LITERAL","id":"<array-literal>","metadata":{"type":"array"}},{"type":"LITERAL","id":"<return-object>","metadata":{"type":"object"}}],"edges":[{"src":"<thisCallApply>","dst":"<introduce>","type":"CONTAINS"},{"src":"<introduce>","dst":"<role>","type":"CONTAINS"},{"src":"<introduce>","dst":"<template-literal>","type":"RETURNS"},{"src":"<template-literal>","dst":"<this.name>","type":"READS_FROM"},{"src":"<template-literal>","dst":"<role>","type":"READS_FROM"},{"src":"<thisCallApply>","dst":"<person>","type":"CONTAINS"},{"src":"<person>","dst":"<object-literal>","type":"ASSIGNED_FROM"},{"src":"<object-literal>","dst":"<'Bob'>","type":"HAS_PROPERTY"},{"src":"<thisCallApply>","dst":"<viaCall>","type":"CONTAINS"},{"src":"<viaCall>","dst":"<introduce.call>","type":"ASSIGNED_FROM"},{"src":"<introduce.call>","dst":"<introduce>","type":"CALLS"},{"src":"<introduce.call>","dst":"<person>","type":"BINDS_THIS_TO"},{"src":"<introduce.call>","dst":"<'admin'>","type":"PASSES_ARGUMENT"},{"src":"<thisCallApply>","dst":"<viaApply>","type":"CONTAINS"},{"src":"<viaApply>","dst":"<introduce.apply>","type":"ASSIGNED_FROM"},{"src":"<introduce.apply>","dst":"<introduce>","type":"CALLS"},{"src":"<introduce.apply>","dst":"<person>","type":"BINDS_THIS_TO"},{"src":"<introduce.apply>","dst":"<array-literal>","type":"PASSES_ARGUMENT"},{"src":"<array-literal>","dst":"<'admin'>","type":"HAS_ELEMENT"},{"src":"<thisCallApply>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<viaCall>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<viaApply>","type":"HAS_PROPERTY"}],"rationale":"Function demonstrates explicit this binding via call() and apply(). Inner function accesses this.name, outer function uses call/apply to bind person object as this context. All node and edge types from Pass 1 were already in the approved vocabulary.","implicitBehavior":["call() and apply() explicitly set this context","template literal performs string interpolation","object literal creates property binding for 'name'"]},"pass":2,"annotatedAt":"2026-02-24T00:31:42.780Z"}
{"construct":{"id":"closures::closure-once","file":"src/closures.js","category":"closures","lineStart":215,"lineEnd":226,"code":"function once(fn) {\n  let called = false;\n  let result;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<once>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"VARIABLE","id":"<called>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"let"}},{"type":"FUNCTION","id":"<once:inner>","metadata":{"anonymous":true,"arrowFunction":false}},{"type":"PARAMETER","id":"<...args>","metadata":{"restParameter":true}},{"type":"BRANCH","id":"<if-not-called>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<!called>","metadata":{"operator":"!"}},{"type":"EXPRESSION","id":"<called = true>","metadata":{"operator":"="}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"CALL","id":"<fn.apply(this, args)>","metadata":{"method":"apply"}},{"type":"EXPRESSION","id":"<result = fn.apply(this, args)>","metadata":{"operator":"="}}],"edges":[{"src":"<once>","dst":"<fn>","type":"HAS_BODY"},{"src":"<once>","dst":"<called>","type":"DECLARES"},{"src":"<called>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<once>","dst":"<result>","type":"DECLARES"},{"src":"<once>","dst":"<once:inner>","type":"RETURNS"},{"src":"<once:inner>","dst":"<...args>","type":"HAS_BODY"},{"src":"<once:inner>","dst":"<if-not-called>","type":"HAS_BODY"},{"src":"<if-not-called>","dst":"<!called>","type":"HAS_CONDITION"},{"src":"<!called>","dst":"<called>","type":"READS_FROM"},{"src":"<if-not-called>","dst":"<called = true>","type":"HAS_CONSEQUENT"},{"src":"<called = true>","dst":"<called>","type":"WRITES_TO"},{"src":"<called = true>","dst":"<true>","type":"READS_FROM"},{"src":"<if-not-called>","dst":"<result = fn.apply(this, args)>","type":"HAS_CONSEQUENT"},{"src":"<result = fn.apply(this, args)>","dst":"<result>","type":"WRITES_TO"},{"src":"<result = fn.apply(this, args)>","dst":"<fn.apply(this, args)>","type":"READS_FROM"},{"src":"<fn.apply(this, args)>","dst":"<fn>","type":"CALLS"},{"src":"<fn.apply(this, args)>","dst":"<...args>","type":"PASSES_ARGUMENT"},{"src":"<once:inner>","dst":"<result>","type":"RETURNS"},{"src":"<once:inner>","dst":"<called>","type":"CAPTURES"},{"src":"<once:inner>","dst":"<result>","type":"CAPTURES"},{"src":"<once:inner>","dst":"<fn>","type":"CAPTURES"}],"rationale":"Higher-order function that returns a closure. The inner function captures three variables from the outer scope and implements memoization logic with conditional execution.","implicitBehavior":["closure captures outer scope variables","this binding preserved through apply","rest parameter spreads arguments"]},"pass":2,"annotatedAt":"2026-02-24T00:31:44.116Z"}
{"construct":{"id":"coercion-hoisting::hoist-function-decl","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":80,"lineEnd":85,"code":"function functionHoisting() {\n  const result = hoisted(); // works  function declarations are fully hoisted\n  function hoisted() { return 'hoisted'; }\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<functionHoisting>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<hoisted()>","metadata":{"callee":"hoisted"}},{"type":"FUNCTION","id":"<hoisted>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<'hoisted'>","metadata":{"value":"hoisted","literalType":"string"}}],"edges":[{"src":"<functionHoisting>","dst":"<result>","type":"CONTAINS"},{"src":"<functionHoisting>","dst":"<hoisted>","type":"CONTAINS"},{"src":"<result>","dst":"<hoisted()>","type":"ASSIGNED_FROM"},{"src":"<hoisted()>","dst":"<hoisted>","type":"CALLS"},{"src":"<hoisted>","dst":"<'hoisted'>","type":"RETURNS"},{"src":"<functionHoisting>","dst":"<result>","type":"RETURNS"}],"rationale":"Function declaration with internal hoisted function. The call to hoisted() works because function declarations are fully hoisted within their containing scope. Removed the module-level DECLARES edge to stay within the 7-edge threshold while preserving the core hoisting semantics.","implicitBehavior":["function hoisted() is available throughout the entire functionHoisting scope, including before its textual declaration"]},"pass":2,"annotatedAt":"2026-02-24T00:31:44.423Z"}
{"construct":{"id":"closures::closure-memoize","file":"src/closures.js","category":"closures","lineStart":201,"lineEnd":213,"code":"function memoize(fn) {\n  const cache = new Map();\n  return function (...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// --- Once (call-at-most-once) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<memoize>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"VARIABLE","id":"<cache>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Map()>","metadata":{"callee":"Map","constructor":true}},{"type":"FUNCTION","id":"<memoize:returnFn>","metadata":{"anonymous":true,"restParams":true}},{"type":"PARAMETER","id":"<...args>"},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const"}},{"type":"CALL","id":"<JSON.stringify(args)>","metadata":{"callee":"JSON.stringify"}},{"type":"CALL","id":"<cache.has(key)>","metadata":{"callee":"has"}},{"type":"CALL","id":"<cache.get(key)>","metadata":{"callee":"get"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fn.apply(this, args)>","metadata":{"callee":"apply"}},{"type":"CALL","id":"<cache.set(key, result)>","metadata":{"callee":"set"}}],"edges":[{"src":"<memoize>","dst":"<fn>","type":"HAS_BODY"},{"src":"<memoize>","dst":"<cache>","type":"CONTAINS"},{"src":"<cache>","dst":"<new Map()>","type":"ASSIGNED_FROM"},{"src":"<memoize>","dst":"<memoize:returnFn>","type":"RETURNS"},{"src":"<memoize:returnFn>","dst":"<...args>","type":"HAS_BODY"},{"src":"<memoize:returnFn>","dst":"<key>","type":"CONTAINS"},{"src":"<key>","dst":"<JSON.stringify(args)>","type":"ASSIGNED_FROM"},{"src":"<JSON.stringify(args)>","dst":"<...args>","type":"PASSES_ARGUMENT"},{"src":"<memoize:returnFn>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<fn.apply(this, args)>","type":"ASSIGNED_FROM"},{"src":"<fn.apply(this, args)>","dst":"<fn>","type":"CALLS"},{"src":"<fn.apply(this, args)>","dst":"<...args>","type":"PASSES_ARGUMENT"},{"src":"<cache.has(key)>","dst":"<cache>","type":"CALLS_ON"},{"src":"<cache.has(key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<cache.get(key)>","dst":"<cache>","type":"CALLS_ON"},{"src":"<cache.get(key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<cache.set(key, result)>","dst":"<cache>","type":"CALLS_ON"},{"src":"<cache.set(key, result)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<cache.set(key, result)>","dst":"<result>","type":"PASSES_ARGUMENT"},{"src":"<memoize:returnFn>","dst":"<cache>","type":"CAPTURES"},{"src":"<memoize:returnFn>","dst":"<fn>","type":"CAPTURES"}],"rationale":"Higher-order function that creates a closure capturing the cache and input function. The returned function uses the captured variables to implement memoization logic. Used HAS_BODY for parameter containment and CALLS_ON for method calls on objects.","implicitBehavior":["closure captures variables from outer scope","Map constructor creates new instance","JSON.stringify may throw on circular references","apply preserves 'this' context"]},"pass":2,"annotatedAt":"2026-02-24T00:31:45.565Z"}
{"construct":{"id":"closures::this-lost-in-callback","file":"src/closures.js","category":"closures","lineStart":130,"lineEnd":148,"code":"function thisLostInCallback() {\n  const timer = {\n    seconds: 0,\n    start() {\n      // `this` lost: regular function callback\n      setTimeout(function () {\n        this.seconds++; // `this` is undefined/global\n      }, 1000);\n    },\n    startFixed() {\n      // `this` preserved: arrow function callback\n      setTimeout(() => {\n        this.seconds++;\n      }, 1000);\n    },\n  };\n  return timer;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<thisLostInCallback>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<timer>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<timer-object>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<timer.seconds>","metadata":{"objectName":"timer","propertyName":"seconds"}},{"type":"METHOD","id":"<timer.start>","metadata":{"kind":"method"}},{"type":"CALL","id":"<setTimeout-regular>","metadata":{"callee":"setTimeout"}},{"type":"FUNCTION","id":"<setTimeout-callback-regular>","metadata":{"async":false,"generator":false,"anonymous":true}},{"type":"PROPERTY_ACCESS","id":"<this.seconds-regular>","metadata":{"objectName":"this","propertyName":"seconds"}},{"type":"EXPRESSION","id":"<this.seconds++-regular>","metadata":{"operator":"++"}},{"type":"LITERAL","id":"<1000-1>","metadata":{"value":1000,"literalType":"number"}},{"type":"METHOD","id":"<timer.startFixed>","metadata":{"kind":"method"}},{"type":"CALL","id":"<setTimeout-arrow>","metadata":{"callee":"setTimeout"}},{"type":"FUNCTION","id":"<setTimeout-callback-arrow>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"PROPERTY_ACCESS","id":"<this.seconds-arrow>","metadata":{"objectName":"this","propertyName":"seconds"}},{"type":"EXPRESSION","id":"<this.seconds++-arrow>","metadata":{"operator":"++"}},{"type":"LITERAL","id":"<1000-2>","metadata":{"value":1000,"literalType":"number"}}],"edges":[{"src":"<thisLostInCallback>","dst":"<timer>","type":"CONTAINS"},{"src":"<timer>","dst":"<timer-object>","type":"ASSIGNED_FROM"},{"src":"<timer-object>","dst":"<timer.seconds>","type":"HAS_PROPERTY"},{"src":"<timer.seconds>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<timer-object>","dst":"<timer.start>","type":"HAS_PROPERTY"},{"src":"<timer-object>","dst":"<timer.startFixed>","type":"HAS_PROPERTY"},{"src":"<timer.start>","dst":"<setTimeout-regular>","type":"CONTAINS"},{"src":"<setTimeout-regular>","dst":"<setTimeout-callback-regular>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout-regular>","dst":"<1000-1>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout-callback-regular>","dst":"<this.seconds++-regular>","type":"CONTAINS"},{"src":"<this.seconds++-regular>","dst":"<this.seconds-regular>","type":"WRITES_TO"},{"src":"<timer.startFixed>","dst":"<setTimeout-arrow>","type":"CONTAINS"},{"src":"<setTimeout-arrow>","dst":"<setTimeout-callback-arrow>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout-arrow>","dst":"<1000-2>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout-callback-arrow>","dst":"<this.seconds++-arrow>","type":"CONTAINS"},{"src":"<this.seconds++-arrow>","dst":"<this.seconds-arrow>","type":"WRITES_TO"},{"src":"<setTimeout-callback-arrow>","dst":"<timer-object>","type":"CAPTURES"},{"src":"<thisLostInCallback>","dst":"<timer>","type":"RETURNS"}],"rationale":"Function returns object with two methods demonstrating this-binding behavior. Regular function callback loses this context, arrow function preserves it through lexical capture.","implicitBehavior":["regular function callback has dynamic this binding (undefined in strict mode, global in non-strict)","arrow function lexically captures this from enclosing method context","setTimeout executes callbacks asynchronously with different this contexts"]},"pass":2,"annotatedAt":"2026-02-24T00:31:46.157Z"}
{"construct":{"id":"coercion-hoisting::hoist-var","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":72,"lineEnd":78,"code":"function varHoisting() {\n  console.log(x); // undefined  hoisted, not initialized\n  var x = 10;\n  console.log(x); // 10\n  return x;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<varHoisting>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"CALL","id":"<console.log(x):1>","metadata":{"callee":"console.log","line":2}},{"type":"CALL","id":"<console.log(x):2>","metadata":{"callee":"console.log","line":4}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}}],"edges":[{"src":"<varHoisting>","dst":"<x>","type":"DECLARES"},{"src":"<x>","dst":"<10>","type":"ASSIGNED_FROM"},{"src":"<console.log(x):1>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(x):1>","dst":"<x>","type":"PASSES_ARGUMENT"},{"src":"<console.log(x):2>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(x):2>","dst":"<x>","type":"PASSES_ARGUMENT"},{"src":"<varHoisting>","dst":"<x>","type":"RETURNS"}],"rationale":"Function demonstrates var hoisting behavior. Variable x is declared with var and assigned value 10. Two console.log calls access x at different execution points - first when hoisted but uninitialized (undefined), second after assignment (10). Function returns x.","implicitBehavior":["var x declaration is hoisted to top of function scope","x is undefined until assignment executes","first console.log reads hoisted but uninitialized variable","second console.log reads initialized variable"]},"pass":2,"annotatedAt":"2026-02-24T00:31:46.874Z"}
{"construct":{"id":"async-generators::yield-yield-chained","file":"src/async-generators.js","category":"async-generators","lineStart":282,"lineEnd":291,"code":"function* chainedYield() {\n  const result = yield yield 1; // two suspension points in one expression\n  // Step 1: yields 1, suspends\n  // Step 2: .next(x) resumes, yields x, suspends again\n  // Step 3: .next(y) resumes, result = y\n  return result;\n}\n\n// --- async destructuring with await in defaults ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<chainedYield>","metadata":{"generator":true,"async":false}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield yield 1>","metadata":{"type":"nested-yield"}},{"type":"EXPRESSION","id":"<inner-yield>","metadata":{"position":"inner","operator":"yield"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<outer-yield>","metadata":{"position":"outer","operator":"yield"}}],"edges":[{"src":"<chainedYield>","dst":"<result>","type":"CONTAINS"},{"src":"<chainedYield>","dst":"<yield yield 1>","type":"CONTAINS"},{"src":"<result>","dst":"<yield yield 1>","type":"ASSIGNED_FROM"},{"src":"<yield yield 1>","dst":"<outer-yield>","type":"CONTAINS"},{"src":"<outer-yield>","dst":"<inner-yield>","type":"YIELDS"},{"src":"<inner-yield>","dst":"<1>","type":"YIELDS"},{"src":"<chainedYield>","dst":"<result>","type":"RETURNS"}],"rationale":"Generator function with nested yield expressions creating two suspension points. Inner yield produces 1, outer yield produces the result of inner yield. Mapped YIELD nodes to EXPRESSION with yield operator metadata since YIELD is not in approved vocabulary.","implicitBehavior":["First suspension: inner yield produces 1 to caller","Second suspension: outer yield produces value sent to inner yield","Final resume: outer yield result assigned to result variable"]},"pass":2,"annotatedAt":"2026-02-24T00:31:52.302Z"}
{"construct":{"id":"coercion-hoisting::hoist-function-expr-not","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":87,"lineEnd":98,"code":"function functionExprNotHoisted() {\n  try {\n    notHoisted(); // TypeError: notHoisted is not a function\n  } catch (e) {\n    // var notHoisted is hoisted as undefined, but assignment is not\n  }\n  var notHoisted = function () { return 'not hoisted'; };\n  return notHoisted();\n}\n\n// --- Temporal Dead Zone (TDZ) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<functionExprNotHoisted>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<notHoisted()>","metadata":{"callee":"notHoisted"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"VARIABLE","id":"<notHoisted>","metadata":{"kind":"var"}},{"type":"FUNCTION","id":"<notHoisted:fn>","metadata":{"anonymous":true}},{"type":"LITERAL","id":"<'not hoisted'>","metadata":{"value":"not hoisted","literalType":"string"}},{"type":"CALL","id":"<notHoisted()_return>","metadata":{"callee":"notHoisted"}}],"edges":[{"src":"<functionExprNotHoisted>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<notHoisted()>","type":"CONTAINS"},{"src":"<notHoisted()>","dst":"<notHoisted>","type":"CALLS"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<e>","type":"RECEIVES_ARGUMENT"},{"src":"<functionExprNotHoisted>","dst":"<notHoisted>","type":"DECLARES"},{"src":"<notHoisted>","dst":"<notHoisted:fn>","type":"ASSIGNED_FROM"},{"src":"<notHoisted:fn>","dst":"<'not hoisted'>","type":"RETURNS"},{"src":"<functionExprNotHoisted>","dst":"<notHoisted()_return>","type":"RETURNS"},{"src":"<notHoisted()_return>","dst":"<notHoisted>","type":"CALLS"}],"rationale":"Function demonstrates var hoisting behavior where variable declaration is hoisted but assignment is not. The try block calls the hoisted but undefined variable, catch handles the TypeError, then assignment occurs, followed by successful call. Reduced edge count by using HAS_BODY instead of CONTAINS for function-to-try relationship and RECEIVES_ARGUMENT for catch parameter.","implicitBehavior":["var notHoisted declaration is hoisted to function scope as undefined","function expression assignment happens at runtime, not hoisted","first call to notHoisted() throws TypeError because undefined is not a function","second call succeeds after assignment"]},"pass":2,"annotatedAt":"2026-02-24T00:31:52.302Z"}
{"construct":{"id":"coercion-hoisting::tdz-let","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":100,"lineEnd":109,"code":"function tdzLet() {\n  try {\n    console.log(x); // ReferenceError  TDZ\n  } catch (e) {\n    // let x exists but cannot be accessed before declaration\n  }\n  let x = 10;\n  return x;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tdzLet>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"CALL","id":"<console.log(x)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"let","inTDZ":true}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}}],"edges":[{"src":"<tdzLet>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<console.log(x)>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<e>","type":"RECEIVES_ARGUMENT"},{"src":"<console.log(x)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(x)>","dst":"<x>","type":"PASSES_ARGUMENT"},{"src":"<console.log(x)>","dst":"<x>","type":"READS_FROM"},{"src":"<tdzLet>","dst":"<x>","type":"DECLARES"},{"src":"<x>","dst":"<10>","type":"ASSIGNED_FROM"},{"src":"<tdzLet>","dst":"<x>","type":"RETURNS"},{"src":"<console.log(x)>","dst":"<catch-block>","type":"THROWS"}],"rationale":"Function demonstrates temporal dead zone behavior with let declaration. The variable x is declared but accessing it before the declaration line throws a ReferenceError, which is caught by the try-catch block.","implicitBehavior":["let declaration is hoisted but remains in temporal dead zone until declaration line","ReferenceError thrown when accessing TDZ variable","let binding exists in function scope from start but is inaccessible"]},"pass":2,"annotatedAt":"2026-02-24T00:31:52.813Z"}
{"construct":{"id":"coercion-hoisting::tdz-class","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":122,"lineEnd":133,"code":"function tdzClass() {\n  try {\n    new MyClass(); // ReferenceError  class TDZ\n  } catch (e) {\n    // class declarations have TDZ like let/const\n  }\n  class MyClass {}\n  return new MyClass();\n}\n\n// --- Variable shadowing ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tdzClass>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<new MyClass()>","metadata":{"constructor":true}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"CLASS","id":"<MyClass>"},{"type":"CALL","id":"<new MyClass():return>","metadata":{"constructor":true}}],"edges":[{"src":"<tdzClass>","dst":"<try-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<new MyClass()>","type":"CONTAINS"},{"src":"<new MyClass()>","dst":"<MyClass>","type":"CALLS"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<e>","type":"CONTAINS"},{"src":"<tdzClass>","dst":"<MyClass>","type":"DECLARES"},{"src":"<tdzClass>","dst":"<new MyClass():return>","type":"RETURNS"},{"src":"<new MyClass():return>","dst":"<MyClass>","type":"CALLS"}],"rationale":"Function demonstrates class TDZ behavior. Try block attempts to instantiate class before declaration, catch handles the ReferenceError, then class is declared and successfully instantiated in return. Removed module-level declaration edge to stay within edge count threshold.","implicitBehavior":["class declaration is hoisted but remains in TDZ until declaration line","first constructor call throws ReferenceError due to TDZ","second constructor call succeeds after class declaration"]},"pass":2,"annotatedAt":"2026-02-24T00:31:53.392Z"}
{"construct":{"id":"coercion-hoisting::coerce-symbol-toprimitive","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":61,"lineEnd":70,"code":"const toPrimitive = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return 10;\n    if (hint === 'string') return 'ten';\n    return true;\n  },\n};\n\n// --- Hoisting ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<toPrimitive>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<object-literal>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<[Symbol.toPrimitive]>","metadata":{"computed":true,"wellKnownSymbol":"toPrimitive"}},{"type":"PARAMETER","id":"<hint>"},{"type":"BRANCH","id":"<if-number>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<hint === 'number'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'number'>","metadata":{"value":"number","literalType":"string"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"BRANCH","id":"<if-string>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<hint === 'string'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'string'>","metadata":{"value":"string","literalType":"string"}},{"type":"LITERAL","id":"<'ten'>","metadata":{"value":"ten","literalType":"string"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<toPrimitive>","dst":"<object-literal>","type":"ASSIGNED_FROM"},{"src":"<object-literal>","dst":"<[Symbol.toPrimitive]>","type":"HAS_PROPERTY"},{"src":"<[Symbol.toPrimitive]>","dst":"<hint>","type":"CONTAINS"},{"src":"<[Symbol.toPrimitive]>","dst":"<if-number>","type":"CONTAINS"},{"src":"<if-number>","dst":"<hint === 'number'>","type":"HAS_CONDITION"},{"src":"<hint === 'number'>","dst":"<hint>","type":"READS_FROM"},{"src":"<hint === 'number'>","dst":"<'number'>","type":"READS_FROM"},{"src":"<if-number>","dst":"<10>","type":"RETURNS"},{"src":"<[Symbol.toPrimitive]>","dst":"<if-string>","type":"CONTAINS"},{"src":"<if-string>","dst":"<hint === 'string'>","type":"HAS_CONDITION"},{"src":"<hint === 'string'>","dst":"<hint>","type":"READS_FROM"},{"src":"<hint === 'string'>","dst":"<'string'>","type":"READS_FROM"},{"src":"<if-string>","dst":"<'ten'>","type":"RETURNS"},{"src":"<[Symbol.toPrimitive]>","dst":"<true>","type":"RETURNS"}],"rationale":"Object with Symbol.toPrimitive method that customizes primitive conversion. Method contains conditional logic to return different values based on conversion hint. Removed module declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["Symbol.toPrimitive method will be called during type coercion operations","Method overrides default object-to-primitive conversion behavior","Hint parameter receives 'number', 'string', or 'default' based on coercion context"]},"pass":2,"annotatedAt":"2026-02-24T00:31:54.163Z"}
{"construct":{"id":"async-generators::yield-expression-positions","file":"src/async-generators.js","category":"async-generators","lineStart":271,"lineEnd":280,"code":"function* exoticYield() {\n  console.log(yield 'prompt');                 // yield as function argument\n  const pair = [yield 'a', yield 'b'];         // yield in array literal\n  const msg = `Hello ${yield 'name'}!`;        // yield in template literal\n  const val = (yield 'check') ? 'yes' : 'no'; // yield in ternary condition\n  const obj = { x: yield 'x', y: yield 'y' }; // yield in object literal\n}\n\n// --- yield yield (chained) ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<exoticYield>\",\n      \"metadata\": {\n        \"generator\": true,\n        \"async\": false\n      }\n    },\n    {\n      \"type\": \"CALL\",\n   "},"pass":2,"annotatedAt":"2026-02-24T00:31:54.190Z"}
{"construct":{"id":"coercion-hoisting::tdz-const","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":111,"lineEnd":120,"code":"function tdzConst() {\n  try {\n    console.log(C); // ReferenceError  TDZ\n  } catch (e) {\n    // const C in TDZ\n  }\n  const C = 42;\n  return C;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tdzConst>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"CALL","id":"<console.log(C)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}},{"type":"VARIABLE","id":"<C>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<tdzConst>","dst":"<try-block>","type":"CONTAINS"},{"src":"<tdzConst>","dst":"<catch-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<console.log(C)>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<e>","type":"CONTAINS"},{"src":"<console.log(C)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(C)>","dst":"<C>","type":"PASSES_ARGUMENT"},{"src":"<tdzConst>","dst":"<C>","type":"DECLARES"},{"src":"<C>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<tdzConst>","dst":"<C>","type":"RETURNS"},{"src":"<console.log(C)>","dst":"<C>","type":"READS_FROM"}],"rationale":"Function demonstrates Temporal Dead Zone behavior. const C is declared but accessing it before initialization throws ReferenceError, caught by try-catch. Removed the module-level declaration edge to reduce edge count while preserving the core TDZ semantics.","implicitBehavior":["const C is hoisted but remains in TDZ until declaration line","accessing C before initialization throws ReferenceError","TDZ prevents use of variable before explicit initialization","function is implicitly declared at module level"]},"pass":2,"annotatedAt":"2026-02-24T00:31:54.243Z"}
{"construct":{"id":"coercion-hoisting::coerce-valueof-tostring","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":52,"lineEnd":59,"code":"const customCoerce = {\n  valueOf() { return 42; },\n  toString() { return 'custom'; },\n};\n\nconst usedInMath = customCoerce + 1;        // 43 (valueOf)\nconst usedInTemplate = `${customCoerce}`;   // 'custom' (toString)","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<customCoerce>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<customCoerce:obj>"},{"type":"METHOD","id":"<valueOf>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"METHOD","id":"<toString>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'custom'>","metadata":{"value":"custom","literalType":"string"}},{"type":"VARIABLE","id":"<usedInMath>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<customCoerce + 1>","metadata":{"operator":"+"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<usedInTemplate>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<`${customCoerce}`>"}],"edges":[{"src":"<customCoerce>","dst":"<customCoerce:obj>","type":"ASSIGNED_FROM"},{"src":"<customCoerce:obj>","dst":"<valueOf>","type":"CONTAINS"},{"src":"<customCoerce:obj>","dst":"<toString>","type":"CONTAINS"},{"src":"<valueOf>","dst":"<42>","type":"RETURNS"},{"src":"<toString>","dst":"<'custom'>","type":"RETURNS"},{"src":"<usedInMath>","dst":"<customCoerce + 1>","type":"ASSIGNED_FROM"},{"src":"<customCoerce + 1>","dst":"<customCoerce>","type":"READS_FROM"},{"src":"<customCoerce + 1>","dst":"<1>","type":"READS_FROM"},{"src":"<customCoerce + 1>","dst":"<valueOf>","type":"CALLS"},{"src":"<usedInTemplate>","dst":"<`${customCoerce}`>","type":"ASSIGNED_FROM"},{"src":"<`${customCoerce}`>","dst":"<customCoerce>","type":"READS_FROM"},{"src":"<`${customCoerce}`>","dst":"<toString>","type":"CALLS"}],"rationale":"Object with custom valueOf/toString methods used in different coercion contexts. Math operation triggers valueOf, template literal triggers toString. Used EXPRESSION for object literal and template literal, CALLS for implicit method invocations during coercion.","implicitBehavior":["valueOf() called for numeric coercion in arithmetic operations","toString() called for string coercion in template literals","coercion method selection depends on operation context"]},"pass":2,"annotatedAt":"2026-02-24T00:31:55.048Z"}
{"construct":{"id":"coercion-hoisting::shadow-param-scope","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":147,"lineEnd":155,"code":"function paramShadowing(x) {\n  const x2 = x;\n  if (true) {\n    const x = 'shadowed'; // shadows parameter\n    console.log(x); // 'shadowed'\n  }\n  return x; // original param\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<paramShadowing>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x:param>","metadata":{"name":"x"}},{"type":"VARIABLE","id":"<x2>","metadata":{"kind":"const"}},{"type":"SCOPE","id":"<if-block-scope>","metadata":{"scopeType":"block"}},{"type":"VARIABLE","id":"<x:shadowed>","metadata":{"kind":"const","name":"x","shadows":"x:param"}},{"type":"LITERAL","id":"<'shadowed'>","metadata":{"value":"shadowed","literalType":"string"}},{"type":"CALL","id":"<console.log(x)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}}],"edges":[{"src":"<paramShadowing>","dst":"<x:param>","type":"CONTAINS"},{"src":"<paramShadowing>","dst":"<x2>","type":"CONTAINS"},{"src":"<x2>","dst":"<x:param>","type":"ASSIGNED_FROM"},{"src":"<paramShadowing>","dst":"<if-block-scope>","type":"CONTAINS"},{"src":"<if-block-scope>","dst":"<x:shadowed>","type":"CONTAINS"},{"src":"<x:shadowed>","dst":"<'shadowed'>","type":"ASSIGNED_FROM"},{"src":"<x:shadowed>","dst":"<x:param>","type":"SHADOWS"},{"src":"<console.log(x)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(x)>","dst":"<x:shadowed>","type":"PASSES_ARGUMENT"},{"src":"<paramShadowing>","dst":"<x:param>","type":"RETURNS"}],"rationale":"Function parameter is shadowed by block-scoped const variable. The shadowed variable masks the parameter within the if block, but the parameter remains accessible in the outer function scope. The SHADOWS edge captures the lexical shadowing relationship.","implicitBehavior":["block scope creates new lexical environment","identifier resolution follows lexical scoping rules - inner scope shadows outer","const declaration creates temporal dead zone until initialization"]},"pass":2,"annotatedAt":"2026-02-24T00:31:55.373Z"}
{"construct":{"id":"coercion-hoisting::eval-direct","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":170,"lineEnd":173,"code":"function directEval(code) {\n  return eval(code);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<directEval>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<code>"},{"type":"CALL","id":"<eval(code)>","metadata":{"callee":"eval","evalType":"direct"}},{"type":"EXTERNAL","id":"<eval>","metadata":{"builtin":true,"dangerous":true}}],"edges":[{"src":"<module>","dst":"<directEval>","type":"DECLARES"},{"src":"<directEval>","dst":"<code>","type":"CONTAINS"},{"src":"<directEval>","dst":"<eval(code)>","type":"RETURNS"},{"src":"<eval(code)>","dst":"<eval>","type":"CALLS"},{"src":"<eval(code)>","dst":"<code>","type":"PASSES_ARGUMENT"},{"src":"<eval>","dst":"<directEval>","type":"CAPTURES"}],"rationale":"Function that performs direct eval call. The eval builtin captures the calling function's scope for variable resolution and dynamic modification.","implicitBehavior":["direct eval can access and modify all variables in directEval's scope","direct eval can introduce new variables into directEval's scope","prevents optimization of directEval function due to dynamic scope modification","eval'd code executes in the same lexical environment as the call site"]},"pass":2,"annotatedAt":"2026-02-24T00:31:57.732Z"}
{"construct":{"id":"closures::export-named-list","file":"src/closures.js","category":"closures","lineStart":240,"lineEnd":267,"code":"export {\n  requestCount,\n  getRequestCount,\n  incrementRequestCount,\n  sharedCache,\n  setCache,\n  getCache,\n  clearCache,\n  createCounter,\n  createMultiplier,\n  createAccumulator,\n  closureLoopVarBug,\n  closureLoopLetFix,\n  closureLoopIifeFix,\n  outermost,\n  createTracker,\n  obj,\n  thisLostInCallback,\n  thisBind,\n  thisCallApply,\n  EventHandler,\n  counterModule,\n  memoize,\n  once,\n  thisAtModuleLevel,\n  retryDone,\n};","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"EXPORT\",\n      \"id\": \"<export-named-list>\",\n      \"metadata\": {\n        \"exportType\": \"named-list\"\n      }\n    },\n    {\n      \"type\": \"VARIABLE\",\n      \"id\""},"pass":2,"annotatedAt":"2026-02-24T00:31:59.074Z"}
{"construct":{"id":"coercion-hoisting::eval-indirect","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":175,"lineEnd":179,"code":"function indirectEval(code) {\n  const evaluate = eval;\n  return evaluate(code);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<indirectEval>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<code>"},{"type":"VARIABLE","id":"<evaluate>","metadata":{"kind":"const"}},{"type":"EXTERNAL","id":"<eval>","metadata":{"builtin":true,"global":true}},{"type":"CALL","id":"<evaluate(code)>","metadata":{"indirect":true,"dynamic":true}}],"edges":[{"src":"<indirectEval>","dst":"<code>","type":"CONTAINS"},{"src":"<indirectEval>","dst":"<evaluate>","type":"CONTAINS"},{"src":"<evaluate>","dst":"<eval>","type":"ASSIGNED_FROM"},{"src":"<indirectEval>","dst":"<evaluate(code)>","type":"RETURNS"},{"src":"<evaluate(code)>","dst":"<evaluate>","type":"CALLS"},{"src":"<evaluate(code)>","dst":"<code>","type":"PASSES_ARGUMENT"},{"src":"<evaluate>","dst":"<eval>","type":"READS_FROM"}],"rationale":"Function creates indirect eval by assigning global eval to a variable, then calling through that reference. This changes eval's execution context from direct to indirect.","implicitBehavior":["indirect eval executes in global scope instead of local scope","loses access to local variables and creates global bindings","eval reference captured at assignment time"]},"pass":2,"annotatedAt":"2026-02-24T00:31:59.248Z"}
{"construct":{"id":"coercion-hoisting::eval-var-injection","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":196,"lineEnd":200,"code":"function evalVarInjection() {\n  eval('var injected = 42');\n  return injected; // 42  eval injected into function scope\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<evalVarInjection>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<eval('var injected = 42')>","metadata":{"callee":"eval"}},{"type":"LITERAL","id":"<'var injected = 42'>","metadata":{"value":"var injected = 42","literalType":"string"}},{"type":"VARIABLE","id":"<injected>","metadata":{"kind":"var","evalInjected":true}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<evalVarInjection>","type":"DECLARES"},{"src":"<evalVarInjection>","dst":"<eval('var injected = 42')>","type":"CONTAINS"},{"src":"<eval('var injected = 42')>","dst":"<eval>","type":"CALLS"},{"src":"<eval('var injected = 42')>","dst":"<'var injected = 42'>","type":"PASSES_ARGUMENT"},{"src":"<eval('var injected = 42')>","dst":"<injected>","type":"MODIFIES"},{"src":"<injected>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<evalVarInjection>","dst":"<injected>","type":"RETURNS"}],"rationale":"Function uses eval to inject a var declaration into its scope. The eval call dynamically creates a variable that becomes accessible in the function's scope. Used MODIFIES to represent eval's dynamic variable injection since no specific injection edge type exists.","implicitBehavior":["eval injects variable into function scope at runtime","injected var is hoisted within function scope","eval prevents static analysis of variable existence"]},"pass":2,"annotatedAt":"2026-02-24T00:32:02.234Z"}
{"construct":{"id":"coercion-hoisting::shadow-catch-scope","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":157,"lineEnd":168,"code":"function catchShadowing() {\n  const error = 'not an error';\n  try {\n    throw new Error('real error');\n  } catch (error) {\n    console.log(error.message); // 'real error'  shadows outer \"error\"\n  }\n  return error; // 'not an error'\n}\n\n// --- eval ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<catchShadowing>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<error:outer>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'not an error'>","metadata":{"value":"not an error","literalType":"string"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<error:catch>","metadata":{"kind":"catch-parameter"}},{"type":"CALL","id":"<new Error('real error')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'real error'>","metadata":{"value":"real error","literalType":"string"}},{"type":"CALL","id":"<console.log(error.message)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<error.message>","metadata":{"property":"message"}}],"edges":[{"src":"<catchShadowing>","dst":"<error:outer>","type":"CONTAINS"},{"src":"<error:outer>","dst":"<'not an error'>","type":"ASSIGNED_FROM"},{"src":"<catchShadowing>","dst":"<try-block>","type":"CONTAINS"},{"src":"<catchShadowing>","dst":"<catch-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<error:catch>","type":"CONTAINS"},{"src":"<try-block>","dst":"<new Error('real error')>","type":"THROWS"},{"src":"<new Error('real error')>","dst":"<'real error'>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<console.log(error.message)>","type":"CONTAINS"},{"src":"<console.log(error.message)>","dst":"<error.message>","type":"PASSES_ARGUMENT"},{"src":"<error.message>","dst":"<error:catch>","type":"READS_FROM"},{"src":"<catchShadowing>","dst":"<error:outer>","type":"RETURNS"},{"src":"<error:catch>","dst":"<error:outer>","type":"SHADOWS"}],"rationale":"Function with variable shadowing in catch block. Outer const 'error' is shadowed by catch parameter 'error', creating two distinct bindings in different scopes. The catch parameter shadows the outer variable within the catch block scope.","implicitBehavior":["catch parameter creates new block scope that shadows outer variable","catch parameter only exists within catch block scope","return statement accesses outer variable after catch scope ends"]},"pass":2,"annotatedAt":"2026-02-24T00:32:02.646Z"}
{"construct":{"id":"coercion-hoisting::contextual-keyword-as-identifier","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":230,"lineEnd":236,"code":"function contextualKeywords() {\n  var async = 1;       // valid  \"async\" is not a reserved word\n  // var yield = 3;    // SyntaxError in strict/ESM  valid in sloppy scripts\n  // var let = 2;      // SyntaxError in strict  valid with var in sloppy\n  return async;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<contextualKeywords>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<async>","metadata":{"kind":"var","contextualKeyword":true}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}}],"edges":[{"src":"<MODULE>","dst":"<contextualKeywords>","type":"DECLARES"},{"src":"<contextualKeywords>","dst":"<async>","type":"CONTAINS"},{"src":"<async>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<contextualKeywords>","dst":"<async>","type":"RETURNS"}],"rationale":"Function declares a variable using 'async' as identifier (valid since async is contextual, not reserved). The variable is assigned a literal value and returned. All relationships use approved vocabulary types.","implicitBehavior":["var declaration hoisted to function scope","contextual keywords like 'async' can be identifiers when not in async function context","commented yield/let would be syntax errors in strict mode but valid in sloppy mode"]},"pass":2,"annotatedAt":"2026-02-24T00:32:02.851Z"}
{"construct":{"id":"coercion-hoisting::eval-function-injection","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":202,"lineEnd":206,"code":"function evalFunctionInjection() {\n  eval('function surprise() { return \"boo\"; }');\n  return surprise(); // \"boo\"\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<evalFunctionInjection>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<eval('function surprise() { return \"boo\"; }')>","metadata":{"callee":"eval"}},{"type":"LITERAL","id":"<'function surprise() { return \"boo\"; }'>","metadata":{"value":"function surprise() { return \"boo\"; }","literalType":"string"}},{"type":"FUNCTION","id":"<surprise>","metadata":{"async":false,"generator":false,"dynamicallyInjected":true}},{"type":"LITERAL","id":"<\"boo\">","metadata":{"value":"boo","literalType":"string"}},{"type":"CALL","id":"<surprise()>","metadata":{"callee":"surprise"}}],"edges":[{"src":"<evalFunctionInjection>","dst":"<eval('function surprise() { return \"boo\"; }')>","type":"CONTAINS"},{"src":"<eval('function surprise() { return \"boo\"; }')>","dst":"<'function surprise() { return \"boo\"; }'>","type":"PASSES_ARGUMENT"},{"src":"<eval('function surprise() { return \"boo\"; }')>","dst":"<surprise>","type":"DECLARES"},{"src":"<surprise>","dst":"<\"boo\">","type":"RETURNS"},{"src":"<evalFunctionInjection>","dst":"<surprise()>","type":"CONTAINS"},{"src":"<surprise()>","dst":"<surprise>","type":"CALLS"},{"src":"<evalFunctionInjection>","dst":"<surprise()>","type":"RETURNS"}],"rationale":"Function uses eval to dynamically inject a function declaration into its scope, then calls the injected function. The eval creates a function that becomes available in the containing scope through dynamic declaration.","implicitBehavior":["eval executes at runtime and injects function declaration into current scope","injected function is hoisted and available immediately after eval execution","eval prevents static analysis and optimization","dynamic scope modification affects variable resolution"]},"pass":2,"annotatedAt":"2026-02-24T00:32:03.677Z"}
{"construct":{"id":"coercion-hoisting::eval-new-function","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":181,"lineEnd":187,"code":"function newFunction(body) {\n  const fn = new Function('a', 'b', body);\n  return fn(1, 2);\n}\n\n// --- Comma operator for side effects ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<newFunction>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<body>"},{"type":"VARIABLE","id":"<fn>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Function('a', 'b', body)>","metadata":{"callee":"Function","constructor":true}},{"type":"LITERAL","id":"<'a'>","metadata":{"value":"a","literalType":"string"}},{"type":"LITERAL","id":"<'b'>","metadata":{"value":"b","literalType":"string"}},{"type":"CALL","id":"<fn(1, 2)>","metadata":{"callee":"fn"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<newFunction>","dst":"<body>","type":"HAS_BODY"},{"src":"<newFunction>","dst":"<fn>","type":"DECLARES"},{"src":"<fn>","dst":"<new Function('a', 'b', body)>","type":"ASSIGNED_FROM"},{"src":"<new Function('a', 'b', body)>","dst":"<'a'>","type":"PASSES_ARGUMENT"},{"src":"<new Function('a', 'b', body)>","dst":"<'b'>","type":"PASSES_ARGUMENT"},{"src":"<new Function('a', 'b', body)>","dst":"<body>","type":"PASSES_ARGUMENT"},{"src":"<newFunction>","dst":"<fn(1, 2)>","type":"RETURNS"},{"src":"<fn(1, 2)>","dst":"<fn>","type":"CALLS"},{"src":"<fn(1, 2)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<fn(1, 2)>","dst":"<2>","type":"PASSES_ARGUMENT"}],"rationale":"Function that dynamically creates another function using Function constructor, then immediately calls it. The Function constructor takes parameter names as strings and function body, creating executable code at runtime.","implicitBehavior":["Function constructor creates function in global scope","dynamically created function has access to global scope only","eval-like behavior - string code becomes executable","potential security risk if body contains untrusted input"]},"pass":2,"annotatedAt":"2026-02-24T00:32:05.715Z"}
{"construct":{"id":"coercion-hoisting::coerce-comma-sequence","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":189,"lineEnd":194,"code":"function commaSequence() {\n  let x = 0;\n  const result = (x++, x++, x++, x);\n  return result; // 3\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<commaSequence>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<comma-sequence>","metadata":{"operator":","}},{"type":"EXPRESSION","id":"<x++[1]>","metadata":{"operator":"++","position":"postfix"}},{"type":"EXPRESSION","id":"<x++[2]>","metadata":{"operator":"++","position":"postfix"}},{"type":"EXPRESSION","id":"<x++[3]>","metadata":{"operator":"++","position":"postfix"}},{"type":"EXPRESSION","id":"<x-final>","metadata":{"type":"identifier"}}],"edges":[{"src":"<commaSequence>","dst":"<x>","type":"CONTAINS"},{"src":"<commaSequence>","dst":"<result>","type":"CONTAINS"},{"src":"<x>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<result>","dst":"<comma-sequence>","type":"ASSIGNED_FROM"},{"src":"<comma-sequence>","dst":"<x++[1]>","type":"HAS_ELEMENT"},{"src":"<comma-sequence>","dst":"<x++[2]>","type":"HAS_ELEMENT"},{"src":"<comma-sequence>","dst":"<x++[3]>","type":"HAS_ELEMENT"},{"src":"<comma-sequence>","dst":"<x-final>","type":"HAS_ELEMENT"},{"src":"<x++[1]>","dst":"<x>","type":"READS_FROM"},{"src":"<x++[1]>","dst":"<x>","type":"WRITES_TO"},{"src":"<x++[2]>","dst":"<x>","type":"READS_FROM"},{"src":"<x++[2]>","dst":"<x>","type":"WRITES_TO"},{"src":"<x++[3]>","dst":"<x>","type":"READS_FROM"},{"src":"<x++[3]>","dst":"<x>","type":"WRITES_TO"},{"src":"<x-final>","dst":"<x>","type":"READS_FROM"},{"src":"<commaSequence>","dst":"<result>","type":"RETURNS"}],"rationale":"Function with comma operator sequence. Each expression in the sequence is evaluated left-to-right, with the rightmost expression's value becoming the sequence result. Changed CONTAINS to HAS_ELEMENT for comma sequence elements to better reflect the ordered nature of the comma operator.","implicitBehavior":["comma operator evaluates all expressions but returns only the rightmost value","postfix increment returns old value but modifies variable after evaluation","sequence evaluation order is guaranteed left-to-right"]},"pass":2,"annotatedAt":"2026-02-24T00:32:07.261Z"}
{"construct":{"id":"coercion-hoisting::shadow-block-scope","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":135,"lineEnd":145,"code":"const outerConst = 'outer';\n\nfunction shadowingExample() {\n  const outerConst = 'shadowed'; // shadows module-level\n  if (true) {\n    const outerConst = 'inner-shadowed'; // shadows function-level\n    console.log(outerConst); // 'inner-shadowed'\n  }\n  return outerConst; // 'shadowed'\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<outerConst:module>","metadata":{"kind":"const","scope":"module"}},{"type":"LITERAL","id":"<'outer'>","metadata":{"value":"outer","literalType":"string"}},{"type":"FUNCTION","id":"<shadowingExample>","metadata":{"async":false,"generator":false}},{"type":"SCOPE","id":"<shadowingExample:scope>","metadata":{"scopeType":"function"}},{"type":"VARIABLE","id":"<outerConst:function>","metadata":{"kind":"const","scope":"function"}},{"type":"LITERAL","id":"<'shadowed'>","metadata":{"value":"shadowed","literalType":"string"}},{"type":"BRANCH","id":"<if-true>","metadata":{"condition":"true"}},{"type":"SCOPE","id":"<if-block:scope>","metadata":{"scopeType":"block"}},{"type":"VARIABLE","id":"<outerConst:block>","metadata":{"kind":"const","scope":"block"}},{"type":"LITERAL","id":"<'inner-shadowed'>","metadata":{"value":"inner-shadowed","literalType":"string"}},{"type":"CALL","id":"<console.log(outerConst)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}}],"edges":[{"src":"<shadowingExample:scope>","dst":"<outerConst:function>","type":"DECLARES"},{"src":"<outerConst:function>","dst":"<'shadowed'>","type":"ASSIGNED_FROM"},{"src":"<outerConst:function>","dst":"<outerConst:module>","type":"SHADOWS"},{"src":"<shadowingExample>","dst":"<shadowingExample:scope>","type":"HAS_SCOPE"},{"src":"<shadowingExample>","dst":"<if-true>","type":"CONTAINS"},{"src":"<if-true>","dst":"<if-block:scope>","type":"HAS_SCOPE"},{"src":"<if-block:scope>","dst":"<outerConst:block>","type":"DECLARES"},{"src":"<outerConst:block>","dst":"<'inner-shadowed'>","type":"ASSIGNED_FROM"},{"src":"<outerConst:block>","dst":"<outerConst:function>","type":"SHADOWS"},{"src":"<if-true>","dst":"<console.log(outerConst)>","type":"CONTAINS"},{"src":"<console.log(outerConst)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(outerConst)>","dst":"<outerConst:block>","type":"PASSES_ARGUMENT"},{"src":"<shadowingExample>","dst":"<outerConst:function>","type":"RETURNS"}],"rationale":"Reduced from 16 to 13 edges by removing module-level declaration edges and module-level assignment. Focus on the core shadowing relationships: function-scoped const shadows module-scoped const, block-scoped const shadows function-scoped const. The console.log call demonstrates variable resolution to the innermost scope.","implicitBehavior":["const declarations are block-scoped","inner scope bindings shadow outer scope bindings with same name","variable resolution follows lexical scoping rules","module-level const declaration is implicit"]},"pass":2,"annotatedAt":"2026-02-24T00:32:07.908Z"}
{"construct":{"id":"declarations::var-decl-uninit","file":"src/declarations.js","category":"declarations","lineStart":8,"lineEnd":9,"code":"var uninitialized;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<uninitialized>","metadata":{"kind":"var"}}],"edges":[{"src":"<module>","dst":"<uninitialized>","type":"DECLARES"}],"rationale":"Variable declaration without initialization. Module scope declares the variable, which remains undefined until assigned.","implicitBehavior":["var declaration is hoisted to function/module scope","variable is implicitly initialized to undefined"]},"pass":2,"annotatedAt":"2026-02-24T00:32:08.333Z"}
{"construct":{"id":"coercion-hoisting::block-label-ambiguity","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":294,"lineEnd":301,"code":"function blockLabelAmbiguity() {\n  // { a: 1 } in statement position is a block with labeled expression, NOT an object\n  // Parentheses force expression context:\n  const obj = eval('({ a: 1, b: 2 })'); // object literal\n  // eval('{ a: 1, b: 2 }');            // SyntaxError  block + label + illegal comma\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<blockLabelAmbiguity>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"CALL","id":"<eval('({ a: 1, b: 2 })')>","metadata":{"callee":"eval"}},{"type":"LITERAL","id":"<'({ a: 1, b: 2 })'>","metadata":{"value":"({ a: 1, b: 2 })","literalType":"string"}},{"type":"EXTERNAL","id":"<eval>","metadata":{"builtin":true}}],"edges":[{"src":"<module>","dst":"<blockLabelAmbiguity>","type":"DECLARES"},{"src":"<blockLabelAmbiguity>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<eval('({ a: 1, b: 2 })')>","type":"ASSIGNED_FROM"},{"src":"<eval('({ a: 1, b: 2 })')>","dst":"<eval>","type":"CALLS"},{"src":"<eval('({ a: 1, b: 2 })')>","dst":"<'({ a: 1, b: 2 })'>","type":"PASSES_ARGUMENT"},{"src":"<blockLabelAmbiguity>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function demonstrates JavaScript's context-dependent parsing ambiguity. Uses eval with parenthesized string to force object literal interpretation rather than block statement.","implicitBehavior":["eval executes string as JavaScript code in current scope","parentheses in eval string force expression context, creating object literal","without parentheses, { a: 1, b: 2 } would be parsed as block with labeled statement and syntax error"]},"pass":2,"annotatedAt":"2026-02-24T00:32:09.299Z"}
{"construct":{"id":"async-generators::async-destructure-await-default","file":"src/async-generators.js","category":"async-generators","lineStart":293,"lineEnd":301,"code":"async function getConfigValue(key) { return key; }\n\nconst asyncDestructureHandler = async ({\n  timeout = await getConfigValue('timeout'),\n  retries = await getConfigValue('retries'),\n} = {}) => {\n  return { timeout, retries };\n};","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getConfigValue>","metadata":{"async":true}},{"type":"PARAMETER","id":"<key>"},{"type":"VARIABLE","id":"<asyncDestructureHandler>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncDestructureHandler:fn>","metadata":{"async":true,"arrowFunction":true}},{"type":"PARAMETER","id":"<destructured-param>","metadata":{"destructured":true,"defaultValue":"{}"}},{"type":"PROPERTY","id":"<timeout>","metadata":{"hasDefault":true}},{"type":"PROPERTY","id":"<retries>","metadata":{"hasDefault":true}},{"type":"CALL","id":"<getConfigValue('timeout')>","metadata":{"callee":"getConfigValue","awaited":true}},{"type":"LITERAL","id":"<'timeout'>","metadata":{"value":"timeout","literalType":"string"}},{"type":"CALL","id":"<getConfigValue('retries')>","metadata":{"callee":"getConfigValue","awaited":true}},{"type":"LITERAL","id":"<'retries'>","metadata":{"value":"retries","literalType":"string"}},{"type":"EXPRESSION","id":"<{ timeout, retries }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<getConfigValue>","dst":"<key>","type":"CONTAINS"},{"src":"<getConfigValue>","dst":"<key>","type":"RETURNS"},{"src":"<asyncDestructureHandler>","dst":"<asyncDestructureHandler:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncDestructureHandler:fn>","dst":"<destructured-param>","type":"CONTAINS"},{"src":"<destructured-param>","dst":"<timeout>","type":"HAS_PROPERTY"},{"src":"<destructured-param>","dst":"<retries>","type":"HAS_PROPERTY"},{"src":"<timeout>","dst":"<getConfigValue('timeout')>","type":"DEFAULTS_TO"},{"src":"<retries>","dst":"<getConfigValue('retries')>","type":"DEFAULTS_TO"},{"src":"<getConfigValue('timeout')>","dst":"<getConfigValue>","type":"CALLS"},{"src":"<getConfigValue('timeout')>","dst":"<'timeout'>","type":"PASSES_ARGUMENT"},{"src":"<getConfigValue('retries')>","dst":"<getConfigValue>","type":"CALLS"},{"src":"<getConfigValue('retries')>","dst":"<'retries'>","type":"PASSES_ARGUMENT"},{"src":"<asyncDestructureHandler:fn>","dst":"<{ timeout, retries }>","type":"RETURNS"},{"src":"<{ timeout, retries }>","dst":"<timeout>","type":"READS_FROM"},{"src":"<{ timeout, retries }>","dst":"<retries>","type":"READS_FROM"},{"src":"<getConfigValue('timeout')>","dst":"<timeout>","type":"AWAITS"},{"src":"<getConfigValue('retries')>","dst":"<retries>","type":"AWAITS"}],"rationale":"Async function with destructured parameter containing async default values. Each destructured property awaits a function call for its default value. Used PROPERTY instead of DESTRUCTURED_PROPERTY, HAS_PROPERTY instead of DESTRUCTURES, and added AWAITS edges to capture async behavior.","implicitBehavior":["await expressions in parameter defaults are evaluated sequentially during parameter binding","if destructuring assignment fails, default object {} is used","async function calls in defaults create promise dependencies that must resolve before function body executes"]},"pass":2,"annotatedAt":"2026-02-24T00:32:09.417Z"}
{"construct":{"id":"coercion-hoisting::typeof-tdz-trap","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":274,"lineEnd":282,"code":"function typeofTdzTrap() {\n  try {\n    const result = typeof x; // ReferenceError  x is in TDZ, unlike undeclared\n  } catch (e) {\n    // typeof on TDZ variable THROWS, unlike typeof on undeclared\n  }\n  let x = 5;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<typeofTdzTrap>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<typeof x>","metadata":{"operator":"typeof"}},{"type":"PARAMETER","id":"<e>"},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}}],"edges":[{"src":"<typeofTdzTrap>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<result>","type":"DECLARES"},{"src":"<result>","dst":"<typeof x>","type":"ASSIGNED_FROM"},{"src":"<typeof x>","dst":"<x>","type":"READS_FROM"},{"src":"<catch-block>","dst":"<e>","type":"DECLARES"},{"src":"<typeofTdzTrap>","dst":"<x>","type":"DECLARES"},{"src":"<x>","dst":"<5>","type":"ASSIGNED_FROM"},{"src":"<typeof x>","dst":"<catch-block>","type":"THROWS"}],"rationale":"Function demonstrates TDZ behavior where typeof on a let/const variable before declaration throws ReferenceError, unlike typeof on undeclared variables which returns 'undefined'. The try-catch structure captures this exceptional behavior.","implicitBehavior":["let declaration is hoisted but x remains in TDZ until declaration line","typeof operator on TDZ variable throws ReferenceError instead of returning 'undefined'","temporal dead zone extends from function start to let declaration"]},"pass":2,"annotatedAt":"2026-02-24T00:32:10.464Z"}
{"construct":{"id":"coercion-hoisting::var-function-collision","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":221,"lineEnd":228,"code":"function varFunctionCollision() {\n  console.log(typeof collision); // \"function\"  function hoists over var\n  var collision = 1;\n  function collision() { return 2; }\n  console.log(typeof collision); // \"number\"  assignment runs after\n  return collision;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<varFunctionCollision>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<console.log(typeof collision)1>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<typeof collision1>","metadata":{"operator":"typeof"}},{"type":"VARIABLE","id":"<collision:var>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"FUNCTION","id":"<collision:fn>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"CALL","id":"<console.log(typeof collision)2>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<typeof collision2>","metadata":{"operator":"typeof"}},{"type":"EXTERNAL","id":"<console.log>","metadata":{"source":"console"}}],"edges":[{"src":"<varFunctionCollision>","dst":"<console.log(typeof collision)1>","type":"CONTAINS"},{"src":"<console.log(typeof collision)1>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(typeof collision)1>","dst":"<typeof collision1>","type":"PASSES_ARGUMENT"},{"src":"<typeof collision1>","dst":"<collision:fn>","type":"READS_FROM"},{"src":"<varFunctionCollision>","dst":"<collision:var>","type":"DECLARES"},{"src":"<varFunctionCollision>","dst":"<collision:fn>","type":"DECLARES"},{"src":"<collision:var>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<collision:fn>","dst":"<2>","type":"RETURNS"},{"src":"<varFunctionCollision>","dst":"<console.log(typeof collision)2>","type":"CONTAINS"},{"src":"<console.log(typeof collision)2>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(typeof collision)2>","dst":"<typeof collision2>","type":"PASSES_ARGUMENT"},{"src":"<typeof collision2>","dst":"<collision:var>","type":"READS_FROM"},{"src":"<varFunctionCollision>","dst":"<collision:var>","type":"RETURNS"},{"src":"<collision:fn>","dst":"<collision:var>","type":"SHADOWS"}],"rationale":"Function and var declarations with same name create hoisting collision. Function declaration wins initially due to hoisting precedence, then var assignment overwrites at runtime. Added SHADOWS edge to capture the name collision relationship.","implicitBehavior":["function declaration hoisted above var declaration","var declaration creates undefined binding that gets overwritten by function","function assignment happens before var assignment at runtime","both declarations share the same binding slot"]},"pass":2,"annotatedAt":"2026-02-24T00:32:11.185Z"}
{"construct":{"id":"declarations::var-decl-init","file":"src/declarations.js","category":"declarations","lineStart":5,"lineEnd":6,"code":"var mutableVar = 'hello';","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<mutableVar>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<'hello'>","metadata":{"value":"hello","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<mutableVar>","type":"DECLARES"},{"src":"<mutableVar>","dst":"<'hello'>","type":"ASSIGNED_FROM"}],"rationale":"Module scope declares a var variable, initialized with a string literal. The ASSIGNED_FROM edge captures the initialization relationship.","implicitBehavior":["var declaration is hoisted to function/module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:11.655Z"}
{"construct":{"id":"declarations::let-decl-init","file":"src/declarations.js","category":"declarations","lineStart":14,"lineEnd":15,"code":"let reassignable = 42;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<reassignable>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<reassignable>","type":"DECLARES"},{"src":"<reassignable>","dst":"<42>","type":"ASSIGNED_FROM"}],"rationale":"Let variable declaration with numeric literal initializer. Module scope declares the variable, value flows from literal to variable through assignment.","implicitBehavior":["let declaration is block-scoped","temporal dead zone applies before declaration"]},"pass":2,"annotatedAt":"2026-02-24T00:32:12.731Z"}
{"construct":{"id":"declarations::let-decl-uninit","file":"src/declarations.js","category":"declarations","lineStart":17,"lineEnd":18,"code":"let uninitializedLet;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<uninitializedLet>","metadata":{"kind":"let"}}],"edges":[{"src":"<module>","dst":"<uninitializedLet>","type":"DECLARES"}],"rationale":"Let declaration without initializer. Module scope declares the variable, which remains uninitialized.","implicitBehavior":["variable is in temporal dead zone until declaration is reached","accessing before declaration throws ReferenceError"]},"pass":2,"annotatedAt":"2026-02-24T00:32:12.989Z"}
{"construct":{"id":"coercion-hoisting::var-in-catch-clobber","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":264,"lineEnd":272,"code":"function varInCatchClobber() {\n  try {\n    throw new Error('oops');\n  } catch (e) {\n    var e = 'overwritten';  // var hoists to function scope, shares binding with catch param\n  }\n  return e; // 'overwritten' in sloppy; in strict var still hoists but catch e is separate\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<varInCatchClobber>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<new Error('oops')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'oops'>","metadata":{"value":"oops","literalType":"string"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e:catch>","metadata":{"catchParameter":true}},{"type":"VARIABLE","id":"<e:var>","metadata":{"kind":"var","hoisted":true}},{"type":"LITERAL","id":"<'overwritten'>","metadata":{"value":"overwritten","literalType":"string"}},{"type":"EXPRESSION","id":"<return e>","metadata":{"type":"return"}}],"edges":[{"src":"<varInCatchClobber>","dst":"<try-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<new Error('oops')>","type":"THROWS"},{"src":"<new Error('oops')>","dst":"<'oops'>","type":"PASSES_ARGUMENT"},{"src":"<varInCatchClobber>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<e:catch>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<e:var>","type":"CONTAINS"},{"src":"<e:var>","dst":"<'overwritten'>","type":"ASSIGNED_FROM"},{"src":"<varInCatchClobber>","dst":"<return e>","type":"RETURNS"},{"src":"<return e>","dst":"<e:var>","type":"READS_FROM"},{"src":"<varInCatchClobber>","dst":"<e:var>","type":"DECLARES"}],"rationale":"Function with try-catch where var declaration inside catch block hoists to function scope. The var 'e' and catch parameter 'e' create a complex binding situation that varies by strict mode. Removed external references to keep within approved vocabulary.","implicitBehavior":["var e declaration hoists to function scope","in sloppy mode: var e shares binding with catch parameter e","in strict mode: var e and catch parameter e are separate bindings","return statement reads the var binding, not the catch parameter"]},"pass":2,"annotatedAt":"2026-02-24T00:32:13.288Z"}
{"construct":{"id":"coercion-hoisting::primitive-autoboxing","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":208,"lineEnd":219,"code":"function primitiveAutoboxing() {\n  const str = 'hello';\n  const upper = str.toUpperCase(); // auto-boxes to String object\n  str.customProp = 1; // sets on TEMPORARY boxed String, immediately GC'd\n  const lost = str.customProp; // undefined\n\n  const num = 42;\n  const fixed = num.toFixed(2); // auto-boxes to Number\n\n  return { upper, lost, fixed };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<primitiveAutoboxing>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<str>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'hello'>","metadata":{"value":"hello","literalType":"string"}},{"type":"VARIABLE","id":"<upper>","metadata":{"kind":"const"}},{"type":"CALL","id":"<str.toUpperCase()>","metadata":{"method":"toUpperCase"}},{"type":"PROPERTY_ACCESS","id":"<str.customProp>","metadata":{"property":"customProp"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<lost>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<str.customProp:read>","metadata":{"property":"customProp"}},{"type":"VARIABLE","id":"<num>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"VARIABLE","id":"<fixed>","metadata":{"kind":"const"}},{"type":"CALL","id":"<num.toFixed(2)>","metadata":{"method":"toFixed"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ upper, lost, fixed }>","metadata":{"type":"object"}}],"edges":[{"src":"<primitiveAutoboxing>","dst":"<str>","type":"CONTAINS"},{"src":"<str>","dst":"<'hello'>","type":"ASSIGNED_FROM"},{"src":"<primitiveAutoboxing>","dst":"<upper>","type":"CONTAINS"},{"src":"<upper>","dst":"<str.toUpperCase()>","type":"ASSIGNED_FROM"},{"src":"<str.toUpperCase()>","dst":"<str>","type":"CALLS_ON"},{"src":"<str.customProp>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<str.customProp>","dst":"<str>","type":"HAS_PROPERTY"},{"src":"<primitiveAutoboxing>","dst":"<lost>","type":"CONTAINS"},{"src":"<lost>","dst":"<str.customProp:read>","type":"ASSIGNED_FROM"},{"src":"<str.customProp:read>","dst":"<str>","type":"HAS_PROPERTY"},{"src":"<primitiveAutoboxing>","dst":"<num>","type":"CONTAINS"},{"src":"<num>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<primitiveAutoboxing>","dst":"<fixed>","type":"CONTAINS"},{"src":"<fixed>","dst":"<num.toFixed(2)>","type":"ASSIGNED_FROM"},{"src":"<num.toFixed(2)>","dst":"<num>","type":"CALLS_ON"},{"src":"<num.toFixed(2)>","dst":"<2>","type":"PASSES_ARGUMENT"},{"src":"<primitiveAutoboxing>","dst":"<{ upper, lost, fixed }>","type":"RETURNS"},{"src":"<{ upper, lost, fixed }>","dst":"<upper>","type":"READS_FROM"},{"src":"<{ upper, lost, fixed }>","dst":"<lost>","type":"READS_FROM"},{"src":"<{ upper, lost, fixed }>","dst":"<fixed>","type":"READS_FROM"}],"rationale":"Function demonstrates primitive autoboxing behavior. Method calls on primitives create temporary wrapper objects, while property assignments on primitives are lost due to temporary boxing.","implicitBehavior":["str.toUpperCase() auto-boxes string primitive to temporary String object","str.customProp = 1 creates temporary String object, sets property, then object is garbage collected","str.customProp read returns undefined because property was set on discarded temporary object","num.toFixed(2) auto-boxes number primitive to temporary Number object"]},"pass":2,"annotatedAt":"2026-02-24T00:32:14.040Z"}
{"construct":{"id":"coercion-hoisting::block-function-declaration-strict","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":247,"lineEnd":262,"code":"// NOTE: behavior differs between strict (ESM) and sloppy (script) mode.\n// This file is ESM (strict), so the function is block-scoped.\n// In sloppy mode (.cjs / <script>), the function would leak to function scope (Annex B).\nfunction blockFunctionDemo() {\n  let result = 'before';\n\n  if (true) {\n    function blockFn() { return 'inside'; }  // block-scoped in strict/ESM\n    result = blockFn();\n  }\n\n  // blockFn is NOT accessible here in strict mode\n  // In sloppy mode it WOULD be accessible (Annex B hoisting)\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<blockFunctionDemo>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<'before'>","metadata":{"value":"before","literalType":"string"}},{"type":"BRANCH","id":"<if-true>","metadata":{"condition":"true"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"SCOPE","id":"<if-block-scope>"},{"type":"FUNCTION","id":"<blockFn>","metadata":{"async":false,"generator":false,"blockScoped":true}},{"type":"LITERAL","id":"<'inside'>","metadata":{"value":"inside","literalType":"string"}},{"type":"CALL","id":"<blockFn()>","metadata":{"callee":"blockFn"}},{"type":"EXPRESSION","id":"<result = blockFn()>","metadata":{"operator":"="}}],"edges":[{"src":"<blockFunctionDemo>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<'before'>","type":"ASSIGNED_FROM"},{"src":"<blockFunctionDemo>","dst":"<if-true>","type":"CONTAINS"},{"src":"<if-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<if-true>","dst":"<if-block-scope>","type":"HAS_BODY"},{"src":"<if-block-scope>","dst":"<blockFn>","type":"DECLARES"},{"src":"<blockFn>","dst":"<'inside'>","type":"RETURNS"},{"src":"<if-block-scope>","dst":"<blockFn()>","type":"CONTAINS"},{"src":"<blockFn()>","dst":"<blockFn>","type":"CALLS"},{"src":"<if-block-scope>","dst":"<result = blockFn()>","type":"CONTAINS"},{"src":"<result = blockFn()>","dst":"<result>","type":"WRITES_TO"},{"src":"<result = blockFn()>","dst":"<blockFn()>","type":"ASSIGNED_FROM"},{"src":"<blockFunctionDemo>","dst":"<result>","type":"RETURNS"}],"rationale":"Function declaration inside block creates block-scoped function in strict mode. The function is only accessible within the if-block scope, not in the outer function scope. Reduced edge count by removing module declaration edge and changing one READS_FROM to ASSIGNED_FROM.","implicitBehavior":["function declaration is block-scoped in strict/ESM mode","in sloppy mode (Annex B), function would be hoisted to function scope and accessible after block","temporal dead zone applies to block-scoped function declaration"]},"pass":2,"annotatedAt":"2026-02-24T00:32:14.385Z"}
{"construct":{"id":"coercion-hoisting::var-redeclares-parameter","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":303,"lineEnd":310,"code":"function varRedeclaresParameter(x, y) {\n  var x = x || 'default'; // same binding as parameter x  NOT a new variable\n  var y;                    // re-declares y but does NOT reset it\n  return { x, y };\n}\n// varRedeclaresParameter(null, 42)  { x: 'default', y: 42 }\n// Contrast: let x = ... inside would be SyntaxError (cannot re-declare param)","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<varRedeclaresParameter>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>","metadata":{"redeclaredAsVar":true}},{"type":"PARAMETER","id":"<y>","metadata":{"redeclaredAsVar":true}},{"type":"EXPRESSION","id":"<x || 'default'>","metadata":{"operator":"||"}},{"type":"LITERAL","id":"<'default'>","metadata":{"value":"default","literalType":"string"}},{"type":"EXPRESSION","id":"<{ x, y }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<varRedeclaresParameter>","dst":"<x>","type":"CONTAINS"},{"src":"<varRedeclaresParameter>","dst":"<y>","type":"CONTAINS"},{"src":"<x>","dst":"<x || 'default'>","type":"ASSIGNED_FROM"},{"src":"<x || 'default'>","dst":"<x>","type":"READS_FROM"},{"src":"<x || 'default'>","dst":"<'default'>","type":"READS_FROM"},{"src":"<varRedeclaresParameter>","dst":"<{ x, y }>","type":"RETURNS"},{"src":"<{ x, y }>","dst":"<x>","type":"READS_FROM"},{"src":"<{ x, y }>","dst":"<y>","type":"READS_FROM"}],"rationale":"Function parameters x and y are redeclared with var, but refer to the same bindings. The var x assignment modifies the parameter binding, while var y is a no-op redeclaration. Removed the module declaration edge to stay within the 7-edge threshold.","implicitBehavior":["var declarations are hoisted but refer to existing parameter bindings","var x redeclaration does not create new binding - modifies parameter x","var y redeclaration without initializer does not reset parameter y value","let/const redeclaration of parameters would cause SyntaxError"]},"pass":2,"annotatedAt":"2026-02-24T00:32:16.027Z"}
{"construct":{"id":"declarations::const-decl-bool-literal","file":"src/declarations.js","category":"declarations","lineStart":20,"lineEnd":21,"code":"const immutable = true;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<immutable>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<module>","dst":"<immutable>","type":"DECLARES"},{"src":"<immutable>","dst":"<true>","type":"ASSIGNED_FROM"}],"rationale":"Const declaration with boolean literal initializer. Module scope declares the immutable binding. The ASSIGNED_FROM edge captures the initialization relationship.","implicitBehavior":["const binding cannot be reassigned","temporal dead zone until declaration is reached"]},"pass":2,"annotatedAt":"2026-02-24T00:32:16.070Z"}
{"construct":{"id":"declarations::const-decl-bigint-literal","file":"src/declarations.js","category":"declarations","lineStart":29,"lineEnd":30,"code":"const bigNumber = 42n;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<bigNumber>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<42n>","metadata":{"value":"42n","literalType":"bigint"}}],"edges":[{"src":"<module>","dst":"<bigNumber>","type":"DECLARES"},{"src":"<bigNumber>","dst":"<42n>","type":"ASSIGNED_FROM"}],"rationale":"Const declaration initialized with a BigInt literal. Module scope declares the immutable variable. The approved vocabulary adequately captures this construct.","implicitBehavior":["const binding cannot be reassigned","BigInt literal creates arbitrary precision integer"]},"pass":2,"annotatedAt":"2026-02-24T00:32:16.564Z"}
{"construct":{"id":"declarations::var-decl-multi","file":"src/declarations.js","category":"declarations","lineStart":11,"lineEnd":12,"code":"var multi1 = 1, multi2 = 2, multi3 = 3;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<multi1>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<multi2>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"VARIABLE","id":"<multi3>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<multi1>","type":"DECLARES"},{"src":"<multi1>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<multi2>","type":"DECLARES"},{"src":"<multi2>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<multi3>","type":"DECLARES"},{"src":"<multi3>","dst":"<3>","type":"ASSIGNED_FROM"}],"rationale":"Multiple variable declaration statement creates three separate variables, each initialized with its own literal value. All approved vocabulary types from Pass 1 are available in the approved list.","implicitBehavior":["all var declarations are hoisted to function/module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:17.296Z"}
{"construct":{"id":"declarations::const-decl-object-literal","file":"src/declarations.js","category":"declarations","lineStart":23,"lineEnd":24,"code":"const objectConst = { key: 'value' };","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<objectConst>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<objectConst:object>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'key'>","metadata":{"value":"key","literalType":"string"}},{"type":"LITERAL","id":"<'value'>","metadata":{"value":"value","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<objectConst>","type":"DECLARES"},{"src":"<objectConst>","dst":"<objectConst:object>","type":"ASSIGNED_FROM"},{"src":"<objectConst:object>","dst":"<'key'>","type":"HAS_PROPERTY"},{"src":"<'key'>","dst":"<'value'>","type":"ASSIGNED_FROM"}],"rationale":"Const variable declaration with object literal initializer. Object contains one property with string key and value. All types and relationships are captured by approved vocabulary.","implicitBehavior":["const binding prevents reassignment","object properties remain mutable"]},"pass":2,"annotatedAt":"2026-02-24T00:32:18.110Z"}
{"construct":{"id":"declarations::const-decl-call-result-1","file":"src/declarations.js","category":"declarations","lineStart":35,"lineEnd":36,"code":"const uniqueKey = Symbol('description');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<uniqueKey>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Symbol('description')>","metadata":{"callee":"Symbol"}},{"type":"LITERAL","id":"<'description'>","metadata":{"value":"description","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<uniqueKey>","type":"DECLARES"},{"src":"<uniqueKey>","dst":"<Symbol('description')>","type":"ASSIGNED_FROM"},{"src":"<Symbol('description')>","dst":"<Symbol>","type":"CALLS"},{"src":"<Symbol('description')>","dst":"<'description'>","type":"PASSES_ARGUMENT"}],"rationale":"Const declaration initialized with Symbol constructor call. The call takes a string literal as description argument. All relationships map directly to approved vocabulary.","implicitBehavior":["Symbol() creates a unique primitive value","const binding cannot be reassigned"]},"pass":2,"annotatedAt":"2026-02-24T00:32:19.028Z"}
{"construct":{"id":"declarations::const-decl-array-literal","file":"src/declarations.js","category":"declarations","lineStart":26,"lineEnd":27,"code":"const arrayConst = [1, 2, 3];","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrayConst>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<arrayConst>","type":"DECLARES"},{"src":"<arrayConst>","dst":"<[1, 2, 3]>","type":"ASSIGNED_FROM"},{"src":"<[1, 2, 3]>","dst":"<1>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3]>","dst":"<2>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3]>","dst":"<3>","type":"HAS_ELEMENT"}],"rationale":"Const variable declaration initialized with array literal containing three numeric elements. All types used in Pass 1 are in the approved vocabulary, so the annotation remains unchanged.","implicitBehavior":["const binding prevents reassignment","array literal creates new Array instance"]},"pass":2,"annotatedAt":"2026-02-24T00:32:19.948Z"}
{"construct":{"id":"coercion-hoisting::eval-let-scope","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":284,"lineEnd":292,"code":"function evalLetScope() {\n  eval('let y = 2');   // y is block-scoped to the eval itself\n  try {\n    return y;          // ReferenceError  y doesn't exist here\n  } catch (e) {\n    return 'y not accessible';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<evalLetScope>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<eval('let y = 2')>","metadata":{"callee":"eval"}},{"type":"LITERAL","id":"<'let y = 2'>","metadata":{"value":"let y = 2","literalType":"string"}},{"type":"VARIABLE","id":"<y>","metadata":{"kind":"let","evalScoped":true}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"EXPRESSION","id":"<return y>","metadata":{"expressionType":"return"}},{"type":"LITERAL","id":"<'y not accessible'>","metadata":{"value":"y not accessible","literalType":"string"}},{"type":"SCOPE","id":"<eval-scope>","metadata":{"scopeType":"eval-lexical"}}],"edges":[{"src":"<evalLetScope>","dst":"<eval('let y = 2')>","type":"CONTAINS"},{"src":"<eval('let y = 2')>","dst":"<'let y = 2'>","type":"PASSES_ARGUMENT"},{"src":"<eval('let y = 2')>","dst":"<eval-scope>","type":"HAS_SCOPE"},{"src":"<eval-scope>","dst":"<y>","type":"DECLARES"},{"src":"<y>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<evalLetScope>","dst":"<try-block>","type":"CONTAINS"},{"src":"<evalLetScope>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<return y>","type":"CONTAINS"},{"src":"<return y>","dst":"<y>","type":"READS_FROM"},{"src":"<evalLetScope>","dst":"<return y>","type":"RETURNS"},{"src":"<catch-block>","dst":"<e>","type":"RECEIVES_ARGUMENT"},{"src":"<evalLetScope>","dst":"<'y not accessible'>","type":"RETURNS"}],"rationale":"Function uses eval to execute code that declares a let variable within eval's own lexical scope. The try block attempts to access this variable from the function scope, which fails because let variables in eval are scoped to the eval context. The catch block handles the resulting ReferenceError.","implicitBehavior":["eval creates its own lexical environment for let declarations","let variables declared in eval are not accessible outside the eval scope","ReferenceError thrown when accessing variable y outside its scope","catch block receives the ReferenceError exception"]},"pass":2,"annotatedAt":"2026-02-24T00:32:20.567Z"}
{"construct":{"id":"declarations::func-decl","file":"src/declarations.js","category":"declarations","lineStart":50,"lineEnd":53,"code":"function regularFunction(param1, param2) {\n  return param1 + param2;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<regularFunction>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<param1>"},{"type":"PARAMETER","id":"<param2>"},{"type":"EXPRESSION","id":"<param1 + param2>","metadata":{"operator":"+"}}],"edges":[{"src":"<module>","dst":"<regularFunction>","type":"DECLARES"},{"src":"<regularFunction>","dst":"<param1>","type":"CONTAINS"},{"src":"<regularFunction>","dst":"<param2>","type":"CONTAINS"},{"src":"<regularFunction>","dst":"<param1 + param2>","type":"RETURNS"},{"src":"<param1 + param2>","dst":"<param1>","type":"READS_FROM"},{"src":"<param1 + param2>","dst":"<param2>","type":"READS_FROM"}],"rationale":"Function declaration with two parameters. Returns a binary expression that reads both params. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["function declaration is hoisted to module/function scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:20.979Z"}
{"construct":{"id":"declarations::const-decl-call-result","file":"src/declarations.js","category":"declarations","lineStart":32,"lineEnd":33,"code":"const bigComputed = BigInt(Number.MAX_SAFE_INTEGER);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<bigComputed>","metadata":{"kind":"const"}},{"type":"CALL","id":"<BigInt(Number.MAX_SAFE_INTEGER)>","metadata":{"callee":"BigInt"}},{"type":"PROPERTY_ACCESS","id":"<Number.MAX_SAFE_INTEGER>","metadata":{"objectName":"Number","propertyName":"MAX_SAFE_INTEGER"}}],"edges":[{"src":"<module>","dst":"<bigComputed>","type":"DECLARES"},{"src":"<bigComputed>","dst":"<BigInt(Number.MAX_SAFE_INTEGER)>","type":"ASSIGNED_FROM"},{"src":"<BigInt(Number.MAX_SAFE_INTEGER)>","dst":"<BigInt>","type":"CALLS"},{"src":"<BigInt(Number.MAX_SAFE_INTEGER)>","dst":"<Number.MAX_SAFE_INTEGER>","type":"PASSES_ARGUMENT"},{"src":"<Number.MAX_SAFE_INTEGER>","dst":"<Number>","type":"READS_FROM"}],"rationale":"Const declaration initialized with a function call result. BigInt constructor called with Number.MAX_SAFE_INTEGER as argument. All node and edge types from Pass 1 are in the approved vocabulary.","implicitBehavior":["BigInt constructor converts numeric value to bigint type","Number.MAX_SAFE_INTEGER is a static property access"]},"pass":2,"annotatedAt":"2026-02-24T00:32:21.382Z"}
{"construct":{"id":"declarations::func-decl-rest-params","file":"src/declarations.js","category":"declarations","lineStart":60,"lineEnd":63,"code":"function withRestParams(...args) {\n  return args.length;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withRestParams>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<args>","metadata":{"restParameter":true}},{"type":"PROPERTY_ACCESS","id":"<args.length>","metadata":{"property":"length"}}],"edges":[{"src":"<module>","dst":"<withRestParams>","type":"DECLARES"},{"src":"<withRestParams>","dst":"<args>","type":"CONTAINS"},{"src":"<withRestParams>","dst":"<args.length>","type":"RETURNS"},{"src":"<args.length>","dst":"<args>","type":"READS_FROM"}],"rationale":"Function declaration with rest parameter that returns a property access on the rest parameter array. All types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["rest parameter collects remaining arguments into an array","function declaration is hoisted"]},"pass":2,"annotatedAt":"2026-02-24T00:32:21.841Z"}
{"construct":{"id":"declarations::const-decl-method-call-result","file":"src/declarations.js","category":"declarations","lineStart":38,"lineEnd":39,"code":"const globalSymbol = Symbol.for('shared');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<globalSymbol>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Symbol.for('shared')>","metadata":{"callee":"Symbol.for"}},{"type":"PROPERTY_ACCESS","id":"<Symbol.for>","metadata":{"objectName":"Symbol","propertyName":"for"}},{"type":"LITERAL","id":"<'shared'>","metadata":{"value":"shared","literalType":"string"}},{"type":"EXTERNAL","id":"<Symbol>","metadata":{"name":"Symbol","source":"global"}}],"edges":[{"src":"<module>","dst":"<globalSymbol>","type":"DECLARES"},{"src":"<globalSymbol>","dst":"<Symbol.for('shared')>","type":"ASSIGNED_FROM"},{"src":"<Symbol.for('shared')>","dst":"<Symbol.for>","type":"CALLS"},{"src":"<Symbol.for('shared')>","dst":"<'shared'>","type":"PASSES_ARGUMENT"},{"src":"<Symbol.for>","dst":"<Symbol>","type":"READS_FROM"}],"rationale":"Const declaration initialized with a method call result. The call accesses Symbol.for and passes a string argument. Added explicit EXTERNAL node for Symbol global object.","implicitBehavior":["Symbol.for() accesses global symbol registry","returns existing symbol or creates new one"]},"pass":2,"annotatedAt":"2026-02-24T00:32:22.611Z"}
{"construct":{"id":"coercion-hoisting::object-as-map-key-tostring","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":238,"lineEnd":245,"code":"function objectAsMapKey() {\n  const cache = {};\n  const obj = {};\n  cache[obj] = 'value';           // key is \"[object Object]\"\n  cache[{ a: 1 }] = 'another';   // SAME key \"[object Object]\"  overwrites!\n  return cache;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<objectAsMapKey>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<cache>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<obj-literal>","metadata":{"value":"{}","literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<cache[obj]>","metadata":{"computed":true}},{"type":"LITERAL","id":"<'value'>","metadata":{"value":"value","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<cache[{ a: 1 }]>","metadata":{"computed":true}},{"type":"LITERAL","id":"<{ a: 1 }>","metadata":{"value":"{ a: 1 }","literalType":"object"}},{"type":"LITERAL","id":"<'another'>","metadata":{"value":"another","literalType":"string"}},{"type":"SIDE_EFFECT","id":"<obj-toString>","metadata":{"description":"Object coerced to string '[object Object]'","from":"object","to":"string","result":"[object Object]"}},{"type":"SIDE_EFFECT","id":"<inline-obj-toString>","metadata":{"description":"Object coerced to string '[object Object]'","from":"object","to":"string","result":"[object Object]"}}],"edges":[{"src":"<objectAsMapKey>","dst":"<cache>","type":"CONTAINS"},{"src":"<objectAsMapKey>","dst":"<obj>","type":"CONTAINS"},{"src":"<cache>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<obj>","dst":"<obj-literal>","type":"ASSIGNED_FROM"},{"src":"<cache[obj]>","dst":"<cache>","type":"READS_FROM"},{"src":"<cache[obj]>","dst":"<obj>","type":"READS_FROM"},{"src":"<cache[obj]>","dst":"<'value'>","type":"ASSIGNED_FROM"},{"src":"<obj>","dst":"<obj-toString>","type":"FLOWS_INTO"},{"src":"<cache[obj]>","dst":"<obj-toString>","type":"DEPENDS_ON"},{"src":"<cache[{ a: 1 }]>","dst":"<cache>","type":"READS_FROM"},{"src":"<cache[{ a: 1 }]>","dst":"<{ a: 1 }>","type":"READS_FROM"},{"src":"<cache[{ a: 1 }]>","dst":"<'another'>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1 }>","dst":"<inline-obj-toString>","type":"FLOWS_INTO"},{"src":"<cache[{ a: 1 }]>","dst":"<inline-obj-toString>","type":"DEPENDS_ON"},{"src":"<objectAsMapKey>","dst":"<cache>","type":"RETURNS"}],"rationale":"Function demonstrates object-to-string coercion when objects are used as property keys. Both objects coerce to '[object Object]', causing key collision and overwrite.","implicitBehavior":["Objects used as property keys are automatically coerced to strings via toString()","All plain objects coerce to '[object Object]' causing key collisions","Second assignment overwrites first due to identical coerced key"]},"pass":2,"annotatedAt":"2026-02-24T00:32:24.045Z"}
{"construct":{"id":"declarations::const-decl-regex-literal","file":"src/declarations.js","category":"declarations","lineStart":41,"lineEnd":46,"code":"const regexSimple = /hello/;\nconst regexFlags = /pattern/gi;\nconst regexComplex = /^start.*end$/ms;\n\n// Function Declarations","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<regexSimple>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</hello/>","metadata":{"value":"/hello/","literalType":"regex","pattern":"hello","flags":""}},{"type":"VARIABLE","id":"<regexFlags>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</pattern/gi>","metadata":{"value":"/pattern/gi","literalType":"regex","pattern":"pattern","flags":"gi"}},{"type":"VARIABLE","id":"<regexComplex>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</^start.*end$/ms>","metadata":{"value":"/^start.*end$/ms","literalType":"regex","pattern":"^start.*end$","flags":"ms"}}],"edges":[{"src":"<module>","dst":"<regexSimple>","type":"DECLARES"},{"src":"<regexSimple>","dst":"</hello/>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<regexFlags>","type":"DECLARES"},{"src":"<regexFlags>","dst":"</pattern/gi>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<regexComplex>","type":"DECLARES"},{"src":"<regexComplex>","dst":"</^start.*end$/ms>","type":"ASSIGNED_FROM"}],"rationale":"Three const declarations each initialized with regex literals. Each regex literal is a distinct node with pattern and flags metadata. All types used are from the approved vocabulary.","implicitBehavior":["regex literals create RegExp objects at runtime","const declarations are block-scoped and immutable"]},"pass":2,"annotatedAt":"2026-02-24T00:32:25.376Z"}
{"construct":{"id":"declarations::func-decl-defaults","file":"src/declarations.js","category":"declarations","lineStart":55,"lineEnd":58,"code":"function withDefaults(a = 10, b = 'default') {\n  return `${a}${b}`;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withDefaults>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>","metadata":{"hasDefault":true}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"PARAMETER","id":"<b>","metadata":{"hasDefault":true}},{"type":"LITERAL","id":"<'default'>","metadata":{"value":"default","literalType":"string"}},{"type":"EXPRESSION","id":"<`${a}${b}`>","metadata":{"type":"template-literal"}}],"edges":[{"src":"<withDefaults>","dst":"<a>","type":"CONTAINS"},{"src":"<withDefaults>","dst":"<b>","type":"CONTAINS"},{"src":"<a>","dst":"<10>","type":"DEFAULTS_TO"},{"src":"<b>","dst":"<'default'>","type":"DEFAULTS_TO"},{"src":"<withDefaults>","dst":"<`${a}${b}`>","type":"RETURNS"},{"src":"<`${a}${b}`>","dst":"<a>","type":"READS_FROM"},{"src":"<`${a}${b}`>","dst":"<b>","type":"READS_FROM"}],"rationale":"Function declaration with default parameter values. Reduced edge count by removing the module declaration edge while preserving all semantic relationships within the function construct.","implicitBehavior":["default expressions are evaluated at call time, not declaration time","parameters with defaults can be omitted in function calls","function is implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:26.298Z"}
{"construct":{"id":"coercion-hoisting::export-named-list","file":"src/coercion-hoisting.js","category":"coercion-hoisting","lineStart":312,"lineEnd":348,"code":"export {\n  stringCoercion,\n  numberCoercion,\n  booleanCoercion,\n  equalityCoercion,\n  customCoerce,\n  usedInMath,\n  usedInTemplate,\n  toPrimitive,\n  varHoisting,\n  functionHoisting,\n  functionExprNotHoisted,\n  tdzLet,\n  tdzConst,\n  tdzClass,\n  outerConst,\n  shadowingExample,\n  paramShadowing,\n  catchShadowing,\n  directEval,\n  indirectEval,\n  newFunction,\n  commaSequence,\n  evalVarInjection,\n  evalFunctionInjection,\n  primitiveAutoboxing,\n  varFunctionCollision,\n  contextualKeywords,\n  objectAsMapKey,\n  blockFunctionDemo,\n  varInCatchClobber,\n  typeofTdzTrap,\n  evalLetScope,\n  blockLabelAmbiguity,\n  varRedeclaresParameter,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named-list"}}],"edges":[{"src":"<module>","dst":"<export-named-list>","type":"CONTAINS"},{"src":"<export-named-list>","dst":"<stringCoercion>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<numberCoercion>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<booleanCoercion>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<equalityCoercion>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<customCoerce>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<usedInMath>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<usedInTemplate>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<toPrimitive>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<varHoisting>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<functionHoisting>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<functionExprNotHoisted>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<tdzLet>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<tdzConst>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<tdzClass>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<outerConst>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<shadowingExample>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<paramShadowing>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<catchShadowing>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<directEval>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<indirectEval>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<newFunction>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<commaSequence>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<evalVarInjection>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<evalFunctionInjection>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<primitiveAutoboxing>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<varFunctionCollision>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<contextualKeywords>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<objectAsMapKey>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<blockFunctionDemo>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<varInCatchClobber>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<typeofTdzTrap>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<evalLetScope>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<blockLabelAmbiguity>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<varRedeclaresParameter>","type":"EXPORTS"}],"rationale":"Named export list that re-exports 34 previously declared identifiers from the module scope. Each identifier is referenced and made available to importers. The Pass 1 annotation already used only approved vocabulary types (EXPORT, CONTAINS, EXPORTS), so no changes were needed.","implicitBehavior":["exported identifiers must be declared in module scope before this export statement","creates named export bindings that can be imported by other modules"]},"pass":2,"annotatedAt":"2026-02-24T00:32:26.358Z"}
{"construct":{"id":"declarations::func-expr-named","file":"src/declarations.js","category":"declarations","lineStart":74,"lineEnd":77,"code":"const namedExpression = function multiply(x, y) {\n  return x * y;\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<namedExpression>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<multiply>","metadata":{"named":true,"expression":true}},{"type":"PARAMETER","id":"<x>"},{"type":"PARAMETER","id":"<y>"},{"type":"EXPRESSION","id":"<x * y>","metadata":{"operator":"*"}}],"edges":[{"src":"<module>","dst":"<namedExpression>","type":"DECLARES"},{"src":"<namedExpression>","dst":"<multiply>","type":"ASSIGNED_FROM"},{"src":"<multiply>","dst":"<x>","type":"CONTAINS"},{"src":"<multiply>","dst":"<y>","type":"CONTAINS"},{"src":"<multiply>","dst":"<x * y>","type":"RETURNS"},{"src":"<x * y>","dst":"<x>","type":"READS_FROM"},{"src":"<x * y>","dst":"<y>","type":"READS_FROM"}],"rationale":"Named function expression assigned to const variable. The function has its own internal name 'multiply' and contains parameters and return expression. All types and edges from Pass 1 are already in the approved vocabulary.","implicitBehavior":["function name 'multiply' is only accessible within the function body itself","const binding prevents reassignment of namedExpression"]},"pass":2,"annotatedAt":"2026-02-24T00:32:26.474Z"}
{"construct":{"id":"declarations::arrow-single-param","file":"src/declarations.js","category":"declarations","lineStart":96,"lineEnd":97,"code":"const arrowSingleParam = x => x * 2;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrowSingleParam>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrowSingleParam:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<arrowSingleParam>","type":"DECLARES"},{"src":"<arrowSingleParam>","dst":"<arrowSingleParam:fn>","type":"ASSIGNED_FROM"},{"src":"<arrowSingleParam:fn>","dst":"<x>","type":"CONTAINS"},{"src":"<arrowSingleParam:fn>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"}],"rationale":"Arrow function with single parameter (no parentheses) and expression body assigned to const. Implicit return of multiplication expression. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["single parameter doesn't require parentheses","expression body has implicit return"]},"pass":2,"annotatedAt":"2026-02-24T00:32:26.971Z"}
{"construct":{"id":"declarations::arrow-block-body","file":"src/declarations.js","category":"declarations","lineStart":88,"lineEnd":91,"code":"const arrowBlock = (a, b) => {\n  return a + b;\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrowBlock>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrowBlock:fn>","metadata":{"arrowFunction":true,"hasBlockBody":true}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"EXPRESSION","id":"<a + b>","metadata":{"operator":"+"}}],"edges":[{"src":"<module>","dst":"<arrowBlock>","type":"DECLARES"},{"src":"<arrowBlock>","dst":"<arrowBlock:fn>","type":"ASSIGNED_FROM"},{"src":"<arrowBlock:fn>","dst":"<a>","type":"CONTAINS"},{"src":"<arrowBlock:fn>","dst":"<b>","type":"CONTAINS"},{"src":"<arrowBlock:fn>","dst":"<a + b>","type":"RETURNS"},{"src":"<a + b>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b>","dst":"<b>","type":"READS_FROM"}],"rationale":"Arrow function with block body assigned to const variable. The function contains two parameters and returns a binary expression that reads from both parameters. All relationships are captured using approved vocabulary.","implicitBehavior":["block body requires explicit return statement","lexical this binding"]},"pass":2,"annotatedAt":"2026-02-24T00:32:27.046Z"}
{"construct":{"id":"declarations::arrow-expression-body","file":"src/declarations.js","category":"declarations","lineStart":93,"lineEnd":94,"code":"const arrowExpression = (a, b) => a + b;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrowExpression>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrowExpression:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"EXPRESSION","id":"<a + b>","metadata":{"operator":"+"}}],"edges":[{"src":"<module>","dst":"<arrowExpression>","type":"DECLARES"},{"src":"<arrowExpression>","dst":"<arrowExpression:fn>","type":"ASSIGNED_FROM"},{"src":"<arrowExpression:fn>","dst":"<a>","type":"CONTAINS"},{"src":"<arrowExpression:fn>","dst":"<b>","type":"CONTAINS"},{"src":"<arrowExpression:fn>","dst":"<a + b>","type":"RETURNS"},{"src":"<a + b>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b>","dst":"<b>","type":"READS_FROM"}],"rationale":"Const variable assigned an arrow function with expression body. Function contains two parameters and implicitly returns the binary expression. All relationships captured using approved vocabulary.","implicitBehavior":["arrow function has lexical this binding","expression body has implicit return"]},"pass":2,"annotatedAt":"2026-02-24T00:32:27.811Z"}
{"construct":{"id":"declarations::arrow-no-params","file":"src/declarations.js","category":"declarations","lineStart":99,"lineEnd":102,"code":"const arrowNoParams = () => 42;\n\n// Generator Functions","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrowNoParams>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrowNoParams:fn>","metadata":{"arrowFunction":true,"parameterCount":0}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<arrowNoParams>","type":"DECLARES"},{"src":"<arrowNoParams>","dst":"<arrowNoParams:fn>","type":"ASSIGNED_FROM"},{"src":"<arrowNoParams:fn>","dst":"<42>","type":"RETURNS"}],"rationale":"Arrow function with no parameters and expression body assigned to const variable. The function implicitly returns the numeric literal 42.","implicitBehavior":["arrow function has lexical this binding","expression body creates implicit return"]},"pass":2,"annotatedAt":"2026-02-24T00:32:28.250Z"}
{"construct":{"id":"declarations::func-expr-anonymous","file":"src/declarations.js","category":"declarations","lineStart":79,"lineEnd":84,"code":"const anonymousExpression = function (x) {\n  return x * 2;\n};\n\n// Arrow Functions","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<anonymousExpression>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<anonymousExpression:fn>","metadata":{"anonymous":true,"functionExpression":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<anonymousExpression>","type":"DECLARES"},{"src":"<anonymousExpression>","dst":"<anonymousExpression:fn>","type":"ASSIGNED_FROM"},{"src":"<anonymousExpression:fn>","dst":"<x>","type":"CONTAINS"},{"src":"<anonymousExpression:fn>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"}],"rationale":"Anonymous function expression assigned to const variable. Function contains parameter and returns multiplication expression that reads the parameter and numeric literal. All relationships captured using approved vocabulary.","implicitBehavior":["function expression creates closure over lexical scope","const binding prevents reassignment"]},"pass":2,"annotatedAt":"2026-02-24T00:32:28.328Z"}
{"construct":{"id":"declarations::func-decl-mixed-params","file":"src/declarations.js","category":"declarations","lineStart":65,"lineEnd":70,"code":"function withMixedParams(required, optional = null, ...rest) {\n  return [required, optional, ...rest];\n}\n\n// Function Expressions","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withMixedParams>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<required>","metadata":{"parameterType":"required"}},{"type":"PARAMETER","id":"<optional>","metadata":{"parameterType":"optional"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"PARAMETER","id":"<rest>","metadata":{"parameterType":"rest"}},{"type":"EXPRESSION","id":"<[required, optional, ...rest]>","metadata":{"expressionType":"array"}}],"edges":[{"src":"<withMixedParams>","dst":"<required>","type":"CONTAINS"},{"src":"<withMixedParams>","dst":"<optional>","type":"CONTAINS"},{"src":"<withMixedParams>","dst":"<rest>","type":"CONTAINS"},{"src":"<optional>","dst":"<null>","type":"DEFAULTS_TO"},{"src":"<withMixedParams>","dst":"<[required, optional, ...rest]>","type":"RETURNS"},{"src":"<[required, optional, ...rest]>","dst":"<required>","type":"READS_FROM"},{"src":"<[required, optional, ...rest]>","dst":"<optional>","type":"READS_FROM"},{"src":"<[required, optional, ...rest]>","dst":"<rest>","type":"READS_FROM"}],"rationale":"Function declaration with three parameter types: required, optional with default value, and rest parameter. Returns array literal that reads from all parameters. Changed ASSIGNED_FROM to DEFAULTS_TO for the optional parameter's default value relationship.","implicitBehavior":["function declaration is hoisted","rest parameter collects remaining arguments into array","optional parameter uses default when undefined passed"]},"pass":2,"annotatedAt":"2026-02-24T00:32:28.691Z"}
{"construct":{"id":"builtins::builtin-json-parse","file":"src/builtins.js","category":"builtins","lineStart":7,"lineEnd":10,"code":"function jsonParse(str) {\n  return JSON.parse(str);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonParse>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<str>"},{"type":"CALL","id":"<JSON.parse(str)>","metadata":{"callee":"JSON.parse"}},{"type":"PROPERTY_ACCESS","id":"<JSON.parse>","metadata":{"objectName":"JSON","propertyName":"parse"}},{"type":"EXTERNAL","id":"<JSON>","metadata":{"builtin":true,"global":true}}],"edges":[{"src":"<jsonParse>","dst":"<str>","type":"CONTAINS"},{"src":"<jsonParse>","dst":"<JSON.parse(str)>","type":"RETURNS"},{"src":"<JSON.parse(str)>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse(str)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<JSON.parse>","dst":"<JSON>","type":"READS_FROM"}],"rationale":"Function that wraps the built-in JSON.parse method. The function contains a parameter, returns the result of calling JSON.parse, which accesses the parse property from the global JSON object and passes the str argument.","implicitBehavior":["JSON is a global built-in object","JSON.parse can throw SyntaxError for invalid JSON"]},"pass":2,"annotatedAt":"2026-02-24T00:32:31.524Z"}
{"construct":{"id":"declarations::generator-decl","file":"src/declarations.js","category":"declarations","lineStart":106,"lineEnd":111,"code":"function* numberGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<numberGenerator>","metadata":{"async":false,"generator":true}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<numberGenerator>","type":"DECLARES"},{"src":"<numberGenerator>","dst":"<1>","type":"YIELDS"},{"src":"<numberGenerator>","dst":"<2>","type":"YIELDS"},{"src":"<numberGenerator>","dst":"<3>","type":"YIELDS"}],"rationale":"Generator function declaration that yields three numeric literals in sequence. The YIELDS edge type from the approved vocabulary precisely captures the generator yield relationship. All node and edge types used are from the approved vocabulary.","implicitBehavior":["function declaration is hoisted","returns iterator object when called","execution pauses at each yield"]},"pass":2,"annotatedAt":"2026-02-24T00:32:31.640Z"}
{"construct":{"id":"declarations::async-func-decl","file":"src/declarations.js","category":"declarations","lineStart":123,"lineEnd":126,"code":"async function asyncFunction() {\n  return await Promise.resolve(42);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<asyncFunction>","metadata":{"async":true,"generator":false}},{"type":"CALL","id":"<Promise.resolve(42)>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"EXPRESSION","id":"<await Promise.resolve(42)>","metadata":{"operator":"await"}}],"edges":[{"src":"<module>","dst":"<asyncFunction>","type":"DECLARES"},{"src":"<asyncFunction>","dst":"<await Promise.resolve(42)>","type":"RETURNS"},{"src":"<await Promise.resolve(42)>","dst":"<Promise.resolve(42)>","type":"AWAITS"},{"src":"<Promise.resolve(42)>","dst":"<Promise.resolve>","type":"CALLS"},{"src":"<Promise.resolve(42)>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Async function declaration that returns an awaited Promise. The await expression awaits the Promise.resolve call, which passes the literal 42 as an argument.","implicitBehavior":["function declaration is hoisted to module scope","async function always returns a Promise","await suspends execution until Promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:32:31.715Z"}
{"construct":{"id":"declarations::generator-delegation","file":"src/declarations.js","category":"declarations","lineStart":113,"lineEnd":119,"code":"function* delegatingGenerator() {\n  yield* numberGenerator();\n  yield 4;\n}\n\n// Async Functions","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<delegatingGenerator>","metadata":{"async":false,"generator":true}},{"type":"EXPRESSION","id":"<yield* numberGenerator()>","metadata":{"type":"yield-delegation"}},{"type":"CALL","id":"<numberGenerator()>","metadata":{"callee":"numberGenerator"}},{"type":"EXPRESSION","id":"<yield 4>","metadata":{"type":"yield"}},{"type":"LITERAL","id":"<4>","metadata":{"value":4,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<delegatingGenerator>","type":"DECLARES"},{"src":"<delegatingGenerator>","dst":"<yield* numberGenerator()>","type":"CONTAINS"},{"src":"<delegatingGenerator>","dst":"<yield 4>","type":"CONTAINS"},{"src":"<yield* numberGenerator()>","dst":"<numberGenerator()>","type":"DELEGATES_TO"},{"src":"<numberGenerator()>","dst":"<numberGenerator>","type":"CALLS"},{"src":"<yield 4>","dst":"<4>","type":"YIELDS"}],"rationale":"Generator function that delegates to another generator with yield* and yields a literal value. The yield* delegates iteration control to the called generator using DELEGATES_TO edge.","implicitBehavior":["yield* passes through all values from the delegated generator","function declaration is hoisted to module scope","generator returns an iterator object when called"]},"pass":2,"annotatedAt":"2026-02-24T00:32:32.400Z"}
{"construct":{"id":"declarations::iife","file":"src/declarations.js","category":"declarations","lineStart":147,"lineEnd":150,"code":"const iifeResult = (function () {\n  return 'iife';\n})();","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<iifeResult>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<iife:fn>","metadata":{"anonymous":true,"iife":true}},{"type":"LITERAL","id":"<'iife'>","metadata":{"value":"iife","literalType":"string"}},{"type":"CALL","id":"<iife:call>","metadata":{"immediateInvocation":true}}],"edges":[{"src":"<module>","dst":"<iifeResult>","type":"DECLARES"},{"src":"<iife:fn>","dst":"<'iife'>","type":"RETURNS"},{"src":"<iife:call>","dst":"<iife:fn>","type":"CALLS"},{"src":"<iifeResult>","dst":"<iife:call>","type":"ASSIGNED_FROM"}],"rationale":"IIFE pattern: anonymous function immediately invoked, result assigned to const variable. Function returns string literal, call captures return value. All types and relationships map directly to approved vocabulary.","implicitBehavior":["creates isolated scope for function execution","function executes immediately during assignment"]},"pass":2,"annotatedAt":"2026-02-24T00:32:32.442Z"}
{"construct":{"id":"declarations::iife-arrow","file":"src/declarations.js","category":"declarations","lineStart":152,"lineEnd":157,"code":"const arrowIifeResult = (() => {\n  return 'arrow iife';\n})();\n\n// Named Exports","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrowIifeResult>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrow-iife:fn>","metadata":{"arrowFunction":true,"iife":true}},{"type":"LITERAL","id":"<'arrow iife'>","metadata":{"value":"arrow iife","literalType":"string"}},{"type":"CALL","id":"<arrow-iife:call>","metadata":{"iife":true}}],"edges":[{"src":"<module>","dst":"<arrowIifeResult>","type":"DECLARES"},{"src":"<arrowIifeResult>","dst":"<arrow-iife:call>","type":"ASSIGNED_FROM"},{"src":"<arrow-iife:call>","dst":"<arrow-iife:fn>","type":"CALLS"},{"src":"<arrow-iife:fn>","dst":"<'arrow iife'>","type":"RETURNS"}],"rationale":"Arrow function IIFE assigned to const variable. The function is immediately invoked and its return value flows to the variable. All types and relationships from Pass 1 are already in the approved vocabulary.","implicitBehavior":["arrow function has lexical this binding","IIFE creates isolated scope that executes immediately"]},"pass":2,"annotatedAt":"2026-02-24T00:32:32.507Z"}
{"construct":{"id":"declarations::async-arrow","file":"src/declarations.js","category":"declarations","lineStart":128,"lineEnd":133,"code":"const asyncArrow = async () => {\n  return await Promise.resolve('async arrow');\n};\n\n// Async Generator Functions","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncArrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncArrow:fn>","metadata":{"arrowFunction":true,"async":true}},{"type":"EXPRESSION","id":"<await Promise.resolve('async arrow')>","metadata":{"operator":"await"}},{"type":"CALL","id":"<Promise.resolve('async arrow')>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<'async arrow'>","metadata":{"value":"async arrow","literalType":"string"}},{"type":"EXTERNAL","id":"<Promise.resolve>","metadata":{"source":"global Promise API"}}],"edges":[{"src":"<module>","dst":"<asyncArrow>","type":"DECLARES"},{"src":"<asyncArrow>","dst":"<asyncArrow:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncArrow:fn>","dst":"<await Promise.resolve('async arrow')>","type":"RETURNS"},{"src":"<await Promise.resolve('async arrow')>","dst":"<Promise.resolve('async arrow')>","type":"AWAITS"},{"src":"<Promise.resolve('async arrow')>","dst":"<Promise.resolve>","type":"CALLS"},{"src":"<Promise.resolve('async arrow')>","dst":"<'async arrow'>","type":"PASSES_ARGUMENT"}],"rationale":"Async arrow function assigned to const variable. Returns awaited Promise.resolve call with string literal argument. Used AWAITS edge type to properly capture the await relationship.","implicitBehavior":["function returns Promise due to async","await suspends execution until Promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:32:34.797Z"}
{"construct":{"id":"declarations::arrow-return-object-literal","file":"src/declarations.js","category":"declarations","lineStart":172,"lineEnd":174,"code":"const arrowReturnsObject = (x) => ({ key: x, value: x * 2 });\n// Without parens: (x) => { key: x }  parsed as block with label \"key\"!","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<arrowReturnsObject>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<arrowReturnsObject:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"LITERAL","id":"<object-literal>","metadata":{"literalType":"object"}},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<arrowReturnsObject>","type":"DECLARES"},{"src":"<arrowReturnsObject>","dst":"<arrowReturnsObject:fn>","type":"ASSIGNED_FROM"},{"src":"<arrowReturnsObject:fn>","dst":"<x>","type":"CONTAINS"},{"src":"<arrowReturnsObject:fn>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<x>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<x * 2>","type":"HAS_PROPERTY"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"}],"rationale":"Arrow function with parenthesized object literal return. Object has two properties: 'key' maps to parameter x, 'value' maps to computed expression x * 2. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["parentheses force object literal interpretation instead of block statement","implicit return of object literal"]},"pass":2,"annotatedAt":"2026-02-24T00:32:35.117Z"}
{"construct":{"id":"declarations::param-default-scope-quirk","file":"src/declarations.js","category":"declarations","lineStart":166,"lineEnd":170,"code":"let outerX = 'outer';\nfunction paramDefaultScope(a = () => outerX, outerX) {\n  return a();\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<outerX>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<'outer'>","metadata":{"value":"outer","literalType":"string"}},{"type":"FUNCTION","id":"<paramDefaultScope>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>","metadata":{"hasDefault":true}},{"type":"FUNCTION","id":"<a:default>","metadata":{"arrowFunction":true,"isDefaultValue":true}},{"type":"PARAMETER","id":"<outerX:param>","metadata":{"shadowsOuter":true}},{"type":"CALL","id":"<a()>","metadata":{"callee":"a"}}],"edges":[{"src":"<outerX>","dst":"<'outer'>","type":"ASSIGNED_FROM"},{"src":"<paramDefaultScope>","dst":"<a>","type":"CONTAINS"},{"src":"<paramDefaultScope>","dst":"<outerX:param>","type":"CONTAINS"},{"src":"<a>","dst":"<a:default>","type":"DEFAULTS_TO"},{"src":"<a:default>","dst":"<outerX>","type":"READS_FROM"},{"src":"<paramDefaultScope>","dst":"<a()>","type":"RETURNS"},{"src":"<a()>","dst":"<a>","type":"CALLS"},{"src":"<outerX:param>","dst":"<outerX>","type":"SHADOWS"}],"rationale":"Parameter default expressions are evaluated in their own scope where later parameters don't exist yet. The arrow function in the default captures the outer 'outerX', not the parameter. Used DEFAULTS_TO for parameter default relationship and SHADOWS for the parameter shadowing the outer variable.","implicitBehavior":["parameter defaults evaluated left-to-right in temporal dead zone for later params","default expression scope is separate from function body scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:37.606Z"}
{"construct":{"id":"declarations::async-iife","file":"src/declarations.js","category":"declarations","lineStart":176,"lineEnd":179,"code":"const asyncIifeResult = (async () => {\n  return await Promise.resolve('async iife');\n})();","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncIifeResult>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<async-iife:fn>","metadata":{"async":true,"arrowFunction":true,"iife":true}},{"type":"CALL","id":"<async-iife:call>","metadata":{"callee":"async-iife:fn","iife":true}},{"type":"CALL","id":"<Promise.resolve('async iife')>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<'async iife'>","metadata":{"value":"async iife","literalType":"string"}},{"type":"EXPRESSION","id":"<await Promise.resolve('async iife')>","metadata":{"operator":"await"}}],"edges":[{"src":"<asyncIifeResult>","dst":"<async-iife:call>","type":"ASSIGNED_FROM"},{"src":"<async-iife:call>","dst":"<async-iife:fn>","type":"CALLS"},{"src":"<async-iife:fn>","dst":"<await Promise.resolve('async iife')>","type":"RETURNS"},{"src":"<await Promise.resolve('async iife')>","dst":"<Promise.resolve('async iife')>","type":"AWAITS"},{"src":"<Promise.resolve('async iife')>","dst":"<'async iife'>","type":"PASSES_ARGUMENT"}],"rationale":"Async IIFE pattern: async arrow function immediately invoked. Variable receives the resolved promise value. Used AWAITS edge type for await expression relationship.","implicitBehavior":["async function returns Promise","await suspends execution until promise resolves","IIFE executes immediately in current context"]},"pass":2,"annotatedAt":"2026-02-24T00:32:39.406Z"}
{"construct":{"id":"declarations::async-generator-decl","file":"src/declarations.js","category":"declarations","lineStart":137,"lineEnd":143,"code":"async function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\n// IIFE (Immediately Invoked Function Expression)","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<asyncGenerator>","metadata":{"async":true,"generator":true}},{"type":"EXPRESSION","id":"<yield await Promise.resolve(1)>","metadata":{"operator":"yield"}},{"type":"EXPRESSION","id":"<await Promise.resolve(1)>","metadata":{"operator":"await"}},{"type":"CALL","id":"<Promise.resolve(1)>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<yield await Promise.resolve(2)>","metadata":{"operator":"yield"}},{"type":"EXPRESSION","id":"<await Promise.resolve(2)>","metadata":{"operator":"await"}},{"type":"CALL","id":"<Promise.resolve(2)>","metadata":{"callee":"Promise.resolve"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXTERNAL","id":"<Promise>","metadata":{"source":"global"}}],"edges":[{"src":"<asyncGenerator>","dst":"<yield await Promise.resolve(1)>","type":"CONTAINS"},{"src":"<asyncGenerator>","dst":"<yield await Promise.resolve(2)>","type":"CONTAINS"},{"src":"<yield await Promise.resolve(1)>","dst":"<await Promise.resolve(1)>","type":"YIELDS"},{"src":"<await Promise.resolve(1)>","dst":"<Promise.resolve(1)>","type":"AWAITS"},{"src":"<Promise.resolve(1)>","dst":"<Promise>","type":"CALLS_ON"},{"src":"<Promise.resolve(1)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<yield await Promise.resolve(2)>","dst":"<await Promise.resolve(2)>","type":"YIELDS"},{"src":"<await Promise.resolve(2)>","dst":"<Promise.resolve(2)>","type":"AWAITS"},{"src":"<Promise.resolve(2)>","dst":"<Promise>","type":"CALLS_ON"},{"src":"<Promise.resolve(2)>","dst":"<2>","type":"PASSES_ARGUMENT"}],"rationale":"Async generator function that yields awaited promises. Each yield expression contains an await expression that waits for a Promise.resolve call. Added explicit EXTERNAL node for Promise to capture the dependency on the global Promise constructor.","implicitBehavior":["function declaration is hoisted","returns AsyncGenerator object when called","execution pauses at each yield/await point","can be consumed with for-await-of"]},"pass":2,"annotatedAt":"2026-02-24T00:32:40.125Z"}
{"construct":{"id":"declarations::param-default-depends-on-prior","file":"src/declarations.js","category":"declarations","lineStart":161,"lineEnd":164,"code":"function paramDefaultChain(a, b = a * 2, c = a + b) {\n  return { a, b, c };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<paramDefaultChain>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>","metadata":{"hasDefault":true}},{"type":"EXPRESSION","id":"<a * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"PARAMETER","id":"<c>","metadata":{"hasDefault":true}},{"type":"EXPRESSION","id":"<a + b>","metadata":{"operator":"+"}},{"type":"EXPRESSION","id":"<{ a, b, c }>","metadata":{"type":"object"}}],"edges":[{"src":"<paramDefaultChain>","dst":"<a>","type":"CONTAINS"},{"src":"<paramDefaultChain>","dst":"<b>","type":"CONTAINS"},{"src":"<paramDefaultChain>","dst":"<c>","type":"CONTAINS"},{"src":"<b>","dst":"<a * 2>","type":"DEFAULTS_TO"},{"src":"<a * 2>","dst":"<a>","type":"READS_FROM"},{"src":"<a * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<c>","dst":"<a + b>","type":"DEFAULTS_TO"},{"src":"<a + b>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b>","dst":"<b>","type":"READS_FROM"},{"src":"<paramDefaultChain>","dst":"<{ a, b, c }>","type":"RETURNS"},{"src":"<{ a, b, c }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<b>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<c>","type":"READS_FROM"}],"rationale":"Function with chained parameter defaults where later parameters depend on earlier ones. Parameter b defaults to expression using a, parameter c defaults to expression using both a and b. All types and edges from Pass 1 are already in the approved vocabulary.","implicitBehavior":["parameters are evaluated left-to-right","default expressions are evaluated only when argument is undefined","temporal dead zone applies to parameter scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:40.217Z"}
{"construct":{"id":"declarations::new-target-in-function","file":"src/declarations.js","category":"declarations","lineStart":191,"lineEnd":197,"code":"function FlexibleConstructor(name) {\n  if (!new.target) {\n    return new FlexibleConstructor(name); // redirect if called without new\n  }\n  this.name = name;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<FlexibleConstructor>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<name>"},{"type":"BRANCH","id":"<if-new-target>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<!new.target>","metadata":{"operator":"!"}},{"type":"META_PROPERTY","id":"<new.target>"},{"type":"CALL","id":"<new FlexibleConstructor(name)>","metadata":{"callee":"FlexibleConstructor","withNew":true}},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}}],"edges":[{"src":"<FlexibleConstructor>","dst":"<name>","type":"CONTAINS"},{"src":"<FlexibleConstructor>","dst":"<if-new-target>","type":"CONTAINS"},{"src":"<if-new-target>","dst":"<!new.target>","type":"HAS_CONDITION"},{"src":"<!new.target>","dst":"<new.target>","type":"READS_FROM"},{"src":"<if-new-target>","dst":"<new FlexibleConstructor(name)>","type":"HAS_CONSEQUENT"},{"src":"<new FlexibleConstructor(name)>","dst":"<FlexibleConstructor>","type":"CALLS"},{"src":"<new FlexibleConstructor(name)>","dst":"<name>","type":"PASSES_ARGUMENT"},{"src":"<if-new-target>","dst":"<new FlexibleConstructor(name)>","type":"RETURNS"},{"src":"<FlexibleConstructor>","dst":"<this.name>","type":"WRITES_TO"},{"src":"<this.name>","dst":"<name>","type":"ASSIGNED_FROM"}],"rationale":"Function that can be called as constructor or regular function. Uses new.target meta-property to detect constructor invocation and redirects if needed. Removed the module declaration edge to reduce complexity while preserving the core semantic relationships.","implicitBehavior":["new.target is undefined when called as regular function","new.target equals constructor when called with new","recursive constructor call creates proper instance"]},"pass":2,"annotatedAt":"2026-02-24T00:32:40.746Z"}
{"construct":{"id":"declarations::func-expr-recursive-self-ref","file":"src/declarations.js","category":"declarations","lineStart":185,"lineEnd":189,"code":"const factorialNamedExpr = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1); // fact visible ONLY inside\n};\n// typeof fact === 'undefined'  internal name not in enclosing scope","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<factorialNamedExpr>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<fact>","metadata":{"namedExpression":true,"internalName":"fact"}},{"type":"PARAMETER","id":"<n>"},{"type":"EXPRESSION","id":"<n <= 1>","metadata":{"operator":"<="}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<1-return>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<n * fact(n - 1)>","metadata":{"operator":"*"}},{"type":"CALL","id":"<fact(n - 1)>","metadata":{"callee":"fact"}},{"type":"EXPRESSION","id":"<n - 1>","metadata":{"operator":"-"}}],"edges":[{"src":"<factorialNamedExpr>","dst":"<fact>","type":"ASSIGNED_FROM"},{"src":"<fact>","dst":"<n>","type":"CONTAINS"},{"src":"<fact>","dst":"<n <= 1>","type":"HAS_CONDITION"},{"src":"<n <= 1>","dst":"<n>","type":"READS_FROM"},{"src":"<n <= 1>","dst":"<1>","type":"READS_FROM"},{"src":"<fact>","dst":"<1-return>","type":"HAS_CONSEQUENT"},{"src":"<fact>","dst":"<n * fact(n - 1)>","type":"HAS_ALTERNATE"},{"src":"<n * fact(n - 1)>","dst":"<n>","type":"READS_FROM"},{"src":"<n * fact(n - 1)>","dst":"<fact(n - 1)>","type":"READS_FROM"},{"src":"<fact(n - 1)>","dst":"<fact>","type":"CALLS"},{"src":"<fact(n - 1)>","dst":"<n - 1>","type":"PASSES_ARGUMENT"},{"src":"<n - 1>","dst":"<n>","type":"READS_FROM"},{"src":"<n - 1>","dst":"<1>","type":"READS_FROM"}],"rationale":"Named function expression creates internal binding 'fact' visible only within function body. External variable 'factorialNamedExpr' holds the function, but 'fact' name is not accessible in enclosing scope. Removed module declaration edge to reduce complexity while preserving core semantics.","implicitBehavior":["internal name 'fact' creates binding in function's own scope only","enables self-recursion without polluting outer scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:42.665Z"}
{"construct":{"id":"error-handling::error-custom-class","file":"src/error-handling.js","category":"error-handling","lineStart":7,"lineEnd":14,"code":"class AppError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<AppError>"},{"type":"METHOD","id":"<AppError.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<message>"},{"type":"PARAMETER","id":"<code>"},{"type":"CALL","id":"<super(message)>","metadata":{"callee":"super"}},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<'AppError'>","metadata":{"value":"AppError","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this.code>","metadata":{"objectName":"this"}}],"edges":[{"src":"<AppError>","dst":"<Error>","type":"EXTENDS"},{"src":"<AppError>","dst":"<AppError.constructor>","type":"CONTAINS"},{"src":"<AppError.constructor>","dst":"<message>","type":"CONTAINS"},{"src":"<AppError.constructor>","dst":"<code>","type":"CONTAINS"},{"src":"<super(message)>","dst":"<Error>","type":"CALLS"},{"src":"<super(message)>","dst":"<message>","type":"PASSES_ARGUMENT"},{"src":"<AppError.constructor>","dst":"<super(message)>","type":"CONTAINS"},{"src":"<this.name>","dst":"<'AppError'>","type":"ASSIGNED_FROM"},{"src":"<AppError.constructor>","dst":"<this.name>","type":"WRITES_TO"},{"src":"<this.code>","dst":"<code>","type":"ASSIGNED_FROM"},{"src":"<AppError.constructor>","dst":"<this.code>","type":"WRITES_TO"}],"rationale":"Custom error class extending Error. Constructor calls super with message, then sets name and code properties on the instance. Removed the module declaration edge as it's not essential to the core construct semantics.","implicitBehavior":["inherits Error prototype methods","super() call must be first in constructor","this binding established after super() call"]},"pass":2,"annotatedAt":"2026-02-24T00:32:43.298Z"}
{"construct":{"id":"declarations::let-const-multi-declaration","file":"src/declarations.js","category":"declarations","lineStart":181,"lineEnd":183,"code":"const constMultiA = 1, constMultiB = constMultiA + 1, constMultiC = constMultiA + constMultiB;\nlet letMultiX = 0, letMultiY = letMultiX + 1;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<constMultiA>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<constMultiB>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<constMultiA + 1>","metadata":{"operator":"+"}},{"type":"VARIABLE","id":"<constMultiC>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<constMultiA + constMultiB>","metadata":{"operator":"+"}},{"type":"VARIABLE","id":"<letMultiX>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<letMultiY>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<letMultiX + 1>","metadata":{"operator":"+"}}],"edges":[{"src":"<constMultiA>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<constMultiB>","dst":"<constMultiA + 1>","type":"ASSIGNED_FROM"},{"src":"<constMultiA + 1>","dst":"<constMultiA>","type":"READS_FROM"},{"src":"<constMultiC>","dst":"<constMultiA + constMultiB>","type":"ASSIGNED_FROM"},{"src":"<constMultiA + constMultiB>","dst":"<constMultiA>","type":"READS_FROM"},{"src":"<constMultiA + constMultiB>","dst":"<constMultiB>","type":"READS_FROM"},{"src":"<letMultiX>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<letMultiY>","dst":"<letMultiX + 1>","type":"ASSIGNED_FROM"},{"src":"<letMultiX + 1>","dst":"<letMultiX>","type":"READS_FROM"}],"rationale":"Multiple variable declarations in single statements. Each variable is assigned from its initializer expression. Dependencies flow from earlier variables to later ones within the same declaration. Removed module-level DECLARES edges to reduce edge count while preserving core semantic relationships.","implicitBehavior":["const variables are immutable after initialization","let variables are block-scoped","evaluation order is left-to-right within each declaration statement","variables are implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:32:43.298Z"}
{"construct":{"id":"builtins::builtin-json-parse-reviver","file":"src/builtins.js","category":"builtins","lineStart":12,"lineEnd":18,"code":"function jsonParseReviver(str) {\n  return JSON.parse(str, (key, value) => {\n    if (key === 'date') return new Date(value);\n    return value;\n  });\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonParseReviver>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<str>"},{"type":"CALL","id":"<JSON.parse(str, reviver)>","metadata":{"callee":"JSON.parse"}},{"type":"PROPERTY_ACCESS","id":"<JSON.parse>","metadata":{"objectName":"JSON","propertyName":"parse"}},{"type":"FUNCTION","id":"<reviver>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<value>"},{"type":"BRANCH","id":"<if-date-check>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<key === 'date'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'date'>","metadata":{"value":"date","literalType":"string"}},{"type":"CALL","id":"<new Date(value)>","metadata":{"callee":"Date","isConstructor":true}},{"type":"EXTERNAL","id":"<Date>","metadata":{"builtin":true}}],"edges":[{"src":"<jsonParseReviver>","dst":"<str>","type":"CONTAINS"},{"src":"<jsonParseReviver>","dst":"<JSON.parse(str, reviver)>","type":"RETURNS"},{"src":"<JSON.parse(str, reviver)>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse(str, reviver)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<JSON.parse(str, reviver)>","dst":"<reviver>","type":"PASSES_ARGUMENT"},{"src":"<reviver>","dst":"<key>","type":"CONTAINS"},{"src":"<reviver>","dst":"<value>","type":"CONTAINS"},{"src":"<reviver>","dst":"<if-date-check>","type":"CONTAINS"},{"src":"<if-date-check>","dst":"<key === 'date'>","type":"HAS_CONDITION"},{"src":"<key === 'date'>","dst":"<key>","type":"READS_FROM"},{"src":"<key === 'date'>","dst":"<'date'>","type":"READS_FROM"},{"src":"<if-date-check>","dst":"<new Date(value)>","type":"HAS_CONSEQUENT"},{"src":"<if-date-check>","dst":"<value>","type":"HAS_ALTERNATE"},{"src":"<new Date(value)>","dst":"<Date>","type":"CALLS"},{"src":"<new Date(value)>","dst":"<value>","type":"PASSES_ARGUMENT"}],"rationale":"Function that wraps JSON.parse with a reviver callback. The reviver function conditionally transforms 'date' keys into Date objects, otherwise returns values unchanged.","implicitBehavior":["JSON.parse calls the reviver function for each key-value pair during parsing","Date constructor coerces string values to Date objects","Arrow function has implicit return for both branches"]},"pass":2,"annotatedAt":"2026-02-24T00:32:43.510Z"}
{"construct":{"id":"builtins::builtin-json-stringify","file":"src/builtins.js","category":"builtins","lineStart":20,"lineEnd":23,"code":"function jsonStringify(obj) {\n  return JSON.stringify(obj);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonStringify>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<JSON.stringify(obj)>","metadata":{"callee":"JSON.stringify"}},{"type":"PROPERTY_ACCESS","id":"<JSON.stringify>","metadata":{"objectName":"JSON","propertyName":"stringify"}},{"type":"EXTERNAL","id":"<JSON>","metadata":{"builtin":true,"global":true}}],"edges":[{"src":"<MODULE>","dst":"<jsonStringify>","type":"DECLARES"},{"src":"<jsonStringify>","dst":"<obj>","type":"CONTAINS"},{"src":"<jsonStringify>","dst":"<JSON.stringify(obj)>","type":"RETURNS"},{"src":"<JSON.stringify(obj)>","dst":"<JSON.stringify>","type":"CALLS"},{"src":"<JSON.stringify(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<JSON.stringify>","dst":"<JSON>","type":"ACCESSES_PRIVATE"}],"rationale":"Function that wraps the built-in JSON.stringify method. Returns a call to the global JSON object's stringify method, passing through the parameter.","implicitBehavior":["JSON is a global built-in object","JSON.stringify may throw TypeError for circular references or non-serializable values"]},"pass":2,"annotatedAt":"2026-02-24T00:32:44.641Z"}
{"construct":{"id":"declarations::numeric-separators","file":"src/declarations.js","category":"declarations","lineStart":209,"lineEnd":215,"code":"const TIMEOUT_MS = 30_000;\nconst MAX_SAFE = 9_007_199_254_740_991;\nconst HEX_COLOR = 0xFF_EC_D9;\nconst BIT_MASK = 0b1111_0000_1010_0101;\nconst BIG_NUM = 1_000_000_000n;\nconst FLOAT_SEP = 1_000.123_456;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<TIMEOUT_MS>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<30_000>","metadata":{"value":30000,"literalType":"number","hasNumericSeparators":true}},{"type":"VARIABLE","id":"<MAX_SAFE>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<9_007_199_254_740_991>","metadata":{"value":9007199254740991,"literalType":"number","hasNumericSeparators":true}},{"type":"VARIABLE","id":"<HEX_COLOR>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<0xFF_EC_D9>","metadata":{"value":16772313,"literalType":"number","base":"hex","hasNumericSeparators":true}},{"type":"VARIABLE","id":"<BIT_MASK>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<0b1111_0000_1010_0101>","metadata":{"value":61605,"literalType":"number","base":"binary","hasNumericSeparators":true}},{"type":"VARIABLE","id":"<BIG_NUM>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<1_000_000_000n>","metadata":{"value":"1000000000","literalType":"bigint","hasNumericSeparators":true}},{"type":"VARIABLE","id":"<FLOAT_SEP>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<1_000.123_456>","metadata":{"value":1000.123456,"literalType":"number","hasNumericSeparators":true}}],"edges":[{"src":"<module>","dst":"<TIMEOUT_MS>","type":"DECLARES"},{"src":"<TIMEOUT_MS>","dst":"<30_000>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<MAX_SAFE>","type":"DECLARES"},{"src":"<MAX_SAFE>","dst":"<9_007_199_254_740_991>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<HEX_COLOR>","type":"DECLARES"},{"src":"<HEX_COLOR>","dst":"<0xFF_EC_D9>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<BIT_MASK>","type":"DECLARES"},{"src":"<BIT_MASK>","dst":"<0b1111_0000_1010_0101>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<BIG_NUM>","type":"DECLARES"},{"src":"<BIG_NUM>","dst":"<1_000_000_000n>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<FLOAT_SEP>","type":"DECLARES"},{"src":"<FLOAT_SEP>","dst":"<1_000.123_456>","type":"ASSIGNED_FROM"}],"rationale":"Six const variable declarations with numeric literals using separators. Each variable is declared by the module and assigned from its corresponding literal value. The literals preserve their original format with separators in metadata while storing the actual numeric value.","implicitBehavior":["numeric separators are purely syntactic - runtime values are identical to non-separated equivalents"]},"pass":2,"annotatedAt":"2026-02-24T00:32:46.574Z"}
{"construct":{"id":"error-handling::error-cause","file":"src/error-handling.js","category":"error-handling","lineStart":36,"lineEnd":46,"code":"async function fetchWithCause(url) {\n  try {\n    const response = await fetch(url);\n    return await response.json();\n  } catch (err) {\n    throw new Error(`Failed to fetch ${url}`, { cause: err });\n  }\n}\n\n// --- Error wrapping / re-throw ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fetchWithCause>","metadata":{"async":true}},{"type":"PARAMETER","id":"<url>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url)>","metadata":{"callee":"fetch","async":true}},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","async":true}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<err>"},{"type":"CALL","id":"<new Error>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'Failed to fetch '>","metadata":{"value":"Failed to fetch ","literalType":"string"}},{"type":"EXPRESSION","id":"<`Failed to fetch ${url}`>","metadata":{"type":"template-literal"}},{"type":"LITERAL","id":"<{ cause: err }>","metadata":{"literalType":"object"}}],"edges":[{"src":"<fetchWithCause>","dst":"<url>","type":"HAS_BODY"},{"src":"<fetchWithCause>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url)>","type":"ASSIGNED_FROM"},{"src":"<fetch(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<try-block>","dst":"<response.json()>","type":"RETURNS"},{"src":"<response.json()>","dst":"<response>","type":"CALLS_ON"},{"src":"<fetchWithCause>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<err>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<new Error>","type":"THROWS"},{"src":"<new Error>","dst":"<`Failed to fetch ${url}`>","type":"PASSES_ARGUMENT"},{"src":"<new Error>","dst":"<{ cause: err }>","type":"PASSES_ARGUMENT"},{"src":"<`Failed to fetch ${url}`>","dst":"<'Failed to fetch '>","type":"CONTAINS"},{"src":"<`Failed to fetch ${url}`>","dst":"<url>","type":"READS_FROM"},{"src":"<{ cause: err }>","dst":"<err>","type":"READS_FROM"}],"rationale":"Async function with try-catch that wraps caught errors with additional context using Error cause option. The catch block creates a new Error with a template literal message and passes the original error as the cause. Reduced edge count by removing module declaration edge and using CALLS_ON for method calls.","implicitBehavior":["Error cause chain preserves original stack trace","Template literal performs string interpolation","Async/await unwraps promises and propagates rejections to catch block"]},"pass":2,"annotatedAt":"2026-02-24T00:32:52.213Z"}
{"construct":{"id":"error-handling::error-wrap-rethrow","file":"src/error-handling.js","category":"error-handling","lineStart":48,"lineEnd":55,"code":"function parseConfig(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch (err) {\n    throw new AppError(`Invalid config: ${err.message}`, 'PARSE_ERROR');\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<parseConfig>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<raw>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<JSON.parse(raw)>","metadata":{"callee":"JSON.parse"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<err>","metadata":{"catchParameter":true}},{"type":"CALL","id":"<new AppError>","metadata":{"callee":"AppError","constructor":true}},{"type":"EXPRESSION","id":"<`Invalid config: ${err.message}`>","metadata":{"type":"template-literal"}},{"type":"LITERAL","id":"<'PARSE_ERROR'>","metadata":{"value":"PARSE_ERROR","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<err.message>","metadata":{"objectName":"err","property":"message"}},{"type":"EXTERNAL","id":"<JSON.parse>","metadata":{"source":"global"}},{"type":"EXTERNAL","id":"<AppError>","metadata":{"source":"unknown"}}],"edges":[{"src":"<parseConfig>","dst":"<raw>","type":"CONTAINS"},{"src":"<parseConfig>","dst":"<try-block>","type":"CONTAINS"},{"src":"<parseConfig>","dst":"<catch-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<JSON.parse(raw)>","type":"CONTAINS"},{"src":"<parseConfig>","dst":"<JSON.parse(raw)>","type":"RETURNS"},{"src":"<JSON.parse(raw)>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse(raw)>","dst":"<raw>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<err>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<new AppError>","type":"THROWS"},{"src":"<new AppError>","dst":"<AppError>","type":"CALLS"},{"src":"<new AppError>","dst":"<`Invalid config: ${err.message}`>","type":"PASSES_ARGUMENT"},{"src":"<new AppError>","dst":"<'PARSE_ERROR'>","type":"PASSES_ARGUMENT"},{"src":"<`Invalid config: ${err.message}`>","dst":"<err.message>","type":"READS_FROM"},{"src":"<err.message>","dst":"<err>","type":"READS_FROM"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<try-block>","type":"CATCHES_FROM"}],"rationale":"Function with try-catch that wraps JSON parsing errors. Try block returns parsed result, catch block creates and throws a custom error with original error message. Added explicit EXTERNAL nodes for JSON.parse and AppError to represent external dependencies.","implicitBehavior":["JSON.parse throws SyntaxError on invalid JSON","AppError constructor presumably extends Error","Template literal performs string interpolation"]},"pass":2,"annotatedAt":"2026-02-24T00:32:52.513Z"}
{"construct":{"id":"error-handling::error-async-catch-all","file":"src/error-handling.js","category":"error-handling","lineStart":117,"lineEnd":126,"code":"async function safeExecute(asyncFn) {\n  try {\n    return { ok: true, value: await asyncFn() };\n  } catch (err) {\n    return { ok: false, error: err };\n  }\n}\n\n// --- Promise rejection handling ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<safeExecute>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<asyncFn>"},{"type":"TRY_BLOCK","id":"<safeExecute:try>"},{"type":"CATCH_BLOCK","id":"<safeExecute:catch>"},{"type":"PARAMETER","id":"<err>"},{"type":"EXPRESSION","id":"<await asyncFn()>","metadata":{"operator":"await"}},{"type":"CALL","id":"<asyncFn()>","metadata":{"callee":"asyncFn"}},{"type":"LITERAL","id":"<{ ok: true, value: await asyncFn() }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<{ ok: false, error: err }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}}],"edges":[{"src":"<safeExecute>","dst":"<asyncFn>","type":"CONTAINS"},{"src":"<safeExecute>","dst":"<safeExecute:try>","type":"HAS_BODY"},{"src":"<safeExecute>","dst":"<safeExecute:catch>","type":"HAS_CATCH"},{"src":"<safeExecute:catch>","dst":"<err>","type":"CONTAINS"},{"src":"<safeExecute:try>","dst":"<{ ok: true, value: await asyncFn() }>","type":"RETURNS"},{"src":"<safeExecute:catch>","dst":"<{ ok: false, error: err }>","type":"RETURNS"},{"src":"<await asyncFn()>","dst":"<asyncFn()>","type":"AWAITS"},{"src":"<asyncFn()>","dst":"<asyncFn>","type":"CALLS"},{"src":"<{ ok: true, value: await asyncFn() }>","dst":"<true>","type":"HAS_PROPERTY"},{"src":"<{ ok: true, value: await asyncFn() }>","dst":"<await asyncFn()>","type":"HAS_PROPERTY"},{"src":"<{ ok: false, error: err }>","dst":"<false>","type":"HAS_PROPERTY"},{"src":"<{ ok: false, error: err }>","dst":"<err>","type":"HAS_PROPERTY"},{"src":"<safeExecute:catch>","dst":"<err>","type":"CATCHES_FROM"}],"rationale":"Async function with try-catch that wraps async operations in a Result-like pattern. Try block awaits the parameter function and returns success object, catch block returns error object. Reduced edge count by removing module declaration edge and using AWAITS instead of READS_FROM for await expression.","implicitBehavior":["async function returns Promise","await suspends execution until promise resolves","any rejection in try block flows to catch block","catch block catches both sync throws and async rejections"]},"pass":2,"annotatedAt":"2026-02-24T00:32:54.242Z"}
{"construct":{"id":"declarations::param-default-from-destructured","file":"src/declarations.js","category":"declarations","lineStart":199,"lineEnd":207,"code":"function paramDefaultFromDestructured({width, height}, area = width * height) {\n  return { width, height, area };\n}\n\n// Also with nested destructuring feeding later default:\nfunction queryBuilder({table, schema = 'public'}, fullName = `${schema}.${table}`) {\n  return `SELECT * FROM ${fullName}`;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<paramDefaultFromDestructured>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<{width, height}>","metadata":{"destructured":true}},{"type":"VARIABLE","id":"<width>","metadata":{"destructuredFrom":"{width, height}"}},{"type":"VARIABLE","id":"<height>","metadata":{"destructuredFrom":"{width, height}"}},{"type":"PARAMETER","id":"<area>","metadata":{"hasDefault":true}},{"type":"EXPRESSION","id":"<width * height>","metadata":{"operator":"*"}},{"type":"EXPRESSION","id":"<{ width, height, area }>","metadata":{"type":"object-literal"}},{"type":"FUNCTION","id":"<queryBuilder>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<{table, schema = 'public'}>","metadata":{"destructured":true}},{"type":"VARIABLE","id":"<table>","metadata":{"destructuredFrom":"{table, schema = 'public'}"}},{"type":"VARIABLE","id":"<schema>","metadata":{"destructuredFrom":"{table, schema = 'public'}","hasDefault":true}},{"type":"LITERAL","id":"<'public'>","metadata":{"value":"public","literalType":"string"}},{"type":"PARAMETER","id":"<fullName>","metadata":{"hasDefault":true}},{"type":"EXPRESSION","id":"<`${schema}.${table}`>","metadata":{"type":"template-literal"}},{"type":"EXPRESSION","id":"<`SELECT * FROM ${fullName}`>","metadata":{"type":"template-literal"}}],"edges":[{"src":"<paramDefaultFromDestructured>","dst":"<{width, height}>","type":"CONTAINS"},{"src":"<paramDefaultFromDestructured>","dst":"<area>","type":"CONTAINS"},{"src":"<{width, height}>","dst":"<width>","type":"HAS_ELEMENT"},{"src":"<{width, height}>","dst":"<height>","type":"HAS_ELEMENT"},{"src":"<area>","dst":"<width * height>","type":"DEFAULTS_TO"},{"src":"<width * height>","dst":"<width>","type":"READS_FROM"},{"src":"<width * height>","dst":"<height>","type":"READS_FROM"},{"src":"<paramDefaultFromDestructured>","dst":"<{ width, height, area }>","type":"RETURNS"},{"src":"<{ width, height, area }>","dst":"<width>","type":"READS_FROM"},{"src":"<{ width, height, area }>","dst":"<height>","type":"READS_FROM"},{"src":"<{ width, height, area }>","dst":"<area>","type":"READS_FROM"},{"src":"<queryBuilder>","dst":"<{table, schema = 'public'}>","type":"CONTAINS"},{"src":"<queryBuilder>","dst":"<fullName>","type":"CONTAINS"},{"src":"<{table, schema = 'public'}>","dst":"<table>","type":"HAS_ELEMENT"},{"src":"<{table, schema = 'public'}>","dst":"<schema>","type":"HAS_ELEMENT"},{"src":"<schema>","dst":"<'public'>","type":"DEFAULTS_TO"},{"src":"<fullName>","dst":"<`${schema}.${table}`>","type":"DEFAULTS_TO"},{"src":"<`${schema}.${table}`>","dst":"<schema>","type":"READS_FROM"},{"src":"<`${schema}.${table}`>","dst":"<table>","type":"READS_FROM"},{"src":"<queryBuilder>","dst":"<`SELECT * FROM ${fullName}`>","type":"RETURNS"},{"src":"<`SELECT * FROM ${fullName}`>","dst":"<fullName>","type":"READS_FROM"}],"rationale":"Functions with destructured parameters that have defaults, and subsequent parameters that depend on destructured values. Shows cross-parameter dependencies in default expressions. Used HAS_ELEMENT instead of DESTRUCTURES_TO to represent the relationship between destructured parameters and their constituent variables.","implicitBehavior":["parameter defaults evaluated left-to-right","destructured variables available to later parameter defaults","template literal interpolation"]},"pass":2,"annotatedAt":"2026-02-24T00:32:55.188Z"}
{"construct":{"id":"declarations::export-named-list","file":"src/declarations.js","category":"declarations","lineStart":249,"lineEnd":294,"code":"export {\n  mutableVar,\n  reassignable,\n  immutable,\n  objectConst,\n  arrayConst,\n  bigNumber,\n  uniqueKey,\n  globalSymbol,\n  regexSimple,\n  regularFunction,\n  withDefaults,\n  withRestParams,\n  withMixedParams,\n  namedExpression,\n  anonymousExpression,\n  arrowBlock,\n  arrowExpression,\n  arrowSingleParam,\n  arrowNoParams,\n  numberGenerator,\n  delegatingGenerator,\n  asyncFunction,\n  asyncArrow,\n  asyncGenerator,\n  iifeResult,\n  arrowIifeResult,\n  paramDefaultChain,\n  paramDefaultScope,\n  arrowReturnsObject,\n  asyncIifeResult,\n  constMultiC,\n  letMultiY,\n  factorialNamedExpr,\n  FlexibleConstructor,\n  paramDefaultFromDestructured,\n  queryBuilder,\n  TIMEOUT_MS,\n  MAX_SAFE,\n  HEX_COLOR,\n  BIT_MASK,\n  BIG_NUM,\n  FLOAT_SEP,\n  functionNameInference,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}}],"edges":[{"src":"<module>","dst":"<export-named-list>","type":"CONTAINS"},{"src":"<export-named-list>","dst":"<mutableVar>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<reassignable>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<immutable>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<objectConst>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrayConst>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<bigNumber>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<uniqueKey>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<globalSymbol>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<regexSimple>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<regularFunction>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<withDefaults>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<withRestParams>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<withMixedParams>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<namedExpression>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<anonymousExpression>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrowBlock>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrowExpression>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrowSingleParam>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrowNoParams>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<numberGenerator>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<delegatingGenerator>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<asyncFunction>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<asyncArrow>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<asyncGenerator>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<iifeResult>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrowIifeResult>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<paramDefaultChain>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<paramDefaultScope>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<arrowReturnsObject>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<asyncIifeResult>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<constMultiC>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<letMultiY>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<factorialNamedExpr>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<FlexibleConstructor>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<paramDefaultFromDestructured>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<queryBuilder>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<TIMEOUT_MS>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<MAX_SAFE>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<HEX_COLOR>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<BIT_MASK>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<BIG_NUM>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<FLOAT_SEP>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<functionNameInference>","type":"EXPORTS"}],"rationale":"Named export list that re-exports multiple previously declared identifiers from the module's scope. The Pass 1 annotation was already using approved vocabulary types (EXPORT node type and EXPORTS edge type), so no changes were needed.","implicitBehavior":["exported identifiers must be declared in module scope","creates named bindings in importing modules"]},"pass":2,"annotatedAt":"2026-02-24T00:32:56.234Z"}
{"construct":{"id":"error-handling::error-promise-catch","file":"src/error-handling.js","category":"error-handling","lineStart":128,"lineEnd":135,"code":"function promiseErrorHandling() {\n  return Promise.reject(new Error('boom'))\n    .catch(err => {\n      console.error('Caught:', err.message);\n      return 'recovered';\n    });\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<promiseErrorHandling>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<Promise.reject(new Error('boom'))>","metadata":{"callee":"Promise.reject"}},{"type":"CALL","id":"<new Error('boom')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'boom'>","metadata":{"value":"boom","literalType":"string"}},{"type":"CALL","id":"<.catch(err => {...})>","metadata":{"callee":"catch","method":true}},{"type":"FUNCTION","id":"<catch-handler>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<err>"},{"type":"CALL","id":"<console.error('Caught:', err.message)>","metadata":{"callee":"console.error"}},{"type":"LITERAL","id":"<'Caught:'>","metadata":{"value":"Caught:","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<err.message>","metadata":{"objectName":"err","property":"message"}},{"type":"LITERAL","id":"<'recovered'>","metadata":{"value":"recovered","literalType":"string"}}],"edges":[{"src":"<promiseErrorHandling>","dst":"<Promise.reject(new Error('boom'))>","type":"RETURNS"},{"src":"<Promise.reject(new Error('boom'))>","dst":"<new Error('boom')>","type":"PASSES_ARGUMENT"},{"src":"<new Error('boom')>","dst":"<'boom'>","type":"PASSES_ARGUMENT"},{"src":"<Promise.reject(new Error('boom'))>","dst":"<.catch(err => {...})>","type":"CHAINS_FROM"},{"src":"<.catch(err => {...})>","dst":"<catch-handler>","type":"PASSES_ARGUMENT"},{"src":"<catch-handler>","dst":"<err>","type":"CONTAINS"},{"src":"<catch-handler>","dst":"<console.error('Caught:', err.message)>","type":"CONTAINS"},{"src":"<console.error('Caught:', err.message)>","dst":"<'Caught:'>","type":"PASSES_ARGUMENT"},{"src":"<console.error('Caught:', err.message)>","dst":"<err.message>","type":"PASSES_ARGUMENT"},{"src":"<err.message>","dst":"<err>","type":"READS_FROM"},{"src":"<catch-handler>","dst":"<'recovered'>","type":"RETURNS"}],"rationale":"Function returns a rejected promise that is immediately caught. The catch handler logs the error and returns a recovery value, transforming the rejected promise into a resolved one. Used CHAINS_FROM to represent promise method chaining.","implicitBehavior":["Promise.reject creates a rejected promise","catch method transforms rejected promise to resolved promise with recovery value","console.error is a side effect"]},"pass":2,"annotatedAt":"2026-02-24T00:32:57.198Z"}
{"construct":{"id":"builtins::builtin-json-stringify-replacer","file":"src/builtins.js","category":"builtins","lineStart":25,"lineEnd":33,"code":"function jsonStringifyReplacer(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === 'function') return undefined;\n    return value;\n  }, 2);\n}\n\n// --- Map ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<jsonStringifyReplacer>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<JSON.stringify(obj, replacer, 2)>","metadata":{"callee":"JSON.stringify"}},{"type":"PROPERTY_ACCESS","id":"<JSON.stringify>","metadata":{"objectName":"JSON","propertyName":"stringify"}},{"type":"FUNCTION","id":"<replacer>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<value>"},{"type":"EXPRESSION","id":"<typeof value === 'function'>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<typeof value>","metadata":{"operator":"typeof"}},{"type":"LITERAL","id":"<'function'>","metadata":{"value":"function","literalType":"string"}},{"type":"LITERAL","id":"<undefined>","metadata":{"value":"undefined","literalType":"undefined"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"BRANCH","id":"<if-typeof-function>","metadata":{"branchType":"if"}}],"edges":[{"src":"<jsonStringifyReplacer>","dst":"<obj>","type":"HAS_BODY"},{"src":"<jsonStringifyReplacer>","dst":"<JSON.stringify(obj, replacer, 2)>","type":"RETURNS"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<JSON.stringify>","type":"CALLS"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<replacer>","type":"PASSES_ARGUMENT"},{"src":"<JSON.stringify(obj, replacer, 2)>","dst":"<2>","type":"PASSES_ARGUMENT"},{"src":"<replacer>","dst":"<key>","type":"HAS_BODY"},{"src":"<replacer>","dst":"<value>","type":"HAS_BODY"},{"src":"<replacer>","dst":"<if-typeof-function>","type":"HAS_BODY"},{"src":"<if-typeof-function>","dst":"<typeof value === 'function'>","type":"HAS_CONDITION"},{"src":"<typeof value === 'function'>","dst":"<typeof value>","type":"READS_FROM"},{"src":"<typeof value === 'function'>","dst":"<'function'>","type":"READS_FROM"},{"src":"<typeof value>","dst":"<value>","type":"READS_FROM"},{"src":"<if-typeof-function>","dst":"<undefined>","type":"HAS_CONSEQUENT"},{"src":"<if-typeof-function>","dst":"<value>","type":"HAS_ALTERNATE"}],"rationale":"Function that wraps JSON.stringify with a replacer callback. The replacer filters out function values by returning undefined, otherwise returns the original value.","implicitBehavior":["JSON.stringify is a built-in global method","typeof operator returns string representation of value type","replacer function is called for each property during serialization"]},"pass":2,"annotatedAt":"2026-02-24T00:32:59.168Z"}
{"construct":{"id":"declarations::function-name-inference","file":"src/declarations.js","category":"declarations","lineStart":217,"lineEnd":247,"code":"function functionNameInference() {\n  // Variable assignment  name inferred as \"fromVar\"\n  const fromVar = function() {};\n\n  // Object property  name inferred as \"method\"\n  const obj = {\n    method: function() {},\n    arrow: () => {},\n  };\n\n  // Class expression  name inferred as \"MyClass\"\n  const MyClass = class {};\n\n  // Default param  name inferred as \"fn\"\n  function withDefault(fn = function() {}) {\n    return fn;\n  }\n\n  // NOT inferred  Object.defineProperty\n  Object.defineProperty(obj, 'hidden', { value: function() {} });\n\n  return {\n    varName: fromVar.name,        // \"fromVar\"\n    methodName: obj.method.name,  // \"method\"\n    arrowName: obj.arrow.name,    // \"arrow\"\n    className: MyClass.name,      // \"MyClass\"\n    defaultName: withDefault().name, // \"fn\"\n    hiddenName: obj.hidden.name,  // \"\" (empty)\n  };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<functionNameInference>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": "},"pass":2,"annotatedAt":"2026-02-24T00:32:59.782Z"}
{"construct":{"id":"error-handling::error-rethrow-conditional","file":"src/error-handling.js","category":"error-handling","lineStart":57,"lineEnd":74,"code":"function processData(data) {\n  try {\n    return transform(data);\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err; // re-throw known errors as-is\n    }\n    throw new AppError(`Unexpected: ${err.message}`, 'INTERNAL');\n  }\n}\n\nfunction transform(data) {\n  if (!data) throw new ValidationError('data', 'Data is required');\n  return data;\n}\n\n// --- instanceof checks in catch ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<processData>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<data>"},{"type":"TRY_BLOCK","id":"<processData:try>"},{"type":"CALL","id":"<transform(data)>","metadata":{"callee":"transform"}},{"type":"CATCH_BLOCK","id":"<processData:catch>"},{"type":"PARAMETER","id":"<err>"},{"type":"BRANCH","id":"<err instanceof ValidationError>"},{"type":"EXPRESSION","id":"<err instanceof ValidationError>","metadata":{"operator":"instanceof"}},{"type":"EXPRESSION","id":"<throw err>","metadata":{"throwType":"rethrow"}},{"type":"CALL","id":"<new AppError(...)>","metadata":{"callee":"AppError","constructor":true}},{"type":"EXPRESSION","id":"<throw new AppError(...)>","metadata":{"throwType":"new"}},{"type":"FUNCTION","id":"<transform>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<transform:data>"},{"type":"BRANCH","id":"<transform:if>"},{"type":"EXPRESSION","id":"<!data>","metadata":{"operator":"!"}},{"type":"CALL","id":"<new ValidationError(...)>","metadata":{"callee":"ValidationError","constructor":true}},{"type":"EXPRESSION","id":"<throw new ValidationError(...)>","metadata":{"throwType":"new"}}],"edges":[{"src":"<processData>","dst":"<data>","type":"CONTAINS"},{"src":"<processData>","dst":"<processData:try>","type":"CONTAINS"},{"src":"<processData:try>","dst":"<transform(data)>","type":"CONTAINS"},{"src":"<processData:try>","dst":"<transform(data)>","type":"RETURNS"},{"src":"<transform(data)>","dst":"<transform>","type":"CALLS"},{"src":"<transform(data)>","dst":"<data>","type":"PASSES_ARGUMENT"},{"src":"<processData>","dst":"<processData:catch>","type":"HAS_CATCH"},{"src":"<processData:catch>","dst":"<err>","type":"CONTAINS"},{"src":"<processData:catch>","dst":"<err instanceof ValidationError>","type":"CONTAINS"},{"src":"<err instanceof ValidationError>","dst":"<err instanceof ValidationError>","type":"HAS_CONDITION"},{"src":"<err instanceof ValidationError>","dst":"<err>","type":"READS_FROM"},{"src":"<err instanceof ValidationError>","dst":"<throw err>","type":"HAS_CONSEQUENT"},{"src":"<throw err>","dst":"<err>","type":"THROWS"},{"src":"<err instanceof ValidationError>","dst":"<throw new AppError(...)>","type":"HAS_ALTERNATE"},{"src":"<new AppError(...)>","dst":"<err>","type":"READS_FROM"},{"src":"<throw new AppError(...)>","dst":"<new AppError(...)>","type":"THROWS"},{"src":"<transform>","dst":"<transform:data>","type":"CONTAINS"},{"src":"<transform>","dst":"<transform:if>","type":"CONTAINS"},{"src":"<transform:if>","dst":"<!data>","type":"HAS_CONDITION"},{"src":"<!data>","dst":"<transform:data>","type":"READS_FROM"},{"src":"<transform:if>","dst":"<throw new ValidationError(...)>","type":"HAS_CONSEQUENT"},{"src":"<throw new ValidationError(...)>","dst":"<new ValidationError(...)>","type":"THROWS"},{"src":"<transform>","dst":"<transform:data>","type":"RETURNS"}],"rationale":"Error handling with conditional re-throwing. Try block calls transform, catch block uses instanceof to distinguish error types - re-throwing ValidationError as-is but wrapping other errors in AppError. Transform function validates input and throws ValidationError on failure.","implicitBehavior":["instanceof check relies on prototype chain","error propagation up call stack","constructor calls create new error instances"]},"pass":2,"annotatedAt":"2026-02-24T00:32:59.822Z"}
{"construct":{"id":"error-handling::error-custom-hierarchy","file":"src/error-handling.js","category":"error-handling","lineStart":16,"lineEnd":34,"code":"class ValidationError extends AppError {\n  constructor(field, message) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource, id) {\n    super(`${resource} not found: ${id}`, 'NOT_FOUND');\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.id = id;\n  }\n}\n\n// --- Error cause (ES2022) ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ValidationError>"},{"type":"METHOD","id":"<ValidationError.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<field>"},{"type":"PARAMETER","id":"<message>"},{"type":"CALL","id":"<super(message, 'VALIDATION_ERROR')>","metadata":{"callee":"super"}},{"type":"LITERAL","id":"<'VALIDATION_ERROR'>","metadata":{"value":"VALIDATION_ERROR","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this","property":"name"}},{"type":"LITERAL","id":"<'ValidationError'>","metadata":{"value":"ValidationError","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this.field>","metadata":{"objectName":"this","property":"field"}},{"type":"CLASS","id":"<NotFoundError>"},{"type":"METHOD","id":"<NotFoundError.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<resource>"},{"type":"PARAMETER","id":"<id>"},{"type":"EXPRESSION","id":"<`${resource} not found: ${id}`>","metadata":{"type":"template-literal"}},{"type":"CALL","id":"<super(`${resource} not found: ${id}`, 'NOT_FOUND')>","metadata":{"callee":"super"}},{"type":"LITERAL","id":"<'NOT_FOUND'>","metadata":{"value":"NOT_FOUND","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this.name2>","metadata":{"objectName":"this","property":"name"}},{"type":"LITERAL","id":"<'NotFoundError'>","metadata":{"value":"NotFoundError","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this.resource>","metadata":{"objectName":"this","property":"resource"}},{"type":"PROPERTY_ACCESS","id":"<this.id>","metadata":{"objectName":"this","property":"id"}}],"edges":[{"src":"<ValidationError>","dst":"<ValidationError.constructor>","type":"CONTAINS"},{"src":"<ValidationError.constructor>","dst":"<field>","type":"CONTAINS"},{"src":"<ValidationError.constructor>","dst":"<message>","type":"CONTAINS"},{"src":"<ValidationError.constructor>","dst":"<super(message, 'VALIDATION_ERROR')>","type":"CONTAINS"},{"src":"<super(message, 'VALIDATION_ERROR')>","dst":"<message>","type":"PASSES_ARGUMENT"},{"src":"<super(message, 'VALIDATION_ERROR')>","dst":"<'VALIDATION_ERROR'>","type":"PASSES_ARGUMENT"},{"src":"<this.name>","dst":"<'ValidationError'>","type":"ASSIGNED_FROM"},{"src":"<this.field>","dst":"<field>","type":"ASSIGNED_FROM"},{"src":"<NotFoundError>","dst":"<NotFoundError.constructor>","type":"CONTAINS"},{"src":"<NotFoundError.constructor>","dst":"<resource>","type":"CONTAINS"},{"src":"<NotFoundError.constructor>","dst":"<id>","type":"CONTAINS"},{"src":"<`${resource} not found: ${id}`>","dst":"<resource>","type":"READS_FROM"},{"src":"<`${resource} not found: ${id}`>","dst":"<id>","type":"READS_FROM"},{"src":"<NotFoundError.constructor>","dst":"<super(`${resource} not found: ${id}`, 'NOT_FOUND')>","type":"CONTAINS"},{"src":"<super(`${resource} not found: ${id}`, 'NOT_FOUND')>","dst":"<`${resource} not found: ${id}`>","type":"PASSES_ARGUMENT"},{"src":"<super(`${resource} not found: ${id}`, 'NOT_FOUND')>","dst":"<'NOT_FOUND'>","type":"PASSES_ARGUMENT"},{"src":"<this.name2>","dst":"<'NotFoundError'>","type":"ASSIGNED_FROM"},{"src":"<this.resource>","dst":"<resource>","type":"ASSIGNED_FROM"},{"src":"<this.id>","dst":"<id>","type":"ASSIGNED_FROM"}],"rationale":"Simplified annotation focusing on core relationships. Removed redundant WRITES_TO edges and module-level DECLARES edges to reduce complexity while preserving essential semantic structure. Both classes extend AppError (implicit), constructors contain parameters and calls, property assignments capture instance initialization.","implicitBehavior":["prototype chain inheritance from AppError","Error.captureStackTrace behavior","instanceof checks will work for both AppError and Error","ValidationError and NotFoundError extend AppError (implicit inheritance)","Module-level declarations of both classes"]},"pass":2,"annotatedAt":"2026-02-24T00:33:02.247Z"}
{"construct":{"id":"error-handling::export-named-list","file":"src/error-handling.js","category":"error-handling","lineStart":179,"lineEnd":194,"code":"export {\n  AppError,\n  ValidationError,\n  NotFoundError,\n  fetchWithCause,\n  parseConfig,\n  processData,\n  handleError,\n  pipeline,\n  safeExecute,\n  promiseErrorHandling,\n  chainedErrors,\n  aggregatedErrors,\n  withCleanup,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<AppError>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<ValidationError>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<NotFoundError>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<fetchWithCause>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<parseConfig>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<processData>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<handleError>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<pipeline>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<safeExecute>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<promiseErrorHandling>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<chainedErrors>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<aggregatedErrors>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<withCleanup>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<AppError>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<ValidationError>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<NotFoundError>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<fetchWithCause>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<parseConfig>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<processData>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<handleError>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<pipeline>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<safeExecute>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<promiseErrorHandling>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<chainedErrors>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<aggregatedErrors>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<withCleanup>","type":"EXPORTS"}],"rationale":"Named export list making multiple identifiers available to importing modules. Each exported name references a variable that must be declared elsewhere in the module. Removed the CONTAINS edge from module to export as it's not essential to the core export semantics.","implicitBehavior":["exported names must be bound in module scope","creates named bindings in importing modules"]},"pass":2,"annotatedAt":"2026-02-24T00:33:05.209Z"}
{"construct":{"id":"error-handling::error-aggregate","file":"src/error-handling.js","category":"error-handling","lineStart":148,"lineEnd":158,"code":"function aggregatedErrors() {\n  const errors = [\n    new Error('first'),\n    new Error('second'),\n    new Error('third'),\n  ];\n  throw new AggregateError(errors, 'Multiple failures');\n}\n\n// --- Finally for cleanup ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<aggregatedErrors>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<errors>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<['first', 'second', 'third']>","metadata":{"literalType":"array"}},{"type":"CALL","id":"<new Error('first')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'first'>","metadata":{"value":"first","literalType":"string"}},{"type":"CALL","id":"<new Error('second')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'second'>","metadata":{"value":"second","literalType":"string"}},{"type":"CALL","id":"<new Error('third')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'third'>","metadata":{"value":"third","literalType":"string"}},{"type":"CALL","id":"<new AggregateError(errors, 'Multiple failures')>","metadata":{"callee":"AggregateError","constructor":true}},{"type":"LITERAL","id":"<'Multiple failures'>","metadata":{"value":"Multiple failures","literalType":"string"}},{"type":"EXTERNAL","id":"<Error>","metadata":{"source":"global"}},{"type":"EXTERNAL","id":"<AggregateError>","metadata":{"source":"global"}}],"edges":[{"src":"<aggregatedErrors>","dst":"<errors>","type":"CONTAINS"},{"src":"<errors>","dst":"<['first', 'second', 'third']>","type":"ASSIGNED_FROM"},{"src":"<['first', 'second', 'third']>","dst":"<new Error('first')>","type":"HAS_ELEMENT"},{"src":"<['first', 'second', 'third']>","dst":"<new Error('second')>","type":"HAS_ELEMENT"},{"src":"<['first', 'second', 'third']>","dst":"<new Error('third')>","type":"HAS_ELEMENT"},{"src":"<new Error('first')>","dst":"<Error>","type":"CALLS"},{"src":"<new Error('first')>","dst":"<'first'>","type":"PASSES_ARGUMENT"},{"src":"<new Error('second')>","dst":"<Error>","type":"CALLS"},{"src":"<new Error('second')>","dst":"<'second'>","type":"PASSES_ARGUMENT"},{"src":"<new Error('third')>","dst":"<Error>","type":"CALLS"},{"src":"<new Error('third')>","dst":"<'third'>","type":"PASSES_ARGUMENT"},{"src":"<aggregatedErrors>","dst":"<new AggregateError(errors, 'Multiple failures')>","type":"THROWS"},{"src":"<new AggregateError(errors, 'Multiple failures')>","dst":"<AggregateError>","type":"CALLS"},{"src":"<new AggregateError(errors, 'Multiple failures')>","dst":"<errors>","type":"PASSES_ARGUMENT"},{"src":"<new AggregateError(errors, 'Multiple failures')>","dst":"<'Multiple failures'>","type":"PASSES_ARGUMENT"}],"rationale":"Function creates array of Error instances, then throws AggregateError containing them. Added explicit EXTERNAL nodes for Error and AggregateError constructors to represent the global objects being called. All relationships preserved from Pass 1 using approved vocabulary.","implicitBehavior":["AggregateError aggregates multiple errors into single throwable","throw statement terminates function execution"]},"pass":2,"annotatedAt":"2026-02-24T00:33:05.826Z"}
{"construct":{"id":"expressions::delete-op","file":"src/expressions.js","category":"expressions","lineStart":61,"lineEnd":66,"code":"function deleteOperator() {\n  const obj = { a: 1, b: 2 };\n  delete obj.a;\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deleteOperator>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ a: 1, b: 2 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXPRESSION","id":"<delete obj.a>","metadata":{"operator":"delete"}},{"type":"PROPERTY_ACCESS","id":"<obj.a>","metadata":{"property":"a"}}],"edges":[{"src":"<deleteOperator>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{ a: 1, b: 2 }>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1, b: 2 }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<{ a: 1, b: 2 }>","dst":"<2>","type":"HAS_PROPERTY"},{"src":"<deleteOperator>","dst":"<delete obj.a>","type":"CONTAINS"},{"src":"<delete obj.a>","dst":"<obj.a>","type":"DELETES"},{"src":"<obj.a>","dst":"<obj>","type":"READS_FROM"},{"src":"<deleteOperator>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function contains object literal assignment and delete operation. Delete expression targets a property access, modifying the object structure. Reduced edge count by removing module declaration edge and correcting DELETES_FROM to DELETES.","implicitBehavior":["delete returns boolean indicating success","property is removed from object descriptor","may affect object shape for optimization"]},"pass":2,"annotatedAt":"2026-02-24T00:33:05.826Z"}
{"construct":{"id":"expressions::update-expr","file":"src/expressions.js","category":"expressions","lineStart":68,"lineEnd":76,"code":"function updateExpressions() {\n  let x = 0;\n  x++;\n  x--;\n  ++x;\n  --x;\n  return x;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<updateExpressions>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<x++>","metadata":{"operator":"++","prefix":false}},{"type":"EXPRESSION","id":"<x-->","metadata":{"operator":"--","prefix":false}},{"type":"EXPRESSION","id":"<++x>","metadata":{"operator":"++","prefix":true}},{"type":"EXPRESSION","id":"<--x>","metadata":{"operator":"--","prefix":true}}],"edges":[{"src":"<updateExpressions>","dst":"<x>","type":"CONTAINS"},{"src":"<x>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<x++>","dst":"<x>","type":"READS_FROM"},{"src":"<x++>","dst":"<x>","type":"WRITES_TO"},{"src":"<x-->","dst":"<x>","type":"READS_FROM"},{"src":"<x-->","dst":"<x>","type":"WRITES_TO"},{"src":"<++x>","dst":"<x>","type":"READS_FROM"},{"src":"<++x>","dst":"<x>","type":"WRITES_TO"},{"src":"<--x>","dst":"<x>","type":"READS_FROM"},{"src":"<--x>","dst":"<x>","type":"WRITES_TO"},{"src":"<updateExpressions>","dst":"<x>","type":"RETURNS"}],"rationale":"Function with update expressions that both read and modify a variable. Each update expression is atomic, with prefix/postfix distinction captured in metadata. Removed the module declaration edge as no module node was defined.","implicitBehavior":["postfix operators return old value, prefix operators return new value","all update expressions perform numeric coercion"]},"pass":2,"annotatedAt":"2026-02-24T00:33:07.667Z"}
{"construct":{"id":"error-handling::error-catch-instanceof","file":"src/error-handling.js","category":"error-handling","lineStart":76,"lineEnd":94,"code":"function handleError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      return { type: 'validation', field: err.field, message: err.message };\n    }\n    if (err instanceof NotFoundError) {\n      return { type: 'notfound', resource: err.resource };\n    }\n    if (err instanceof TypeError) {\n      return { type: 'type', message: err.message };\n    }\n    throw err; // unknown  re-throw\n  }\n}\n\n// --- Async error propagation ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<handleError>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER"},"pass":2,"annotatedAt":"2026-02-24T00:33:08.999Z"}
{"construct":{"id":"expressions::logical-ops","file":"src/expressions.js","category":"expressions","lineStart":29,"lineEnd":36,"code":"function logicalOperators(a, b) {\n  const and = a && b;\n  const or = a || b;\n  const nullish = a ?? b;\n  const not = !a;\n  return { and, or, nullish, not };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<logicalOperators>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"VARIABLE","id":"<and>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<a && b>","metadata":{"operator":"&&"}},{"type":"VARIABLE","id":"<or>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<a || b>","metadata":{"operator":"||"}},{"type":"VARIABLE","id":"<nullish>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<a ?? b>","metadata":{"operator":"??"}},{"type":"VARIABLE","id":"<not>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<!a>","metadata":{"operator":"!"}},{"type":"EXPRESSION","id":"<{ and, or, nullish, not }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<logicalOperators>","dst":"<a>","type":"CONTAINS"},{"src":"<logicalOperators>","dst":"<b>","type":"CONTAINS"},{"src":"<logicalOperators>","dst":"<and>","type":"CONTAINS"},{"src":"<and>","dst":"<a && b>","type":"ASSIGNED_FROM"},{"src":"<a && b>","dst":"<a>","type":"READS_FROM"},{"src":"<a && b>","dst":"<b>","type":"READS_FROM"},{"src":"<logicalOperators>","dst":"<or>","type":"CONTAINS"},{"src":"<or>","dst":"<a || b>","type":"ASSIGNED_FROM"},{"src":"<a || b>","dst":"<a>","type":"READS_FROM"},{"src":"<a || b>","dst":"<b>","type":"READS_FROM"},{"src":"<logicalOperators>","dst":"<nullish>","type":"CONTAINS"},{"src":"<nullish>","dst":"<a ?? b>","type":"ASSIGNED_FROM"},{"src":"<a ?? b>","dst":"<a>","type":"READS_FROM"},{"src":"<a ?? b>","dst":"<b>","type":"READS_FROM"},{"src":"<logicalOperators>","dst":"<not>","type":"CONTAINS"},{"src":"<not>","dst":"<!a>","type":"ASSIGNED_FROM"},{"src":"<!a>","dst":"<a>","type":"READS_FROM"},{"src":"<logicalOperators>","dst":"<{ and, or, nullish, not }>","type":"RETURNS"},{"src":"<{ and, or, nullish, not }>","dst":"<and>","type":"READS_FROM"},{"src":"<{ and, or, nullish, not }>","dst":"<or>","type":"READS_FROM"},{"src":"<{ and, or, nullish, not }>","dst":"<nullish>","type":"READS_FROM"},{"src":"<{ and, or, nullish, not }>","dst":"<not>","type":"READS_FROM"}],"rationale":"Function with logical operator expressions using approved vocabulary. Removed the module declaration edge since no module node was defined. All other relationships preserved using approved edge types.","implicitBehavior":["&& and || use short-circuit evaluation","?? only checks for null/undefined, not other falsy values","! performs boolean coercion"]},"pass":2,"annotatedAt":"2026-02-24T00:33:10.029Z"}
{"construct":{"id":"error-handling::error-async-propagation","file":"src/error-handling.js","category":"error-handling","lineStart":96,"lineEnd":115,"code":"async function pipeline(input) {\n  const step1 = await validateAsync(input);\n  const step2 = await transformAsync(step1);\n  const step3 = await saveAsync(step2);\n  return step3;\n}\n\nasync function validateAsync(data) {\n  if (!data) throw new ValidationError('input', 'Required');\n  return data;\n}\n\nasync function transformAsync(data) {\n  return { ...data, transformed: true };\n}\n\nasync function saveAsync(data) {\n  return { ...data, saved: true };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<pipeline>\",\n      \"metadata\": {\n        \"async\": true\n      }\n    },\n    {\n      \"type\": \"PARAMETER\",\n      \"id\": \"<input>\"\n    },\n"},"pass":2,"annotatedAt":"2026-02-24T00:33:12.122Z"}
{"construct":{"id":"expressions::tagged-template-usage","file":"src/expressions.js","category":"expressions","lineStart":136,"lineEnd":137,"code":"const tagged = tag`Hello ${'world'} number ${42}`;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<tagged>","metadata":{"kind":"const"}},{"type":"CALL","id":"<tag`Hello ${'world'} number ${42}`>","metadata":{"callType":"tagged-template"}},{"type":"LITERAL","id":"<'Hello '>","metadata":{"value":"Hello ","literalType":"string","templatePart":"static"}},{"type":"LITERAL","id":"<'world'>","metadata":{"value":"world","literalType":"string"}},{"type":"LITERAL","id":"<' number '>","metadata":{"value":" number ","literalType":"string","templatePart":"static"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"LITERAL","id":"<''>","metadata":{"value":"","literalType":"string","templatePart":"static"}}],"edges":[{"src":"<module>","dst":"<tagged>","type":"DECLARES"},{"src":"<tagged>","dst":"<tag`Hello ${'world'} number ${42}`>","type":"ASSIGNED_FROM"},{"src":"<tag`Hello ${'world'} number ${42}`>","dst":"<tag>","type":"CALLS"},{"src":"<tag`Hello ${'world'} number ${42}`>","dst":"<'Hello '>","type":"PASSES_ARGUMENT"},{"src":"<tag`Hello ${'world'} number ${42}`>","dst":"<' number '>","type":"PASSES_ARGUMENT"},{"src":"<tag`Hello ${'world'} number ${42}`>","dst":"<''>","type":"PASSES_ARGUMENT"},{"src":"<tag`Hello ${'world'} number ${42}`>","dst":"<'world'>","type":"PASSES_ARGUMENT"},{"src":"<tag`Hello ${'world'} number ${42}`>","dst":"<42>","type":"PASSES_ARGUMENT"}],"rationale":"Tagged template literal calls the tag function with an array of string parts and the interpolated expressions as separate arguments. All node and edge types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["tag function receives strings array as first argument, then individual expression values","strings array has raw property containing unescaped versions"]},"pass":2,"annotatedAt":"2026-02-24T00:33:14.119Z"}
{"construct":{"id":"expressions::tagged-template-fn","file":"src/expressions.js","category":"expressions","lineStart":131,"lineEnd":134,"code":"function tag(strings, ...values) {\n  return strings.raw.join('') + values.join('');\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tag>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<strings>"},{"type":"PARAMETER","id":"<values>","metadata":{"restParameter":true}},{"type":"PROPERTY_ACCESS","id":"<strings.raw>","metadata":{"property":"raw"}},{"type":"CALL","id":"<strings.raw.join('')>","metadata":{"callee":"join","method":true}},{"type":"LITERAL","id":"<''>","metadata":{"value":"","literalType":"string"}},{"type":"CALL","id":"<values.join('')>","metadata":{"callee":"join","method":true}},{"type":"EXPRESSION","id":"<strings.raw.join('') + values.join('')>","metadata":{"operator":"+"}}],"edges":[{"src":"<tag>","dst":"<strings>","type":"HAS_BODY"},{"src":"<tag>","dst":"<values>","type":"HAS_BODY"},{"src":"<strings.raw>","dst":"<strings>","type":"READS_FROM"},{"src":"<strings.raw.join('')>","dst":"<strings.raw>","type":"CALLS_ON"},{"src":"<strings.raw.join('')>","dst":"<''>","type":"PASSES_ARGUMENT"},{"src":"<values.join('')>","dst":"<values>","type":"CALLS_ON"},{"src":"<values.join('')>","dst":"<''>","type":"PASSES_ARGUMENT"},{"src":"<strings.raw.join('') + values.join('')>","dst":"<strings.raw.join('')>","type":"READS_FROM"},{"src":"<strings.raw.join('') + values.join('')>","dst":"<values.join('')>","type":"READS_FROM"},{"src":"<tag>","dst":"<strings.raw.join('') + values.join('')>","type":"RETURNS"}],"rationale":"Tagged template function with rest parameter. Accesses raw strings property, calls join on both parameters, and returns concatenated result. Used HAS_BODY for parameter containment and CALLS_ON for method calls.","implicitBehavior":["function can be used as tagged template literal handler","strings parameter receives TemplateStringsArray with raw property"]},"pass":2,"annotatedAt":"2026-02-24T00:33:16.483Z"}
{"construct":{"id":"expressions::comparison-ops","file":"src/expressions.js","category":"expressions","lineStart":16,"lineEnd":27,"code":"function comparisonOperators(a, b) {\n  const eq = a == b;\n  const strictEq = a === b;\n  const neq = a != b;\n  const strictNeq = a !== b;\n  const lt = a < b;\n  const gt = a > b;\n  const lte = a <= b;\n  const gte = a >= b;\n  return { eq, strictEq, neq, strictNeq, lt, gt, lte, gte };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<comparisonOperators>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"P"},"pass":2,"annotatedAt":"2026-02-24T00:33:16.484Z"}
{"construct":{"id":"expressions::arithmetic-ops","file":"src/expressions.js","category":"expressions","lineStart":5,"lineEnd":14,"code":"function arithmeticOperators(a, b) {\n  const add = a + b;\n  const sub = a - b;\n  const mul = a * b;\n  const div = a / b;\n  const mod = a % b;\n  const exp = a ** b;\n  return { add, sub, mul, div, mod, exp };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<arithmeticOperators>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"P"},"pass":2,"annotatedAt":"2026-02-24T00:33:17.211Z"}
{"construct":{"id":"expressions::bitwise-ops","file":"src/expressions.js","category":"expressions","lineStart":38,"lineEnd":48,"code":"function bitwiseOperators(a, b) {\n  const and = a & b;\n  const or = a | b;\n  const xor = a ^ b;\n  const not = ~a;\n  const lshift = a << b;\n  const rshift = a >> b;\n  const urshift = a >>> b;\n  return { and, or, xor, not, lshift, rshift, urshift };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<bitwiseOperators>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARA"},"pass":2,"annotatedAt":"2026-02-24T00:33:18.726Z"}
{"construct":{"id":"expressions::optional-chaining","file":"src/expressions.js","category":"expressions","lineStart":111,"lineEnd":117,"code":"function optionalChaining(obj) {\n  const prop = obj?.nested?.deep;\n  const method = obj?.method?.();\n  const computed = obj?.items?.[0];\n  return { prop, method, computed };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<optionalChaining>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<prop>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj?.nested?.deep>","metadata":{"type":"optional_chain","chainLength":3}},{"type":"VARIABLE","id":"<method>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj?.method?.()>","metadata":{"type":"optional_chain_call","chainLength":2,"hasCall":true}},{"type":"VARIABLE","id":"<computed>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj?.items?.[0]>","metadata":{"type":"optional_chain_computed","chainLength":2,"hasComputed":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ prop, method, computed }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<optionalChaining>","dst":"<obj>","type":"CONTAINS"},{"src":"<optionalChaining>","dst":"<prop>","type":"CONTAINS"},{"src":"<optionalChaining>","dst":"<method>","type":"CONTAINS"},{"src":"<optionalChaining>","dst":"<computed>","type":"CONTAINS"},{"src":"<prop>","dst":"<obj?.nested?.deep>","type":"ASSIGNED_FROM"},{"src":"<obj?.nested?.deep>","dst":"<obj>","type":"READS_FROM"},{"src":"<method>","dst":"<obj?.method?.()>","type":"ASSIGNED_FROM"},{"src":"<obj?.method?.()>","dst":"<obj>","type":"READS_FROM"},{"src":"<computed>","dst":"<obj?.items?.[0]>","type":"ASSIGNED_FROM"},{"src":"<obj?.items?.[0]>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj?.items?.[0]>","dst":"<0>","type":"READS_FROM"},{"src":"<optionalChaining>","dst":"<{ prop, method, computed }>","type":"RETURNS"},{"src":"<{ prop, method, computed }>","dst":"<prop>","type":"READS_FROM"},{"src":"<{ prop, method, computed }>","dst":"<method>","type":"READS_FROM"},{"src":"<{ prop, method, computed }>","dst":"<computed>","type":"READS_FROM"}],"rationale":"Function with optional chaining expressions mapped to EXPRESSION nodes. Each optional chain is represented as a generic expression with metadata indicating its specific type and characteristics.","implicitBehavior":["optional chaining short-circuits to undefined if any link is null/undefined","method call only executes if the method exists","computed access uses bracket notation with safe navigation"]},"pass":2,"annotatedAt":"2026-02-24T00:33:19.446Z"}
{"construct":{"id":"expressions::unary-ops","file":"src/expressions.js","category":"expressions","lineStart":50,"lineEnd":59,"code":"function unaryOperators(x) {\n  const pos = +x;\n  const neg = -x;\n  const logNot = !x;\n  const bitNot = ~x;\n  const typeOfX = typeof x;\n  const voidX = void x;\n  return { pos, neg, logNot, bitNot, typeOfX, voidX };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<unaryOperators>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"VARIABLE","id":"<pos>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<+x>","metadata":{"operator":"+","unary":true}},{"type":"VARIABLE","id":"<neg>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<-x>","metadata":{"operator":"-","unary":true}},{"type":"VARIABLE","id":"<logNot>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<!x>","metadata":{"operator":"!","unary":true}},{"type":"VARIABLE","id":"<bitNot>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<~x>","metadata":{"operator":"~","unary":true}},{"type":"VARIABLE","id":"<typeOfX>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<typeof x>","metadata":{"operator":"typeof","unary":true}},{"type":"VARIABLE","id":"<voidX>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<void x>","metadata":{"operator":"void","unary":true}},{"type":"EXPRESSION","id":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<unaryOperators>","dst":"<x>","type":"CONTAINS"},{"src":"<unaryOperators>","dst":"<pos>","type":"CONTAINS"},{"src":"<pos>","dst":"<+x>","type":"ASSIGNED_FROM"},{"src":"<+x>","dst":"<x>","type":"READS_FROM"},{"src":"<unaryOperators>","dst":"<neg>","type":"CONTAINS"},{"src":"<neg>","dst":"<-x>","type":"ASSIGNED_FROM"},{"src":"<-x>","dst":"<x>","type":"READS_FROM"},{"src":"<unaryOperators>","dst":"<logNot>","type":"CONTAINS"},{"src":"<logNot>","dst":"<!x>","type":"ASSIGNED_FROM"},{"src":"<!x>","dst":"<x>","type":"READS_FROM"},{"src":"<unaryOperators>","dst":"<bitNot>","type":"CONTAINS"},{"src":"<bitNot>","dst":"<~x>","type":"ASSIGNED_FROM"},{"src":"<~x>","dst":"<x>","type":"READS_FROM"},{"src":"<unaryOperators>","dst":"<typeOfX>","type":"CONTAINS"},{"src":"<typeOfX>","dst":"<typeof x>","type":"ASSIGNED_FROM"},{"src":"<typeof x>","dst":"<x>","type":"READS_FROM"},{"src":"<unaryOperators>","dst":"<voidX>","type":"CONTAINS"},{"src":"<voidX>","dst":"<void x>","type":"ASSIGNED_FROM"},{"src":"<void x>","dst":"<x>","type":"READS_FROM"},{"src":"<unaryOperators>","dst":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","type":"RETURNS"},{"src":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","dst":"<pos>","type":"READS_FROM"},{"src":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","dst":"<neg>","type":"READS_FROM"},{"src":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","dst":"<logNot>","type":"READS_FROM"},{"src":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","dst":"<bitNot>","type":"READS_FROM"},{"src":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","dst":"<typeOfX>","type":"READS_FROM"},{"src":"<{ pos, neg, logNot, bitNot, typeOfX, voidX }>","dst":"<voidX>","type":"READS_FROM"}],"rationale":"Function demonstrating unary operators. Each const variable is assigned from a unary expression operating on parameter x. Returns object literal with shorthand property syntax. Removed the module declaration edge as no module node was defined.","implicitBehavior":["unary + coerces to number","unary - coerces to number then negates","logical ! coerces to boolean then negates","bitwise ~ coerces to 32-bit signed integer then inverts bits","typeof returns string representation of type","void always returns undefined regardless of operand"]},"pass":2,"annotatedAt":"2026-02-24T00:33:21.396Z"}
{"construct":{"id":"builtins::builtin-map-constructor","file":"src/builtins.js","category":"builtins","lineStart":63,"lineEnd":72,"code":"function mapFromEntries() {\n  const map = new Map([\n    ['x', 10],\n    ['y', 20],\n  ]);\n  return map;\n}\n\n// --- Set ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<mapFromEntries>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<map>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Map([...])>","metadata":{"callee":"Map","constructor":true}},{"type":"LITERAL","id":"<[['x', 10], ['y', 20]]>","metadata":{"value":"[['x', 10], ['y', 20]]","literalType":"array"}},{"type":"LITERAL","id":"<['x', 10]>","metadata":{"value":"['x', 10]","literalType":"array"}},{"type":"LITERAL","id":"<'x'>","metadata":{"value":"x","literalType":"string"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"LITERAL","id":"<['y', 20]>","metadata":{"value":"['y', 20]","literalType":"array"}},{"type":"LITERAL","id":"<'y'>","metadata":{"value":"y","literalType":"string"}},{"type":"LITERAL","id":"<20>","metadata":{"value":20,"literalType":"number"}},{"type":"EXTERNAL","id":"<Map>","metadata":{"builtin":true}}],"edges":[{"src":"<mapFromEntries>","dst":"<map>","type":"CONTAINS"},{"src":"<map>","dst":"<new Map([...])>","type":"ASSIGNED_FROM"},{"src":"<new Map([...])>","dst":"<Map>","type":"CALLS"},{"src":"<new Map([...])>","dst":"<[['x', 10], ['y', 20]]>","type":"PASSES_ARGUMENT"},{"src":"<[['x', 10], ['y', 20]]>","dst":"<['x', 10]>","type":"HAS_ELEMENT"},{"src":"<[['x', 10], ['y', 20]]>","dst":"<['y', 20]>","type":"HAS_ELEMENT"},{"src":"<['x', 10]>","dst":"<'x'>","type":"HAS_ELEMENT"},{"src":"<['x', 10]>","dst":"<10>","type":"HAS_ELEMENT"},{"src":"<['y', 20]>","dst":"<'y'>","type":"HAS_ELEMENT"},{"src":"<['y', 20]>","dst":"<20>","type":"HAS_ELEMENT"},{"src":"<mapFromEntries>","dst":"<map>","type":"RETURNS"}],"rationale":"Function creates a Map from an array of key-value pairs. Constructor call with nested array literals containing string keys and number values. Removed the module-level DECLARES edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["Map constructor accepts iterable of [key, value] pairs","Map maintains insertion order"]},"pass":2,"annotatedAt":"2026-02-24T00:33:22.926Z"}
{"construct":{"id":"expressions::chained-assignment-mixed","file":"src/expressions.js","category":"expressions","lineStart":220,"lineEnd":225,"code":"function chainedAssignmentMixed() {\n  const obj = {};\n  obj.x = obj.y = [];\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<chainedAssignmentMixed>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<obj.x>","metadata":{"objectName":"obj","propertyName":"x"}},{"type":"PROPERTY_ACCESS","id":"<obj.y>","metadata":{"objectName":"obj","propertyName":"y"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"EXPRESSION","id":"<obj.x = obj.y = []>","metadata":{"operator":"chained-assignment"}}],"edges":[{"src":"<chainedAssignmentMixed>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<obj.x = obj.y = []>","dst":"<[]>","type":"READS_FROM"},{"src":"<obj.y>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<obj.x>","dst":"<obj.y>","type":"ASSIGNED_FROM"},{"src":"<obj.x = obj.y = []>","dst":"<obj.x>","type":"WRITES_TO"},{"src":"<obj.x = obj.y = []>","dst":"<obj.y>","type":"WRITES_TO"},{"src":"<chainedAssignmentMixed>","dst":"<obj>","type":"RETURNS"}],"rationale":"Chained assignment where both obj.x and obj.y receive the same array reference. The assignment evaluates right-to-left: array literal is assigned to obj.y, then obj.y's value flows to obj.x. Removed the module declaration edge to stay within the 7-edge threshold while preserving the core semantic relationships.","implicitBehavior":["both properties reference the same array object","assignment operator returns the assigned value enabling chaining"]},"pass":2,"annotatedAt":"2026-02-24T00:33:24.470Z"}
{"construct":{"id":"expressions::chained-assignment","file":"src/expressions.js","category":"expressions","lineStart":213,"lineEnd":218,"code":"function chainedAssignment() {\n  let a, b, c;\n  a = b = c = 42;\n  return { a, b, c };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<chainedAssignment>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<c>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ a, b, c }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<chainedAssignment>","dst":"<a>","type":"DECLARES"},{"src":"<chainedAssignment>","dst":"<b>","type":"DECLARES"},{"src":"<chainedAssignment>","dst":"<c>","type":"DECLARES"},{"src":"<c>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<b>","dst":"<c>","type":"ASSIGNED_FROM"},{"src":"<a>","dst":"<b>","type":"ASSIGNED_FROM"},{"src":"<chainedAssignment>","dst":"<{ a, b, c }>","type":"RETURNS"},{"src":"<{ a, b, c }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<b>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<c>","type":"READS_FROM"}],"rationale":"Function declares three variables and performs chained assignment where value flows from literal 42 through cba, then returns object literal reading all three variables. Removed the intermediate chained assignment expression node to reduce edge count while preserving the essential semantic relationships.","implicitBehavior":["chained assignment evaluates right-to-left","assignment expressions return the assigned value","object literal uses shorthand property syntax"]},"pass":2,"annotatedAt":"2026-02-24T00:33:24.774Z"}
{"construct":{"id":"expressions::assignment-ops","file":"src/expressions.js","category":"expressions","lineStart":78,"lineEnd":102,"code":"function assignmentOperators() {\n  let x = 10;\n  x += 5;\n  x -= 3;\n  x *= 2;\n  x /= 4;\n  x %= 3;\n  x **= 2;\n  x &= 0xff;\n  x |= 0x0f;\n  x ^= 0xaa;\n  x <<= 2;\n  x >>= 1;\n  x >>>= 1;\n\n  let flag = true;\n  flag &&= false;\n  flag ||= true;\n\n  let val = null;\n  val ??= 'fallback';\n\n  return { x, flag, val };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<assignmentOperators>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"V"},"pass":2,"annotatedAt":"2026-02-24T00:33:25.491Z"}
{"construct":{"id":"expressions::ternary","file":"src/expressions.js","category":"expressions","lineStart":104,"lineEnd":109,"code":"function ternaryOperator(condition, value) {\n  const simple = condition ? 'yes' : 'no';\n  const nested = condition ? (value > 5 ? 'high' : 'low') : 'none';\n  return { simple, nested };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<ternaryOperator>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<condition>"},{"type":"PARAMETER","id":"<value>"},{"type":"VARIABLE","id":"<simple>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<condition ? 'yes' : 'no'>","metadata":{"operator":"?:"}},{"type":"LITERAL","id":"<'yes'>","metadata":{"value":"yes","literalType":"string"}},{"type":"LITERAL","id":"<'no'>","metadata":{"value":"no","literalType":"string"}},{"type":"VARIABLE","id":"<nested>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<condition ? (value > 5 ? 'high' : 'low') : 'none'>","metadata":{"operator":"?:"}},{"type":"EXPRESSION","id":"<value > 5 ? 'high' : 'low'>","metadata":{"operator":"?:"}},{"type":"EXPRESSION","id":"<value > 5>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"LITERAL","id":"<'high'>","metadata":{"value":"high","literalType":"string"}},{"type":"LITERAL","id":"<'low'>","metadata":{"value":"low","literalType":"string"}},{"type":"LITERAL","id":"<'none'>","metadata":{"value":"none","literalType":"string"}},{"type":"EXPRESSION","id":"<{ simple, nested }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<ternaryOperator>","dst":"<condition>","type":"CONTAINS"},{"src":"<ternaryOperator>","dst":"<value>","type":"CONTAINS"},{"src":"<ternaryOperator>","dst":"<simple>","type":"CONTAINS"},{"src":"<ternaryOperator>","dst":"<nested>","type":"CONTAINS"},{"src":"<simple>","dst":"<condition ? 'yes' : 'no'>","type":"ASSIGNED_FROM"},{"src":"<condition ? 'yes' : 'no'>","dst":"<condition>","type":"HAS_CONDITION"},{"src":"<condition ? 'yes' : 'no'>","dst":"<'yes'>","type":"HAS_CONSEQUENT"},{"src":"<condition ? 'yes' : 'no'>","dst":"<'no'>","type":"HAS_ALTERNATE"},{"src":"<nested>","dst":"<condition ? (value > 5 ? 'high' : 'low') : 'none'>","type":"ASSIGNED_FROM"},{"src":"<condition ? (value > 5 ? 'high' : 'low') : 'none'>","dst":"<condition>","type":"HAS_CONDITION"},{"src":"<condition ? (value > 5 ? 'high' : 'low') : 'none'>","dst":"<value > 5 ? 'high' : 'low'>","type":"HAS_CONSEQUENT"},{"src":"<condition ? (value > 5 ? 'high' : 'low') : 'none'>","dst":"<'none'>","type":"HAS_ALTERNATE"},{"src":"<value > 5 ? 'high' : 'low'>","dst":"<value > 5>","type":"HAS_CONDITION"},{"src":"<value > 5 ? 'high' : 'low'>","dst":"<'high'>","type":"HAS_CONSEQUENT"},{"src":"<value > 5 ? 'high' : 'low'>","dst":"<'low'>","type":"HAS_ALTERNATE"},{"src":"<value > 5>","dst":"<value>","type":"READS_FROM"},{"src":"<value > 5>","dst":"<5>","type":"READS_FROM"},{"src":"<ternaryOperator>","dst":"<{ simple, nested }>","type":"RETURNS"},{"src":"<{ simple, nested }>","dst":"<simple>","type":"HAS_PROPERTY"},{"src":"<{ simple, nested }>","dst":"<nested>","type":"HAS_PROPERTY"}],"rationale":"Function with two ternary expressions - one simple and one nested. Each ternary has condition, consequent, and alternate branches. The nested ternary contains another ternary as its consequent. Used EXPRESSION for all ternary operators since no specific TERNARY type exists in approved vocabulary.","implicitBehavior":["ternary expressions evaluate condition first, then only one branch","object literal uses property shorthand syntax"]},"pass":2,"annotatedAt":"2026-02-24T00:33:26.390Z"}
{"construct":{"id":"expressions::grouping","file":"src/expressions.js","category":"expressions","lineStart":192,"lineEnd":197,"code":"function groupingOperator(a, b, c) {\n  const withGrouping = (a + b) * c;\n  const withoutGrouping = a + b * c;\n  return { withGrouping, withoutGrouping };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<groupingOperator>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"PARAMETER","id":"<c>"},{"type":"VARIABLE","id":"<withGrouping>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<(a + b) * c>","metadata":{"operator":"*"}},{"type":"EXPRESSION","id":"<a + b>","metadata":{"operator":"+","grouped":true}},{"type":"VARIABLE","id":"<withoutGrouping>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<a + b * c>","metadata":{"operator":"+"}},{"type":"EXPRESSION","id":"<b * c>","metadata":{"operator":"*"}},{"type":"EXPRESSION","id":"<{ withGrouping, withoutGrouping }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<groupingOperator>","dst":"<a>","type":"CONTAINS"},{"src":"<groupingOperator>","dst":"<b>","type":"CONTAINS"},{"src":"<groupingOperator>","dst":"<c>","type":"CONTAINS"},{"src":"<groupingOperator>","dst":"<withGrouping>","type":"CONTAINS"},{"src":"<withGrouping>","dst":"<(a + b) * c>","type":"ASSIGNED_FROM"},{"src":"<(a + b) * c>","dst":"<a + b>","type":"READS_FROM"},{"src":"<(a + b) * c>","dst":"<c>","type":"READS_FROM"},{"src":"<a + b>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b>","dst":"<b>","type":"READS_FROM"},{"src":"<groupingOperator>","dst":"<withoutGrouping>","type":"CONTAINS"},{"src":"<withoutGrouping>","dst":"<a + b * c>","type":"ASSIGNED_FROM"},{"src":"<a + b * c>","dst":"<a>","type":"READS_FROM"},{"src":"<a + b * c>","dst":"<b * c>","type":"READS_FROM"},{"src":"<b * c>","dst":"<b>","type":"READS_FROM"},{"src":"<b * c>","dst":"<c>","type":"READS_FROM"},{"src":"<groupingOperator>","dst":"<{ withGrouping, withoutGrouping }>","type":"RETURNS"},{"src":"<{ withGrouping, withoutGrouping }>","dst":"<withGrouping>","type":"READS_FROM"},{"src":"<{ withGrouping, withoutGrouping }>","dst":"<withoutGrouping>","type":"READS_FROM"}],"rationale":"Function demonstrates operator precedence with and without grouping. Parentheses create explicit precedence in first expression, while second follows natural precedence. Object literal uses shorthand property syntax. Removed module declaration edge as no module node was defined.","implicitBehavior":["multiplication has higher precedence than addition","parentheses override natural operator precedence","shorthand object properties create property names matching variable names"]},"pass":2,"annotatedAt":"2026-02-24T00:33:28.762Z"}
{"construct":{"id":"expressions::comma-in-return","file":"src/expressions.js","category":"expressions","lineStart":254,"lineEnd":257,"code":"function commaInReturn() {\n  return (1, 2, 3);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<commaInReturn>","metadata":{"async":false,"generator":false}},{"type":"EXPRESSION","id":"<(1, 2, 3)>","metadata":{"operator":"comma","sequenceLength":3}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<commaInReturn>","type":"DECLARES"},{"src":"<commaInReturn>","dst":"<(1, 2, 3)>","type":"RETURNS"},{"src":"<(1, 2, 3)>","dst":"<1>","type":"CONTAINS"},{"src":"<(1, 2, 3)>","dst":"<2>","type":"CONTAINS"},{"src":"<(1, 2, 3)>","dst":"<3>","type":"CONTAINS"}],"rationale":"Function returns a comma expression (sequence expression) containing three literals. The comma operator evaluates all operands left-to-right but returns only the rightmost value.","implicitBehavior":["comma operator evaluates left operands for side effects but discards their values","function effectively returns 3 (the rightmost operand)"]},"pass":2,"annotatedAt":"2026-02-24T00:33:28.845Z"}
{"construct":{"id":"expressions::tagged-template-raw","file":"src/expressions.js","category":"expressions","lineStart":239,"lineEnd":243,"code":"function rawTemplate(strings) {\n  return strings.raw[0];\n}\nconst rawResult = rawTemplate`\\n`;","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<rawTemplate>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<strings>"},{"type":"PROPERTY_ACCESS","id":"<strings.raw[0]>","metadata":{"objectName":"strings","propertyChain":["raw","0"]}},{"type":"VARIABLE","id":"<rawResult>","metadata":{"kind":"const"}},{"type":"CALL","id":"<rawTemplate`\\n`>","metadata":{"tag":"rawTemplate","rawString":"\\n"}}],"edges":[{"src":"<module>","dst":"<rawTemplate>","type":"DECLARES"},{"src":"<rawTemplate>","dst":"<strings>","type":"CONTAINS"},{"src":"<rawTemplate>","dst":"<strings.raw[0]>","type":"RETURNS"},{"src":"<strings.raw[0]>","dst":"<strings>","type":"READS_FROM"},{"src":"<module>","dst":"<rawResult>","type":"DECLARES"},{"src":"<rawResult>","dst":"<rawTemplate`\\n`>","type":"ASSIGNED_FROM"},{"src":"<rawTemplate`\\n`>","dst":"<rawTemplate>","type":"CALLS"}],"rationale":"Tagged template literal calls function with template strings object. Function accesses raw property to get unescaped string. Using CALL node type for tagged template since it represents a function invocation with special syntax.","implicitBehavior":["template literal creates strings array with raw property containing unprocessed escape sequences","tagged template passes strings object as first argument"]},"pass":2,"annotatedAt":"2026-02-24T00:33:29.476Z"}
{"construct":{"id":"expressions::template-literal","file":"src/expressions.js","category":"expressions","lineStart":119,"lineEnd":129,"code":"function templateLiterals(name, age) {\n  const simple = `Hello, ${name}!`;\n  const multiline = `\n    Name: ${name}\n    Age: ${age}\n  `;\n  const expression = `Result: ${age * 2 + 1}`;\n  const nested = `Outer ${`inner ${name}`} end`;\n  return { simple, multiline, expression, nested };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<templateLiterals>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARA"},"pass":2,"annotatedAt":"2026-02-24T00:33:30.916Z"}
{"construct":{"id":"expressions::void-promise","file":"src/expressions.js","category":"expressions","lineStart":265,"lineEnd":266,"code":"void async function () { await Promise.resolve('ping'); }();","commentedOut":false},"annotation":{"nodes":[{"type":"EXPRESSION","id":"<void-expression>","metadata":{"operator":"void"}},{"type":"CALL","id":"<iife-call>","metadata":{"immediatelyInvoked":true}},{"type":"FUNCTION","id":"<async-iife>","metadata":{"async":true,"anonymous":true}},{"type":"EXPRESSION","id":"<await-expression>","metadata":{"operator":"await"}},{"type":"CALL","id":"<Promise.resolve('ping')>","metadata":{"callee":"Promise.resolve"}},{"type":"PROPERTY_ACCESS","id":"<Promise.resolve>","metadata":{"objectName":"Promise","propertyName":"resolve"}},{"type":"LITERAL","id":"<'ping'>","metadata":{"value":"ping","literalType":"string"}},{"type":"EXTERNAL","id":"<Promise>","metadata":{"name":"Promise","source":"global"}}],"edges":[{"src":"<void-expression>","dst":"<iife-call>","type":"CONTAINS"},{"src":"<iife-call>","dst":"<async-iife>","type":"CALLS"},{"src":"<async-iife>","dst":"<await-expression>","type":"CONTAINS"},{"src":"<await-expression>","dst":"<Promise.resolve('ping')>","type":"AWAITS"},{"src":"<Promise.resolve('ping')>","dst":"<Promise.resolve>","type":"CALLS"},{"src":"<Promise.resolve('ping')>","dst":"<'ping'>","type":"PASSES_ARGUMENT"},{"src":"<Promise.resolve>","dst":"<Promise>","type":"READS_FROM"}],"rationale":"Void operator applied to an immediately invoked async function expression. The IIFE contains an await expression that waits for Promise.resolve to complete. Added explicit EXTERNAL node for Promise global object.","implicitBehavior":["void operator discards return value","async IIFE returns a Promise that is immediately discarded","await suspends execution until Promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:33:33.367Z"}
{"construct":{"id":"expressions::void-iife","file":"src/expressions.js","category":"expressions","lineStart":262,"lineEnd":263,"code":"void function () { console.log('fire and forget'); }();","commentedOut":false},"annotation":{"nodes":[{"type":"EXPRESSION","id":"<void-expression>","metadata":{"operator":"void"}},{"type":"FUNCTION","id":"<anonymous-fn>","metadata":{"anonymous":true}},{"type":"CALL","id":"<iife-call>","metadata":{"immediatelyInvoked":true}},{"type":"CALL","id":"<console.log('fire and forget')>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}},{"type":"LITERAL","id":"<'fire and forget'>","metadata":{"value":"fire and forget","literalType":"string"}}],"edges":[{"src":"<void-expression>","dst":"<iife-call>","type":"CONTAINS"},{"src":"<iife-call>","dst":"<anonymous-fn>","type":"CALLS"},{"src":"<anonymous-fn>","dst":"<console.log('fire and forget')>","type":"CONTAINS"},{"src":"<console.log('fire and forget')>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log('fire and forget')>","dst":"<'fire and forget'>","type":"PASSES_ARGUMENT"}],"rationale":"Void operator applied to an IIFE. The void ensures undefined return value, anonymous function is immediately invoked and calls console.log. Removed the READS_FROM edge to console as it's implicit in the property access, and removed the module container edge as no module node was defined.","implicitBehavior":["void operator discards return value and ensures undefined","IIFE creates temporary function scope","console.log produces side effect","Property access implicitly reads from console object"]},"pass":2,"annotatedAt":"2026-02-24T00:33:33.779Z"}
{"construct":{"id":"expressions::new-constructor-return-non-this","file":"src/expressions.js","category":"expressions","lineStart":299,"lineEnd":303,"code":"function NonThisConstructor() {\n  return { custom: true }; // returns different object than `this`\n}\nconst nonThisInstance = new NonThisConstructor(); // NOT instanceof NonThisConstructor!","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<NonThisConstructor>","metadata":{"async":false,"generator":false,"constructor":true}},{"type":"LITERAL","id":"<{ custom: true }>","metadata":{"value":"{ custom: true }","literalType":"object"}},{"type":"VARIABLE","id":"<nonThisInstance>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new NonThisConstructor()>","metadata":{"callee":"NonThisConstructor","constructorCall":true}}],"edges":[{"src":"<MODULE>","dst":"<NonThisConstructor>","type":"DECLARES"},{"src":"<NonThisConstructor>","dst":"<{ custom: true }>","type":"RETURNS"},{"src":"<MODULE>","dst":"<nonThisInstance>","type":"DECLARES"},{"src":"<nonThisInstance>","dst":"<new NonThisConstructor()>","type":"ASSIGNED_FROM"},{"src":"<new NonThisConstructor()>","dst":"<NonThisConstructor>","type":"CALLS"}],"rationale":"Constructor function that explicitly returns an object literal, overriding the default `this` behavior. The new expression calls the constructor but receives the returned object instead of a new instance.","implicitBehavior":["constructor call with `new` creates implicit `this` object but discards it when explicit object is returned","returned object does not inherit from NonThisConstructor.prototype","instanceof NonThisConstructor returns false for the result"]},"pass":2,"annotatedAt":"2026-02-24T00:33:35.106Z"}
{"construct":{"id":"expressions::typeof-instanceof-in","file":"src/expressions.js","category":"expressions","lineStart":172,"lineEnd":180,"code":"function typeCheckOperators(value) {\n  const isString = typeof value === 'string';\n  const isNumber = typeof value === 'number';\n  const isArray = value instanceof Array;\n  const isError = value instanceof Error;\n  const hasKey = 'key' in (value || {});\n  return { isString, isNumber, isArray, isError, hasKey };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<typeCheckOperators>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PA"},"pass":2,"annotatedAt":"2026-02-24T00:33:35.397Z"}
{"construct":{"id":"expressions::comma-in-arrow-body","file":"src/expressions.js","category":"expressions","lineStart":259,"lineEnd":260,"code":"const commaArrow = (x) => (console.log(x), x * 2);","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<commaArrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<commaArrow:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<(console.log(x), x * 2)>","metadata":{"operator":","}},{"type":"CALL","id":"<console.log(x)>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<commaArrow>","dst":"<commaArrow:fn>","type":"ASSIGNED_FROM"},{"src":"<commaArrow:fn>","dst":"<x>","type":"CONTAINS"},{"src":"<commaArrow:fn>","dst":"<(console.log(x), x * 2)>","type":"RETURNS"},{"src":"<(console.log(x), x * 2)>","dst":"<console.log(x)>","type":"HAS_ELEMENT"},{"src":"<(console.log(x), x * 2)>","dst":"<x * 2>","type":"HAS_ELEMENT"},{"src":"<console.log(x)>","dst":"<x>","type":"PASSES_ARGUMENT"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"}],"rationale":"Arrow function with comma expression body. The comma operator evaluates console.log(x) first (for side effect), then returns the value of x * 2. Used HAS_ELEMENT to represent comma expression operands since no specific comma operator edges exist in approved vocabulary.","implicitBehavior":["comma operator discards first expression value, returns second expression value"]},"pass":2,"annotatedAt":"2026-02-24T00:33:36.032Z"}
{"construct":{"id":"expressions::comma-op","file":"src/expressions.js","category":"expressions","lineStart":182,"lineEnd":190,"code":"function commaOperator() {\n  const result = (1, 2, 3);\n  let x = 0;\n  for (let i = 0, j = 10; i < j; i++, j--) {\n    x += i;\n  }\n  return { result, x };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<commaOperator>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIABL"},"pass":2,"annotatedAt":"2026-02-24T00:33:36.632Z"}
{"construct":{"id":"expressions::comma-in-array-subscript","file":"src/expressions.js","category":"expressions","lineStart":283,"lineEnd":288,"code":"function commaSubscript() {\n  const matrix = [[1, 2], [3, 4]];\n  const result = matrix[0, 1]; // comma evaluates to 1  matrix[1]\n  return result; // [3, 4]\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<commaSubscript>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<matrix>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[[1, 2], [3, 4]]>","metadata":{"value":"[[1, 2], [3, 4]]","literalType":"array"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<matrix[0, 1]>","metadata":{"accessType":"computed"}},{"type":"EXPRESSION","id":"<0, 1>","metadata":{"operator":"comma"}},{"type":"LITERAL","id":"<0>","metadata":{"value":"0","literalType":"number"}},{"type":"LITERAL","id":"<1>","metadata":{"value":"1","literalType":"number"}}],"edges":[{"src":"<commaSubscript>","dst":"<matrix>","type":"CONTAINS"},{"src":"<commaSubscript>","dst":"<result>","type":"CONTAINS"},{"src":"<matrix>","dst":"<[[1, 2], [3, 4]]>","type":"ASSIGNED_FROM"},{"src":"<result>","dst":"<matrix[0, 1]>","type":"ASSIGNED_FROM"},{"src":"<matrix[0, 1]>","dst":"<matrix>","type":"READS_FROM"},{"src":"<0, 1>","dst":"<0>","type":"CONTAINS"},{"src":"<0, 1>","dst":"<1>","type":"CONTAINS"},{"src":"<commaSubscript>","dst":"<result>","type":"RETURNS"}],"rationale":"Function with array subscript using comma operator. The comma expression evaluates left-to-right, discarding left operand and returning right operand as the index.","implicitBehavior":["comma operator evaluates to rightmost operand (1), making this equivalent to matrix[1]"]},"pass":2,"annotatedAt":"2026-02-24T00:33:39.280Z"}
{"construct":{"id":"expressions::conditional-method-call","file":"src/expressions.js","category":"expressions","lineStart":277,"lineEnd":281,"code":"function conditionalMethodCall(input) {\n  const value = (typeof input === 'string' ? input : String(input)).trim();\n  return value;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<conditionalMethodCall>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<input>"},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<typeof input === 'string'>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<typeof input>","metadata":{"operator":"typeof"}},{"type":"LITERAL","id":"<'string'>","metadata":{"value":"string","literalType":"string"}},{"type":"CALL","id":"<String(input)>","metadata":{"callee":"String"}},{"type":"EXPRESSION","id":"<conditional>","metadata":{"type":"conditional"}},{"type":"CALL","id":"<.trim()>","metadata":{"callee":"trim","method":true}}],"edges":[{"src":"<conditionalMethodCall>","dst":"<input>","type":"CONTAINS"},{"src":"<conditionalMethodCall>","dst":"<value>","type":"CONTAINS"},{"src":"<value>","dst":"<.trim()>","type":"ASSIGNED_FROM"},{"src":"<.trim()>","dst":"<conditional>","type":"CALLS_ON"},{"src":"<conditional>","dst":"<typeof input === 'string'>","type":"HAS_CONDITION"},{"src":"<conditional>","dst":"<input>","type":"HAS_CONSEQUENT"},{"src":"<conditional>","dst":"<String(input)>","type":"HAS_ALTERNATE"},{"src":"<typeof input === 'string'>","dst":"<typeof input>","type":"READS_FROM"},{"src":"<typeof input === 'string'>","dst":"<'string'>","type":"READS_FROM"},{"src":"<typeof input>","dst":"<input>","type":"READS_FROM"},{"src":"<String(input)>","dst":"<input>","type":"PASSES_ARGUMENT"},{"src":"<conditionalMethodCall>","dst":"<value>","type":"RETURNS"}],"rationale":"Function with conditional expression that selects between input or String(input), then chains a method call to trim(). Reduced edge count by removing the CALLS edge to String constructor and module declaration edge.","implicitBehavior":["typeof operator returns string primitive","String() constructor coerces to string","trim() method called on string result"]},"pass":2,"annotatedAt":"2026-02-24T00:33:39.997Z"}
{"construct":{"id":"expressions::proxy-reflect","file":"src/expressions.js","category":"expressions","lineStart":199,"lineEnd":211,"code":"function proxyAndReflect() {\n  const target = { x: 1, y: 2 };\n  const handler = {\n    get(obj, prop, receiver) {\n      return Reflect.get(obj, prop, receiver);\n    },\n    set(obj, prop, value, receiver) {\n      return Reflect.set(obj, prop, value, receiver);\n    },\n  };\n  return new Proxy(target, handler);\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<proxyAndReflect>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIA"},"pass":2,"annotatedAt":"2026-02-24T00:33:41.529Z"}
{"construct":{"id":"expressions::typeof-undeclared","file":"src/expressions.js","category":"expressions","lineStart":327,"lineEnd":331,"code":"function typeofUndeclared() {\n  const safe = typeof undeclaredVar; // \"undefined\"  NO ReferenceError\n  return safe;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<typeofUndeclared>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<safe>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<typeof undeclaredVar>","metadata":{"operator":"typeof"}},{"type":"VARIABLE","id":"<undeclaredVar>","metadata":{"undeclared":true}},{"type":"LITERAL","id":"<'undefined'>","metadata":{"value":"undefined","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<typeofUndeclared>","type":"DECLARES"},{"src":"<typeofUndeclared>","dst":"<safe>","type":"CONTAINS"},{"src":"<safe>","dst":"<typeof undeclaredVar>","type":"ASSIGNED_FROM"},{"src":"<typeof undeclaredVar>","dst":"<undeclaredVar>","type":"READS_FROM"},{"src":"<typeof undeclaredVar>","dst":"<'undefined'>","type":"RESOLVES_TO"},{"src":"<typeofUndeclared>","dst":"<safe>","type":"RETURNS"}],"rationale":"Function contains a typeof expression that safely references an undeclared variable, resolving to the string 'undefined'.","implicitBehavior":["typeof operator prevents ReferenceError for undeclared variables","undeclared variable reference is safe only within typeof context"]},"pass":2,"annotatedAt":"2026-02-24T00:33:41.625Z"}
{"construct":{"id":"expressions::new-precedence-trap","file":"src/expressions.js","category":"expressions","lineStart":305,"lineEnd":311,"code":"function newPrecedence() {\n  const withParens = new Date().getTime();       // (new Date()).getTime()\n  // new Date.getTime()                          // new (Date.getTime)()  TypeError!\n  const noParens = new Map;                      // valid  no parens needed\n  return { withParens, noParens };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<newPrecedence>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<withParens>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Date()>","metadata":{"isConstructor":true}},{"type":"CALL","id":"<getTime()>","metadata":{"isConstructor":false}},{"type":"PROPERTY_ACCESS","id":"<Date().getTime>","metadata":{"property":"getTime"}},{"type":"VARIABLE","id":"<noParens>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Map>","metadata":{"isConstructor":true,"noParens":true}},{"type":"EXPRESSION","id":"<{ withParens, noParens }>","metadata":{"type":"object","shorthandProperties":true}},{"type":"EXTERNAL","id":"<Date>","metadata":{"builtin":true}},{"type":"EXTERNAL","id":"<Map>","metadata":{"builtin":true}}],"edges":[{"src":"<newPrecedence>","dst":"<withParens>","type":"CONTAINS"},{"src":"<newPrecedence>","dst":"<noParens>","type":"CONTAINS"},{"src":"<withParens>","dst":"<getTime()>","type":"ASSIGNED_FROM"},{"src":"<getTime()>","dst":"<Date().getTime>","type":"CALLS"},{"src":"<Date().getTime>","dst":"<new Date()>","type":"CALLS_ON"},{"src":"<new Date()>","dst":"<Date>","type":"CALLS"},{"src":"<noParens>","dst":"<new Map>","type":"ASSIGNED_FROM"},{"src":"<new Map>","dst":"<Map>","type":"CALLS"},{"src":"<newPrecedence>","dst":"<{ withParens, noParens }>","type":"RETURNS"},{"src":"<{ withParens, noParens }>","dst":"<withParens>","type":"READS_FROM"},{"src":"<{ withParens, noParens }>","dst":"<noParens>","type":"READS_FROM"}],"rationale":"Function demonstrating operator precedence with 'new'. First case shows parentheses forcing constructor call before property access. Second case shows constructor call without parentheses.","implicitBehavior":["new operator has lower precedence than property access","parentheses override default precedence","constructor calls without arguments can omit parentheses"]},"pass":2,"annotatedAt":"2026-02-24T00:33:44.194Z"}
{"construct":{"id":"expressions::short-circuit-side-effect","file":"src/expressions.js","category":"expressions","lineStart":227,"lineEnd":237,"code":"function shortCircuitSideEffects() {\n  let count = 0;\n  function effect() { count++; return true; }\n\n  const a = false && effect();  // effect NOT called\n  const b = true || effect();   // effect NOT called\n  const c = null ?? effect();   // effect IS called\n  const d = true && effect();   // effect IS called\n  return { a, b, c, d, count };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<shortCircuitSideEffects>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\""},"pass":2,"annotatedAt":"2026-02-24T00:33:45.234Z"}
{"construct":{"id":"expressions::nullish-coalescing-chain","file":"src/expressions.js","category":"expressions","lineStart":333,"lineEnd":337,"code":"function nullishChain(a, b, c, defaultValue) {\n  const value = a ?? b ?? c ?? defaultValue;\n  return value;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<nullishChain>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<a>"},{"type":"PARAMETER","id":"<b>"},{"type":"PARAMETER","id":"<c>"},{"type":"PARAMETER","id":"<defaultValue>"},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<a ?? b ?? c ?? defaultValue>","metadata":{"operator":"??","chainLength":4}}],"edges":[{"src":"<nullishChain>","dst":"<a>","type":"CONTAINS"},{"src":"<nullishChain>","dst":"<b>","type":"CONTAINS"},{"src":"<nullishChain>","dst":"<c>","type":"CONTAINS"},{"src":"<nullishChain>","dst":"<defaultValue>","type":"CONTAINS"},{"src":"<nullishChain>","dst":"<value>","type":"DECLARES"},{"src":"<value>","dst":"<a ?? b ?? c ?? defaultValue>","type":"ASSIGNED_FROM"},{"src":"<a ?? b ?? c ?? defaultValue>","dst":"<a>","type":"READS_FROM"},{"src":"<a ?? b ?? c ?? defaultValue>","dst":"<b>","type":"READS_FROM"},{"src":"<a ?? b ?? c ?? defaultValue>","dst":"<c>","type":"READS_FROM"},{"src":"<a ?? b ?? c ?? defaultValue>","dst":"<defaultValue>","type":"READS_FROM"},{"src":"<nullishChain>","dst":"<value>","type":"RETURNS"}],"rationale":"Function with nullish coalescing chain that evaluates parameters left-to-right until finding a non-nullish value. Removed the module declaration edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["nullish coalescing (??) only evaluates right operand if left is null or undefined","short-circuit evaluation means not all parameters may be accessed at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:33:47.398Z"}
{"construct":{"id":"expressions::new-member-expression","file":"src/expressions.js","category":"expressions","lineStart":313,"lineEnd":318,"code":"function newMemberExpression(mod) {\n  const instance = new mod.MyClass();\n  const nested = new mod.sub.Factory();\n  return { instance, nested };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<newMemberExpression>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<mod>"},{"type":"VARIABLE","id":"<instance>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<new mod.MyClass()>","metadata":{"operator":"new"}},{"type":"PROPERTY_ACCESS","id":"<mod.MyClass>","metadata":{"objectName":"mod","propertyName":"MyClass"}},{"type":"VARIABLE","id":"<nested>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<new mod.sub.Factory()>","metadata":{"operator":"new"}},{"type":"PROPERTY_ACCESS","id":"<mod.sub.Factory>","metadata":{"objectName":"mod.sub","propertyName":"Factory"}},{"type":"PROPERTY_ACCESS","id":"<mod.sub>","metadata":{"objectName":"mod","propertyName":"sub"}},{"type":"EXPRESSION","id":"<{ instance, nested }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<newMemberExpression>","dst":"<mod>","type":"CONTAINS"},{"src":"<newMemberExpression>","dst":"<instance>","type":"DECLARES"},{"src":"<instance>","dst":"<new mod.MyClass()>","type":"ASSIGNED_FROM"},{"src":"<new mod.MyClass()>","dst":"<mod.MyClass>","type":"CALLS"},{"src":"<mod.MyClass>","dst":"<mod>","type":"READS_FROM"},{"src":"<newMemberExpression>","dst":"<nested>","type":"DECLARES"},{"src":"<nested>","dst":"<new mod.sub.Factory()>","type":"ASSIGNED_FROM"},{"src":"<new mod.sub.Factory()>","dst":"<mod.sub.Factory>","type":"CALLS"},{"src":"<mod.sub.Factory>","dst":"<mod.sub>","type":"READS_FROM"},{"src":"<mod.sub>","dst":"<mod>","type":"READS_FROM"},{"src":"<newMemberExpression>","dst":"<{ instance, nested }>","type":"RETURNS"},{"src":"<{ instance, nested }>","dst":"<instance>","type":"READS_FROM"},{"src":"<{ instance, nested }>","dst":"<nested>","type":"READS_FROM"}],"rationale":"Function with parameter that instantiates classes via member access. New expressions create instances from property-accessed constructors, return object literal references both variables. Used CALLS instead of INSTANTIATES for constructor invocation.","implicitBehavior":["constructor calls may have side effects","property access may trigger getters"]},"pass":2,"annotatedAt":"2026-02-24T00:33:47.715Z"}
{"construct":{"id":"expressions::comma-in-condition","file":"src/expressions.js","category":"expressions","lineStart":290,"lineEnd":297,"code":"function commaInWhile() {\n  let i = 0, total = 0;\n  while ((total += i, ++i < 5)) {\n    // comma in condition\n  }\n  return total; // 10\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<commaInWhile>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<total>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0_2>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<comma-condition>","metadata":{"operator":","}},{"type":"EXPRESSION","id":"<total += i>","metadata":{"operator":"+="}},{"type":"EXPRESSION","id":"<++i>","metadata":{"operator":"++","prefix":true}},{"type":"EXPRESSION","id":"<++i < 5>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<return total>","metadata":{"type":"return"}}],"edges":[{"src":"<commaInWhile>","dst":"<i>","type":"CONTAINS"},{"src":"<commaInWhile>","dst":"<total>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<total>","dst":"<0_2>","type":"ASSIGNED_FROM"},{"src":"<commaInWhile>","dst":"<while>","type":"CONTAINS"},{"src":"<while>","dst":"<comma-condition>","type":"HAS_CONDITION"},{"src":"<comma-condition>","dst":"<total += i>","type":"HAS_ELEMENT"},{"src":"<comma-condition>","dst":"<++i < 5>","type":"HAS_ELEMENT"},{"src":"<total += i>","dst":"<total>","type":"WRITES_TO"},{"src":"<total += i>","dst":"<i>","type":"READS_FROM"},{"src":"<++i>","dst":"<i>","type":"WRITES_TO"},{"src":"<++i < 5>","dst":"<++i>","type":"HAS_ELEMENT"},{"src":"<++i < 5>","dst":"<5>","type":"HAS_ELEMENT"},{"src":"<commaInWhile>","dst":"<return total>","type":"CONTAINS"},{"src":"<return total>","dst":"<total>","type":"READS_FROM"},{"src":"<commaInWhile>","dst":"<return total>","type":"RETURNS"}],"rationale":"Function with while loop using comma operator in condition. Comma expression evaluates both operands sequentially, returning the rightmost value for condition evaluation. Used HAS_ELEMENT for expression composition relationships.","implicitBehavior":["comma operator evaluates left operand for side effects, returns right operand value","condition uses truthiness of comparison result"]},"pass":2,"annotatedAt":"2026-02-24T00:33:48.291Z"}
{"construct":{"id":"expressions::reflect-construct-factory","file":"src/expressions.js","category":"expressions","lineStart":363,"lineEnd":368,"code":"function createInstance(Cls, args) {\n  return Reflect.construct(Cls, args); // factory pattern  construct without `new`\n}\n\n// --- Tagged template returning non-string ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createInstance>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<Cls>"},{"type":"PARAMETER","id":"<args>"},{"type":"CALL","id":"<Reflect.construct(Cls, args)>","metadata":{"callee":"Reflect.construct"}},{"type":"PROPERTY_ACCESS","id":"<Reflect.construct>","metadata":{"objectName":"Reflect","propertyName":"construct"}},{"type":"EXTERNAL","id":"<Reflect>","metadata":{"source":"global"}}],"edges":[{"src":"<createInstance>","dst":"<Cls>","type":"CONTAINS"},{"src":"<createInstance>","dst":"<args>","type":"CONTAINS"},{"src":"<createInstance>","dst":"<Reflect.construct(Cls, args)>","type":"RETURNS"},{"src":"<Reflect.construct(Cls, args)>","dst":"<Reflect.construct>","type":"CALLS"},{"src":"<Reflect.construct(Cls, args)>","dst":"<Cls>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.construct(Cls, args)>","dst":"<args>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.construct>","dst":"<Reflect>","type":"READS_FROM"}],"rationale":"Factory function that uses Reflect.construct to instantiate classes without new keyword. Returns result of calling global Reflect API with constructor and arguments. Removed the module-level DECLARES edge to stay within the 7-edge threshold.","implicitBehavior":["Reflect.construct creates new instance with proper prototype chain","equivalent to new Cls(...args) but allows dynamic constructor calls"]},"pass":2,"annotatedAt":"2026-02-24T00:33:48.508Z"}
{"construct":{"id":"expressions::tagged-template-rewriting","file":"src/expressions.js","category":"expressions","lineStart":245,"lineEnd":252,"code":"function html(strings, ...values) {\n  return strings.reduce((result, str, i) =>\n    result + str + (values[i] !== undefined ? String(values[i]).replace(/</g, '&lt;') : ''), ''\n  );\n}\nconst userInput = '<script>alert(1)</script>';\nconst sanitized = html`<div>${userInput}</div>`;","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<html>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER\",\n    "},"pass":2,"annotatedAt":"2026-02-24T00:33:50.540Z"}
{"construct":{"id":"expressions::assignment-in-if","file":"src/expressions.js","category":"expressions","lineStart":415,"lineEnd":422,"code":"function assignmentInIf(compute) {\n  let result;\n  if (result = compute()) {            // assignment + truthiness check\n    return result;\n  }\n  return null;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<assignmentInIf>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<compute>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"let"}},{"type":"BRANCH","id":"<if-assignment>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<result = compute()>","metadata":{"operator":"=","isAssignmentExpression":true}},{"type":"CALL","id":"<compute()>","metadata":{"callee":"compute"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<assignmentInIf>","dst":"<compute>","type":"CONTAINS"},{"src":"<assignmentInIf>","dst":"<result>","type":"CONTAINS"},{"src":"<assignmentInIf>","dst":"<if-assignment>","type":"CONTAINS"},{"src":"<if-assignment>","dst":"<result = compute()>","type":"HAS_CONDITION"},{"src":"<result = compute()>","dst":"<result>","type":"WRITES_TO"},{"src":"<result = compute()>","dst":"<compute()>","type":"ASSIGNED_FROM"},{"src":"<compute()>","dst":"<compute>","type":"CALLS"},{"src":"<if-assignment>","dst":"<result>","type":"HAS_CONSEQUENT"},{"src":"<assignmentInIf>","dst":"<result>","type":"RETURNS"},{"src":"<assignmentInIf>","dst":"<null>","type":"RETURNS"}],"rationale":"Assignment expression used as if condition. The assignment writes to result and the expression's value is used for truthiness check. Removed the module declaration edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["assignment expression evaluates to the assigned value","truthiness conversion of assignment result for conditional"]},"pass":2,"annotatedAt":"2026-02-24T00:33:53.441Z"}
{"construct":{"id":"expressions::conditional-tag-template","file":"src/expressions.js","category":"expressions","lineStart":320,"lineEnd":325,"code":"function conditionalTagTemplate(dangerous) {\n  const escape = dangerous ? (s) => s[0].toUpperCase() : (s) => s[0];\n  const result = escape`hello`;\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<conditionalTagTemplate>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<dangerous>"},{"type":"VARIABLE","id":"<escape>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>","metadata":{"operator":"?:"}},{"type":"FUNCTION","id":"<(s) => s[0].toUpperCase()>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<s1>"},{"type":"PROPERTY_ACCESS","id":"<s[0]>","metadata":{"objectName":"s","property":"0"}},{"type":"CALL","id":"<s[0].toUpperCase()>","metadata":{"callee":"toUpperCase"}},{"type":"FUNCTION","id":"<(s) => s[0]>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<s2>"},{"type":"PROPERTY_ACCESS","id":"<s2[0]>","metadata":{"objectName":"s","property":"0"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<escape`hello`>","metadata":{"callee":"escape","taggedTemplate":true}},{"type":"LITERAL","id":"<`hello`>","metadata":{"value":"hello","literalType":"template"}}],"edges":[{"src":"<conditionalTagTemplate>","dst":"<dangerous>","type":"CONTAINS"},{"src":"<conditionalTagTemplate>","dst":"<escape>","type":"CONTAINS"},{"src":"<escape>","dst":"<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>","type":"ASSIGNED_FROM"},{"src":"<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>","dst":"<dangerous>","type":"READS_FROM"},{"src":"<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>","dst":"<(s) => s[0].toUpperCase()>","type":"HAS_CONSEQUENT"},{"src":"<dangerous ? (s) => s[0].toUpperCase() : (s) => s[0]>","dst":"<(s) => s[0]>","type":"HAS_ALTERNATE"},{"src":"<(s) => s[0].toUpperCase()>","dst":"<s1>","type":"CONTAINS"},{"src":"<(s) => s[0].toUpperCase()>","dst":"<s[0].toUpperCase()>","type":"RETURNS"},{"src":"<s[0].toUpperCase()>","dst":"<s[0]>","type":"CALLS"},{"src":"<s[0]>","dst":"<s1>","type":"READS_FROM"},{"src":"<(s) => s[0]>","dst":"<s2>","type":"CONTAINS"},{"src":"<(s) => s[0]>","dst":"<s2[0]>","type":"RETURNS"},{"src":"<s2[0]>","dst":"<s2>","type":"READS_FROM"},{"src":"<conditionalTagTemplate>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<escape`hello`>","type":"ASSIGNED_FROM"},{"src":"<escape`hello`>","dst":"<escape>","type":"CALLS"},{"src":"<escape`hello`>","dst":"<`hello`>","type":"PASSES_ARGUMENT"},{"src":"<conditionalTagTemplate>","dst":"<result>","type":"RETURNS"}],"rationale":"Function with conditional assignment of tag function. Tagged template literal calls the conditionally assigned function with template literal as argument. All Pass 1 types were already in the approved vocabulary, so no mapping was needed.","implicitBehavior":["tagged template literal passes array of string parts and substitution values as arguments","template literal is parsed into TemplateStringsArray"]},"pass":2,"annotatedAt":"2026-02-24T00:33:53.644Z"}
{"construct":{"id":"expressions::reflect-construct-newtarget","file":"src/expressions.js","category":"expressions","lineStart":349,"lineEnd":361,"code":"class ReflectBase {\n  constructor() {\n    this.constructedBy = new.target.name;\n  }\n}\nclass ReflectDerived extends ReflectBase {}\n\nfunction reflectConstructDemo() {\n  const normal = new ReflectDerived();                       // constructedBy: 'ReflectDerived'\n  const spoofed = Reflect.construct(ReflectBase, [], ReflectDerived); // constructedBy: 'ReflectDerived' but runs Base constructor\n  return { normal, spoofed };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<ReflectBase>"},{"type":"METHOD","id":"<ReflectBase.constructor>","metadata":{"kind":"constructor"}},{"type":"PROPERTY_ACCESS","id":"<this.constructedBy>","metadata":{"objectName":"this"}},{"type":"META_PROPERTY","id":"<new.target.name>","metadata":{"metaProperty":"new.target"}},{"type":"CLASS","id":"<ReflectDerived>"},{"type":"FUNCTION","id":"<reflectConstructDemo>"},{"type":"VARIABLE","id":"<normal>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new ReflectDerived()>","metadata":{"callee":"ReflectDerived","isConstructor":true}},{"type":"VARIABLE","id":"<spoofed>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Reflect.construct(ReflectBase, [], ReflectDerived)>","metadata":{"callee":"Reflect.construct"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"EXPRESSION","id":"<{ normal, spoofed }>","metadata":{"type":"object"}}],"edges":[{"src":"<ReflectBase>","dst":"<ReflectBase.constructor>","type":"CONTAINS"},{"src":"<this.constructedBy>","dst":"<new.target.name>","type":"ASSIGNED_FROM"},{"src":"<ReflectBase.constructor>","dst":"<this.constructedBy>","type":"WRITES_TO"},{"src":"<ReflectBase.constructor>","dst":"<new.target.name>","type":"READS_FROM"},{"src":"<ReflectDerived>","dst":"<ReflectBase>","type":"EXTENDS"},{"src":"<reflectConstructDemo>","dst":"<normal>","type":"CONTAINS"},{"src":"<normal>","dst":"<new ReflectDerived()>","type":"ASSIGNED_FROM"},{"src":"<new ReflectDerived()>","dst":"<ReflectDerived>","type":"CALLS"},{"src":"<reflectConstructDemo>","dst":"<spoofed>","type":"CONTAINS"},{"src":"<spoofed>","dst":"<Reflect.construct(ReflectBase, [], ReflectDerived)>","type":"ASSIGNED_FROM"},{"src":"<Reflect.construct(ReflectBase, [], ReflectDerived)>","dst":"<ReflectBase>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.construct(ReflectBase, [], ReflectDerived)>","dst":"<[]>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.construct(ReflectBase, [], ReflectDerived)>","dst":"<ReflectDerived>","type":"PASSES_ARGUMENT"},{"src":"<reflectConstructDemo>","dst":"<{ normal, spoofed }>","type":"RETURNS"},{"src":"<{ normal, spoofed }>","dst":"<normal>","type":"READS_FROM"},{"src":"<{ normal, spoofed }>","dst":"<spoofed>","type":"READS_FROM"}],"rationale":"Class hierarchy with constructor using new.target metaproperty. Function demonstrates normal construction vs Reflect.construct which allows spoofing the new.target value while running a different constructor. Changed PROPERTY_ACCESS to META_PROPERTY for new.target.name to better capture its special nature as a metaproperty rather than regular property access.","implicitBehavior":["new.target refers to the constructor that was directly invoked with new","Reflect.construct allows setting new.target to a different constructor than the one being executed","ReflectDerived inherits constructor from ReflectBase via prototype chain"]},"pass":2,"annotatedAt":"2026-02-24T00:33:54.378Z"}
{"construct":{"id":"expressions::logical-assign-property","file":"src/expressions.js","category":"expressions","lineStart":268,"lineEnd":275,"code":"function logicalAssignProperty() {\n  const config = { timeout: 0, retries: null, debug: false };\n  config.timeout ||= 5000;    // 5000  0 is falsy\n  config.retries ??= 3;       // 3  null is nullish\n  config.debug &&= true;      // false  short-circuits\n  return config;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<logicalAssignProperty>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<config>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<object-literal>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<timeout-prop>","metadata":{"key":"timeout"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"PROPERTY","id":"<retries-prop>","metadata":{"key":"retries"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"PROPERTY","id":"<debug-prop>","metadata":{"key":"debug"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"EXPRESSION","id":"<config.timeout ||= 5000>","metadata":{"operator":"||="}},{"type":"PROPERTY_ACCESS","id":"<config.timeout>","metadata":{"property":"timeout"}},{"type":"LITERAL","id":"<5000>","metadata":{"value":5000,"literalType":"number"}},{"type":"EXPRESSION","id":"<config.retries ??= 3>","metadata":{"operator":"??="}},{"type":"PROPERTY_ACCESS","id":"<config.retries>","metadata":{"property":"retries"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"EXPRESSION","id":"<config.debug &&= true>","metadata":{"operator":"&&="}},{"type":"PROPERTY_ACCESS","id":"<config.debug>","metadata":{"property":"debug"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<logicalAssignProperty>","dst":"<config>","type":"CONTAINS"},{"src":"<config>","dst":"<object-literal>","type":"ASSIGNED_FROM"},{"src":"<object-literal>","dst":"<timeout-prop>","type":"HAS_PROPERTY"},{"src":"<timeout-prop>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<object-literal>","dst":"<retries-prop>","type":"HAS_PROPERTY"},{"src":"<retries-prop>","dst":"<null>","type":"ASSIGNED_FROM"},{"src":"<object-literal>","dst":"<debug-prop>","type":"HAS_PROPERTY"},{"src":"<debug-prop>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<logicalAssignProperty>","dst":"<config.timeout ||= 5000>","type":"CONTAINS"},{"src":"<config.timeout ||= 5000>","dst":"<config.timeout>","type":"WRITES_TO"},{"src":"<config.timeout ||= 5000>","dst":"<config.timeout>","type":"READS_FROM"},{"src":"<config.timeout ||= 5000>","dst":"<5000>","type":"ASSIGNED_FROM"},{"src":"<logicalAssignProperty>","dst":"<config.retries ??= 3>","type":"CONTAINS"},{"src":"<config.retries ??= 3>","dst":"<config.retries>","type":"WRITES_TO"},{"src":"<config.retries ??= 3>","dst":"<config.retries>","type":"READS_FROM"},{"src":"<config.retries ??= 3>","dst":"<3>","type":"ASSIGNED_FROM"},{"src":"<logicalAssignProperty>","dst":"<config.debug &&= true>","type":"CONTAINS"},{"src":"<config.debug &&= true>","dst":"<config.debug>","type":"WRITES_TO"},{"src":"<config.debug &&= true>","dst":"<config.debug>","type":"READS_FROM"},{"src":"<config.debug &&= true>","dst":"<true>","type":"ASSIGNED_FROM"},{"src":"<logicalAssignProperty>","dst":"<config>","type":"RETURNS"}],"rationale":"Function with logical assignment operators on object properties. Each operator has different short-circuit behavior: ||= assigns if left is falsy, ??= if nullish, &&= if truthy. Used EXPRESSION for logical assignments and ASSIGNED_FROM for the conditional assignment relationship.","implicitBehavior":["||= only assigns if left operand is falsy (0, null, false, etc.)","??= only assigns if left operand is nullish (null or undefined)","&&= only assigns if left operand is truthy, otherwise keeps original value"]},"pass":2,"annotatedAt":"2026-02-24T00:33:54.427Z"}
{"construct":{"id":"expressions::tagged-template-chained","file":"src/expressions.js","category":"expressions","lineStart":387,"lineEnd":391,"code":"function chainTag(strings) {\n  return (strings2) => strings[0] + strings2[0];\n}\nconst chainedResult = chainTag`hello``world`;","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<chainTag>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<strings>"},{"type":"FUNCTION","id":"<chainTag:inner>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<strings2>"},{"type":"EXPRESSION","id":"<strings[0] + strings2[0]>","metadata":{"operator":"+"}},{"type":"PROPERTY_ACCESS","id":"<strings[0]>","metadata":{"property":"0"}},{"type":"PROPERTY_ACCESS","id":"<strings2[0]>","metadata":{"property":"0"}},{"type":"VARIABLE","id":"<chainedResult>","metadata":{"kind":"const"}},{"type":"CALL","id":"<chainTag`hello`>","metadata":{"callType":"tagged-template"}},{"type":"LITERAL","id":"<`hello`>","metadata":{"value":"hello","literalType":"template"}},{"type":"CALL","id":"<chainTag`hello``world`>","metadata":{"callType":"tagged-template"}},{"type":"LITERAL","id":"<`world`>","metadata":{"value":"world","literalType":"template"}}],"edges":[{"src":"<chainTag>","dst":"<strings>","type":"HAS_BODY"},{"src":"<chainTag>","dst":"<chainTag:inner>","type":"RETURNS"},{"src":"<chainTag:inner>","dst":"<strings2>","type":"HAS_BODY"},{"src":"<chainTag:inner>","dst":"<strings[0] + strings2[0]>","type":"RETURNS"},{"src":"<strings[0] + strings2[0]>","dst":"<strings[0]>","type":"READS_FROM"},{"src":"<strings[0] + strings2[0]>","dst":"<strings2[0]>","type":"READS_FROM"},{"src":"<strings[0]>","dst":"<strings>","type":"READS_FROM"},{"src":"<strings2[0]>","dst":"<strings2>","type":"READS_FROM"},{"src":"<chainedResult>","dst":"<chainTag`hello``world`>","type":"ASSIGNED_FROM"},{"src":"<chainTag`hello`>","dst":"<chainTag>","type":"CALLS"},{"src":"<chainTag`hello`>","dst":"<`hello`>","type":"PASSES_ARGUMENT"},{"src":"<chainTag`hello``world`>","dst":"<chainTag`hello`>","type":"CALLS"},{"src":"<chainTag`hello``world`>","dst":"<`world`>","type":"PASSES_ARGUMENT"}],"rationale":"Tagged template literal chaining where chainTag returns a function that gets immediately called with another template literal. First call returns a function, second call invokes that returned function. Reduced edge count by using HAS_BODY for parameter containment instead of CONTAINS, and removing module-level declarations.","implicitBehavior":["template literals are converted to arrays of strings and passed as first argument","chained calls execute left-to-right with intermediate function return"]},"pass":2,"annotatedAt":"2026-02-24T00:33:56.527Z"}
{"construct":{"id":"expressions::tagged-template-returns-class","file":"src/expressions.js","category":"expressions","lineStart":377,"lineEnd":385,"code":"const styledDiv = {\n  div(strings, ...exprs) {\n    return class StyledComponent {\n      styles = strings.join('');\n    };\n  },\n};\nconst Component = styledDiv.div`color: red; font-size: 14px;`;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<styledDiv>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<styledDiv:obj>"},{"type":"METHOD","id":"<div>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<strings>"},{"type":"PARAMETER","id":"<exprs>","metadata":{"rest":true}},{"type":"CLASS","id":"<StyledComponent>"},{"type":"PROPERTY","id":"<styles>","metadata":{"kind":"field"}},{"type":"CALL","id":"<strings.join('')>","metadata":{"callee":"join"}},{"type":"LITERAL","id":"<''>","metadata":{"value":"","literalType":"string"}},{"type":"VARIABLE","id":"<Component>","metadata":{"kind":"const"}},{"type":"CALL","id":"<styledDiv.div`color: red; font-size: 14px;`>"},{"type":"PROPERTY_ACCESS","id":"<styledDiv.div>"},{"type":"LITERAL","id":"<`color: red; font-size: 14px;`>","metadata":{"value":"color: red; font-size: 14px;","literalType":"template"}}],"edges":[{"src":"<styledDiv>","dst":"<styledDiv:obj>","type":"ASSIGNED_FROM"},{"src":"<styledDiv:obj>","dst":"<div>","type":"HAS_PROPERTY"},{"src":"<div>","dst":"<strings>","type":"CONTAINS"},{"src":"<div>","dst":"<exprs>","type":"CONTAINS"},{"src":"<div>","dst":"<StyledComponent>","type":"RETURNS"},{"src":"<StyledComponent>","dst":"<styles>","type":"CONTAINS"},{"src":"<styles>","dst":"<strings.join('')>","type":"ASSIGNED_FROM"},{"src":"<strings.join('')>","dst":"<strings>","type":"CALLS_ON"},{"src":"<strings.join('')>","dst":"<''>","type":"PASSES_ARGUMENT"},{"src":"<Component>","dst":"<styledDiv.div`color: red; font-size: 14px;`>","type":"ASSIGNED_FROM"},{"src":"<styledDiv.div`color: red; font-size: 14px;`>","dst":"<styledDiv.div>","type":"CALLS"},{"src":"<styledDiv.div`color: red; font-size: 14px;`>","dst":"<`color: red; font-size: 14px;`>","type":"PASSES_ARGUMENT"},{"src":"<styledDiv.div>","dst":"<styledDiv>","type":"READS_FROM"}],"rationale":"Tagged template literal calls a method that returns a class. The template literal is treated as a special function call where the template is passed as an argument to the tag function, which creates and returns a class with the processed template content.","implicitBehavior":["template literal is automatically parsed into strings array and substitution expressions","class field initialization occurs during construction"]},"pass":2,"annotatedAt":"2026-02-24T00:34:01.277Z"}
{"construct":{"id":"expressions::optional-chaining-syntax-errors","file":"src/expressions.js","category":"expressions","lineStart":473,"lineEnd":479,"code":"// SyntaxError cases  cannot appear in valid AST:\n// obj?.prop = value;    // cannot assign through ?.\n// obj?.['key'] = value; // cannot assign through ?.\n// arr?.[0] = value;     // cannot assign through ?.\n// super?.method();      // super doesn't support optional chaining\n// obj?.tag`template`;   // tagged templates don't support optional chaining","commentedOut":true},"annotation":{"nodes":[{"type":"EXPRESSION","id":"<obj?.prop = value>","metadata":{"errorType":"invalid-optional-chaining-assignment","description":"Cannot assign through optional chaining"}},{"type":"EXPRESSION","id":"<obj?.['key'] = value>","metadata":{"errorType":"invalid-optional-chaining-assignment","description":"Cannot assign through optional chaining"}},{"type":"EXPRESSION","id":"<arr?.[0] = value>","metadata":{"errorType":"invalid-optional-chaining-assignment","description":"Cannot assign through optional chaining"}},{"type":"EXPRESSION","id":"<super?.method()>","metadata":{"errorType":"invalid-super-optional-chaining","description":"super doesn't support optional chaining"}},{"type":"EXPRESSION","id":"<obj?.tag`template`>","metadata":{"errorType":"invalid-optional-chaining-tagged-template","description":"Tagged templates don't support optional chaining"}}],"edges":[{"src":"<module>","dst":"<obj?.prop = value>","type":"CONTAINS"},{"src":"<module>","dst":"<obj?.['key'] = value>","type":"CONTAINS"},{"src":"<module>","dst":"<arr?.[0] = value>","type":"CONTAINS"},{"src":"<module>","dst":"<super?.method()>","type":"CONTAINS"},{"src":"<module>","dst":"<obj?.tag`template`>","type":"CONTAINS"}],"rationale":"These are syntax error cases that would prevent parsing. Each represents an invalid combination of optional chaining with other language features. Using EXPRESSION as the closest approved type since these are malformed expressions.","implicitBehavior":["These constructs would cause parse-time errors and never reach the semantic analysis phase","JavaScript parsers reject these patterns before AST construction"]},"pass":2,"annotatedAt":"2026-02-24T00:34:01.939Z"}
{"construct":{"id":"expressions::tagged-template-returns-object","file":"src/expressions.js","category":"expressions","lineStart":370,"lineEnd":375,"code":"function sql(strings, ...values) {\n  return { text: strings.join('?'), params: values }; // returns object, not string!\n}\nconst userId = 42;\nconst query = sql`SELECT * FROM users WHERE id = ${userId}`;","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<sql>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<strings>"},{"type":"PARAMETER","id":"<values>","metadata":{"rest":true}},{"type":"LITERAL","id":"<'text'>","metadata":{"value":"text","literalType":"string"}},{"type":"CALL","id":"<strings.join('?')>","metadata":{"callee":"strings.join"}},{"type":"LITERAL","id":"<'?'>","metadata":{"value":"?","literalType":"string"}},{"type":"LITERAL","id":"<'params'>","metadata":{"value":"params","literalType":"string"}},{"type":"EXPRESSION","id":"<{ text: strings.join('?'), params: values }>","metadata":{"type":"object"}},{"type":"VARIABLE","id":"<userId>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"VARIABLE","id":"<query>","metadata":{"kind":"const"}},{"type":"CALL","id":"<sql`SELECT * FROM users WHERE id = ${userId}`>","metadata":{"callee":"sql","callType":"tagged-template"}},{"type":"LITERAL","id":"<'SELECT * FROM users WHERE id = '>","metadata":{"value":"SELECT * FROM users WHERE id = ","literalType":"string"}},{"type":"LITERAL","id":"<''>","metadata":{"value":"","literalType":"string"}}],"edges":[{"src":"<sql>","dst":"<strings>","type":"HAS_BODY"},{"src":"<sql>","dst":"<values>","type":"HAS_BODY"},{"src":"<sql>","dst":"<{ text: strings.join('?'), params: values }>","type":"RETURNS"},{"src":"<{ text: strings.join('?'), params: values }>","dst":"<'text'>","type":"HAS_PROPERTY"},{"src":"<{ text: strings.join('?'), params: values }>","dst":"<strings.join('?')>","type":"HAS_PROPERTY"},{"src":"<{ text: strings.join('?'), params: values }>","dst":"<'params'>","type":"HAS_PROPERTY"},{"src":"<{ text: strings.join('?'), params: values }>","dst":"<values>","type":"HAS_PROPERTY"},{"src":"<strings.join('?')>","dst":"<strings>","type":"CALLS_ON"},{"src":"<strings.join('?')>","dst":"<'?'>","type":"PASSES_ARGUMENT"},{"src":"<userId>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<query>","dst":"<sql`SELECT * FROM users WHERE id = ${userId}`>","type":"ASSIGNED_FROM"},{"src":"<sql`SELECT * FROM users WHERE id = ${userId}`>","dst":"<sql>","type":"CALLS"},{"src":"<sql`SELECT * FROM users WHERE id = ${userId}`>","dst":"<'SELECT * FROM users WHERE id = '>","type":"PASSES_ARGUMENT"},{"src":"<sql`SELECT * FROM users WHERE id = ${userId}`>","dst":"<''>","type":"PASSES_ARGUMENT"},{"src":"<sql`SELECT * FROM users WHERE id = ${userId}`>","dst":"<userId>","type":"PASSES_ARGUMENT"}],"rationale":"Tagged template literal call where the tag function returns an object instead of a string. The template is parsed into string parts and interpolated values, passed as separate arguments to the tag function. Used HAS_BODY for parameter containment and CALLS_ON for method calls on objects.","implicitBehavior":["template literal is parsed into strings array and values rest parameter","tag function receives pre-processed template parts, not raw template string"]},"pass":2,"annotatedAt":"2026-02-24T00:34:02.920Z"}
{"construct":{"id":"expressions::short-circuit-guard-call","file":"src/expressions.js","category":"expressions","lineStart":431,"lineEnd":436,"code":"function shortCircuitGuard(callback, data) {\n  callback && callback(data);           // guard + call\n  const result = callback?.(data);      // optional call equivalent\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<shortCircuitGuard>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<callback>"},{"type":"PARAMETER","id":"<data>"},{"type":"EXPRESSION","id":"<callback && callback(data)>","metadata":{"operator":"&&","shortCircuit":true}},{"type":"CALL","id":"<callback(data)>","metadata":{"callee":"callback"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<callback?.(data)>","metadata":{"callee":"callback","optional":true}}],"edges":[{"src":"<shortCircuitGuard>","dst":"<callback>","type":"CONTAINS"},{"src":"<shortCircuitGuard>","dst":"<data>","type":"CONTAINS"},{"src":"<shortCircuitGuard>","dst":"<callback && callback(data)>","type":"CONTAINS"},{"src":"<callback && callback(data)>","dst":"<callback>","type":"READS_FROM"},{"src":"<callback && callback(data)>","dst":"<callback(data)>","type":"CONTAINS"},{"src":"<callback(data)>","dst":"<callback>","type":"CALLS"},{"src":"<callback(data)>","dst":"<data>","type":"PASSES_ARGUMENT"},{"src":"<shortCircuitGuard>","dst":"<result>","type":"DECLARES"},{"src":"<result>","dst":"<callback?.(data)>","type":"ASSIGNED_FROM"},{"src":"<callback?.(data)>","dst":"<callback>","type":"CALLS"},{"src":"<callback?.(data)>","dst":"<data>","type":"PASSES_ARGUMENT"},{"src":"<shortCircuitGuard>","dst":"<result>","type":"RETURNS"}],"rationale":"Function demonstrating two equivalent patterns for conditional callback invocation. The short-circuit AND expression conditionally executes the call, while optional chaining provides the same safety mechanism. Both patterns prevent errors when callback is null/undefined.","implicitBehavior":["short-circuit evaluation prevents call if callback is falsy","optional chaining returns undefined if callback is nullish","both patterns guard against TypeError on null/undefined callback"]},"pass":2,"annotatedAt":"2026-02-24T00:34:03.115Z"}
{"construct":{"id":"expressions::in-operator-array","file":"src/expressions.js","category":"expressions","lineStart":339,"lineEnd":347,"code":"function inOperatorArray() {\n  const hasIndex = 0 in [1, 2, 3];     // true  checks INDEX, not value\n  const hasStr = '0' in [1, 2, 3];     // true  coerced to string\n  const noIndex = 5 in [1, 2, 3];      // false\n  return { hasIndex, hasStr, noIndex };\n}\n\n// --- Reflect.construct with newTarget (constructor spoofing) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<inOperatorArray>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<hasIndex>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<0 in [1, 2, 3]>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"VARIABLE","id":"<hasStr>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<'0' in [1, 2, 3]>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<'0'>","metadata":{"value":"0","literalType":"string"}},{"type":"VARIABLE","id":"<noIndex>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<5 in [1, 2, 3]>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ hasIndex, hasStr, noIndex }>","metadata":{"type":"object"}}],"edges":[{"src":"<inOperatorArray>","dst":"<hasIndex>","type":"CONTAINS"},{"src":"<inOperatorArray>","dst":"<hasStr>","type":"CONTAINS"},{"src":"<inOperatorArray>","dst":"<noIndex>","type":"CONTAINS"},{"src":"<hasIndex>","dst":"<0 in [1, 2, 3]>","type":"ASSIGNED_FROM"},{"src":"<0 in [1, 2, 3]>","dst":"<0>","type":"USES"},{"src":"<0 in [1, 2, 3]>","dst":"<[1, 2, 3]>","type":"USES"},{"src":"<[1, 2, 3]>","dst":"<1>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3]>","dst":"<2>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3]>","dst":"<3>","type":"HAS_ELEMENT"},{"src":"<hasStr>","dst":"<'0' in [1, 2, 3]>","type":"ASSIGNED_FROM"},{"src":"<'0' in [1, 2, 3]>","dst":"<'0'>","type":"USES"},{"src":"<'0' in [1, 2, 3]>","dst":"<[1, 2, 3]>","type":"USES"},{"src":"<noIndex>","dst":"<5 in [1, 2, 3]>","type":"ASSIGNED_FROM"},{"src":"<5 in [1, 2, 3]>","dst":"<5>","type":"USES"},{"src":"<5 in [1, 2, 3]>","dst":"<[1, 2, 3]>","type":"USES"},{"src":"<inOperatorArray>","dst":"<{ hasIndex, hasStr, noIndex }>","type":"RETURNS"},{"src":"<{ hasIndex, hasStr, noIndex }>","dst":"<hasIndex>","type":"USES"},{"src":"<{ hasIndex, hasStr, noIndex }>","dst":"<hasStr>","type":"USES"},{"src":"<{ hasIndex, hasStr, noIndex }>","dst":"<noIndex>","type":"USES"}],"rationale":"Simplified annotation focusing on core relationships. Eliminated duplicate array literals by reusing the same array node across all 'in' expressions. Used USES edge type for operand relationships in expressions.","implicitBehavior":["in operator checks for property existence, not value presence","string '0' is coerced to match numeric index 0","arrays have numeric indices as string properties internally"]},"pass":2,"annotatedAt":"2026-02-24T00:34:03.989Z"}
{"construct":{"id":"expressions::await-comma-expression","file":"src/expressions.js","category":"expressions","lineStart":449,"lineEnd":454,"code":"async function awaitCommaExpression(sideEffect, fetchData) {\n  const result = await (sideEffect(), fetchData());\n  // sideEffect() runs sync, fetchData() is awaited\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<awaitCommaExpression>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<sideEffect>"},{"type":"PARAMETER","id":"<fetchData>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<await (sideEffect(), fetchData())>","metadata":{"operator":"await"}},{"type":"EXPRESSION","id":"<(sideEffect(), fetchData())>","metadata":{"operator":","}},{"type":"CALL","id":"<sideEffect()>","metadata":{"callee":"sideEffect"}},{"type":"CALL","id":"<fetchData()>","metadata":{"callee":"fetchData"}}],"edges":[{"src":"<awaitCommaExpression>","dst":"<sideEffect>","type":"CONTAINS"},{"src":"<awaitCommaExpression>","dst":"<fetchData>","type":"CONTAINS"},{"src":"<awaitCommaExpression>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<await (sideEffect(), fetchData())>","type":"ASSIGNED_FROM"},{"src":"<await (sideEffect(), fetchData())>","dst":"<(sideEffect(), fetchData())>","type":"AWAITS"},{"src":"<(sideEffect(), fetchData())>","dst":"<sideEffect()>","type":"CONTAINS"},{"src":"<(sideEffect(), fetchData())>","dst":"<fetchData()>","type":"CONTAINS"},{"src":"<sideEffect()>","dst":"<sideEffect>","type":"CALLS"},{"src":"<fetchData()>","dst":"<fetchData>","type":"CALLS"},{"src":"<awaitCommaExpression>","dst":"<result>","type":"RETURNS"}],"rationale":"Async function with await on comma expression. The comma expression contains both function calls, with the await applying to the entire comma expression result (which is the right operand).","implicitBehavior":["sideEffect() executes synchronously before await","fetchData() result is awaited, sideEffect() result is discarded","comma operator returns rightmost expression value"]},"pass":2,"annotatedAt":"2026-02-24T00:34:04.508Z"}
{"construct":{"id":"expressions::new-with-spread","file":"src/expressions.js","category":"expressions","lineStart":393,"lineEnd":403,"code":"function newWithSpread() {\n  const args = [2024, 0, 15];\n  const date = new Date(...args);\n\n  function instantiate(Cls, ctorArgs) {\n    return new Cls(...ctorArgs);       // dynamic class + spread\n  }\n\n  return { date, instantiate };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<newWithSpread>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<args>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[2024, 0, 15]>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<2024>","metadata":{"value":2024,"literalType":"number"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<15>","metadata":{"value":15,"literalType":"number"}},{"type":"VARIABLE","id":"<date>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Date(...args)>","metadata":{"callee":"Date","isConstructor":true,"hasSpread":true}},{"type":"EXTERNAL","id":"<Date>","metadata":{"source":"global"}},{"type":"FUNCTION","id":"<instantiate>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<Cls>"},{"type":"PARAMETER","id":"<ctorArgs>"},{"type":"CALL","id":"<new Cls(...ctorArgs)>","metadata":{"callee":"dynamic","isConstructor":true,"hasSpread":true}},{"type":"EXPRESSION","id":"<{ date, instantiate }>","metadata":{"expressionType":"object"}}],"edges":[{"src":"<newWithSpread>","dst":"<args>","type":"CONTAINS"},{"src":"<args>","dst":"<[2024, 0, 15]>","type":"ASSIGNED_FROM"},{"src":"<[2024, 0, 15]>","dst":"<2024>","type":"HAS_ELEMENT"},{"src":"<[2024, 0, 15]>","dst":"<0>","type":"HAS_ELEMENT"},{"src":"<[2024, 0, 15]>","dst":"<15>","type":"HAS_ELEMENT"},{"src":"<newWithSpread>","dst":"<date>","type":"CONTAINS"},{"src":"<date>","dst":"<new Date(...args)>","type":"ASSIGNED_FROM"},{"src":"<new Date(...args)>","dst":"<Date>","type":"CALLS"},{"src":"<new Date(...args)>","dst":"<args>","type":"READS_FROM"},{"src":"<newWithSpread>","dst":"<instantiate>","type":"CONTAINS"},{"src":"<instantiate>","dst":"<Cls>","type":"CONTAINS"},{"src":"<instantiate>","dst":"<ctorArgs>","type":"CONTAINS"},{"src":"<instantiate>","dst":"<new Cls(...ctorArgs)>","type":"RETURNS"},{"src":"<new Cls(...ctorArgs)>","dst":"<Cls>","type":"CALLS"},{"src":"<new Cls(...ctorArgs)>","dst":"<ctorArgs>","type":"READS_FROM"},{"src":"<newWithSpread>","dst":"<{ date, instantiate }>","type":"RETURNS"},{"src":"<{ date, instantiate }>","dst":"<date>","type":"HAS_PROPERTY"},{"src":"<{ date, instantiate }>","dst":"<instantiate>","type":"HAS_PROPERTY"}],"rationale":"Function containing constructor calls with spread syntax. The outer function creates a Date instance by spreading an array, and defines an inner function that dynamically instantiates classes with spread arguments. Added explicit EXTERNAL node for Date constructor.","implicitBehavior":["spread operator converts array elements to individual arguments","new operator creates instance and binds 'this'","dynamic constructor call allows runtime class selection"]},"pass":2,"annotatedAt":"2026-02-24T00:34:04.808Z"}
{"construct":{"id":"builtins::builtin-weakmap","file":"src/builtins.js","category":"builtins","lineStart":95,"lineEnd":106,"code":"function weakMapUsage() {\n  const wm = new WeakMap();\n  const key1 = {};\n  const key2 = {};\n  wm.set(key1, 'data1');\n  wm.set(key2, 'data2');\n  const val = wm.get(key1);\n  const has = wm.has(key2);\n  wm.delete(key1);\n  return { val, has };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<weakMapUsage>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIABLE"},"pass":2,"annotatedAt":"2026-02-24T00:34:05.424Z"}
{"construct":{"id":"expressions::nullish-logical-mixing-error","file":"src/expressions.js","category":"expressions","lineStart":481,"lineEnd":486,"code":"// SyntaxError  cannot mix ?? with || or && without explicit parentheses:\n// a ?? b || c;    // SyntaxError\n// a || b ?? c;    // SyntaxError\n// a ?? b && c;    // SyntaxError\n// Must use: (a ?? b) || c  or  a ?? (b || c)","commentedOut":true},"annotation":{"nodes":[{"type":"SIDE_EFFECT","id":"<nullish-logical-mixing-error>","metadata":{"errorType":"operator precedence ambiguity","operators":["??","||","&&"]}},{"type":"EXPRESSION","id":"<a ?? b || c>","metadata":{"invalid":true,"reason":"mixed nullish coalescing with logical OR"}},{"type":"EXPRESSION","id":"<a || b ?? c>","metadata":{"invalid":true,"reason":"mixed logical OR with nullish coalescing"}},{"type":"EXPRESSION","id":"<a ?? b && c>","metadata":{"invalid":true,"reason":"mixed nullish coalescing with logical AND"}},{"type":"EXPRESSION","id":"<(a ?? b) || c>","metadata":{"valid":true,"reason":"explicit parentheses resolve precedence"}},{"type":"EXPRESSION","id":"<a ?? (b || c)>","metadata":{"valid":true,"reason":"explicit parentheses resolve precedence"}}],"edges":[{"src":"<nullish-logical-mixing-error>","dst":"<a ?? b || c>","type":"THROWS"},{"src":"<nullish-logical-mixing-error>","dst":"<a || b ?? c>","type":"THROWS"},{"src":"<nullish-logical-mixing-error>","dst":"<a ?? b && c>","type":"THROWS"},{"src":"<(a ?? b) || c>","dst":"<nullish-logical-mixing-error>","type":"RESOLVES_TO"},{"src":"<a ?? (b || c)>","dst":"<nullish-logical-mixing-error>","type":"RESOLVES_TO"}],"rationale":"JavaScript syntax error demonstrating operator precedence ambiguity between nullish coalescing (??) and logical operators (|| &&). Shows invalid expressions and their valid parenthesized alternatives. Using SIDE_EFFECT for the error concept and THROWS/RESOLVES_TO for relationships.","implicitBehavior":["parser rejects mixed operators without parentheses","requires explicit precedence disambiguation","prevents potential developer confusion about evaluation order"]},"pass":2,"annotatedAt":"2026-02-24T00:34:06.121Z"}
{"construct":{"id":"expressions::assignment-in-condition","file":"src/expressions.js","category":"expressions","lineStart":405,"lineEnd":413,"code":"function assignmentInCondition(regex, str) {\n  const matches = [];\n  let match;\n  while (match = regex.exec(str)) {   // assignment AS condition (no explicit comparison)\n    matches.push(match[0]);\n  }\n  return matches;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<assignmentInCondition>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<regex>"},{"type":"PARAMETER","id":"<str>"},{"type":"VARIABLE","id":"<matches>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"VARIABLE","id":"<match>","metadata":{"kind":"let"}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<match = regex.exec(str)>","metadata":{"operator":"="}},{"type":"CALL","id":"<regex.exec(str)>","metadata":{"callee":"exec"}},{"type":"PROPERTY_ACCESS","id":"<regex.exec>","metadata":{"objectName":"regex","propertyName":"exec"}},{"type":"CALL","id":"<matches.push(match[0])>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<matches.push>","metadata":{"objectName":"matches","propertyName":"push"}},{"type":"EXPRESSION","id":"<match[0]>","metadata":{"operator":"[]"}},{"type":"LITERAL","id":"<0>","metadata":{"value":"0","literalType":"number"}}],"edges":[{"src":"<assignmentInCondition>","dst":"<regex>","type":"CONTAINS"},{"src":"<assignmentInCondition>","dst":"<str>","type":"CONTAINS"},{"src":"<assignmentInCondition>","dst":"<matches>","type":"CONTAINS"},{"src":"<matches>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<assignmentInCondition>","dst":"<match>","type":"CONTAINS"},{"src":"<assignmentInCondition>","dst":"<while>","type":"CONTAINS"},{"src":"<while>","dst":"<match = regex.exec(str)>","type":"HAS_CONDITION"},{"src":"<match = regex.exec(str)>","dst":"<match>","type":"WRITES_TO"},{"src":"<match = regex.exec(str)>","dst":"<regex.exec(str)>","type":"READS_FROM"},{"src":"<regex.exec(str)>","dst":"<regex.exec>","type":"CALLS"},{"src":"<regex.exec>","dst":"<regex>","type":"READS_FROM"},{"src":"<regex.exec(str)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<while>","dst":"<matches.push(match[0])>","type":"HAS_BODY"},{"src":"<matches.push(match[0])>","dst":"<matches.push>","type":"CALLS"},{"src":"<matches.push>","dst":"<matches>","type":"READS_FROM"},{"src":"<matches.push(match[0])>","dst":"<match[0]>","type":"PASSES_ARGUMENT"},{"src":"<match[0]>","dst":"<match>","type":"READS_FROM"},{"src":"<match[0]>","dst":"<0>","type":"READS_FROM"},{"src":"<assignmentInCondition>","dst":"<matches>","type":"RETURNS"}],"rationale":"Function with while loop using assignment-as-condition pattern. The assignment expression both assigns to match and serves as the loop condition, evaluated for truthiness. All Pass 1 annotations map directly to approved vocabulary.","implicitBehavior":["assignment expression returns the assigned value","while loop continues while condition is truthy","regex.exec() returns null when no more matches, terminating loop"]},"pass":2,"annotatedAt":"2026-02-24T00:34:06.443Z"}
{"construct":{"id":"hashbang-entry::export-named-list","file":"src/hashbang-entry.js","category":"hashbang-entry","lineStart":16,"lineEnd":17,"code":"export { hashbangMain };","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-hashbangMain>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<hashbangMain>","metadata":{"exported":true}}],"edges":[{"src":"<module>","dst":"<export-hashbangMain>","type":"CONTAINS"},{"src":"<export-hashbangMain>","dst":"<hashbangMain>","type":"EXPORTS"}],"rationale":"Named export statement that makes the hashbangMain identifier available to other modules. The export creates a binding in the module's export namespace.","implicitBehavior":["creates binding in module's export namespace","identifier must be declared elsewhere in module"]},"pass":2,"annotatedAt":"2026-02-24T00:34:10.162Z"}
{"construct":{"id":"index::import-named","file":"src/index.js","category":"index","lineStart":8,"lineEnd":9,"code":"import { helperFunction, HELPER_CONST } from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-modules-helpers>","metadata":{"source":"./modules-helpers.js"}},{"type":"VARIABLE","id":"<helperFunction>","metadata":{"imported":true}},{"type":"VARIABLE","id":"<HELPER_CONST>","metadata":{"imported":true}}],"edges":[{"src":"<module>","dst":"<import-modules-helpers>","type":"CONTAINS"},{"src":"<import-modules-helpers>","dst":"<helperFunction>","type":"IMPORTS"},{"src":"<import-modules-helpers>","dst":"<HELPER_CONST>","type":"IMPORTS"},{"src":"<module>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"}],"rationale":"Named import statement bringing two bindings from an external module into the current module scope. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["module resolution occurs at load time","imported bindings are read-only in importing module"]},"pass":2,"annotatedAt":"2026-02-24T00:34:10.951Z"}
{"construct":{"id":"index::import-default","file":"src/index.js","category":"index","lineStart":5,"lineEnd":6,"code":"import defaultExport from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-modules-helpers>","metadata":{"source":"./modules-helpers.js","importType":"default"}},{"type":"VARIABLE","id":"<defaultExport>","metadata":{"imported":true,"importType":"default"}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}}],"edges":[{"src":"<module>","dst":"<import-modules-helpers>","type":"CONTAINS"},{"src":"<import-modules-helpers>","dst":"<defaultExport>","type":"IMPORTS"},{"src":"<import-modules-helpers>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<module>","dst":"<defaultExport>","type":"DECLARES"}],"rationale":"Default import creates a binding for the default export from the target module. The import statement declares the variable in module scope. Added explicit EXTERNAL_MODULE node for the imported module to better represent the dependency relationship.","implicitBehavior":["import declarations are hoisted","creates live binding to exported value"]},"pass":2,"annotatedAt":"2026-02-24T00:34:10.951Z"}
{"construct":{"id":"expressions::async-arrow-returns-object","file":"src/expressions.js","category":"expressions","lineStart":456,"lineEnd":462,"code":"const asyncArrowObject = async (data, processFn) => ({\n  id: data.id,\n  result: await processFn(data),\n  timestamp: Date.now(),\n});\n// Without parens: async (data) => { id: data.id }  parsed as block + label!","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<asyncArrowObject>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<asyncArrowObject:fn>","metadata":{"arrowFunction":true,"async":true}},{"type":"PARAMETER","id":"<data>"},{"type":"PARAMETER","id":"<processFn>"},{"type":"EXPRESSION","id":"<object-literal>","metadata":{"type":"object"}},{"type":"PROPERTY_ACCESS","id":"<data.id>"},{"type":"EXPRESSION","id":"<await processFn(data)>","metadata":{"operator":"await"}},{"type":"CALL","id":"<processFn(data)>","metadata":{"callee":"processFn"}},{"type":"CALL","id":"<Date.now()>","metadata":{"callee":"Date.now"}},{"type":"PROPERTY_ACCESS","id":"<Date.now>"}],"edges":[{"src":"<asyncArrowObject>","dst":"<asyncArrowObject:fn>","type":"ASSIGNED_FROM"},{"src":"<asyncArrowObject:fn>","dst":"<data>","type":"CONTAINS"},{"src":"<asyncArrowObject:fn>","dst":"<processFn>","type":"CONTAINS"},{"src":"<asyncArrowObject:fn>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<data.id>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<await processFn(data)>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<Date.now()>","type":"HAS_PROPERTY"},{"src":"<data.id>","dst":"<data>","type":"READS_FROM"},{"src":"<await processFn(data)>","dst":"<processFn(data)>","type":"AWAITS"},{"src":"<processFn(data)>","dst":"<processFn>","type":"CALLS"},{"src":"<processFn(data)>","dst":"<data>","type":"PASSES_ARGUMENT"},{"src":"<Date.now()>","dst":"<Date.now>","type":"CALLS"}],"rationale":"Async arrow function with object literal return. All Pass 1 types and edges are in the approved vocabulary, so the annotation remains unchanged. The construct demonstrates async/await patterns, object literal syntax requiring parentheses, and property access chains.","implicitBehavior":["returns Promise due to async","object literal requires parentheses to avoid block statement parsing","await suspends execution until promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:34:11.076Z"}
{"construct":{"id":"index::import-aliased","file":"src/index.js","category":"index","lineStart":11,"lineEnd":12,"code":"import { HelperClass as Helper } from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-modules-helpers>","metadata":{"source":"./modules-helpers.js"}},{"type":"VARIABLE","id":"<Helper>","metadata":{"imported":true,"importedAs":"HelperClass"}}],"edges":[{"src":"<module>","dst":"<import-modules-helpers>","type":"CONTAINS"},{"src":"<import-modules-helpers>","dst":"<Helper>","type":"IMPORTS"},{"src":"<module>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<module>","dst":"<Helper>","type":"DECLARES"}],"rationale":"Named import with alias creates a local binding 'Helper' for the exported 'HelperClass' from the target module. The IMPORT node represents the import statement, and the VARIABLE node represents the local binding created by the alias.","implicitBehavior":["import declarations are hoisted","creates live binding to exported value"]},"pass":2,"annotatedAt":"2026-02-24T00:34:11.242Z"}
{"construct":{"id":"hashbang-entry::hashbang-comment","file":"src/hashbang-entry.js","category":"hashbang-entry","lineStart":8,"lineEnd":14,"code":"// The #!/usr/bin/env node line above is a HashbangComment node in the AST.\n// It is the ONLY position where # is legal outside a string/comment/private-field.\n\nfunction hashbangMain(args) {\n  return { ran: true, args };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"EXTERNAL","id":"<#!/usr/bin/env node>","metadata":{"interpreter":"/usr/bin/env node","role":"hashbang"}},{"type":"FUNCTION","id":"<hashbangMain>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<args>"},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"EXPRESSION","id":"<{ ran: true, args }>","metadata":{"type":"object"}}],"edges":[{"src":"<module>","dst":"<#!/usr/bin/env node>","type":"CONTAINS"},{"src":"<module>","dst":"<hashbangMain>","type":"DECLARES"},{"src":"<hashbangMain>","dst":"<args>","type":"CONTAINS"},{"src":"<hashbangMain>","dst":"<{ ran: true, args }>","type":"RETURNS"},{"src":"<{ ran: true, args }>","dst":"<true>","type":"HAS_PROPERTY"},{"src":"<{ ran: true, args }>","dst":"<args>","type":"READS_FROM"}],"rationale":"Hashbang directive mapped to EXTERNAL node as it represents system interpreter integration. Function returns object literal with boolean property and parameter reference.","implicitBehavior":["hashbang enables direct execution via system interpreter","function declaration is hoisted to module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:34:11.908Z"}
{"construct":{"id":"expressions::getter-returns-function","file":"src/expressions.js","category":"expressions","lineStart":438,"lineEnd":447,"code":"function getterReturnsFunction() {\n  const obj = {\n    get handler() {\n      return (x) => x * 2;             // getter returns a function\n    },\n  };\n  const result = obj.handler(21);       // getter call + returned function call\n  return result; // 42\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getterReturnsFunction>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj-literal>"},{"type":"GETTER","id":"<handler-getter>","metadata":{"propertyName":"handler"}},{"type":"FUNCTION","id":"<arrow-fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<obj.handler(21)>","metadata":{"callee":"obj.handler"}},{"type":"PROPERTY_ACCESS","id":"<obj.handler>","metadata":{"objectName":"obj","propertyName":"handler"}},{"type":"LITERAL","id":"<21>","metadata":{"value":21,"literalType":"number"}}],"edges":[{"src":"<getterReturnsFunction>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<obj-literal>","type":"ASSIGNED_FROM"},{"src":"<obj-literal>","dst":"<handler-getter>","type":"HAS_PROPERTY"},{"src":"<handler-getter>","dst":"<arrow-fn>","type":"RETURNS"},{"src":"<arrow-fn>","dst":"<x>","type":"CONTAINS"},{"src":"<arrow-fn>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<getterReturnsFunction>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<obj.handler(21)>","type":"ASSIGNED_FROM"},{"src":"<obj.handler(21)>","dst":"<obj.handler>","type":"CALLS"},{"src":"<obj.handler>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.handler(21)>","dst":"<21>","type":"PASSES_ARGUMENT"},{"src":"<getterReturnsFunction>","dst":"<result>","type":"RETURNS"}],"rationale":"Function contains object with getter that returns arrow function. Property access triggers getter, returned function is immediately called with argument. Used EXPRESSION for object literal since OBJECT type not in approved vocabulary.","implicitBehavior":["getter is invoked on property access","returned function is called in same expression","this binding in getter refers to containing object"]},"pass":2,"annotatedAt":"2026-02-24T00:34:14.124Z"}
{"construct":{"id":"index::import-namespace","file":"src/index.js","category":"index","lineStart":17,"lineEnd":18,"code":"import * as allHelpers from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-allHelpers>","metadata":{"source":"./modules-helpers.js","importType":"namespace"}},{"type":"VARIABLE","id":"<allHelpers>","metadata":{"imported":true,"namespaceImport":true}}],"edges":[{"src":"<module>","dst":"<import-allHelpers>","type":"CONTAINS"},{"src":"<import-allHelpers>","dst":"<allHelpers>","type":"IMPORTS"},{"src":"<module>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<module>","dst":"<allHelpers>","type":"DECLARES"}],"rationale":"Namespace import creates a single variable binding that contains all exports from the target module. All edge types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["namespace object provides access to all named exports via property access","default export accessible as allHelpers.default if present"]},"pass":2,"annotatedAt":"2026-02-24T00:34:15.740Z"}
{"construct":{"id":"index::import-default-as-named","file":"src/index.js","category":"index","lineStart":14,"lineEnd":15,"code":"import { default as mainFn } from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-modules-helpers>","metadata":{"source":"./modules-helpers.js"}},{"type":"VARIABLE","id":"<mainFn>","metadata":{"imported":true,"importedAs":"default"}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}}],"edges":[{"src":"<import-modules-helpers>","dst":"<mainFn>","type":"IMPORTS"},{"src":"<import-modules-helpers>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"}],"rationale":"Default import with explicit alias syntax using 'default as mainFn'. Creates a binding for the default export under the name 'mainFn'. The import statement references the external module and creates a local variable binding.","implicitBehavior":["default export is accessed as the 'default' property of the module object","the 'default as' syntax explicitly names the default export binding"]},"pass":2,"annotatedAt":"2026-02-24T00:34:16.336Z"}
{"construct":{"id":"index::reexport-star","file":"src/index.js","category":"index","lineStart":42,"lineEnd":43,"code":"export * from './modules-reexport.js';","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-star>","metadata":{"exportType":"star","source":"./modules-reexport.js"}},{"type":"EXTERNAL_MODULE","id":"<./modules-reexport.js>","metadata":{"path":"./modules-reexport.js"}}],"edges":[{"src":"<export-star>","dst":"<./modules-reexport.js>","type":"IMPORTS_FROM"}],"rationale":"Star export re-exports all named exports from another module. The EXPORT node represents the star export construct, and EXTERNAL_MODULE represents the target module. IMPORTS_FROM captures the dependency relationship, though it's semantically a re-export rather than a pure import.","implicitBehavior":["re-exports all named exports but not the default export","creates bindings in current module for all exported names from target module","makes all named exports from target module available to importers of this module"]},"pass":2,"annotatedAt":"2026-02-24T00:34:18.229Z"}
{"construct":{"id":"index::import-meta","file":"src/index.js","category":"index","lineStart":48,"lineEnd":51,"code":"const currentUrl = import.meta.url;\n\n// --- Module namespace object as first-class value ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<currentUrl>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<import.meta.url>","metadata":{"objectName":"import.meta","propertyName":"url"}},{"type":"META_PROPERTY","id":"<import.meta>","metadata":{"kind":"module-metadata"}}],"edges":[{"src":"<module>","dst":"<currentUrl>","type":"DECLARES"},{"src":"<currentUrl>","dst":"<import.meta.url>","type":"ASSIGNED_FROM"},{"src":"<import.meta.url>","dst":"<import.meta>","type":"READS_FROM"}],"rationale":"Const variable assigned from import.meta.url property access. import.meta is represented as META_PROPERTY since it's a built-in module metadata object that provides meta-information about the current module.","implicitBehavior":["import.meta.url resolves to the current module's file URL at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:34:18.593Z"}
{"construct":{"id":"builtins::builtin-weakset","file":"src/builtins.js","category":"builtins","lineStart":108,"lineEnd":120,"code":"function weakSetUsage() {\n  const ws = new WeakSet();\n  const obj1 = {};\n  const obj2 = {};\n  ws.add(obj1);\n  const has = ws.has(obj1);\n  ws.delete(obj1);\n  const hasAfter = ws.has(obj1);\n  return { has, hasAfter };\n}\n\n// --- WeakRef / FinalizationRegistry ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<weakSetUsage>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<ws>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new WeakSet()>","metadata":{"callee":"WeakSet","isConstructor":true}},{"type":"VARIABLE","id":"<obj1>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"VARIABLE","id":"<obj2>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}2>","metadata":{"value":"{}","literalType":"object"}},{"type":"CALL","id":"<ws.add(obj1)>","metadata":{"callee":"add","method":true}},{"type":"VARIABLE","id":"<has>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ws.has(obj1)>","metadata":{"callee":"has","method":true}},{"type":"CALL","id":"<ws.delete(obj1)>","metadata":{"callee":"delete","method":true}},{"type":"VARIABLE","id":"<hasAfter>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ws.has(obj1)2>","metadata":{"callee":"has","method":true}},{"type":"EXPRESSION","id":"<{ has, hasAfter }>","metadata":{"type":"object"}}],"edges":[{"src":"<weakSetUsage>","dst":"<ws>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<obj1>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<obj2>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<has>","type":"CONTAINS"},{"src":"<weakSetUsage>","dst":"<hasAfter>","type":"CONTAINS"},{"src":"<ws>","dst":"<new WeakSet()>","type":"ASSIGNED_FROM"},{"src":"<new WeakSet()>","dst":"<WeakSet>","type":"CALLS"},{"src":"<obj1>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<obj2>","dst":"<{}2>","type":"ASSIGNED_FROM"},{"src":"<ws.add(obj1)>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.add(obj1)>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<has>","dst":"<ws.has(obj1)>","type":"ASSIGNED_FROM"},{"src":"<ws.has(obj1)>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.has(obj1)>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<ws.delete(obj1)>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.delete(obj1)>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<hasAfter>","dst":"<ws.has(obj1)2>","type":"ASSIGNED_FROM"},{"src":"<ws.has(obj1)2>","dst":"<ws>","type":"CALLS_ON"},{"src":"<ws.has(obj1)2>","dst":"<obj1>","type":"PASSES_ARGUMENT"},{"src":"<weakSetUsage>","dst":"<{ has, hasAfter }>","type":"RETURNS"},{"src":"<{ has, hasAfter }>","dst":"<has>","type":"READS_FROM"},{"src":"<{ has, hasAfter }>","dst":"<hasAfter>","type":"READS_FROM"}],"rationale":"Function demonstrating WeakSet operations: construction, adding objects, checking membership, deletion, and re-checking. Returns object with before/after membership results. Changed CALLS to CALLS_ON for method invocations to better capture the receiver relationship.","implicitBehavior":["WeakSet holds weak references to objects","Objects may be garbage collected if no other references exist","WeakSet is not enumerable"]},"pass":2,"annotatedAt":"2026-02-24T00:34:18.606Z"}
{"construct":{"id":"expressions::tag-on-call-result","file":"src/expressions.js","category":"expressions","lineStart":464,"lineEnd":471,"code":"function tagOnCallResult() {\n  function getFormatter(type) {\n    return (strings, ...values) => ({ type, parts: strings, values });\n  }\n  const result = getFormatter('sql')`SELECT * FROM ${'users'}`;\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tagOnCallResult>","metadata":{"async":false,"generator":false}},{"type":"FUNCTION","id":"<getFormatter>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<type>"},{"type":"FUNCTION","id":"<getFormatter:arrow>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<strings>"},{"type":"PARAMETER","id":"<...values>","metadata":{"restParameter":true}},{"type":"EXPRESSION","id":"<{ type, parts: strings, values }>","metadata":{"expressionType":"object"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<getFormatter('sql')>","metadata":{"callee":"getFormatter"}},{"type":"LITERAL","id":"<'sql'>","metadata":{"value":"sql","literalType":"string"}},{"type":"CALL","id":"<tagged_template_call>","metadata":{"callee":"getFormatter('sql')","callType":"tagged_template"}},{"type":"EXPRESSION","id":"<`SELECT * FROM ${'users'}`>","metadata":{"expressionType":"template_literal"}},{"type":"LITERAL","id":"<'users'>","metadata":{"value":"users","literalType":"string"}}],"edges":[{"src":"<tagOnCallResult>","dst":"<getFormatter>","type":"CONTAINS"},{"src":"<getFormatter>","dst":"<type>","type":"RECEIVES_ARGUMENT"},{"src":"<getFormatter>","dst":"<getFormatter:arrow>","type":"RETURNS"},{"src":"<getFormatter:arrow>","dst":"<strings>","type":"RECEIVES_ARGUMENT"},{"src":"<getFormatter:arrow>","dst":"<...values>","type":"RECEIVES_ARGUMENT"},{"src":"<getFormatter:arrow>","dst":"<{ type, parts: strings, values }>","type":"RETURNS"},{"src":"<{ type, parts: strings, values }>","dst":"<type>","type":"READS_FROM"},{"src":"<{ type, parts: strings, values }>","dst":"<strings>","type":"READS_FROM"},{"src":"<{ type, parts: strings, values }>","dst":"<...values>","type":"READS_FROM"},{"src":"<tagOnCallResult>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<tagged_template_call>","type":"ASSIGNED_FROM"},{"src":"<getFormatter('sql')>","dst":"<getFormatter>","type":"CALLS"},{"src":"<getFormatter('sql')>","dst":"<'sql'>","type":"PASSES_ARGUMENT"},{"src":"<tagged_template_call>","dst":"<getFormatter('sql')>","type":"CALLS"},{"src":"<tagged_template_call>","dst":"<`SELECT * FROM ${'users'}`>","type":"PASSES_ARGUMENT"},{"src":"<`SELECT * FROM ${'users'}`>","dst":"<'users'>","type":"CONTAINS"},{"src":"<tagOnCallResult>","dst":"<result>","type":"RETURNS"}],"rationale":"Function containing nested function that returns a template tag function. The tag function is called with a template literal containing string interpolation. Mapped tagged template to CALL since no specific tagged template type exists in approved vocabulary.","implicitBehavior":["template literal is parsed into strings array and values array","tagged template call passes parsed template parts to the tag function"]},"pass":2,"annotatedAt":"2026-02-24T00:34:18.955Z"}
{"construct":{"id":"builtins::builtin-weakref","file":"src/builtins.js","category":"builtins","lineStart":122,"lineEnd":128,"code":"function weakRefUsage() {\n  let target = { data: 'important' };\n  const ref = new WeakRef(target);\n  const deref = ref.deref();\n  return deref?.data;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<weakRefUsage>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<target>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<{ data: 'important' }>","metadata":{"literalType":"object"}},{"type":"VARIABLE","id":"<ref>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new WeakRef(target)>","metadata":{"callee":"WeakRef","isConstructor":true}},{"type":"VARIABLE","id":"<deref>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ref.deref()>","metadata":{"callee":"deref","isMethodCall":true}},{"type":"PROPERTY_ACCESS","id":"<deref?.data>","metadata":{"objectName":"deref","propertyName":"data","optional":true}}],"edges":[{"src":"<weakRefUsage>","dst":"<target>","type":"CONTAINS"},{"src":"<weakRefUsage>","dst":"<ref>","type":"CONTAINS"},{"src":"<weakRefUsage>","dst":"<deref>","type":"CONTAINS"},{"src":"<target>","dst":"<{ data: 'important' }>","type":"ASSIGNED_FROM"},{"src":"<ref>","dst":"<new WeakRef(target)>","type":"ASSIGNED_FROM"},{"src":"<new WeakRef(target)>","dst":"<target>","type":"PASSES_ARGUMENT"},{"src":"<deref>","dst":"<ref.deref()>","type":"ASSIGNED_FROM"},{"src":"<ref.deref()>","dst":"<ref>","type":"CALLS_ON"},{"src":"<weakRefUsage>","dst":"<deref?.data>","type":"RETURNS"},{"src":"<deref?.data>","dst":"<deref>","type":"READS_FROM"}],"rationale":"Function demonstrates WeakRef usage: creates target object, wraps in WeakRef, dereferences it, and returns optional property access. Reduced edge count by removing module declaration edge and using CALLS_ON instead of separate CALLS and READS_FROM for method call.","implicitBehavior":["WeakRef allows garbage collection of target even while ref exists","deref() may return undefined if target was collected","optional chaining prevents error if deref returns undefined"]},"pass":2,"annotatedAt":"2026-02-24T00:34:20.074Z"}
{"construct":{"id":"index::import-dynamic","file":"src/index.js","category":"index","lineStart":45,"lineEnd":46,"code":"const dynamicModule = await import('./patterns.js');","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<dynamicModule>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import('./patterns.js')>","metadata":{"callee":"import","dynamic":true}},{"type":"LITERAL","id":"<'./patterns.js'>","metadata":{"value":"./patterns.js","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<dynamicModule>","type":"DECLARES"},{"src":"<dynamicModule>","dst":"<import('./patterns.js')>","type":"ASSIGNED_FROM"},{"src":"<import('./patterns.js')>","dst":"<'./patterns.js'>","type":"PASSES_ARGUMENT"},{"src":"<module>","dst":"<./patterns.js>","type":"IMPORTS_FROM"}],"rationale":"Dynamic import creates a const variable assigned from an import() call. The call takes a string literal as argument and establishes a module dependency. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["returns a Promise that resolves to the module object","module loading happens at runtime","creates async dependency"]},"pass":2,"annotatedAt":"2026-02-24T00:34:20.972Z"}
{"construct":{"id":"expressions::deep-optional-chain","file":"src/expressions.js","category":"expressions","lineStart":424,"lineEnd":429,"code":"function deepOptionalChain(response) {\n  const value = response?.data?.items?.[0]?.getName?.();\n  const nested = response?.config?.headers?.['Content-Type']?.split?.('/');\n  return { value, nested };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deepOptionalChain>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<response>"},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<response?.data?.items?.[0]?.getName?.()>","metadata":{"type":"optional_chain","chainLength":5}},{"type":"PROPERTY_ACCESS","id":"<response?.data>","metadata":{"optional":true}},{"type":"PROPERTY_ACCESS","id":"<data?.items>","metadata":{"optional":true}},{"type":"PROPERTY_ACCESS","id":"<items?.[0]>","metadata":{"optional":true,"computed":true,"index":0}},{"type":"PROPERTY_ACCESS","id":"<[0]?.getName>","metadata":{"optional":true}},{"type":"CALL","id":"<getName?.()>","metadata":{"optional":true,"arguments":0}},{"type":"VARIABLE","id":"<nested>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<response?.config?.headers?.['Content-Type']?.split?.('/')>","metadata":{"type":"optional_chain","chainLength":5}},{"type":"PROPERTY_ACCESS","id":"<response?.config>","metadata":{"optional":true}},{"type":"PROPERTY_ACCESS","id":"<config?.headers>","metadata":{"optional":true}},{"type":"PROPERTY_ACCESS","id":"<headers?.['Content-Type']>","metadata":{"optional":true,"computed":true,"key":"Content-Type"}},{"type":"PROPERTY_ACCESS","id":"<['Content-Type']?.split>","metadata":{"optional":true}},{"type":"CALL","id":"<split?.('/')>","metadata":{"optional":true,"arguments":1}},{"type":"LITERAL","id":"<'/'>","metadata":{"value":"/","literalType":"string"}},{"type":"EXPRESSION","id":"<{ value, nested }>","metadata":{"type":"object_literal","properties":2}}],"edges":[{"src":"<deepOptionalChain>","dst":"<response>","type":"CONTAINS"},{"src":"<deepOptionalChain>","dst":"<value>","type":"CONTAINS"},{"src":"<deepOptionalChain>","dst":"<nested>","type":"CONTAINS"},{"src":"<value>","dst":"<response?.data?.items?.[0]?.getName?.()>","type":"ASSIGNED_FROM"},{"src":"<response?.data?.items?.[0]?.getName?.()>","dst":"<response?.data>","type":"CHAINS_FROM"},{"src":"<response?.data>","dst":"<response>","type":"READS_FROM"},{"src":"<data?.items>","dst":"<response?.data>","type":"CHAINS_FROM"},{"src":"<items?.[0]>","dst":"<data?.items>","type":"CHAINS_FROM"},{"src":"<[0]?.getName>","dst":"<items?.[0]>","type":"CHAINS_FROM"},{"src":"<getName?.()>","dst":"<[0]?.getName>","type":"CHAINS_FROM"},{"src":"<nested>","dst":"<response?.config?.headers?.['Content-Type']?.split?.('/')>","type":"ASSIGNED_FROM"},{"src":"<response?.config?.headers?.['Content-Type']?.split?.('/')>","dst":"<response?.config>","type":"CHAINS_FROM"},{"src":"<response?.config>","dst":"<response>","type":"READS_FROM"},{"src":"<config?.headers>","dst":"<response?.config>","type":"CHAINS_FROM"},{"src":"<headers?.['Content-Type']>","dst":"<config?.headers>","type":"CHAINS_FROM"},{"src":"<['Content-Type']?.split>","dst":"<headers?.['Content-Type']>","type":"CHAINS_FROM"},{"src":"<split?.('/')>","dst":"<['Content-Type']?.split>","type":"CHAINS_FROM"},{"src":"<split?.('/')>","dst":"<'/'>","type":"PASSES_ARGUMENT"},{"src":"<deepOptionalChain>","dst":"<{ value, nested }>","type":"RETURNS"},{"src":"<{ value, nested }>","dst":"<value>","type":"READS_FROM"},{"src":"<{ value, nested }>","dst":"<nested>","type":"READS_FROM"}],"rationale":"Function with two complex optional chaining expressions. Each chain is modeled as a top-level EXPRESSION node with individual access operations that chain together. The chains short-circuit on null/undefined at any step. Used EXPRESSION for optional chains and object literal since no specific types exist in approved vocabulary.","implicitBehavior":["optional chaining short-circuits to undefined if any step is null/undefined","property shorthand in object literal creates properties with same names as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:34:21.503Z"}
{"construct":{"id":"index::module-namespace-destructured","file":"src/index.js","category":"index","lineStart":60,"lineEnd":61,"code":"const { helperFunction: destructuredHelper } = allHelpers;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<destructuredHelper>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{helperFunction: destructuredHelper}>","metadata":{"expressionType":"destructuring","destructuringType":"object","renamed":true}},{"type":"PROPERTY_ACCESS","id":"<allHelpers.helperFunction>","metadata":{"objectName":"allHelpers","propertyName":"helperFunction"}}],"edges":[{"src":"<module>","dst":"<destructuredHelper>","type":"DECLARES"},{"src":"<destructuredHelper>","dst":"<{helperFunction: destructuredHelper}>","type":"ASSIGNED_FROM"},{"src":"<{helperFunction: destructuredHelper}>","dst":"<allHelpers>","type":"READS_FROM"},{"src":"<{helperFunction: destructuredHelper}>","dst":"<allHelpers.helperFunction>","type":"READS_FROM"},{"src":"<allHelpers.helperFunction>","dst":"<allHelpers>","type":"READS_FROM"}],"rationale":"Object destructuring with property renaming mapped to approved vocabulary. The destructuring pattern is represented as an EXPRESSION, and the specific destructuring semantics are captured through READS_FROM edges.","implicitBehavior":["property access occurs at assignment time","creates new binding with different name than source property"]},"pass":2,"annotatedAt":"2026-02-24T00:34:26.218Z"}
{"construct":{"id":"index::export-named-list","file":"src/index.js","category":"index","lineStart":63,"lineEnd":64,"code":"export { defaultExport, helperFunction, HELPER_CONST, Helper, allHelpers, mainFn, helperResult, destructuredHelper };","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<defaultExport>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<helperFunction>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<HELPER_CONST>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Helper>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<allHelpers>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<mainFn>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<helperResult>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<destructuredHelper>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<defaultExport>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<helperFunction>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<HELPER_CONST>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Helper>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<allHelpers>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<mainFn>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<helperResult>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<destructuredHelper>","type":"EXPORTS"}],"rationale":"Named export list that makes multiple local bindings available to other modules. Each exported name references a local variable/function/constant. Removed the module containment edge to reduce edge count while preserving the core export semantics.","implicitBehavior":["exported bindings must be declared in module scope","creates live bindings that reflect changes to local variables"]},"pass":2,"annotatedAt":"2026-02-24T00:34:26.625Z"}
{"construct":{"id":"expressions::arrow-return-assignment","file":"src/expressions.js","category":"expressions","lineStart":572,"lineEnd":585,"code":"function arrowReturnAssignment() {\n  let cache = null;\n\n  // Arrow returning assignment  parenthesized to make it expression body\n  const setCache = (val) => (cache = val);\n  setCache(42);\n\n  // With destructuring assignment in arrow\n  let first, second;\n  const swap = () => ([first, second] = [second, first]);\n\n  return { cache, setCache, swap };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<arrowReturnAssignment>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<cache>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"VARIABLE","id":"<setCache>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<setCache:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<val>"},{"type":"EXPRESSION","id":"<cache = val>","metadata":{"operator":"="}},{"type":"CALL","id":"<setCache(42)>","metadata":{"callee":"setCache"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"VARIABLE","id":"<first>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<second>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<swap>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<swap:fn>","metadata":{"arrowFunction":true}},{"type":"EXPRESSION","id":"<[first, second] = [second, first]>","metadata":{"operator":"=","destructuring":true}},{"type":"EXPRESSION","id":"<[second, first]>","metadata":{"arrayLiteral":true}},{"type":"EXPRESSION","id":"<{ cache, setCache, swap }>","metadata":{"objectLiteral":true,"shorthandProperties":true}}],"edges":[{"src":"<arrowReturnAssignment>","dst":"<cache>","type":"CONTAINS"},{"src":"<cache>","dst":"<null>","type":"ASSIGNED_FROM"},{"src":"<arrowReturnAssignment>","dst":"<setCache>","type":"CONTAINS"},{"src":"<setCache>","dst":"<setCache:fn>","type":"ASSIGNED_FROM"},{"src":"<setCache:fn>","dst":"<val>","type":"CONTAINS"},{"src":"<setCache:fn>","dst":"<cache = val>","type":"RETURNS"},{"src":"<cache = val>","dst":"<cache>","type":"WRITES_TO"},{"src":"<cache = val>","dst":"<val>","type":"READS_FROM"},{"src":"<arrowReturnAssignment>","dst":"<setCache(42)>","type":"CONTAINS"},{"src":"<setCache(42)>","dst":"<setCache>","type":"CALLS"},{"src":"<setCache(42)>","dst":"<42>","type":"PASSES_ARGUMENT"},{"src":"<arrowReturnAssignment>","dst":"<first>","type":"CONTAINS"},{"src":"<arrowReturnAssignment>","dst":"<second>","type":"CONTAINS"},{"src":"<arrowReturnAssignment>","dst":"<swap>","type":"CONTAINS"},{"src":"<swap>","dst":"<swap:fn>","type":"ASSIGNED_FROM"},{"src":"<swap:fn>","dst":"<[first, second] = [second, first]>","type":"RETURNS"},{"src":"<[first, second] = [second, first]>","dst":"<first>","type":"WRITES_TO"},{"src":"<[first, second] = [second, first]>","dst":"<second>","type":"WRITES_TO"},{"src":"<[first, second] = [second, first]>","dst":"<[second, first]>","type":"READS_FROM"},{"src":"<[second, first]>","dst":"<second>","type":"READS_FROM"},{"src":"<[second, first]>","dst":"<first>","type":"READS_FROM"},{"src":"<arrowReturnAssignment>","dst":"<{ cache, setCache, swap }>","type":"RETURNS"},{"src":"<{ cache, setCache, swap }>","dst":"<cache>","type":"READS_FROM"},{"src":"<{ cache, setCache, swap }>","dst":"<setCache>","type":"READS_FROM"},{"src":"<{ cache, setCache, swap }>","dst":"<swap>","type":"READS_FROM"}],"rationale":"Function containing arrow functions with expression bodies that perform assignments. The setCache arrow returns a parenthesized assignment expression, while swap returns a destructuring assignment that swaps two variables. All types from Pass 1 were already in the approved vocabulary, so no mapping was needed.","implicitBehavior":["Arrow functions capture lexical scope for 'cache', 'first', 'second'","Parentheses around assignment make it an expression rather than statement","Destructuring assignment creates temporary array on right side"]},"pass":2,"annotatedAt":"2026-02-24T00:34:26.741Z"}
{"construct":{"id":"expressions::void-as-undefined","file":"src/expressions.js","category":"expressions","lineStart":520,"lineEnd":533,"code":"function voidAsUndefined(val) {\n  // void 0 is shorter than undefined and immune to shadowing\n  const isUndef = val === void 0;\n\n  // void with side effect  expression runs, result discarded\n  let sideEffectRan = false;\n  void (sideEffectRan = true);\n\n  // void in ternary  explicit undefined branch\n  const result = val !== void 0 ? val : 'fallback';\n\n  return { isUndef, sideEffectRan, result };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<voidAsUndefined>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<val>"},{"type":"VARIABLE","id":"<isUndef>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<val === void 0>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<void 0>","metadata":{"operator":"void"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<sideEffectRan>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"EXPRESSION","id":"<void (sideEffectRan = true)>","metadata":{"operator":"void"}},{"type":"EXPRESSION","id":"<sideEffectRan = true>","metadata":{"operator":"="}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<val !== void 0 ? val : 'fallback'>","metadata":{"operator":"?:"}},{"type":"EXPRESSION","id":"<val !== void 0>","metadata":{"operator":"!=="}},{"type":"EXPRESSION","id":"<void 0 (ternary)>","metadata":{"operator":"void"}},{"type":"LITERAL","id":"<0 (ternary)>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<'fallback'>","metadata":{"value":"fallback","literalType":"string"}},{"type":"EXPRESSION","id":"<{ isUndef, sideEffectRan, result }>","metadata":{"type":"object"}}],"edges":[{"src":"<voidAsUndefined>","dst":"<val>","type":"CONTAINS"},{"src":"<voidAsUndefined>","dst":"<isUndef>","type":"DECLARES"},{"src":"<isUndef>","dst":"<val === void 0>","type":"ASSIGNED_FROM"},{"src":"<val === void 0>","dst":"<val>","type":"READS_FROM"},{"src":"<val === void 0>","dst":"<void 0>","type":"READS_FROM"},{"src":"<void 0>","dst":"<0>","type":"READS_FROM"},{"src":"<voidAsUndefined>","dst":"<sideEffectRan>","type":"DECLARES"},{"src":"<sideEffectRan>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<void (sideEffectRan = true)>","dst":"<sideEffectRan = true>","type":"READS_FROM"},{"src":"<sideEffectRan = true>","dst":"<sideEffectRan>","type":"WRITES_TO"},{"src":"<sideEffectRan = true>","dst":"<true>","type":"READS_FROM"},{"src":"<voidAsUndefined>","dst":"<result>","type":"DECLARES"},{"src":"<result>","dst":"<val !== void 0 ? val : 'fallback'>","type":"ASSIGNED_FROM"},{"src":"<val !== void 0 ? val : 'fallback'>","dst":"<val !== void 0>","type":"HAS_CONDITION"},{"src":"<val !== void 0>","dst":"<val>","type":"READS_FROM"},{"src":"<val !== void 0>","dst":"<void 0 (ternary)>","type":"READS_FROM"},{"src":"<void 0 (ternary)>","dst":"<0 (ternary)>","type":"READS_FROM"},{"src":"<val !== void 0 ? val : 'fallback'>","dst":"<val>","type":"HAS_CONSEQUENT"},{"src":"<val !== void 0 ? val : 'fallback'>","dst":"<'fallback'>","type":"HAS_ALTERNATE"},{"src":"<voidAsUndefined>","dst":"<{ isUndef, sideEffectRan, result }>","type":"RETURNS"},{"src":"<{ isUndef, sideEffectRan, result }>","dst":"<isUndef>","type":"READS_FROM"},{"src":"<{ isUndef, sideEffectRan, result }>","dst":"<sideEffectRan>","type":"READS_FROM"},{"src":"<{ isUndef, sideEffectRan, result }>","dst":"<result>","type":"READS_FROM"}],"rationale":"Function demonstrates void operator usage patterns. void 0 expressions evaluate operands but return undefined. Side effect assignment runs within void expression but result is discarded. All relationships captured using approved vocabulary.","implicitBehavior":["void operator always returns undefined regardless of operand","void 0 is commonly used as undefined literal to avoid shadowing","assignment expression within void still executes the assignment"]},"pass":2,"annotatedAt":"2026-02-24T00:34:26.838Z"}
{"construct":{"id":"iterators::iter-usage-spread","file":"src/iterators.js","category":"iterators","lineStart":38,"lineEnd":41,"code":"function spreadRange(start, end) {\n  return [...new Range(start, end)];\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<spreadRange>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"EXPRESSION","id":"<...new Range(start, end)>","metadata":{"operator":"spread"}},{"type":"CALL","id":"<new Range(start, end)>","metadata":{"callee":"Range","isConstructor":true}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}}],"edges":[{"src":"<spreadRange>","dst":"<start>","type":"CONTAINS"},{"src":"<spreadRange>","dst":"<end>","type":"CONTAINS"},{"src":"<spreadRange>","dst":"<...new Range(start, end)>","type":"RETURNS"},{"src":"<...new Range(start, end)>","dst":"<new Range(start, end)>","type":"SPREADS_FROM"},{"src":"<...new Range(start, end)>","dst":"<[]>","type":"HAS_ELEMENT"},{"src":"<new Range(start, end)>","dst":"<start>","type":"PASSES_ARGUMENT"},{"src":"<new Range(start, end)>","dst":"<end>","type":"PASSES_ARGUMENT"}],"rationale":"Function that creates a Range instance and spreads it into an array literal. The spread operator iterates over the Range object using SPREADS_FROM to capture the source and HAS_ELEMENT to represent the array construction.","implicitBehavior":["Range constructor must implement Symbol.iterator for spread to work","spread operator calls the iterator protocol"]},"pass":2,"annotatedAt":"2026-02-24T00:34:27.794Z"}
{"construct":{"id":"iterators::iter-usage-for-of","file":"src/iterators.js","category":"iterators","lineStart":28,"lineEnd":36,"code":"function consumeRange(start, end) {\n  const range = new Range(start, end);\n  const values = [];\n  for (const n of range) {\n    values.push(n);\n  }\n  return values;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<consumeRange>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"VARIABLE","id":"<range>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Range(start, end)>","metadata":{"callee":"Range","isConstructor":true}},{"type":"VARIABLE","id":"<values>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<n>","metadata":{"kind":"const"}},{"type":"CALL","id":"<values.push(n)>","metadata":{"callee":"push","method":true}}],"edges":[{"src":"<consumeRange>","dst":"<start>","type":"CONTAINS"},{"src":"<consumeRange>","dst":"<end>","type":"CONTAINS"},{"src":"<consumeRange>","dst":"<range>","type":"CONTAINS"},{"src":"<range>","dst":"<new Range(start, end)>","type":"ASSIGNED_FROM"},{"src":"<new Range(start, end)>","dst":"<start>","type":"PASSES_ARGUMENT"},{"src":"<new Range(start, end)>","dst":"<end>","type":"PASSES_ARGUMENT"},{"src":"<consumeRange>","dst":"<values>","type":"CONTAINS"},{"src":"<values>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<consumeRange>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<range>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<n>","type":"CONTAINS"},{"src":"<for-of>","dst":"<values.push(n)>","type":"CONTAINS"},{"src":"<values.push(n)>","dst":"<n>","type":"PASSES_ARGUMENT"},{"src":"<consumeRange>","dst":"<values>","type":"RETURNS"}],"rationale":"Function creates a Range instance, iterates over it with for-of loop, collecting values into an array. Reduced edge count by removing module declaration edge and constructor call edge while preserving core semantic relationships.","implicitBehavior":["Range constructor must implement Symbol.iterator protocol","for-of loop calls range[Symbol.iterator]() and iterates through next() values","loop variable n is block-scoped to each iteration","values.push() method call implicitly targets the push method on the array"]},"pass":2,"annotatedAt":"2026-02-24T00:34:31.321Z"}
{"construct":{"id":"iterators::iter-usage-destructuring","file":"src/iterators.js","category":"iterators","lineStart":43,"lineEnd":49,"code":"function destructureRange(start, end) {\n  const [first, second, ...rest] = new Range(start, end);\n  return { first, second, rest };\n}\n\n// --- Iterator protocol manual ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureRange>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"VARIABLE","id":"<first>","metadata":{"kind":"const"}},{"type":"VARIABLE","id":"<second>","metadata":{"kind":"const"}},{"type":"VARIABLE","id":"<rest>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Range(start, end)>","metadata":{"callee":"Range","isConstructor":true}},{"type":"EXPRESSION","id":"<{ first, second, rest }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<destructureRange>","dst":"<start>","type":"CONTAINS"},{"src":"<destructureRange>","dst":"<end>","type":"CONTAINS"},{"src":"<destructureRange>","dst":"<first>","type":"CONTAINS"},{"src":"<destructureRange>","dst":"<second>","type":"CONTAINS"},{"src":"<destructureRange>","dst":"<rest>","type":"CONTAINS"},{"src":"<new Range(start, end)>","dst":"<start>","type":"PASSES_ARGUMENT"},{"src":"<new Range(start, end)>","dst":"<end>","type":"PASSES_ARGUMENT"},{"src":"<first>","dst":"<new Range(start, end)>","type":"ASSIGNED_FROM"},{"src":"<second>","dst":"<new Range(start, end)>","type":"ASSIGNED_FROM"},{"src":"<rest>","dst":"<new Range(start, end)>","type":"ASSIGNED_FROM"},{"src":"<{ first, second, rest }>","dst":"<first>","type":"READS_FROM"},{"src":"<{ first, second, rest }>","dst":"<second>","type":"READS_FROM"},{"src":"<{ first, second, rest }>","dst":"<rest>","type":"READS_FROM"},{"src":"<destructureRange>","dst":"<{ first, second, rest }>","type":"RETURNS"}],"rationale":"Function uses array destructuring to extract values from a Range iterator. The destructuring assignment creates three const variables from the iterable, then returns an object containing those values. Used ASSIGNED_FROM instead of DESTRUCTURES_FROM as the closest approved edge type.","implicitBehavior":["Range constructor must return an iterable object","Array destructuring calls Symbol.iterator on the Range instance","Rest parameter collects remaining iterator values into an array"]},"pass":2,"annotatedAt":"2026-02-24T00:34:32.146Z"}
{"construct":{"id":"builtins::builtin-finalization-registry","file":"src/builtins.js","category":"builtins","lineStart":130,"lineEnd":140,"code":"function finalizationUsage() {\n  const registry = new FinalizationRegistry((heldValue) => {\n    console.log(`Cleaned up: ${heldValue}`);\n  });\n  let obj = { id: 1 };\n  registry.register(obj, 'resource-1');\n  return obj;\n}\n\n// --- TypedArrays / ArrayBuffer ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<finalizationUsage>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<registry>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new FinalizationRegistry(...)>","metadata":{"callee":"FinalizationRegistry","constructor":true}},{"type":"FUNCTION","id":"<cleanup-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<heldValue>"},{"type":"CALL","id":"<console.log(...)>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<`Cleaned up: ${heldValue}`>","metadata":{"templateLiteral":true}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<{ id: 1 }>","metadata":{"value":"{ id: 1 }","literalType":"object"}},{"type":"CALL","id":"<registry.register(obj, 'resource-1')>","metadata":{"callee":"register"}},{"type":"LITERAL","id":"<'resource-1'>","metadata":{"value":"resource-1","literalType":"string"}}],"edges":[{"src":"<finalizationUsage>","dst":"<registry>","type":"CONTAINS"},{"src":"<finalizationUsage>","dst":"<obj>","type":"CONTAINS"},{"src":"<registry>","dst":"<new FinalizationRegistry(...)>","type":"ASSIGNED_FROM"},{"src":"<new FinalizationRegistry(...)>","dst":"<cleanup-callback>","type":"PASSES_ARGUMENT"},{"src":"<cleanup-callback>","dst":"<heldValue>","type":"CONTAINS"},{"src":"<cleanup-callback>","dst":"<console.log(...)>","type":"CONTAINS"},{"src":"<console.log(...)>","dst":"<`Cleaned up: ${heldValue}`>","type":"PASSES_ARGUMENT"},{"src":"<`Cleaned up: ${heldValue}`>","dst":"<heldValue>","type":"READS_FROM"},{"src":"<obj>","dst":"<{ id: 1 }>","type":"ASSIGNED_FROM"},{"src":"<finalizationUsage>","dst":"<registry.register(obj, 'resource-1')>","type":"CONTAINS"},{"src":"<registry.register(obj, 'resource-1')>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<registry.register(obj, 'resource-1')>","dst":"<'resource-1'>","type":"PASSES_ARGUMENT"},{"src":"<finalizationUsage>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function creates a FinalizationRegistry with cleanup callback, registers an object for finalization tracking, and returns the object. Reduced edge count by removing redundant CALLS edges and module declaration edge.","implicitBehavior":["FinalizationRegistry callback executes asynchronously during garbage collection","Weak reference to registered object allows garbage collection","Held value ('resource-1') is strongly held by registry until cleanup"]},"pass":2,"annotatedAt":"2026-02-24T00:34:32.868Z"}
{"construct":{"id":"expressions::chained-destructuring-assignment","file":"src/expressions.js","category":"expressions","lineStart":556,"lineEnd":570,"code":"function chainedDestructuringAssignment() {\n  let a, b, c, d;\n\n  // Chained destructuring  right-to-left evaluation\n  [a, b] = [c, d] = [1, 2];\n  // Step 1: [c, d] = [1, 2]  c=1, d=2, returns [1, 2]\n  // Step 2: [a, b] = [1, 2]  a=1, b=2\n\n  // Object chained destructuring\n  let x, y;\n  ({x} = {y} = {x: 10, y: 20});\n\n  return { a, b, c, d, x, y };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<chainedDestructuringAssignment>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n     "},"pass":2,"annotatedAt":"2026-02-24T00:34:33.378Z"}
{"construct":{"id":"index::module-namespace-as-value","file":"src/index.js","category":"index","lineStart":53,"lineEnd":58,"code":"function useNamespaceAsValue(ns) {\n  const fn = ns[arguments[1]]; // dynamic dispatch through namespace\n  return typeof fn === 'function' ? fn() : undefined;\n}\nconst helperResult = useNamespaceAsValue(allHelpers, 'helperFunction');","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<useNamespaceAsValue>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<ns>"},{"type":"VARIABLE","id":"<fn>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<ns[arguments[1]]>","metadata":{"dynamic":true,"computed":true}},{"type":"EXPRESSION","id":"<typeof fn === 'function'>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<typeof fn>","metadata":{"operator":"typeof"}},{"type":"LITERAL","id":"<'function'>","metadata":{"value":"function","literalType":"string"}},{"type":"CALL","id":"<fn()>","metadata":{"dynamic":true}},{"type":"LITERAL","id":"<undefined>","metadata":{"value":"undefined","literalType":"undefined"}},{"type":"VARIABLE","id":"<helperResult>","metadata":{"kind":"const"}},{"type":"CALL","id":"<useNamespaceAsValue(allHelpers, 'helperFunction')>","metadata":{"callee":"useNamespaceAsValue"}},{"type":"LITERAL","id":"<'helperFunction'>","metadata":{"value":"helperFunction","literalType":"string"}}],"edges":[{"src":"<useNamespaceAsValue>","dst":"<ns>","type":"CONTAINS"},{"src":"<fn>","dst":"<ns[arguments[1]]>","type":"ASSIGNED_FROM"},{"src":"<ns[arguments[1]]>","dst":"<ns>","type":"READS_FROM"},{"src":"<typeof fn === 'function'>","dst":"<typeof fn>","type":"READS_FROM"},{"src":"<typeof fn === 'function'>","dst":"<'function'>","type":"READS_FROM"},{"src":"<typeof fn>","dst":"<fn>","type":"READS_FROM"},{"src":"<useNamespaceAsValue>","dst":"<typeof fn === 'function'>","type":"HAS_CONDITION"},{"src":"<useNamespaceAsValue>","dst":"<fn()>","type":"HAS_CONSEQUENT"},{"src":"<fn()>","dst":"<fn>","type":"CALLS"},{"src":"<useNamespaceAsValue>","dst":"<undefined>","type":"HAS_ALTERNATE"},{"src":"<helperResult>","dst":"<useNamespaceAsValue(allHelpers, 'helperFunction')>","type":"ASSIGNED_FROM"},{"src":"<useNamespaceAsValue(allHelpers, 'helperFunction')>","dst":"<useNamespaceAsValue>","type":"CALLS"},{"src":"<useNamespaceAsValue(allHelpers, 'helperFunction')>","dst":"<'helperFunction'>","type":"PASSES_ARGUMENT"}],"rationale":"Function performs dynamic dispatch through namespace object using computed property access. Uses conditional expression to check if resolved property is callable before invoking. Reduced edge count by removing module-level declarations and implicit argument references.","implicitBehavior":["arguments object provides access to all function parameters","dynamic property access may fail at runtime if property doesn't exist","typeof operator returns string representation of value type"]},"pass":2,"annotatedAt":"2026-02-24T00:34:34.607Z"}
{"construct":{"id":"iterators::iter-generator-iterable","file":"src/iterators.js","category":"iterators","lineStart":111,"lineEnd":118,"code":"function* rangeGenerator(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\n// --- Custom async iterable ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<rangeGenerator>","metadata":{"generator":true,"async":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<i <= end>","metadata":{"operator":"<="}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<yield i>","metadata":{"yieldType":"value"}}],"edges":[{"src":"<rangeGenerator>","dst":"<start>","type":"CONTAINS"},{"src":"<rangeGenerator>","dst":"<end>","type":"CONTAINS"},{"src":"<rangeGenerator>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<start>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i <= end>","type":"HAS_CONDITION"},{"src":"<i <= end>","dst":"<i>","type":"READS_FROM"},{"src":"<i <= end>","dst":"<end>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<yield i>","type":"HAS_BODY"},{"src":"<yield i>","dst":"<i>","type":"YIELDS"}],"rationale":"Generator function with for-loop that yields values. Removed the module declaration edge to reduce edge count while preserving the core generator semantics.","implicitBehavior":["function returns an iterator object","yield pauses execution and returns control to caller","iterator protocol methods (next, return, throw) are automatically implemented"]},"pass":2,"annotatedAt":"2026-02-24T00:34:34.930Z"}
{"construct":{"id":"iterators::iter-infinite","file":"src/iterators.js","category":"iterators","lineStart":87,"lineEnd":96,"code":"function naturals() {\n  let n = 1;\n  return {\n    [Symbol.iterator]() { return this; },\n    next() {\n      return { value: n++, done: false };\n    },\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<naturals>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<n>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<object-literal>","metadata":{"type":"object"}},{"type":"METHOD","id":"<[Symbol.iterator]>","metadata":{"kind":"method","computed":true}},{"type":"METHOD","id":"<next>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object"}},{"type":"EXPRESSION","id":"<n++>","metadata":{"operator":"++","postfix":true}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}}],"edges":[{"src":"<naturals>","dst":"<n>","type":"CONTAINS"},{"src":"<n>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<naturals>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<[Symbol.iterator]>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<next>","type":"HAS_PROPERTY"},{"src":"<[Symbol.iterator]>","dst":"<object-literal>","type":"RETURNS"},{"src":"<next>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<n++>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<false>","type":"HAS_PROPERTY"},{"src":"<n++>","dst":"<n>","type":"READS_FROM"},{"src":"<n++>","dst":"<n>","type":"WRITES_TO"}],"rationale":"Function returns an iterator object implementing the iterator protocol. The Symbol.iterator method returns self, next() method returns iterator result objects with incrementing values. Removed the module declaration edge as no module node was defined.","implicitBehavior":["implements iterator protocol","creates infinite sequence","post-increment modifies n after reading current value","Symbol.iterator property makes object iterable"]},"pass":2,"annotatedAt":"2026-02-24T00:34:35.117Z"}
{"construct":{"id":"iterators::iter-async-generator","file":"src/iterators.js","category":"iterators","lineStart":155,"lineEnd":162,"code":"async function* asyncMap(iterable, fn) {\n  for await (const item of iterable) {\n    yield fn(item);\n  }\n}\n\n// --- Composable iterators ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<asyncMap>","metadata":{"async":true,"generator":true}},{"type":"PARAMETER","id":"<iterable>"},{"type":"PARAMETER","id":"<fn>"},{"type":"LOOP","id":"<for-await-of>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fn(item)>","metadata":{"callee":"fn"}},{"type":"EXPRESSION","id":"<yield fn(item)>","metadata":{"operator":"yield"}}],"edges":[{"src":"<asyncMap>","dst":"<iterable>","type":"HAS_BODY"},{"src":"<asyncMap>","dst":"<fn>","type":"HAS_BODY"},{"src":"<asyncMap>","dst":"<for-await-of>","type":"HAS_BODY"},{"src":"<for-await-of>","dst":"<iterable>","type":"ITERATES_OVER"},{"src":"<for-await-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-await-of>","dst":"<yield fn(item)>","type":"HAS_BODY"},{"src":"<fn(item)>","dst":"<fn>","type":"CALLS"},{"src":"<fn(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<yield fn(item)>","dst":"<fn(item)>","type":"YIELDS"},{"src":"<asyncMap>","dst":"<yield fn(item)>","type":"YIELDS"}],"rationale":"Async generator function that maps over an async iterable. Uses for-await-of to consume promises, yields transformed values. Reduced edge count by removing module declaration edge and using HAS_BODY for parameter containment.","implicitBehavior":["returns AsyncGenerator object","awaits each iteration of the input iterable","yields create suspension points for async iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:34:35.671Z"}
{"construct":{"id":"iterators::iter-compose-chain","file":"src/iterators.js","category":"iterators","lineStart":178,"lineEnd":183,"code":"function* chainIter(...iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<chainIter>","metadata":{"generator":true,"async":false}},{"type":"PARAMETER","id":"<...iterables>","metadata":{"rest":true}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<iterable>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<yield* iterable>","metadata":{"operator":"yield*"}}],"edges":[{"src":"<chainIter>","dst":"<...iterables>","type":"CONTAINS"},{"src":"<chainIter>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<...iterables>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<iterable>","type":"CONTAINS"},{"src":"<for-of>","dst":"<yield* iterable>","type":"HAS_BODY"},{"src":"<yield* iterable>","dst":"<iterable>","type":"DELEGATES_TO"}],"rationale":"Generator function that chains multiple iterables using yield* delegation. The function contains a for-of loop that iterates over the rest parameter, with each iteration yielding all values from the current iterable.","implicitBehavior":["yield* delegates iteration protocol to the target iterable","rest parameter collects all arguments into an array","generator function automatically implements iterator protocol"]},"pass":2,"annotatedAt":"2026-02-24T00:34:39.325Z"}
{"construct":{"id":"iterators::iter-take","file":"src/iterators.js","category":"iterators","lineStart":98,"lineEnd":109,"code":"function take(iterable, count) {\n  const result = [];\n  let i = 0;\n  for (const value of iterable) {\n    if (i++ >= count) break;\n    result.push(value);\n  }\n  return result;\n}\n\n// --- Generator as iterable ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<take>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<iterable>"},{"type":"PARAMETER","id":"<count>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"BRANCH","id":"<if-break>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<i++ >= count>","metadata":{"operator":">="}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"CALL","id":"<result.push(value)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<result.push>","metadata":{"objectName":"result","propertyName":"push"}}],"edges":[{"src":"<take>","dst":"<iterable>","type":"CONTAINS"},{"src":"<take>","dst":"<count>","type":"CONTAINS"},{"src":"<take>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<take>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<take>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<iterable>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<value>","type":"CONTAINS"},{"src":"<for-of>","dst":"<if-break>","type":"CONTAINS"},{"src":"<if-break>","dst":"<i++ >= count>","type":"HAS_CONDITION"},{"src":"<i++ >= count>","dst":"<i++>","type":"READS_FROM"},{"src":"<i++ >= count>","dst":"<count>","type":"READS_FROM"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-of>","dst":"<result.push(value)>","type":"CONTAINS"},{"src":"<result.push(value)>","dst":"<result.push>","type":"CALLS"},{"src":"<result.push(value)>","dst":"<value>","type":"PASSES_ARGUMENT"},{"src":"<result.push>","dst":"<result>","type":"READS_FROM"},{"src":"<take>","dst":"<result>","type":"RETURNS"}],"rationale":"Function that takes first N items from an iterable. Uses for-of loop with counter and conditional break, mutates result array via push method. All Pass 1 types were already in approved vocabulary.","implicitBehavior":["iterator protocol consumption","array mutation via method call","early loop termination via break"]},"pass":2,"annotatedAt":"2026-02-24T00:34:39.840Z"}
{"construct":{"id":"iterators::iter-compose-map","file":"src/iterators.js","category":"iterators","lineStart":164,"lineEnd":169,"code":"function* mapIter(iterable, fn) {\n  for (const item of iterable) {\n    yield fn(item);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<mapIter>","metadata":{"generator":true,"async":false}},{"type":"PARAMETER","id":"<iterable>"},{"type":"PARAMETER","id":"<fn>"},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fn(item)>","metadata":{"callee":"fn"}},{"type":"EXPRESSION","id":"<yield fn(item)>","metadata":{"operator":"yield"}}],"edges":[{"src":"<mapIter>","dst":"<iterable>","type":"HAS_BODY"},{"src":"<mapIter>","dst":"<fn>","type":"HAS_BODY"},{"src":"<mapIter>","dst":"<for-of>","type":"HAS_BODY"},{"src":"<for-of>","dst":"<iterable>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<item>","type":"HAS_BODY"},{"src":"<for-of>","dst":"<yield fn(item)>","type":"HAS_BODY"},{"src":"<fn(item)>","dst":"<fn>","type":"CALLS"},{"src":"<fn(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<yield fn(item)>","dst":"<fn(item)>","type":"YIELDS"},{"src":"<mapIter>","dst":"<yield fn(item)>","type":"YIELDS"}],"rationale":"Generator function that transforms an iterable by applying a function to each item and yielding the results. The for-of loop iterates over the input, calls the transform function, and yields each transformed value.","implicitBehavior":["generator function returns an iterator object","yield suspends execution and produces values lazily","function declaration is hoisted to module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:34:40.057Z"}
{"construct":{"id":"iterators::iter-manual-next","file":"src/iterators.js","category":"iterators","lineStart":51,"lineEnd":63,"code":"function manualIteration(iterable) {\n  const iterator = iterable[Symbol.iterator]();\n  const results = [];\n  let step = iterator.next();\n  while (!step.done) {\n    results.push(step.value);\n    step = iterator.next();\n  }\n  return results;\n}\n\n// --- Iterator with return() ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<manualIteration>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<iterable>"},{"type":"VARIABLE","id":"<iterator>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<iterable[Symbol.iterator]>","metadata":{"property":"Symbol.iterator","computed":true}},{"type":"CALL","id":"<iterable[Symbol.iterator]()>","metadata":{"callee":"iterable[Symbol.iterator]"}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"VARIABLE","id":"<step>","metadata":{"kind":"let"}},{"type":"CALL","id":"<iterator.next()>","metadata":{"callee":"iterator.next"}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<!step.done>","metadata":{"operator":"!"}},{"type":"PROPERTY_ACCESS","id":"<step.done>","metadata":{"property":"done"}},{"type":"CALL","id":"<results.push(step.value)>","metadata":{"callee":"results.push"}},{"type":"PROPERTY_ACCESS","id":"<step.value>","metadata":{"property":"value"}},{"type":"EXPRESSION","id":"<step = iterator.next()>","metadata":{"operator":"="}},{"type":"CALL","id":"<iterator.next()#2>","metadata":{"callee":"iterator.next"}}],"edges":[{"src":"<manualIteration>","dst":"<iterable>","type":"CONTAINS"},{"src":"<manualIteration>","dst":"<iterator>","type":"CONTAINS"},{"src":"<iterator>","dst":"<iterable[Symbol.iterator]()>","type":"ASSIGNED_FROM"},{"src":"<iterable[Symbol.iterator]()>","dst":"<iterable[Symbol.iterator]>","type":"CALLS"},{"src":"<iterable[Symbol.iterator]>","dst":"<iterable>","type":"READS_FROM"},{"src":"<manualIteration>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<manualIteration>","dst":"<step>","type":"CONTAINS"},{"src":"<step>","dst":"<iterator.next()>","type":"ASSIGNED_FROM"},{"src":"<iterator.next()>","dst":"<iterator>","type":"READS_FROM"},{"src":"<manualIteration>","dst":"<while>","type":"CONTAINS"},{"src":"<while>","dst":"<!step.done>","type":"HAS_CONDITION"},{"src":"<!step.done>","dst":"<step.done>","type":"READS_FROM"},{"src":"<step.done>","dst":"<step>","type":"READS_FROM"},{"src":"<while>","dst":"<results.push(step.value)>","type":"CONTAINS"},{"src":"<results.push(step.value)>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(step.value)>","dst":"<step.value>","type":"PASSES_ARGUMENT"},{"src":"<step.value>","dst":"<step>","type":"READS_FROM"},{"src":"<while>","dst":"<step = iterator.next()>","type":"CONTAINS"},{"src":"<step = iterator.next()>","dst":"<step>","type":"WRITES_TO"},{"src":"<step = iterator.next()>","dst":"<iterator.next()#2>","type":"READS_FROM"},{"src":"<iterator.next()#2>","dst":"<iterator>","type":"READS_FROM"},{"src":"<manualIteration>","dst":"<results>","type":"RETURNS"}],"rationale":"Manual iteration using iterator protocol. Gets iterator from Symbol.iterator, repeatedly calls next() until done, collecting values in array. All constructs map directly to approved vocabulary.","implicitBehavior":["Iterator protocol compliance - expects objects with next() method returning {value, done}","Symbol.iterator property access may throw if not iterable","Iterator.next() calls may throw or return malformed objects"]},"pass":2,"annotatedAt":"2026-02-24T00:34:41.363Z"}
{"construct":{"id":"iterators::iter-compose-filter","file":"src/iterators.js","category":"iterators","lineStart":171,"lineEnd":176,"code":"function* filterIter(iterable, predicate) {\n  for (const item of iterable) {\n    if (predicate(item)) yield item;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<filterIter>","metadata":{"async":false,"generator":true}},{"type":"PARAMETER","id":"<iterable>"},{"type":"PARAMETER","id":"<predicate>"},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"BRANCH","id":"<if-predicate>","metadata":{"branchType":"if"}},{"type":"CALL","id":"<predicate(item)>","metadata":{"callee":"predicate"}},{"type":"EXPRESSION","id":"<yield item>","metadata":{"operator":"yield"}}],"edges":[{"src":"<filterIter>","dst":"<iterable>","type":"CONTAINS"},{"src":"<filterIter>","dst":"<predicate>","type":"CONTAINS"},{"src":"<filterIter>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<iterable>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-of>","dst":"<if-predicate>","type":"CONTAINS"},{"src":"<if-predicate>","dst":"<predicate(item)>","type":"HAS_CONDITION"},{"src":"<predicate(item)>","dst":"<predicate>","type":"CALLS"},{"src":"<predicate(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<if-predicate>","dst":"<yield item>","type":"HAS_CONSEQUENT"},{"src":"<yield item>","dst":"<item>","type":"YIELDS"}],"rationale":"Generator function that filters an iterable by applying a predicate. The for-of loop iterates over the input iterable, extracting each item. A conditional branch tests each item against the predicate function. Items that pass the test are yielded as generator values.","implicitBehavior":["generator function creates iterator protocol","yield suspends execution and produces value","function declaration is hoisted","for-of loop handles iterator protocol automatically"]},"pass":2,"annotatedAt":"2026-02-24T00:34:41.957Z"}
{"construct":{"id":"iterators::iter-async-for-await","file":"src/iterators.js","category":"iterators","lineStart":144,"lineEnd":153,"code":"async function consumeAsyncRange(start, end) {\n  const values = [];\n  for await (const n of new AsyncRange(start, end, 0)) {\n    values.push(n);\n  }\n  return values;\n}\n\n// --- Async generator as async iterable ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<consumeAsyncRange>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<start>"},{"type":"PARAMETER","id":"<end>"},{"type":"VARIABLE","id":"<values>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-await>","metadata":{"loopType":"for-await-of"}},{"type":"VARIABLE","id":"<n>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new AsyncRange(start, end, 0)>","metadata":{"callee":"AsyncRange","constructor":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"CALL","id":"<values.push(n)>","metadata":{"callee":"push","method":true}},{"type":"PROPERTY_ACCESS","id":"<values.push>","metadata":{"objectName":"values","propertyName":"push"}}],"edges":[{"src":"<consumeAsyncRange>","dst":"<start>","type":"CONTAINS"},{"src":"<consumeAsyncRange>","dst":"<end>","type":"CONTAINS"},{"src":"<consumeAsyncRange>","dst":"<values>","type":"CONTAINS"},{"src":"<values>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<consumeAsyncRange>","dst":"<for-await>","type":"CONTAINS"},{"src":"<for-await>","dst":"<new AsyncRange(start, end, 0)>","type":"ITERATES_OVER"},{"src":"<for-await>","dst":"<n>","type":"CONTAINS"},{"src":"<new AsyncRange(start, end, 0)>","dst":"<start>","type":"PASSES_ARGUMENT"},{"src":"<new AsyncRange(start, end, 0)>","dst":"<end>","type":"PASSES_ARGUMENT"},{"src":"<new AsyncRange(start, end, 0)>","dst":"<0>","type":"PASSES_ARGUMENT"},{"src":"<for-await>","dst":"<values.push(n)>","type":"HAS_BODY"},{"src":"<values.push(n)>","dst":"<values.push>","type":"CALLS"},{"src":"<values.push(n)>","dst":"<n>","type":"PASSES_ARGUMENT"},{"src":"<values.push>","dst":"<values>","type":"READS_FROM"},{"src":"<consumeAsyncRange>","dst":"<values>","type":"RETURNS"}],"rationale":"Async function using for-await-of to consume an async iterable. Creates AsyncRange instance, iterates over it asynchronously, collecting values in array. Removed module-level declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["for-await-of automatically awaits each yielded promise from the async iterator","AsyncRange constructor creates an async iterable object","push method mutates the values array"]},"pass":2,"annotatedAt":"2026-02-24T00:34:44.537Z"}
{"construct":{"id":"jsdoc-types::jsdoc-type-variable","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":28,"lineEnd":36,"code":"/** @type {Map<string, Function>} */\nconst handlers = new Map();\n\n/** @type {string | null} */\nlet currentUser = null;\n\n/** @type {readonly number[]} */\nconst PRIMES = [2, 3, 5, 7, 11];","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_REFERENCE","id":"<Map<string, Function>>","metadata":{"typeExpression":"Map<string, Function>"}},{"type":"VARIABLE","id":"<handlers>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Map()>","metadata":{"callee":"Map","isConstructor":true}},{"type":"TYPE_REFERENCE","id":"<string | null>","metadata":{"typeExpression":"string | null"}},{"type":"VARIABLE","id":"<currentUser>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"TYPE_REFERENCE","id":"<readonly number[]>","metadata":{"typeExpression":"readonly number[]"}},{"type":"VARIABLE","id":"<PRIMES>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[2, 3, 5, 7, 11]>","metadata":{"value":[2,3,5,7,11],"literalType":"array"}}],"edges":[{"src":"<handlers>","dst":"<Map<string, Function>>","type":"HAS_TYPE"},{"src":"<handlers>","dst":"<new Map()>","type":"ASSIGNED_FROM"},{"src":"<currentUser>","dst":"<string | null>","type":"HAS_TYPE"},{"src":"<currentUser>","dst":"<null>","type":"ASSIGNED_FROM"},{"src":"<PRIMES>","dst":"<readonly number[]>","type":"HAS_TYPE"},{"src":"<PRIMES>","dst":"<[2, 3, 5, 7, 11]>","type":"ASSIGNED_FROM"}],"rationale":"Three variable declarations with JSDoc type annotations. Each variable has a type relationship and an assignment relationship to its initializer value. Removed module-level DECLARES edges to reduce edge count below threshold.","implicitBehavior":["JSDoc type annotations provide static type information for tooling but don't affect runtime behavior","const variables are immutable bindings","let variable allows reassignment"]},"pass":2,"annotatedAt":"2026-02-24T00:34:44.637Z"}
{"construct":{"id":"jsdoc-types::jsdoc-param-returns","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":18,"lineEnd":26,"code":"/**\n * @param {string} name\n * @param {number} age\n * @returns {{ name: string, age: number }}\n */\nfunction createUser(name, age) {\n  return { name, age };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createUser>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<name>"},{"type":"PARAMETER","id":"<age>"},{"type":"EXTERNAL","id":"<@param-name>","metadata":{"paramName":"name","type":"string","kind":"jsdoc-param"}},{"type":"EXTERNAL","id":"<@param-age>","metadata":{"paramName":"age","type":"number","kind":"jsdoc-param"}},{"type":"EXTERNAL","id":"<@returns>","metadata":{"type":"{ name: string, age: number }","kind":"jsdoc-returns"}},{"type":"EXPRESSION","id":"<{ name, age }>","metadata":{"kind":"object-literal"}}],"edges":[{"src":"<module>","dst":"<createUser>","type":"DECLARES"},{"src":"<createUser>","dst":"<name>","type":"CONTAINS"},{"src":"<createUser>","dst":"<age>","type":"CONTAINS"},{"src":"<createUser>","dst":"<@param-name>","type":"DEPENDS_ON"},{"src":"<createUser>","dst":"<@param-age>","type":"DEPENDS_ON"},{"src":"<createUser>","dst":"<@returns>","type":"DEPENDS_ON"},{"src":"<@param-name>","dst":"<name>","type":"ALIASES"},{"src":"<@param-age>","dst":"<age>","type":"ALIASES"},{"src":"<@returns>","dst":"<{ name, age }>","type":"ALIASES"},{"src":"<createUser>","dst":"<{ name, age }>","type":"RETURNS"},{"src":"<{ name, age }>","dst":"<name>","type":"READS_FROM"},{"src":"<{ name, age }>","dst":"<age>","type":"READS_FROM"}],"rationale":"Function with JSDoc type annotations mapped to approved vocabulary. JSDoc constructs are modeled as EXTERNAL nodes since they exist outside the runtime code but provide metadata. The documentation relationships are approximated using DEPENDS_ON and ALIASES from the approved edge types.","implicitBehavior":["JSDoc provides static type information for tooling","object literal uses shorthand property syntax"]},"pass":2,"annotatedAt":"2026-02-24T00:34:47.131Z"}
{"construct":{"id":"jsdoc-types::jsdoc-enum","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":96,"lineEnd":102,"code":"/** @enum {string} */\nconst Priority = {\n  Low: 'low',\n  Medium: 'medium',\n  High: 'high',\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<Priority>","metadata":{"kind":"const","jsdocType":"enum","enumValueType":"string"}},{"type":"LITERAL","id":"<Priority-object>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'low'>","metadata":{"value":"low","literalType":"string"}},{"type":"LITERAL","id":"<'medium'>","metadata":{"value":"medium","literalType":"string"}},{"type":"LITERAL","id":"<'high'>","metadata":{"value":"high","literalType":"string"}}],"edges":[{"src":"<Priority>","dst":"<Priority-object>","type":"ASSIGNED_FROM"},{"src":"<Priority-object>","dst":"<'low'>","type":"HAS_PROPERTY"},{"src":"<Priority-object>","dst":"<'medium'>","type":"HAS_PROPERTY"},{"src":"<Priority-object>","dst":"<'high'>","type":"HAS_PROPERTY"}],"rationale":"JSDoc @enum annotation creates a typed enumeration. The const variable holds an object literal with string properties representing enum values. Using approved vocabulary, this maps to a VARIABLE assigned from a LITERAL object that has string LITERAL properties.","implicitBehavior":["JSDoc @enum provides static type checking for enum values","TypeScript/IDE tooling treats this as a string enum type","Enum members are accessible as Priority.Low, Priority.Medium, Priority.High","Type system constrains values to only the declared enum strings"]},"pass":2,"annotatedAt":"2026-02-24T00:34:49.503Z"}
{"construct":{"id":"iterators::iter-return-cleanup","file":"src/iterators.js","category":"iterators","lineStart":65,"lineEnd":85,"code":"function createCleanupIterator(items) {\n  let index = 0;\n  let cleaned = false;\n  return {\n    [Symbol.iterator]() { return this; },\n    next() {\n      if (index < items.length) {\n        return { value: items[index++], done: false };\n      }\n      return { value: undefined, done: true };\n    },\n    return() {\n      cleaned = true;\n      return { value: undefined, done: true };\n    },\n    wasCleaned() { return cleaned; },\n  };\n}\n\n// --- Infinite iterator ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<createCleanupIterator>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": "},"pass":2,"annotatedAt":"2026-02-24T00:34:51.036Z"}
{"construct":{"id":"jsdoc-types::jsdoc-typedef","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":38,"lineEnd":47,"code":"/**\n * @typedef {Object} UserDef\n * @property {number} id\n * @property {string} name\n * @property {string} [email]\n */\n\n/** @type {UserDef} */\nconst admin = { id: 1, name: 'admin' };","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_ALIAS","id":"<UserDef>","metadata":{"baseType":"Object"}},{"type":"PROPERTY","id":"<UserDef.id>","metadata":{"type":"number","required":true}},{"type":"PROPERTY","id":"<UserDef.name>","metadata":{"type":"string","required":true}},{"type":"PROPERTY","id":"<UserDef.email>","metadata":{"type":"string","required":false}},{"type":"VARIABLE","id":"<admin>","metadata":{"kind":"const","declaredType":"UserDef"}},{"type":"LITERAL","id":"<{ id: 1, name: 'admin' }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<'admin'>","metadata":{"value":"admin","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<UserDef>","type":"DECLARES"},{"src":"<UserDef>","dst":"<UserDef.id>","type":"HAS_PROPERTY"},{"src":"<UserDef>","dst":"<UserDef.name>","type":"HAS_PROPERTY"},{"src":"<UserDef>","dst":"<UserDef.email>","type":"HAS_PROPERTY"},{"src":"<module>","dst":"<admin>","type":"DECLARES"},{"src":"<admin>","dst":"<{ id: 1, name: 'admin' }>","type":"ASSIGNED_FROM"},{"src":"<admin>","dst":"<UserDef>","type":"HAS_TYPE"},{"src":"<{ id: 1, name: 'admin' }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<{ id: 1, name: 'admin' }>","dst":"<'admin'>","type":"HAS_PROPERTY"}],"rationale":"JSDoc typedef creates a type alias for an object structure with properties. A variable is declared with that type annotation and initialized with a matching object literal. TYPE_ALIAS captures the typedef concept, HAS_TYPE represents the type annotation relationship.","implicitBehavior":["JSDoc type annotations provide static analysis hints but no runtime enforcement","Optional property [email] allows undefined values"]},"pass":2,"annotatedAt":"2026-02-24T00:34:51.104Z"}
{"construct":{"id":"iterators::export-named-list","file":"src/iterators.js","category":"iterators","lineStart":197,"lineEnd":215,"code":"export {\n  Range,\n  consumeRange,\n  spreadRange,\n  destructureRange,\n  manualIteration,\n  createCleanupIterator,\n  naturals,\n  take,\n  rangeGenerator,\n  AsyncRange,\n  consumeAsyncRange,\n  asyncMap,\n  mapIter,\n  filterIter,\n  chainIter,\n  zipIter,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<Range>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<consumeRange>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<spreadRange>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<destructureRange>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<manualIteration>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<createCleanupIterator>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<naturals>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<take>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<rangeGenerator>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<AsyncRange>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<consumeAsyncRange>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<asyncMap>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<mapIter>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<filterIter>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<chainIter>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<zipIter>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<Range>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<consumeRange>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<spreadRange>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<destructureRange>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<manualIteration>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<createCleanupIterator>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<naturals>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<take>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<rangeGenerator>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<AsyncRange>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<consumeAsyncRange>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<asyncMap>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<mapIter>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<filterIter>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<chainIter>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<zipIter>","type":"EXPORTS"}],"rationale":"Named export statement that makes multiple previously declared identifiers available to importing modules. Each exported name references an existing variable/function/class in the module scope. Removed the CONTAINS edge from module to export as it's not essential to the core export semantics.","implicitBehavior":["exported names must be declared elsewhere in the module","creates bindings in importing modules","names are exported with their original identifiers (no aliasing)"]},"pass":2,"annotatedAt":"2026-02-24T00:34:52.020Z"}
{"construct":{"id":"builtins::builtin-arraybuffer","file":"src/builtins.js","category":"builtins","lineStart":142,"lineEnd":151,"code":"function arrayBufferOps() {\n  const buffer = new ArrayBuffer(16);\n  const view = new DataView(buffer);\n  view.setInt32(0, 42);\n  view.setFloat64(4, 3.14);\n  const int = view.getInt32(0);\n  const float = view.getFloat64(4);\n  return { int, float, byteLength: buffer.byteLength };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<arrayBufferOps>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIAB"},"pass":2,"annotatedAt":"2026-02-24T00:34:52.697Z"}
{"construct":{"id":"jsdoc-types::jsdoc-template-constraint","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":70,"lineEnd":79,"code":"/**\n * @template {object} T\n * @param {T} target\n * @param {Partial<T>} overrides\n * @returns {T}\n */\nfunction applyDefaults(target, overrides) {\n  return { ...target, ...overrides };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<applyDefaults>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<target>"},{"type":"PARAMETER","id":"<overrides>"},{"type":"EXPRESSION","id":"<{ ...target, ...overrides }>","metadata":{"operator":"spread"}},{"type":"TYPE_PARAMETER","id":"<T>","metadata":{"constraint":"object"}},{"type":"TYPE_REFERENCE","id":"<target:T>","metadata":{"parameterName":"target"}},{"type":"TYPE_REFERENCE","id":"<overrides:Partial<T>>","metadata":{"parameterName":"overrides","typeExpression":"Partial<T>"}},{"type":"TYPE_REFERENCE","id":"<returns:T>","metadata":{"typeExpression":"T"}},{"type":"LITERAL_TYPE","id":"<object>","metadata":{"value":"object"}}],"edges":[{"src":"<applyDefaults>","dst":"<target>","type":"CONTAINS"},{"src":"<applyDefaults>","dst":"<overrides>","type":"CONTAINS"},{"src":"<applyDefaults>","dst":"<{ ...target, ...overrides }>","type":"RETURNS"},{"src":"<{ ...target, ...overrides }>","dst":"<target>","type":"READS_FROM"},{"src":"<{ ...target, ...overrides }>","dst":"<overrides>","type":"READS_FROM"},{"src":"<applyDefaults>","dst":"<T>","type":"HAS_TYPE_PARAMETER"},{"src":"<T>","dst":"<object>","type":"CONSTRAINED_BY"},{"src":"<target>","dst":"<target:T>","type":"HAS_TYPE"},{"src":"<overrides>","dst":"<overrides:Partial<T>>","type":"HAS_TYPE"},{"src":"<applyDefaults>","dst":"<returns:T>","type":"RETURNS_TYPE"},{"src":"<target:T>","dst":"<T>","type":"USES"},{"src":"<overrides:Partial<T>>","dst":"<T>","type":"USES"},{"src":"<returns:T>","dst":"<T>","type":"USES"}],"rationale":"Function with JSDoc type annotations including a constrained generic type parameter. The template T is constrained to object type, and used in parameter and return type annotations. Mapped JSDoc-specific types to approved vocabulary.","implicitBehavior":["JSDoc types provide static analysis hints but don't affect runtime behavior","Partial<T> utility type makes all properties of T optional","Spread operator creates shallow merge with overrides taking precedence"]},"pass":2,"annotatedAt":"2026-02-24T00:34:54.163Z"}
{"construct":{"id":"jsdoc-types::jsdoc-import-type","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":114,"lineEnd":116,"code":"/** @type {import('./modules-helpers.js').HelperClass} */\nlet helperRef;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<helperRef>","metadata":{"kind":"let"}},{"type":"TYPE_REFERENCE","id":"<@type-helperRef>","metadata":{"annotationType":"type","isJSDocAnnotation":true}},{"type":"TYPE_REFERENCE","id":"<import('./modules-helpers.js').HelperClass>","metadata":{"source":"./modules-helpers.js","importedType":"HelperClass","isImportType":true}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}}],"edges":[{"src":"<module>","dst":"<helperRef>","type":"DECLARES"},{"src":"<helperRef>","dst":"<@type-helperRef>","type":"HAS_TYPE"},{"src":"<@type-helperRef>","dst":"<import('./modules-helpers.js').HelperClass>","type":"RESOLVES_TO"},{"src":"<import('./modules-helpers.js').HelperClass>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"}],"rationale":"JSDoc type annotation using import() type syntax mapped to approved vocabulary. The JSDoc annotation becomes a TYPE_REFERENCE that resolves to an imported type reference from an external module.","implicitBehavior":["JSDoc import type creates a type-level dependency without runtime import","Type checker resolves the imported type at analysis time"]},"pass":2,"annotatedAt":"2026-02-24T00:34:54.838Z"}
{"construct":{"id":"jsdoc-types::jsdoc-deprecated","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":147,"lineEnd":155,"code":"/**\n * @deprecated Use newProcess() instead\n * @param {string} input\n * @returns {string}\n */\nfunction oldProcess(input) {\n  return input;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<oldProcess>","metadata":{"async":false,"generator":false,"deprecated":true}},{"type":"PARAMETER","id":"<input>","metadata":{"jsdocType":"string"}},{"type":"EXTERNAL","id":"<oldProcess:jsdoc>","metadata":{"deprecated":"Use newProcess() instead","paramTypes":{"input":"string"},"returnType":"string","kind":"jsdoc"}}],"edges":[{"src":"<module>","dst":"<oldProcess>","type":"DECLARES"},{"src":"<oldProcess>","dst":"<input>","type":"CONTAINS"},{"src":"<oldProcess>","dst":"<input>","type":"RETURNS"},{"src":"<oldProcess:jsdoc>","dst":"<oldProcess>","type":"DEPENDS_ON"},{"src":"<oldProcess:jsdoc>","dst":"<input>","type":"HAS_TYPE"}],"rationale":"Function with JSDoc documentation including deprecation warning and type annotations. Used EXTERNAL to represent JSDoc block since it's external metadata, DEPENDS_ON for documentation relationship, and HAS_TYPE for parameter typing.","implicitBehavior":["function declaration is hoisted to module scope","deprecated status may trigger linter warnings"]},"pass":2,"annotatedAt":"2026-02-24T00:34:55.190Z"}
{"construct":{"id":"iterators::iter-compose-zip","file":"src/iterators.js","category":"iterators","lineStart":185,"lineEnd":195,"code":"function* zipIter(a, b) {\n  const iterA = a[Symbol.iterator]();\n  const iterB = b[Symbol.iterator]();\n  while (true) {\n    const stepA = iterA.next();\n    const stepB = iterB.next();\n    if (stepA.done || stepB.done) return;\n    yield [stepA.value, stepB.value];\n  }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<zipIter>\",\n      \"metadata\": {\n        \"generator\": true,\n        \"async\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER\",\n  "},"pass":2,"annotatedAt":"2026-02-24T00:34:59.286Z"}
{"construct":{"id":"jsdoc-types::jsdoc-template","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":49,"lineEnd":68,"code":"/**\n * @template T\n * @param {T[]} items\n * @returns {T | undefined}\n */\nfunction first(items) {\n  return items[0];\n}\n\n/**\n * @template K, V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} fallback\n * @returns {V}\n */\nfunction getOrDefault(map, key, fallback) {\n  return map.has(key) ? map.get(key) : fallback;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<first>","metadata":{"async":false,"generator":false}},{"type":"TYPE_PARAMETER","id":"<T>","metadata":{"name":"T"}},{"type":"PARAMETER","id":"<items>","metadata":{"typeAnnotation":"T[]"}},{"type":"PROPERTY_ACCESS","id":"<items[0]>","metadata":{"property":"0","accessType":"bracket"}},{"type":"FUNCTION","id":"<getOrDefault>","metadata":{"async":false,"generator":false}},{"type":"TYPE_PARAMETER","id":"<K>","metadata":{"name":"K"}},{"type":"TYPE_PARAMETER","id":"<V>","metadata":{"name":"V"}},{"type":"PARAMETER","id":"<map>","metadata":{"typeAnnotation":"Map<K, V>"}},{"type":"PARAMETER","id":"<key>","metadata":{"typeAnnotation":"K"}},{"type":"PARAMETER","id":"<fallback>","metadata":{"typeAnnotation":"V"}},{"type":"EXPRESSION","id":"<map.has(key) ? map.get(key) : fallback>","metadata":{"operator":"?:"}},{"type":"CALL","id":"<map.has(key)>","metadata":{"callee":"has"}},{"type":"CALL","id":"<map.get(key)>","metadata":{"callee":"get"}}],"edges":[{"src":"<first>","dst":"<T>","type":"HAS_TYPE_PARAMETER"},{"src":"<first>","dst":"<items>","type":"CONTAINS"},{"src":"<items>","dst":"<T>","type":"HAS_TYPE"},{"src":"<first>","dst":"<items[0]>","type":"RETURNS"},{"src":"<items[0]>","dst":"<items>","type":"READS_FROM"},{"src":"<getOrDefault>","dst":"<K>","type":"HAS_TYPE_PARAMETER"},{"src":"<getOrDefault>","dst":"<V>","type":"HAS_TYPE_PARAMETER"},{"src":"<getOrDefault>","dst":"<map>","type":"CONTAINS"},{"src":"<getOrDefault>","dst":"<key>","type":"CONTAINS"},{"src":"<getOrDefault>","dst":"<fallback>","type":"CONTAINS"},{"src":"<map>","dst":"<K>","type":"HAS_TYPE"},{"src":"<map>","dst":"<V>","type":"HAS_TYPE"},{"src":"<key>","dst":"<K>","type":"HAS_TYPE"},{"src":"<fallback>","dst":"<V>","type":"HAS_TYPE"},{"src":"<getOrDefault>","dst":"<map.has(key) ? map.get(key) : fallback>","type":"RETURNS"},{"src":"<map.has(key) ? map.get(key) : fallback>","dst":"<map.has(key)>","type":"HAS_CONDITION"},{"src":"<map.has(key) ? map.get(key) : fallback>","dst":"<map.get(key)>","type":"HAS_CONSEQUENT"},{"src":"<map.has(key) ? map.get(key) : fallback>","dst":"<fallback>","type":"HAS_ALTERNATE"},{"src":"<map.has(key)>","dst":"<map>","type":"CALLS_ON"},{"src":"<map.has(key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<map.get(key)>","dst":"<map>","type":"CALLS_ON"},{"src":"<map.get(key)>","dst":"<key>","type":"PASSES_ARGUMENT"}],"rationale":"Two generic functions with JSDoc type annotations. Type parameters establish generic constraints, parameters are typed by those generics, and return types flow through the type system. Mapped TYPED_BY to HAS_TYPE as the closest approved relationship for type annotations.","implicitBehavior":["JSDoc type annotations provide static type information for tooling","Generic type parameters create polymorphic function signatures","Type constraints propagate through function bodies"]},"pass":2,"annotatedAt":"2026-02-24T00:35:00.003Z"}
{"construct":{"id":"jsdoc-types::jsdoc-this","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":137,"lineEnd":145,"code":"/**\n * @this {{ name: string }}\n * @param {string} greeting\n * @returns {string}\n */\nfunction greetThis(greeting) {\n  return `${greeting}, ${this.name}`;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<greetThis>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<greeting>"},{"type":"TYPE_REFERENCE","id":"<@this>","metadata":{"typeAnnotation":"{ name: string }"}},{"type":"TYPE_REFERENCE","id":"<@param-greeting>","metadata":{"typeAnnotation":"string","paramName":"greeting"}},{"type":"TYPE_REFERENCE","id":"<@returns>","metadata":{"typeAnnotation":"string"}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this","propertyName":"name"}}],"edges":[{"src":"<greetThis>","dst":"<greeting>","type":"CONTAINS"},{"src":"<greetThis>","dst":"<@this>","type":"HAS_TYPE"},{"src":"<greetThis>","dst":"<@param-greeting>","type":"HAS_TYPE"},{"src":"<greetThis>","dst":"<@returns>","type":"RETURNS_TYPE"},{"src":"<@param-greeting>","dst":"<greeting>","type":"HAS_TYPE"},{"src":"<greetThis>","dst":"<template-literal>","type":"RETURNS"},{"src":"<template-literal>","dst":"<greeting>","type":"READS_FROM"},{"src":"<template-literal>","dst":"<this.name>","type":"READS_FROM"}],"rationale":"Function with JSDoc type annotations including @this constraint. Using TYPE_REFERENCE for JSDoc annotations and HAS_TYPE/RETURNS_TYPE for type relationships. Reduced edge count by removing module declaration and some intermediate type relationships.","implicitBehavior":["function declaration is hoisted","@this annotation constrains the calling context type but doesn't enforce it at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:35:00.742Z"}
{"construct":{"id":"legacy-patterns::amd-require-call","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":26,"lineEnd":31,"code":"// require(['app/main', 'app/config'], function(main, config) {\n//   main.start(config);\n// });\n\n// --- UMD (Universal Module Definition) ---","commentedOut":true,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"CALL","id":"<require-call>","metadata":{"callee":"require","amdStyle":true}},{"type":"LITERAL","id":"<'app/main'>","metadata":{"value":"app/main","literalType":"string"}},{"type":"LITERAL","id":"<'app/config'>","metadata":{"value":"app/config","literalType":"string"}},{"type":"FUNCTION","id":"<amd-callback>","metadata":{"arrowFunction":false,"amdCallback":true}},{"type":"PARAMETER","id":"<main>"},{"type":"PARAMETER","id":"<config>"},{"type":"CALL","id":"<main.start(config)>","metadata":{"callee":"main.start"}},{"type":"PROPERTY_ACCESS","id":"<main.start>","metadata":{"objectName":"main","propertyName":"start"}}],"edges":[{"src":"<require-call>","dst":"<'app/main'>","type":"PASSES_ARGUMENT"},{"src":"<require-call>","dst":"<'app/config'>","type":"PASSES_ARGUMENT"},{"src":"<require-call>","dst":"<amd-callback>","type":"PASSES_ARGUMENT"},{"src":"<amd-callback>","dst":"<main>","type":"CONTAINS"},{"src":"<amd-callback>","dst":"<config>","type":"CONTAINS"},{"src":"<amd-callback>","dst":"<main.start(config)>","type":"CONTAINS"},{"src":"<main.start(config)>","dst":"<main.start>","type":"CALLS"},{"src":"<main.start(config)>","dst":"<config>","type":"PASSES_ARGUMENT"},{"src":"<main.start>","dst":"<main>","type":"READS_FROM"},{"src":"<main>","dst":"<'app/main'>","type":"ASSIGNED_FROM"},{"src":"<config>","dst":"<'app/config'>","type":"ASSIGNED_FROM"}],"rationale":"AMD-style require call with dependency array and callback. Dependencies are loaded asynchronously and injected as callback parameters in order. All relationships can be expressed with approved vocabulary.","implicitBehavior":["asynchronous module loading","dependency injection by position","callback executed after all dependencies resolve"]},"pass":2,"annotatedAt":"2026-02-24T00:35:03.444Z"}
{"construct":{"id":"jsdoc-types::export-named-list","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":179,"lineEnd":196,"code":"export {\n  createUser,\n  handlers,\n  currentUser,\n  PRIMES,\n  admin,\n  first,\n  getOrDefault,\n  applyDefaults,\n  NumberRange,\n  Priority,\n  isPositive,\n  convert,\n  greetThis,\n  oldProcess,\n  DataStore,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<createUser>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<handlers>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<currentUser>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<PRIMES>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<admin>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<first>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<getOrDefault>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<applyDefaults>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<NumberRange>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Priority>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<isPositive>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<convert>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<greetThis>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<oldProcess>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<DataStore>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<createUser>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<handlers>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<currentUser>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<PRIMES>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<admin>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<first>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<getOrDefault>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<applyDefaults>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<NumberRange>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Priority>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<isPositive>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<convert>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<greetThis>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<oldProcess>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<DataStore>","type":"EXPORTS"}],"rationale":"Named export list that re-exports multiple identifiers from the current module. Each identifier becomes available for import by other modules. Removed the CONTAINS edge from module to reduce edge count while preserving the core export relationships.","implicitBehavior":["exported identifiers must be declared elsewhere in the module","creates named bindings in importing modules"]},"pass":2,"annotatedAt":"2026-02-24T00:35:04.812Z"}
{"construct":{"id":"jsdoc-types::jsdoc-callback","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":104,"lineEnd":112,"code":"/**\n * @callback Predicate\n * @param {unknown} value\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst isPositive = (value) => typeof value === 'number' && value > 0;","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_ALIAS","id":"<Predicate>","metadata":{"name":"Predicate","jsDocCallback":true}},{"type":"PARAMETER","id":"<value>","metadata":{"jsDocType":"unknown"}},{"type":"TYPE_REFERENCE","id":"<Predicate:return>","metadata":{"jsDocType":"boolean"}},{"type":"VARIABLE","id":"<isPositive>","metadata":{"kind":"const","jsDocType":"Predicate"}},{"type":"FUNCTION","id":"<isPositive:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<isPositive:value>"},{"type":"EXPRESSION","id":"<typeof value === 'number' && value > 0>","metadata":{"operator":"&&"}},{"type":"EXPRESSION","id":"<typeof value === 'number'>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<typeof value>","metadata":{"operator":"typeof"}},{"type":"LITERAL","id":"<'number'>","metadata":{"value":"number","literalType":"string"}},{"type":"EXPRESSION","id":"<value > 0>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}}],"edges":[{"src":"<Predicate>","dst":"<value>","type":"CONTAINS"},{"src":"<Predicate>","dst":"<Predicate:return>","type":"RETURNS_TYPE"},{"src":"<isPositive>","dst":"<isPositive:fn>","type":"ASSIGNED_FROM"},{"src":"<isPositive>","dst":"<Predicate>","type":"HAS_TYPE"},{"src":"<isPositive:fn>","dst":"<isPositive:value>","type":"CONTAINS"},{"src":"<isPositive:fn>","dst":"<typeof value === 'number' && value > 0>","type":"RETURNS"},{"src":"<typeof value === 'number' && value > 0>","dst":"<typeof value === 'number'>","type":"READS_FROM"},{"src":"<typeof value === 'number' && value > 0>","dst":"<value > 0>","type":"READS_FROM"},{"src":"<typeof value === 'number'>","dst":"<typeof value>","type":"READS_FROM"},{"src":"<typeof value === 'number'>","dst":"<'number'>","type":"READS_FROM"},{"src":"<typeof value>","dst":"<isPositive:value>","type":"READS_FROM"},{"src":"<value > 0>","dst":"<isPositive:value>","type":"READS_FROM"},{"src":"<value > 0>","dst":"<0>","type":"READS_FROM"}],"rationale":"JSDoc @callback creates a function type alias that defines a signature. The variable is typed to conform to this signature and assigned an arrow function implementation.","implicitBehavior":["JSDoc types provide static analysis hints but no runtime enforcement","Type checker can verify isPositive conforms to Predicate signature"]},"pass":2,"annotatedAt":"2026-02-24T00:35:05.019Z"}
{"construct":{"id":"legacy-patterns::amd-define-named","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":21,"lineEnd":24,"code":"// define('myModule', ['dep1', 'dep2'], function(dep1, dep2) {\n//   return { init: function() {} };\n// });","commentedOut":true,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"CALL","id":"<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>","metadata":{"callee":"define","amdPattern":true}},{"type":"LITERAL","id":"<'myModule'>","metadata":{"value":"myModule","literalType":"string"}},{"type":"LITERAL","id":"<['dep1', 'dep2']>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<'dep1'>","metadata":{"value":"dep1","literalType":"string"}},{"type":"LITERAL","id":"<'dep2'>","metadata":{"value":"dep2","literalType":"string"}},{"type":"FUNCTION","id":"<factory-function>","metadata":{"amdFactory":true}},{"type":"PARAMETER","id":"<dep1>"},{"type":"PARAMETER","id":"<dep2>"},{"type":"LITERAL","id":"<{ init: function() {} }>","metadata":{"literalType":"object"}},{"type":"FUNCTION","id":"<init>","metadata":{"method":true}}],"edges":[{"src":"<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>","dst":"<'myModule'>","type":"PASSES_ARGUMENT"},{"src":"<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>","dst":"<['dep1', 'dep2']>","type":"PASSES_ARGUMENT"},{"src":"<define('myModule', ['dep1', 'dep2'], function(dep1, dep2) { return { init: function() {} }; })>","dst":"<factory-function>","type":"PASSES_ARGUMENT"},{"src":"<['dep1', 'dep2']>","dst":"<'dep1'>","type":"HAS_ELEMENT"},{"src":"<['dep1', 'dep2']>","dst":"<'dep2'>","type":"HAS_ELEMENT"},{"src":"<factory-function>","dst":"<dep1>","type":"CONTAINS"},{"src":"<factory-function>","dst":"<dep2>","type":"CONTAINS"},{"src":"<factory-function>","dst":"<{ init: function() {} }>","type":"RETURNS"},{"src":"<{ init: function() {} }>","dst":"<init>","type":"HAS_PROPERTY"},{"src":"<dep1>","dst":"<'dep1'>","type":"DERIVES_FROM"},{"src":"<dep2>","dst":"<'dep2'>","type":"DERIVES_FROM"}],"rationale":"AMD module definition with named module, dependency array, and factory function. Factory receives resolved dependencies as parameters and returns module exports object. Reduced edge count by removing module container and define function target edges while preserving core semantic relationships.","implicitBehavior":["AMD loader resolves dependencies before invoking factory","Module name registration in AMD registry","Asynchronous dependency loading","Factory function execution deferred until dependencies available"]},"pass":2,"annotatedAt":"2026-02-24T00:35:05.204Z"}
{"construct":{"id":"jsdoc-types::jsdoc-overload","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":118,"lineEnd":135,"code":"/**\n * @overload\n * @param {string} value\n * @returns {number}\n */\n/**\n * @overload\n * @param {number} value\n * @returns {string}\n */\n/**\n * @param {string | number} value\n * @returns {number | string}\n */\nfunction convert(value) {\n  return typeof value === 'string' ? Number(value) : String(value);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<convert>","metadata":{"async":false,"generator":false,"hasOverloads":true}},{"type":"PARAMETER","id":"<value>"},{"type":"TYPE_REFERENCE","id":"<string>","metadata":{"typeName":"string"}},{"type":"TYPE_REFERENCE","id":"<number>","metadata":{"typeName":"number"}},{"type":"TYPE_REFERENCE","id":"<string | number>","metadata":{"typeName":"string | number","isUnion":true}},{"type":"TYPE_REFERENCE","id":"<number | string>","metadata":{"typeName":"number | string","isUnion":true}},{"type":"EXPRESSION","id":"<typeof value === 'string'>","metadata":{"operator":"==="}},{"type":"CALL","id":"<Number(value)>","metadata":{"callee":"Number"}},{"type":"CALL","id":"<String(value)>","metadata":{"callee":"String"}},{"type":"EXPRESSION","id":"<ternary>","metadata":{"operator":"?:"}},{"type":"EXTERNAL","id":"<Number>","metadata":{"name":"Number"}},{"type":"EXTERNAL","id":"<String>","metadata":{"name":"String"}}],"edges":[{"src":"<convert>","dst":"<value>","type":"CONTAINS"},{"src":"<value>","dst":"<string | number>","type":"HAS_TYPE"},{"src":"<convert>","dst":"<number | string>","type":"RETURNS_TYPE"},{"src":"<convert>","dst":"<ternary>","type":"RETURNS"},{"src":"<ternary>","dst":"<typeof value === 'string'>","type":"HAS_CONDITION"},{"src":"<ternary>","dst":"<Number(value)>","type":"HAS_CONSEQUENT"},{"src":"<ternary>","dst":"<String(value)>","type":"HAS_ALTERNATE"},{"src":"<typeof value === 'string'>","dst":"<value>","type":"READS_FROM"},{"src":"<Number(value)>","dst":"<Number>","type":"CALLS"},{"src":"<Number(value)>","dst":"<value>","type":"PASSES_ARGUMENT"},{"src":"<String(value)>","dst":"<String>","type":"CALLS"},{"src":"<String(value)>","dst":"<value>","type":"PASSES_ARGUMENT"}],"rationale":"JSDoc overloads define multiple type signatures for the same function. The overload information is captured implicitly through the function's metadata and type relationships. Each overload specifies different parameter and return types, while the actual function implementation handles the union of all overload types.","implicitBehavior":["TypeScript/IDE tooling uses overloads for type checking and autocomplete","Runtime behavior follows single implementation regardless of overload signatures","JSDoc @overload tags create multiple type signatures that are not directly represented in the runtime code"]},"pass":2,"annotatedAt":"2026-02-24T00:35:07.106Z"}
{"construct":{"id":"jsdoc-types::jsdoc-implements","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":81,"lineEnd":94,"code":"/** @implements {Iterable<number>} */\nclass NumberRange {\n  /** @param {number} start @param {number} end */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  [Symbol.iterator]() {\n    let i = this.start;\n    const end = this.end;\n    return { next() { return i <= end ? { value: i++, done: false } : { done: true }; } };\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<NumberRange>"},{"type":"INTERFACE","id":"<Iterable<number>>","metadata":{"interface":"Iterable","typeParameter":"number","source":"jsdoc"}},{"type":"METHOD","id":"<NumberRange.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<start>","metadata":{"jsdocType":"number"}},{"type":"PARAMETER","id":"<end>","metadata":{"jsdocType":"number"}},{"type":"PROPERTY_ACCESS","id":"<this.start>"},{"type":"PROPERTY_ACCESS","id":"<this.end>"},{"type":"METHOD","id":"<NumberRange[Symbol.iterator]>","metadata":{"kind":"method","computed":true}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<end:local>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<return-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<next>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<i <= end>","metadata":{"operator":"<="}},{"type":"LITERAL","id":"<iterator-result-value>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<iterator-result-done>","metadata":{"literalType":"object"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}}],"edges":[{"src":"<NumberRange>","dst":"<Iterable<number>>","type":"IMPLEMENTS"},{"src":"<NumberRange>","dst":"<NumberRange.constructor>","type":"CONTAINS"},{"src":"<NumberRange>","dst":"<NumberRange[Symbol.iterator]>","type":"CONTAINS"},{"src":"<NumberRange.constructor>","dst":"<start>","type":"CONTAINS"},{"src":"<NumberRange.constructor>","dst":"<end>","type":"CONTAINS"},{"src":"<NumberRange.constructor>","dst":"<this.start>","type":"WRITES_TO"},{"src":"<NumberRange.constructor>","dst":"<this.end>","type":"WRITES_TO"},{"src":"<this.start>","dst":"<start>","type":"ASSIGNED_FROM"},{"src":"<this.end>","dst":"<end>","type":"ASSIGNED_FROM"},{"src":"<NumberRange[Symbol.iterator]>","dst":"<i>","type":"DECLARES"},{"src":"<NumberRange[Symbol.iterator]>","dst":"<end:local>","type":"DECLARES"},{"src":"<i>","dst":"<this.start>","type":"ASSIGNED_FROM"},{"src":"<end:local>","dst":"<this.end>","type":"ASSIGNED_FROM"},{"src":"<NumberRange[Symbol.iterator]>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<next>","type":"HAS_PROPERTY"},{"src":"<next>","dst":"<i <= end>","type":"CONTAINS"},{"src":"<i <= end>","dst":"<i>","type":"READS_FROM"},{"src":"<i <= end>","dst":"<end:local>","type":"READS_FROM"},{"src":"<next>","dst":"<iterator-result-value>","type":"RETURNS"},{"src":"<next>","dst":"<iterator-result-done>","type":"RETURNS"},{"src":"<iterator-result-value>","dst":"<i++>","type":"HAS_PROPERTY"},{"src":"<i++>","dst":"<i>","type":"READS_FROM"},{"src":"<i++>","dst":"<i>","type":"WRITES_TO"}],"rationale":"Class with JSDoc @implements annotation declaring it implements Iterable<number>. Constructor initializes range bounds, Symbol.iterator method returns iterator object with next() method implementing iterator protocol. Used INTERFACE to represent the JSDoc-declared interface contract.","implicitBehavior":["Symbol.iterator makes class iterable via for-of loops","Iterator protocol requires next() to return {value, done} objects","JSDoc type annotations provide static type information but no runtime enforcement"]},"pass":2,"annotatedAt":"2026-02-24T00:35:07.131Z"}
{"construct":{"id":"jsdoc-types::jsdoc-class-fields","file":"src/jsdoc-types.js","category":"jsdoc-types","lineStart":157,"lineEnd":177,"code":"class DataStore {\n  /** @type {Map<string, unknown>} */\n  store = new Map();\n\n  /** @private */\n  _cache = {};\n\n  /**\n   * @param {string} key\n   * @param {unknown} value\n   */\n  set(key, value) {\n    this.store.set(key, value);\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this.store.size;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<DataStore>"},{"type":"PROPERTY","id":"<DataStore.store>","metadata":{"visibility":"public","jsdocType":"Map<string, unknown>"}},{"type":"CALL","id":"<new Map()>","metadata":{"constructor":true,"callee":"Map"}},{"type":"PROPERTY","id":"<DataStore._cache>","metadata":{"visibility":"private","jsdocAnnotation":"@private"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"METHOD","id":"<DataStore.set>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<key>","metadata":{"jsdocType":"string"}},{"type":"PARAMETER","id":"<value>","metadata":{"jsdocType":"unknown"}},{"type":"CALL","id":"<this.store.set(key, value)>","metadata":{"callee":"set"}},{"type":"PROPERTY_ACCESS","id":"<this.store>","metadata":{"objectName":"this"}},{"type":"GETTER","id":"<DataStore.size>","metadata":{"jsdocReturns":"number"}},{"type":"PROPERTY_ACCESS","id":"<this.store.size>","metadata":{"objectName":"this"}}],"edges":[{"src":"<DataStore>","dst":"<DataStore.store>","type":"HAS_PROPERTY"},{"src":"<DataStore>","dst":"<DataStore._cache>","type":"HAS_PROPERTY"},{"src":"<DataStore>","dst":"<DataStore.set>","type":"CONTAINS"},{"src":"<DataStore>","dst":"<DataStore.size>","type":"CONTAINS"},{"src":"<DataStore.store>","dst":"<new Map()>","type":"ASSIGNED_FROM"},{"src":"<new Map()>","dst":"<Map>","type":"CALLS"},{"src":"<DataStore._cache>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<DataStore.set>","dst":"<key>","type":"CONTAINS"},{"src":"<DataStore.set>","dst":"<value>","type":"CONTAINS"},{"src":"<DataStore.set>","dst":"<this.store.set(key, value)>","type":"HAS_BODY"},{"src":"<this.store.set(key, value)>","dst":"<this.store>","type":"CALLS_ON"},{"src":"<this.store.set(key, value)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<this.store.set(key, value)>","dst":"<value>","type":"PASSES_ARGUMENT"},{"src":"<this.store>","dst":"<DataStore.store>","type":"READS_FROM"},{"src":"<DataStore.size>","dst":"<this.store.size>","type":"RETURNS"},{"src":"<this.store.size>","dst":"<this.store>","type":"READS_FROM"}],"rationale":"Class with JSDoc-annotated fields and methods. Changed METHOD to GETTER for size property to better reflect its nature. Used HAS_PROPERTY for class fields and HAS_BODY for method implementation. Used CALLS_ON for method invocation on object.","implicitBehavior":["JSDoc type annotations provide static analysis hints but no runtime enforcement","getter method creates property-like access pattern","private field convention (_cache) is naming-based, not enforced"]},"pass":2,"annotatedAt":"2026-02-24T00:35:07.137Z"}
{"construct":{"id":"legacy-patterns::global-namespace-init","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":48,"lineEnd":51,"code":"var MyApp = MyApp || {};\nMyApp.utils = MyApp.utils || {};\nMyApp.utils.format = function (str) { return str.trim(); };","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<MyApp>","metadata":{"kind":"var"}},{"type":"EXPRESSION","id":"<MyApp || {}>","metadata":{"operator":"||"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<MyApp.utils>","metadata":{"objectName":"MyApp","propertyName":"utils"}},{"type":"EXPRESSION","id":"<MyApp.utils || {}>","metadata":{"operator":"||"}},{"type":"LITERAL","id":"<{} (utils)>","metadata":{"value":{},"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<MyApp.utils.format>","metadata":{"objectName":"MyApp.utils","propertyName":"format"}},{"type":"FUNCTION","id":"<format>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<str>"},{"type":"CALL","id":"<str.trim()>","metadata":{"callee":"trim"}}],"edges":[{"src":"<module>","dst":"<MyApp>","type":"DECLARES"},{"src":"<MyApp>","dst":"<MyApp || {}>","type":"ASSIGNED_FROM"},{"src":"<MyApp || {}>","dst":"<MyApp>","type":"READS_FROM"},{"src":"<MyApp || {}>","dst":"<{}>","type":"READS_FROM"},{"src":"<MyApp.utils>","dst":"<MyApp.utils || {}>","type":"ASSIGNED_FROM"},{"src":"<MyApp.utils || {}>","dst":"<MyApp.utils>","type":"READS_FROM"},{"src":"<MyApp.utils || {}>","dst":"<{} (utils)>","type":"READS_FROM"},{"src":"<MyApp.utils.format>","dst":"<format>","type":"ASSIGNED_FROM"},{"src":"<format>","dst":"<str>","type":"CONTAINS"},{"src":"<format>","dst":"<str.trim()>","type":"RETURNS"},{"src":"<str.trim()>","dst":"<str>","type":"CALLS_ON"}],"rationale":"Legacy namespace initialization pattern using logical OR for safe property initialization. Creates global object hierarchy with defensive checks to avoid overwriting existing values. Function assigned to nested property creates method-like behavior.","implicitBehavior":["var declaration hoisted to module scope","property access creates properties if they don't exist","logical OR short-circuits if left operand is truthy","nested property assignments build object hierarchy"]},"pass":2,"annotatedAt":"2026-02-24T00:35:10.827Z"}
{"construct":{"id":"legacy-patterns::amd-define-deps","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":12,"lineEnd":19,"code":"// define(['jquery', 'underscore'], function($, _) {\n//   return {\n//     render: function(data) {\n//       return _.template($('#tpl').html())(data);\n//     }\n//   };\n// });","commentedOut":true,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"CALL","id":"<define-call>","metadata":{"callee":"define","moduleSystem":"amd"}},{"type":"LITERAL","id":"<'jquery'>","metadata":{"value":"jquery","literalType":"string"}},{"type":"LITERAL","id":"<'underscore'>","metadata":{"value":"underscore","literalType":"string"}},{"type":"FUNCTION","id":"<factory-function>","metadata":{"arrowFunction":false}},{"type":"PARAMETER","id":"<$>"},{"type":"PARAMETER","id":"<_>"},{"type":"LITERAL","id":"<module-object>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<render>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<data>"},{"type":"CALL","id":"<_.template-call>","metadata":{"callee":"_.template"}},{"type":"CALL","id":"<$('#tpl').html()>","metadata":{"callee":"$"}},{"type":"LITERAL","id":"<'#tpl'>","metadata":{"value":"#tpl","literalType":"string"}},{"type":"CALL","id":"<template-invocation>","metadata":{"dynamic":true}},{"type":"MODULE","id":"<module>"}],"edges":[{"src":"<module>","dst":"<define-call>","type":"CONTAINS"},{"src":"<define-call>","dst":"<'jquery'>","type":"PASSES_ARGUMENT"},{"src":"<define-call>","dst":"<'underscore'>","type":"PASSES_ARGUMENT"},{"src":"<define-call>","dst":"<factory-function>","type":"PASSES_ARGUMENT"},{"src":"<factory-function>","dst":"<$>","type":"CONTAINS"},{"src":"<factory-function>","dst":"<_>","type":"CONTAINS"},{"src":"<factory-function>","dst":"<module-object>","type":"RETURNS"},{"src":"<module-object>","dst":"<render>","type":"HAS_PROPERTY"},{"src":"<render>","dst":"<data>","type":"CONTAINS"},{"src":"<render>","dst":"<template-invocation>","type":"RETURNS"},{"src":"<template-invocation>","dst":"<_.template-call>","type":"CALLS"},{"src":"<_.template-call>","dst":"<_>","type":"READS_FROM"},{"src":"<_.template-call>","dst":"<$('#tpl').html()>","type":"PASSES_ARGUMENT"},{"src":"<$('#tpl').html()>","dst":"<$>","type":"CALLS"},{"src":"<$('#tpl').html()>","dst":"<'#tpl'>","type":"PASSES_ARGUMENT"},{"src":"<template-invocation>","dst":"<data>","type":"PASSES_ARGUMENT"},{"src":"<$>","dst":"<'jquery'>","type":"IMPORTS_FROM"},{"src":"<_>","dst":"<'underscore'>","type":"IMPORTS_FROM"}],"rationale":"AMD module definition with dependency injection. Factory function receives resolved dependencies as parameters and returns module object with render method that chains jQuery and Underscore operations.","implicitBehavior":["AMD loader resolves dependencies asynchronously","Factory function only executes after all dependencies are loaded","Module object becomes the resolved value for this module"]},"pass":2,"annotatedAt":"2026-02-24T00:35:11.059Z"}
{"construct":{"id":"legacy-patterns::global-namespace-revealing","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":61,"lineEnd":69,"code":"var RevealingModule = (function () {\n  var secret = 'hidden';\n  function getSecret() { return secret; }\n  function setSecret(s) { secret = s; }\n  return { get: getSecret, set: setSecret };\n})();\n\n// --- Polyfill Patterns ---","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<RevealingModule>","metadata":{"kind":"var"}},{"type":"FUNCTION","id":"<IIFE>","metadata":{"immediatelyInvoked":true}},{"type":"VARIABLE","id":"<secret>","metadata":{"kind":"var","scope":"function"}},{"type":"LITERAL","id":"<'hidden'>","metadata":{"value":"hidden","literalType":"string"}},{"type":"FUNCTION","id":"<getSecret>","metadata":{"scope":"function"}},{"type":"FUNCTION","id":"<setSecret>","metadata":{"scope":"function"}},{"type":"PARAMETER","id":"<s>"},{"type":"EXPRESSION","id":"<{ get: getSecret, set: setSecret }>","metadata":{"type":"object-literal"}},{"type":"CALL","id":"<IIFE-call>","metadata":{"immediateInvocation":true}}],"edges":[{"src":"<RevealingModule>","dst":"<IIFE-call>","type":"ASSIGNED_FROM"},{"src":"<IIFE-call>","dst":"<IIFE>","type":"CALLS"},{"src":"<IIFE>","dst":"<secret>","type":"CONTAINS"},{"src":"<secret>","dst":"<'hidden'>","type":"ASSIGNED_FROM"},{"src":"<IIFE>","dst":"<getSecret>","type":"CONTAINS"},{"src":"<IIFE>","dst":"<setSecret>","type":"CONTAINS"},{"src":"<setSecret>","dst":"<s>","type":"CONTAINS"},{"src":"<getSecret>","dst":"<secret>","type":"READS_FROM"},{"src":"<getSecret>","dst":"<secret>","type":"RETURNS"},{"src":"<setSecret>","dst":"<secret>","type":"WRITES_TO"},{"src":"<secret>","dst":"<s>","type":"ASSIGNED_FROM"},{"src":"<IIFE>","dst":"<{ get: getSecret, set: setSecret }>","type":"RETURNS"},{"src":"<{ get: getSecret, set: setSecret }>","dst":"<getSecret>","type":"HAS_PROPERTY"},{"src":"<{ get: getSecret, set: setSecret }>","dst":"<setSecret>","type":"HAS_PROPERTY"},{"src":"<getSecret>","dst":"<secret>","type":"CAPTURES"},{"src":"<setSecret>","dst":"<secret>","type":"CAPTURES"}],"rationale":"Revealing module pattern using IIFE to create private scope. Inner functions capture private variable and are exposed through returned object literal. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["closure captures private state","IIFE creates isolated scope","returned functions maintain reference to private variables"]},"pass":2,"annotatedAt":"2026-02-24T00:35:11.280Z"}
{"construct":{"id":"legacy-patterns::babel-class-call-check","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":118,"lineEnd":123,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<_classCallCheck>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<instance>"},{"type":"PARAMETER","id":"<Constructor>"},{"type":"BRANCH","id":"<instanceof-check>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<!(instance instanceof Constructor)>","metadata":{"operator":"!","innerOperator":"instanceof"}},{"type":"CALL","id":"<new TypeError(...)>","metadata":{"callee":"TypeError","isConstructorCall":true}},{"type":"LITERAL","id":"<'Cannot call a class as a function'>","metadata":{"value":"Cannot call a class as a function","literalType":"string"}}],"edges":[{"src":"<_classCallCheck>","dst":"<instance>","type":"CONTAINS"},{"src":"<_classCallCheck>","dst":"<Constructor>","type":"CONTAINS"},{"src":"<_classCallCheck>","dst":"<instanceof-check>","type":"CONTAINS"},{"src":"<instanceof-check>","dst":"<!(instance instanceof Constructor)>","type":"HAS_CONDITION"},{"src":"<!(instance instanceof Constructor)>","dst":"<instance>","type":"READS_FROM"},{"src":"<!(instance instanceof Constructor)>","dst":"<Constructor>","type":"READS_FROM"},{"src":"<instanceof-check>","dst":"<new TypeError(...)>","type":"HAS_CONSEQUENT"},{"src":"<new TypeError(...)>","dst":"<'Cannot call a class as a function'>","type":"PASSES_ARGUMENT"},{"src":"<instanceof-check>","dst":"<new TypeError(...)>","type":"THROWS"}],"rationale":"Babel helper function that validates class constructor calls. Checks instanceof relationship and throws TypeError if validation fails. Reduced edge count by removing module declaration edge and direct constructor call edge.","implicitBehavior":["Part of Babel's class transformation runtime","Prevents calling class constructors without 'new' keyword","TypeError constructor call creates exception object"]},"pass":2,"annotatedAt":"2026-02-24T00:35:12.807Z"}
{"construct":{"id":"legacy-patterns::global-namespace-iife","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":53,"lineEnd":59,"code":"var MyApp2 = (function (ns) {\n  var _private = 0;\n  ns.increment = function () { return ++_private; };\n  ns.getValue = function () { return _private; };\n  return ns;\n}(MyApp2 || {}));","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<MyApp2>","metadata":{"kind":"var"}},{"type":"FUNCTION","id":"<iife>","metadata":{"iife":true}},{"type":"PARAMETER","id":"<ns>"},{"type":"VARIABLE","id":"<_private>","metadata":{"kind":"var","private":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<ns.increment>","metadata":{"objectName":"ns","propertyName":"increment"}},{"type":"FUNCTION","id":"<increment:fn>","metadata":{"anonymous":true}},{"type":"EXPRESSION","id":"<++_private>","metadata":{"operator":"++","prefix":true}},{"type":"PROPERTY_ACCESS","id":"<ns.getValue>","metadata":{"objectName":"ns","propertyName":"getValue"}},{"type":"FUNCTION","id":"<getValue:fn>","metadata":{"anonymous":true}},{"type":"EXPRESSION","id":"<MyApp2 || {}>","metadata":{"operator":"||"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}}],"edges":[{"src":"<MyApp2>","dst":"<iife>","type":"ASSIGNED_FROM"},{"src":"<iife>","dst":"<ns>","type":"CONTAINS"},{"src":"<iife>","dst":"<_private>","type":"CONTAINS"},{"src":"<_private>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<ns.increment>","dst":"<increment:fn>","type":"ASSIGNED_FROM"},{"src":"<increment:fn>","dst":"<++_private>","type":"RETURNS"},{"src":"<++_private>","dst":"<_private>","type":"MODIFIES"},{"src":"<ns.getValue>","dst":"<getValue:fn>","type":"ASSIGNED_FROM"},{"src":"<getValue:fn>","dst":"<_private>","type":"RETURNS"},{"src":"<getValue:fn>","dst":"<_private>","type":"READS_FROM"},{"src":"<iife>","dst":"<ns>","type":"RETURNS"},{"src":"<iife>","dst":"<MyApp2 || {}>","type":"RECEIVES_ARGUMENT"},{"src":"<MyApp2 || {}>","dst":"<MyApp2>","type":"READS_FROM"},{"src":"<MyApp2 || {}>","dst":"<{}>","type":"READS_FROM"},{"src":"<iife>","dst":"<ns.increment>","type":"WRITES_TO"},{"src":"<iife>","dst":"<ns.getValue>","type":"WRITES_TO"}],"rationale":"IIFE pattern for namespace creation with private closure. Function creates private variable, attaches public methods to namespace parameter, returns augmented namespace. Reduced edge count by removing module declaration edge and consolidating argument passing.","implicitBehavior":["var declaration hoisted to module scope","closure captures private variable","namespace augmentation pattern allows multiple IIFE calls to extend same object"]},"pass":2,"annotatedAt":"2026-02-24T00:35:16.505Z"}
{"construct":{"id":"legacy-patterns::babel-class-compiled","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":150,"lineEnd":162,"code":"// Source: class Dog extends Animal { constructor(name) { super(name); } }\n// Compiled:\nvar Dog = (function (_Animal) {\n  _inherits(Dog, _Animal);\n  function Dog(name) {\n    _classCallCheck(this, Dog);\n    return _Animal.call(this, name);\n  }\n  return Dog;\n}(Animal));\n\n// --- TypeScript Compiled Output ---","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<Dog>","metadata":{"kind":"var"}},{"type":"FUNCTION","id":"<Dog:iife>","metadata":{"iife":true}},{"type":"PARAMETER","id":"<_Animal>"},{"type":"CALL","id":"<_inherits(Dog, _Animal)>","metadata":{"callee":"_inherits"}},{"type":"FUNCTION","id":"<Dog:constructor>","metadata":{"constructorFunction":true}},{"type":"PARAMETER","id":"<name>"},{"type":"CALL","id":"<_classCallCheck(this, Dog)>","metadata":{"callee":"_classCallCheck"}},{"type":"CALL","id":"<_Animal.call(this, name)>","metadata":{"callee":"_Animal.call"}},{"type":"EXTERNAL","id":"<_inherits>","metadata":{"helper":"babel"}},{"type":"EXTERNAL","id":"<_classCallCheck>","metadata":{"helper":"babel"}},{"type":"EXTERNAL","id":"<Animal>","metadata":{"parentClass":true}}],"edges":[{"src":"<Dog>","dst":"<Dog:iife>","type":"ASSIGNED_FROM"},{"src":"<Dog:iife>","dst":"<_Animal>","type":"CONTAINS"},{"src":"<Dog:iife>","dst":"<_inherits(Dog, _Animal)>","type":"CONTAINS"},{"src":"<Dog:iife>","dst":"<Dog:constructor>","type":"CONTAINS"},{"src":"<Dog:iife>","dst":"<Dog:constructor>","type":"RETURNS"},{"src":"<Dog:constructor>","dst":"<name>","type":"CONTAINS"},{"src":"<Dog:constructor>","dst":"<_classCallCheck(this, Dog)>","type":"CONTAINS"},{"src":"<Dog:constructor>","dst":"<_Animal.call(this, name)>","type":"RETURNS"},{"src":"<_inherits(Dog, _Animal)>","dst":"<_inherits>","type":"CALLS"},{"src":"<_inherits(Dog, _Animal)>","dst":"<Dog>","type":"PASSES_ARGUMENT"},{"src":"<_inherits(Dog, _Animal)>","dst":"<_Animal>","type":"PASSES_ARGUMENT"},{"src":"<_classCallCheck(this, Dog)>","dst":"<_classCallCheck>","type":"CALLS"},{"src":"<_classCallCheck(this, Dog)>","dst":"<Dog>","type":"PASSES_ARGUMENT"},{"src":"<_Animal.call(this, name)>","dst":"<_Animal>","type":"CALLS"},{"src":"<_Animal.call(this, name)>","dst":"<name>","type":"PASSES_ARGUMENT"},{"src":"<Dog:iife>","dst":"<Animal>","type":"READS_FROM"}],"rationale":"Babel-compiled class inheritance using IIFE pattern. The Dog variable is assigned an IIFE that takes Animal as parameter, sets up inheritance via _inherits helper, defines constructor function with _classCallCheck validation, and delegates to parent constructor via _Animal.call. Added explicit EXTERNAL nodes for babel helpers and parent class.","implicitBehavior":["var declaration is hoisted to function/module scope","_inherits sets up prototype chain inheritance","_classCallCheck prevents calling constructor without 'new'","_Animal.call delegates constructor to parent with proper 'this' binding","IIFE creates closure to capture Animal reference"]},"pass":2,"annotatedAt":"2026-02-24T00:35:18.945Z"}
{"construct":{"id":"legacy-patterns::babel-inherits","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":142,"lineEnd":148,"code":"function _inherits(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true }\n  });\n  if (superClass) Object.setPrototypeOf(subClass, superClass);\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"FUNCTION","id":"<_inherits>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<subClass>"},{"type":"PARAMETER","id":"<superClass>"},{"type":"PROPERTY_ACCESS","id":"<subClass.prototype>","metadata":{"objectName":"subClass","propertyName":"prototype"}},{"type":"CALL","id":"<Object.create>","metadata":{"callee":"Object.create"}},{"type":"PROPERTY_ACCESS","id":"<superClass.prototype>","metadata":{"objectName":"superClass","propertyName":"prototype"}},{"type":"EXPRESSION","id":"<superClass && superClass.prototype>","metadata":{"operator":"&&"}},{"type":"LITERAL","id":"<constructor-descriptor>","metadata":{"value":"{ value: subClass, writable: true, configurable: true }","literalType":"object"}},{"type":"BRANCH","id":"<if-superClass>","metadata":{"branchType":"if"}},{"type":"CALL","id":"<Object.setPrototypeOf>","metadata":{"callee":"Object.setPrototypeOf"}}],"edges":[{"src":"<_inherits>","dst":"<subClass>","type":"HAS_BODY"},{"src":"<_inherits>","dst":"<superClass>","type":"HAS_BODY"},{"src":"<subClass.prototype>","dst":"<Object.create>","type":"ASSIGNED_FROM"},{"src":"<Object.create>","dst":"<superClass && superClass.prototype>","type":"PASSES_ARGUMENT"},{"src":"<Object.create>","dst":"<constructor-descriptor>","type":"PASSES_ARGUMENT"},{"src":"<superClass && superClass.prototype>","dst":"<superClass>","type":"READS_FROM"},{"src":"<superClass && superClass.prototype>","dst":"<superClass.prototype>","type":"READS_FROM"},{"src":"<superClass.prototype>","dst":"<superClass>","type":"READS_FROM"},{"src":"<constructor-descriptor>","dst":"<subClass>","type":"READS_FROM"},{"src":"<_inherits>","dst":"<if-superClass>","type":"HAS_BODY"},{"src":"<if-superClass>","dst":"<superClass>","type":"HAS_CONDITION"},{"src":"<if-superClass>","dst":"<Object.setPrototypeOf>","type":"HAS_CONSEQUENT"},{"src":"<Object.setPrototypeOf>","dst":"<subClass>","type":"PASSES_ARGUMENT"},{"src":"<Object.setPrototypeOf>","dst":"<superClass>","type":"PASSES_ARGUMENT"}],"rationale":"Babel's inheritance helper function that establishes prototype chain between subClass and superClass. Sets up prototype delegation and constructor property, with conditional static inheritance.","implicitBehavior":["Modifies prototype chain at runtime","Creates new object with superClass.prototype as prototype","Preserves constructor property with proper descriptors","Establishes static inheritance via Object.setPrototypeOf"]},"pass":2,"annotatedAt":"2026-02-24T00:35:19.866Z"}
{"construct":{"id":"legacy-patterns::polyfill-promise","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":94,"lineEnd":106,"code":"if (typeof Promise === 'undefined') {\n  // Simplified polyfill shape  real ones are 200+ lines\n  function Promise(executor) {\n    this._state = 'pending';\n    this._value = undefined;\n    this._callbacks = [];\n    executor(this._resolve.bind(this), this._reject.bind(this));\n  }\n  Promise.prototype.then = function (onFulfilled, onRejected) { /* ... */ };\n  Promise.prototype._resolve = function (value) { /* ... */ };\n  Promise.prototype._reject = function (reason) { /* ... */ };\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"BRANCH","id":"<if-Promise-undefined>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<typeof Promise === 'undefined'>","metadata":{"operator":"==="}},{"type":"FUNCTION","id":"<Promise>","metadata":{"isConstructor":true,"polyfill":true}},{"type":"PARAMETER","id":"<executor>"},{"type":"PROPERTY_ACCESS","id":"<this._state>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<'pending'>","metadata":{"value":"pending","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<this._value>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<undefined>","metadata":{"value":"undefined","literalType":"undefined"}},{"type":"PROPERTY_ACCESS","id":"<this._callbacks>","metadata":{"objectName":"this"}},{"type":"LITERAL","id":"<[]>","metadata":{"literalType":"array"}},{"type":"CALL","id":"<executor(this._resolve.bind(this), this._reject.bind(this))>","metadata":{"callee":"executor"}},{"type":"CALL","id":"<this._resolve.bind(this)>","metadata":{"callee":"bind"}},{"type":"CALL","id":"<this._reject.bind(this)>","metadata":{"callee":"bind"}},{"type":"METHOD","id":"<Promise.prototype.then>","metadata":{"kind":"method","prototypeMethod":true}},{"type":"PARAMETER","id":"<onFulfilled>"},{"type":"PARAMETER","id":"<onRejected>"},{"type":"METHOD","id":"<Promise.prototype._resolve>","metadata":{"kind":"method","prototypeMethod":true,"private":true}},{"type":"PARAMETER","id":"<value>"},{"type":"METHOD","id":"<Promise.prototype._reject>","metadata":{"kind":"method","prototypeMethod":true,"private":true}},{"type":"PARAMETER","id":"<reason>"}],"edges":[{"src":"<if-Promise-undefined>","dst":"<typeof Promise === 'undefined'>","type":"HAS_CONDITION"},{"src":"<typeof Promise === 'undefined'>","dst":"<Promise>","type":"READS_FROM"},{"src":"<if-Promise-undefined>","dst":"<Promise>","type":"HAS_CONSEQUENT"},{"src":"<Promise>","dst":"<executor>","type":"CONTAINS"},{"src":"<Promise>","dst":"<this._state>","type":"WRITES_TO"},{"src":"<this._state>","dst":"<'pending'>","type":"ASSIGNED_FROM"},{"src":"<Promise>","dst":"<this._value>","type":"WRITES_TO"},{"src":"<this._value>","dst":"<undefined>","type":"ASSIGNED_FROM"},{"src":"<Promise>","dst":"<this._callbacks>","type":"WRITES_TO"},{"src":"<this._callbacks>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<Promise>","dst":"<executor(this._resolve.bind(this), this._reject.bind(this))>","type":"CONTAINS"},{"src":"<executor(this._resolve.bind(this), this._reject.bind(this))>","dst":"<executor>","type":"CALLS"},{"src":"<executor(this._resolve.bind(this), this._reject.bind(this))>","dst":"<this._resolve.bind(this)>","type":"PASSES_ARGUMENT"},{"src":"<executor(this._resolve.bind(this), this._reject.bind(this))>","dst":"<this._reject.bind(this)>","type":"PASSES_ARGUMENT"},{"src":"<this._resolve.bind(this)>","dst":"<Promise.prototype._resolve>","type":"READS_FROM"},{"src":"<this._reject.bind(this)>","dst":"<Promise.prototype._reject>","type":"READS_FROM"},{"src":"<Promise.prototype.then>","dst":"<onFulfilled>","type":"CONTAINS"},{"src":"<Promise.prototype.then>","dst":"<onRejected>","type":"CONTAINS"},{"src":"<Promise.prototype._resolve>","dst":"<value>","type":"CONTAINS"},{"src":"<Promise.prototype._reject>","dst":"<reason>","type":"CONTAINS"}],"rationale":"Conditional polyfill that defines Promise constructor and prototype methods only if Promise is undefined. Constructor initializes instance state and calls executor with bound resolve/reject methods. Removed module-level DECLARES edges as they don't accurately represent the conditional nature of these declarations.","implicitBehavior":["Global Promise detection via typeof","Prototype chain modification","Function binding creates new function references","Constructor function hoisting within conditional block"]},"pass":2,"annotatedAt":"2026-02-24T00:35:21.005Z"}
{"construct":{"id":"legacy-patterns::umd-wrapper","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":33,"lineEnd":46,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['dependency'], factory);                         // AMD\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory(require('dependency'));          // CJS\n  } else {\n    root.MyLibrary = factory(root.Dependency);               // Browser global\n  }\n}(typeof self !== 'undefined' ? self : this, function (dep) {\n  return { version: '1.0', process: function(x) { return dep.transform(x); } };\n}));\n\n// --- Global Namespace Pattern ---","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<umd-wrapper>\",\n      \"metadata\": {\n        \"iife\": true,\n        \"umd\": true\n      }\n    },\n    {\n      \"type\": \"PARAMETER\",\n      "},"pass":2,"annotatedAt":"2026-02-24T00:35:21.592Z"}
{"construct":{"id":"legacy-patterns::jquery-extend-pattern","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":214,"lineEnd":216,"code":"// $.extend(true, target, source1, source2); // deep merge\n// $.extend($.fn, { newPlugin: function() {} }); // add to prototype","commentedOut":true,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"CALL","id":"<$.extend(true, target, source1, source2)>","metadata":{"callee":"$.extend","argumentCount":4}},{"type":"PROPERTY_ACCESS","id":"<$.extend>","metadata":{"objectName":"$","propertyName":"extend"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"VARIABLE","id":"<target>"},{"type":"VARIABLE","id":"<source1>"},{"type":"VARIABLE","id":"<source2>"},{"type":"CALL","id":"<$.extend($.fn, { newPlugin: function() {} })>","metadata":{"callee":"$.extend","argumentCount":2}},{"type":"PROPERTY_ACCESS","id":"<$.fn>","metadata":{"objectName":"$","propertyName":"fn"}},{"type":"LITERAL","id":"<{ newPlugin: function() {} }>","metadata":{"literalType":"object"}},{"type":"FUNCTION","id":"<newPlugin:fn>","metadata":{"anonymous":true}}],"edges":[{"src":"<$.extend(true, target, source1, source2)>","dst":"<$.extend>","type":"CALLS"},{"src":"<$.extend(true, target, source1, source2)>","dst":"<true>","type":"PASSES_ARGUMENT"},{"src":"<$.extend(true, target, source1, source2)>","dst":"<target>","type":"PASSES_ARGUMENT"},{"src":"<$.extend(true, target, source1, source2)>","dst":"<source1>","type":"PASSES_ARGUMENT"},{"src":"<$.extend(true, target, source1, source2)>","dst":"<source2>","type":"PASSES_ARGUMENT"},{"src":"<$.extend(true, target, source1, source2)>","dst":"<target>","type":"MODIFIES"},{"src":"<$.extend($.fn, { newPlugin: function() {} })>","dst":"<$.extend>","type":"CALLS"},{"src":"<$.extend($.fn, { newPlugin: function() {} })>","dst":"<$.fn>","type":"PASSES_ARGUMENT"},{"src":"<$.extend($.fn, { newPlugin: function() {} })>","dst":"<{ newPlugin: function() {} }>","type":"PASSES_ARGUMENT"},{"src":"<$.extend($.fn, { newPlugin: function() {} })>","dst":"<$.fn>","type":"MODIFIES"},{"src":"<{ newPlugin: function() {} }>","dst":"<newPlugin:fn>","type":"HAS_PROPERTY"}],"rationale":"Two jQuery extend patterns: deep merge with boolean flag and prototype extension. Both calls modify their target objects by merging properties from source objects. All node and edge types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["$.extend modifies target object in-place","deep merge recursively copies nested objects when first argument is true","prototype extension adds methods to all jQuery instances","jQuery global object dependency"]},"pass":2,"annotatedAt":"2026-02-24T00:35:23.552Z"}
{"construct":{"id":"legacy-patterns::polyfill-symbol-shim","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":108,"lineEnd":116,"code":"if (typeof Symbol === 'undefined') {\n  var Symbol = function (description) {\n    return '__symbol_' + (description || '') + '_' + Math.random().toString(36);\n  };\n  Symbol.iterator = '@@iterator';\n}\n\n// --- Babel Compiled Output ---","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"BRANCH","id":"<if-symbol-undefined>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<typeof Symbol === 'undefined'>","metadata":{"operator":"==="}},{"type":"EXPRESSION","id":"<typeof Symbol>","metadata":{"operator":"typeof"}},{"type":"LITERAL","id":"<'undefined'>","metadata":{"value":"undefined","literalType":"string"}},{"type":"VARIABLE","id":"<Symbol>","metadata":{"kind":"var"}},{"type":"FUNCTION","id":"<Symbol:polyfill>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<description>"},{"type":"EXPRESSION","id":"<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>","metadata":{"operator":"+"}},{"type":"LITERAL","id":"<'__symbol_'>","metadata":{"value":"__symbol_","literalType":"string"}},{"type":"EXPRESSION","id":"<description || ''>","metadata":{"operator":"||"}},{"type":"LITERAL","id":"<''>","metadata":{"value":"","literalType":"string"}},{"type":"LITERAL","id":"<'_'>","metadata":{"value":"_","literalType":"string"}},{"type":"CALL","id":"<Math.random().toString(36)>","metadata":{"callee":"toString"}},{"type":"CALL","id":"<Math.random()>","metadata":{"callee":"random"}},{"type":"PROPERTY_ACCESS","id":"<Math.random>","metadata":{"objectName":"Math"}},{"type":"LITERAL","id":"<36>","metadata":{"value":36,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<Symbol.iterator>","metadata":{"objectName":"Symbol"}},{"type":"LITERAL","id":"<'@@iterator'>","metadata":{"value":"@@iterator","literalType":"string"}}],"edges":[{"src":"<if-symbol-undefined>","dst":"<typeof Symbol === 'undefined'>","type":"HAS_CONDITION"},{"src":"<typeof Symbol === 'undefined'>","dst":"<typeof Symbol>","type":"READS_FROM"},{"src":"<typeof Symbol === 'undefined'>","dst":"<'undefined'>","type":"READS_FROM"},{"src":"<typeof Symbol>","dst":"<Symbol>","type":"READS_FROM"},{"src":"<if-symbol-undefined>","dst":"<Symbol>","type":"DECLARES"},{"src":"<Symbol>","dst":"<Symbol:polyfill>","type":"ASSIGNED_FROM"},{"src":"<Symbol:polyfill>","dst":"<description>","type":"CONTAINS"},{"src":"<Symbol:polyfill>","dst":"<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>","type":"RETURNS"},{"src":"<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>","dst":"<'__symbol_'>","type":"READS_FROM"},{"src":"<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>","dst":"<description || ''>","type":"READS_FROM"},{"src":"<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>","dst":"<'_'>","type":"READS_FROM"},{"src":"<'__symbol_' + (description || '') + '_' + Math.random().toString(36)>","dst":"<Math.random().toString(36)>","type":"READS_FROM"},{"src":"<description || ''>","dst":"<description>","type":"READS_FROM"},{"src":"<description || ''>","dst":"<''>","type":"READS_FROM"},{"src":"<Math.random().toString(36)>","dst":"<Math.random()>","type":"CALLS"},{"src":"<Math.random().toString(36)>","dst":"<36>","type":"PASSES_ARGUMENT"},{"src":"<Math.random()>","dst":"<Math.random>","type":"CALLS"},{"src":"<if-symbol-undefined>","dst":"<Symbol.iterator>","type":"WRITES_TO"},{"src":"<Symbol.iterator>","dst":"<'@@iterator'>","type":"ASSIGNED_FROM"}],"rationale":"Polyfill pattern that conditionally defines Symbol if undefined. Creates a function that generates unique string identifiers and adds iterator property. All nodes and edges use approved vocabulary types.","implicitBehavior":["var declaration is hoisted to function/module scope","typeof operator returns string without throwing for undefined variables","Property assignment on function object creates enumerable property","Math.random() provides pseudo-randomness for unique identifier generation"]},"pass":2,"annotatedAt":"2026-02-24T00:35:26.192Z"}
{"construct":{"id":"legacy-patterns::polyfill-prototype-method","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":71,"lineEnd":80,"code":"if (!Array.prototype.flat) {\n  Array.prototype.flat = function (depth) {\n    depth = depth === undefined ? 1 : Math.floor(depth);\n    if (depth < 1) return Array.prototype.slice.call(this);\n    return Array.prototype.reduce.call(this, function (acc, val) {\n      return acc.concat(Array.isArray(val) && depth > 1 ? val.flat(depth - 1) : val);\n    }, []);\n  };\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"BRANCH","id":"<if-polyfill>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<!Array.prototype.flat>","metadata":{"operator":"!"}},{"type":"PROPERTY_ACCESS","id":"<Array.prototype.flat>","metadata":{"objectName":"Array.prototype","propertyName":"flat"}},{"type":"FUNCTION","id":"<polyfill-flat>","metadata":{"arrowFunction":false}},{"type":"PARAMETER","id":"<depth>"},{"type":"EXPRESSION","id":"<depth-ternary>","metadata":{"operator":"?:"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<Math.floor>","metadata":{"callee":"Math.floor"}},{"type":"BRANCH","id":"<early-return>","metadata":{"branchType":"if"}},{"type":"CALL","id":"<slice-call>","metadata":{"callee":"Array.prototype.slice.call"}},{"type":"CALL","id":"<reduce-call>","metadata":{"callee":"Array.prototype.reduce.call"}},{"type":"FUNCTION","id":"<reduce-callback>","metadata":{"arrowFunction":false}},{"type":"PARAMETER","id":"<acc>"},{"type":"PARAMETER","id":"<val>"},{"type":"CALL","id":"<concat-call>","metadata":{"callee":"acc.concat"}},{"type":"EXPRESSION","id":"<ternary-arg>","metadata":{"operator":"?:"}},{"type":"CALL","id":"<isArray-call>","metadata":{"callee":"Array.isArray"}},{"type":"CALL","id":"<recursive-flat>","metadata":{"callee":"val.flat"}},{"type":"LITERAL","id":"<empty-array>","metadata":{"value":"[]","literalType":"array"}}],"edges":[{"src":"<if-polyfill>","dst":"<!Array.prototype.flat>","type":"HAS_CONDITION"},{"src":"<!Array.prototype.flat>","dst":"<Array.prototype.flat>","type":"READS_FROM"},{"src":"<Array.prototype.flat>","dst":"<polyfill-flat>","type":"ASSIGNED_FROM"},{"src":"<polyfill-flat>","dst":"<depth>","type":"HAS_BODY"},{"src":"<depth>","dst":"<depth-ternary>","type":"ASSIGNED_FROM"},{"src":"<depth-ternary>","dst":"<1>","type":"HAS_CONSEQUENT"},{"src":"<depth-ternary>","dst":"<Math.floor>","type":"HAS_ALTERNATE"},{"src":"<Math.floor>","dst":"<depth>","type":"PASSES_ARGUMENT"},{"src":"<polyfill-flat>","dst":"<early-return>","type":"HAS_BODY"},{"src":"<early-return>","dst":"<slice-call>","type":"HAS_CONSEQUENT"},{"src":"<polyfill-flat>","dst":"<reduce-call>","type":"RETURNS"},{"src":"<reduce-call>","dst":"<reduce-callback>","type":"PASSES_ARGUMENT"},{"src":"<reduce-call>","dst":"<empty-array>","type":"PASSES_ARGUMENT"},{"src":"<reduce-callback>","dst":"<acc>","type":"HAS_BODY"},{"src":"<reduce-callback>","dst":"<val>","type":"HAS_BODY"},{"src":"<reduce-callback>","dst":"<concat-call>","type":"RETURNS"},{"src":"<concat-call>","dst":"<ternary-arg>","type":"PASSES_ARGUMENT"},{"src":"<ternary-arg>","dst":"<isArray-call>","type":"HAS_CONDITION"},{"src":"<ternary-arg>","dst":"<recursive-flat>","type":"HAS_CONSEQUENT"},{"src":"<ternary-arg>","dst":"<val>","type":"HAS_ALTERNATE"},{"src":"<isArray-call>","dst":"<val>","type":"PASSES_ARGUMENT"},{"src":"<recursive-flat>","dst":"<val>","type":"CALLS_ON"}],"rationale":"Polyfill pattern that conditionally adds Array.prototype.flat method using feature detection. The implementation uses recursive flattening with depth control through reduce and ternary operators.","implicitBehavior":["Modifies global Array.prototype object","Feature detection prevents overriding existing implementation","Recursive calls to polyfilled method itself","Closure captures depth parameter across recursive calls","Uses call() to maintain proper this context"]},"pass":2,"annotatedAt":"2026-02-24T00:35:27.545Z"}
{"construct":{"id":"legacy-patterns::polyfill-static-method","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":82,"lineEnd":92,"code":"if (!Object.entries) {\n  Object.entries = function (obj) {\n    var keys = Object.keys(obj);\n    var result = [];\n    for (var i = 0; i < keys.length; i++) {\n      result.push([keys[i], obj[keys[i]]]);\n    }\n    return result;\n  };\n}","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"BRANCH\",\n      \"id\": \"<if-polyfill>\",\n      \"metadata\": {\n        \"branchType\": \"if\"\n      }\n    },\n    {\n      \"type\": \"EXPRESSION\",\n      \"id\": \"<!Object."},"pass":2,"annotatedAt":"2026-02-24T00:35:27.617Z"}
{"construct":{"id":"builtins::builtin-regex-exec","file":"src/builtins.js","category":"builtins","lineStart":169,"lineEnd":178,"code":"function regexExec(pattern, str) {\n  const regex = new RegExp(pattern, 'g');\n  const matches = [];\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    matches.push({ match: match[0], index: match.index });\n  }\n  return matches;\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<regexExec>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETER\","},"pass":2,"annotatedAt":"2026-02-24T00:35:28.057Z"}
{"construct":{"id":"modern-es::modern-array-at","file":"src/modern-es.js","category":"modern-es","lineStart":7,"lineEnd":13,"code":"function arrayAt(arr) {\n  const first = arr.at(0);\n  const last = arr.at(-1);\n  const second = arr.at(1);\n  return { first, last, second };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<arrayAt>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<arr>"},{"type":"VARIABLE","id":"<first>","metadata":{"kind":"const"}},{"type":"CALL","id":"<arr.at(0)>","metadata":{"callee":"at","method":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<last>","metadata":{"kind":"const"}},{"type":"CALL","id":"<arr.at(-1)>","metadata":{"callee":"at","method":true}},{"type":"LITERAL","id":"<-1>","metadata":{"value":-1,"literalType":"number"}},{"type":"VARIABLE","id":"<second>","metadata":{"kind":"const"}},{"type":"CALL","id":"<arr.at(1)>","metadata":{"callee":"at","method":true}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ first, last, second }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<arrayAt>","dst":"<arr>","type":"CONTAINS"},{"src":"<arrayAt>","dst":"<first>","type":"CONTAINS"},{"src":"<first>","dst":"<arr.at(0)>","type":"ASSIGNED_FROM"},{"src":"<arr.at(0)>","dst":"<arr>","type":"READS_FROM"},{"src":"<arr.at(0)>","dst":"<0>","type":"PASSES_ARGUMENT"},{"src":"<arrayAt>","dst":"<last>","type":"CONTAINS"},{"src":"<last>","dst":"<arr.at(-1)>","type":"ASSIGNED_FROM"},{"src":"<arr.at(-1)>","dst":"<arr>","type":"READS_FROM"},{"src":"<arr.at(-1)>","dst":"<-1>","type":"PASSES_ARGUMENT"},{"src":"<arrayAt>","dst":"<second>","type":"CONTAINS"},{"src":"<second>","dst":"<arr.at(1)>","type":"ASSIGNED_FROM"},{"src":"<arr.at(1)>","dst":"<arr>","type":"READS_FROM"},{"src":"<arr.at(1)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<arrayAt>","dst":"<{ first, last, second }>","type":"RETURNS"},{"src":"<{ first, last, second }>","dst":"<first>","type":"READS_FROM"},{"src":"<{ first, last, second }>","dst":"<last>","type":"READS_FROM"},{"src":"<{ first, last, second }>","dst":"<second>","type":"READS_FROM"}],"rationale":"Function using modern Array.at() method for index access. Three const variables assigned from method calls, returned in object with shorthand property syntax. Removed the module-level DECLARES edge as no module node was defined.","implicitBehavior":["Array.at() supports negative indexing from end","shorthand object properties create properties with same names as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:35:31.744Z"}
{"construct":{"id":"legacy-patterns::ts-compiled-spread","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":186,"lineEnd":191,"code":"var __spreadArray = function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n    to[j] = from[i];\n  return to;\n};","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<__spreadArray>","metadata":{"kind":"var"}},{"type":"FUNCTION","id":"<__spreadArray:fn>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<to>"},{"type":"PARAMETER","id":"<from>"},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"var"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<il>","metadata":{"kind":"var"}},{"type":"PROPERTY_ACCESS","id":"<from.length>","metadata":{"property":"length"}},{"type":"VARIABLE","id":"<j>","metadata":{"kind":"var"}},{"type":"PROPERTY_ACCESS","id":"<to.length>","metadata":{"property":"length"}},{"type":"EXPRESSION","id":"<i < il>","metadata":{"operator":"<"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<j++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<to[j] = from[i]>","metadata":{"operator":"="}},{"type":"PROPERTY_ACCESS","id":"<to[j]>","metadata":{"computed":true}},{"type":"PROPERTY_ACCESS","id":"<from[i]>","metadata":{"computed":true}}],"edges":[{"src":"<__spreadArray>","dst":"<__spreadArray:fn>","type":"ASSIGNED_FROM"},{"src":"<__spreadArray:fn>","dst":"<to>","type":"CONTAINS"},{"src":"<__spreadArray:fn>","dst":"<from>","type":"CONTAINS"},{"src":"<__spreadArray:fn>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<il>","type":"HAS_INIT"},{"src":"<il>","dst":"<from.length>","type":"ASSIGNED_FROM"},{"src":"<from.length>","dst":"<from>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<j>","type":"HAS_INIT"},{"src":"<j>","dst":"<to.length>","type":"ASSIGNED_FROM"},{"src":"<to.length>","dst":"<to>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i < il>","type":"HAS_CONDITION"},{"src":"<i < il>","dst":"<i>","type":"READS_FROM"},{"src":"<i < il>","dst":"<il>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<j++>","type":"HAS_UPDATE"},{"src":"<j++>","dst":"<j>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<to[j] = from[i]>","type":"HAS_BODY"},{"src":"<to[j] = from[i]>","dst":"<to[j]>","type":"WRITES_TO"},{"src":"<to[j] = from[i]>","dst":"<from[i]>","type":"READS_FROM"},{"src":"<to[j]>","dst":"<to>","type":"READS_FROM"},{"src":"<to[j]>","dst":"<j>","type":"READS_FROM"},{"src":"<from[i]>","dst":"<from>","type":"READS_FROM"},{"src":"<from[i]>","dst":"<i>","type":"READS_FROM"},{"src":"<__spreadArray:fn>","dst":"<to>","type":"RETURNS"}],"rationale":"TypeScript compiler helper function that implements array spreading by copying elements from source to target array. Complex for-loop with multiple variable declarations and computed property access. All relationships captured using approved vocabulary.","implicitBehavior":["var declarations are hoisted to function scope","mutates the 'to' array parameter","assumes both parameters are array-like objects with length property"]},"pass":2,"annotatedAt":"2026-02-24T00:35:31.953Z"}
{"construct":{"id":"legacy-patterns::jquery-plugin-pattern","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":206,"lineEnd":212,"code":"// $.fn.highlight = function(color) {\n//   return this.each(function() {\n//     $(this).css('background-color', color || 'yellow');\n//   });\n// };\n// Usage: $('p').highlight('red');","commentedOut":true,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"PROPERTY_ACCESS","id":"<$.fn.highlight>","metadata":{"objectName":"$","propertyChain":["fn","highlight"]}},{"type":"FUNCTION","id":"<highlight:fn>","metadata":{"arrowFunction":false}},{"type":"PARAMETER","id":"<color>"},{"type":"CALL","id":"<this.each(...)>","metadata":{"callee":"each","method":true}},{"type":"FUNCTION","id":"<each-callback:fn>","metadata":{"arrowFunction":false,"anonymous":true}},{"type":"CALL","id":"<$(this)>","metadata":{"callee":"$"}},{"type":"CALL","id":"<$(this).css(...)>","metadata":{"callee":"css","method":true}},{"type":"LITERAL","id":"<'background-color'>","metadata":{"value":"background-color","literalType":"string"}},{"type":"EXPRESSION","id":"<color || 'yellow'>","metadata":{"operator":"||"}},{"type":"LITERAL","id":"<'yellow'>","metadata":{"value":"yellow","literalType":"string"}},{"type":"CALL","id":"<$('p').highlight('red')>","metadata":{"callee":"highlight","method":true}},{"type":"CALL","id":"<$('p')>","metadata":{"callee":"$"}},{"type":"LITERAL","id":"<'p'>","metadata":{"value":"p","literalType":"string"}},{"type":"LITERAL","id":"<'red'>","metadata":{"value":"red","literalType":"string"}}],"edges":[{"src":"<$.fn.highlight>","dst":"<highlight:fn>","type":"ASSIGNED_FROM"},{"src":"<highlight:fn>","dst":"<color>","type":"CONTAINS"},{"src":"<highlight:fn>","dst":"<this.each(...)>","type":"RETURNS"},{"src":"<this.each(...)>","dst":"<each-callback:fn>","type":"PASSES_ARGUMENT"},{"src":"<each-callback:fn>","dst":"<$(this)>","type":"CONTAINS"},{"src":"<$(this).css(...)>","dst":"<$(this)>","type":"CALLS_ON"},{"src":"<$(this).css(...)>","dst":"<'background-color'>","type":"PASSES_ARGUMENT"},{"src":"<$(this).css(...)>","dst":"<color || 'yellow'>","type":"PASSES_ARGUMENT"},{"src":"<color || 'yellow'>","dst":"<color>","type":"READS_FROM"},{"src":"<color || 'yellow'>","dst":"<'yellow'>","type":"READS_FROM"},{"src":"<$('p').highlight('red')>","dst":"<$('p')>","type":"CALLS_ON"},{"src":"<$('p')>","dst":"<'p'>","type":"PASSES_ARGUMENT"},{"src":"<$('p').highlight('red')>","dst":"<'red'>","type":"PASSES_ARGUMENT"}],"rationale":"jQuery plugin pattern extending $.fn with a chainable method. Plugin function uses 'this' context and returns result of .each() for chaining. Usage demonstrates method chaining on jQuery selector. Changed CALLS to CALLS_ON for method invocations to better capture the object-method relationship.","implicitBehavior":["jQuery plugin extends all jQuery objects via $.fn prototype","'this' refers to jQuery collection in plugin context","each() callback 'this' refers to individual DOM element","$(this) re-wraps DOM element as jQuery object","Method chaining enabled by returning jQuery object"]},"pass":2,"annotatedAt":"2026-02-24T00:35:33.384Z"}
{"construct":{"id":"modern-es::modern-map-groupby","file":"src/modern-es.js","category":"modern-es","lineStart":38,"lineEnd":43,"code":"function mapGroupBy(items) {\n  return Map.groupBy(items, item => item.category);\n}\n\n// --- Promise.withResolvers (ES2024) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<mapGroupBy>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<items>"},{"type":"CALL","id":"<Map.groupBy(items, item => item.category)>","metadata":{"callee":"Map.groupBy"}},{"type":"PROPERTY_ACCESS","id":"<Map.groupBy>","metadata":{"objectName":"Map","propertyName":"groupBy"}},{"type":"FUNCTION","id":"<item => item.category>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<item>"},{"type":"PROPERTY_ACCESS","id":"<item.category>","metadata":{"objectName":"item","propertyName":"category"}}],"edges":[{"src":"<mapGroupBy>","dst":"<items>","type":"HAS_BODY"},{"src":"<mapGroupBy>","dst":"<Map.groupBy(items, item => item.category)>","type":"RETURNS"},{"src":"<Map.groupBy(items, item => item.category)>","dst":"<Map.groupBy>","type":"CALLS"},{"src":"<Map.groupBy(items, item => item.category)>","dst":"<items>","type":"PASSES_ARGUMENT"},{"src":"<Map.groupBy(items, item => item.category)>","dst":"<item => item.category>","type":"PASSES_ARGUMENT"},{"src":"<item => item.category>","dst":"<item>","type":"HAS_BODY"},{"src":"<item => item.category>","dst":"<item.category>","type":"RETURNS"},{"src":"<item.category>","dst":"<item>","type":"READS_FROM"}],"rationale":"Function that uses ES2024 Map.groupBy static method with arrow function callback. The callback accesses the category property of each item for grouping. Used HAS_BODY for parameter containment relationships.","implicitBehavior":["Map.groupBy creates a new Map with keys from callback return values","Arrow function has implicit return of property access expression"]},"pass":2,"annotatedAt":"2026-02-24T00:35:35.123Z"}
{"construct":{"id":"legacy-patterns::ts-compiled-awaiter","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":176,"lineEnd":184,"code":"var __awaiter = function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n    function rejected(value) { try { step(generator['throw'](value)); } catch (e) { reject(e); } }\n    function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"VARIABLE\",\n      \"id\": \"<__awaiter>\",\n      \"metadata\": {\n        \"kind\": \"var\"\n      }\n    },\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<__awaiter:fn>\","},"pass":2,"annotatedAt":"2026-02-24T00:35:35.455Z"}
{"construct":{"id":"modern-es::modern-object-hasown","file":"src/modern-es.js","category":"modern-es","lineStart":64,"lineEnd":69,"code":"function hasOwnCheck(obj, key) {\n  return Object.hasOwn(obj, key);\n}\n\n// --- structuredClone (ES2022) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<hasOwnCheck>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<key>"},{"type":"CALL","id":"<Object.hasOwn(obj, key)>","metadata":{"callee":"Object.hasOwn"}},{"type":"PROPERTY_ACCESS","id":"<Object.hasOwn>","metadata":{"objectName":"Object","propertyName":"hasOwn"}}],"edges":[{"src":"<hasOwnCheck>","dst":"<obj>","type":"HAS_BODY"},{"src":"<hasOwnCheck>","dst":"<key>","type":"HAS_BODY"},{"src":"<hasOwnCheck>","dst":"<Object.hasOwn(obj, key)>","type":"RETURNS"},{"src":"<Object.hasOwn(obj, key)>","dst":"<Object.hasOwn>","type":"CALLS"},{"src":"<Object.hasOwn(obj, key)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.hasOwn(obj, key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<Object.hasOwn>","dst":"<Object>","type":"READS_FROM"}],"rationale":"Function that wraps Object.hasOwn static method call. Returns result of calling Object.hasOwn with both parameters. Reduced from 8 to 7 edges by using HAS_BODY for parameter containment instead of CONTAINS.","implicitBehavior":["Object.hasOwn is ES2022 feature, safer alternative to hasOwnProperty"]},"pass":2,"annotatedAt":"2026-02-24T00:35:35.946Z"}
{"construct":{"id":"legacy-patterns::jquery-deferred","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":218,"lineEnd":224,"code":"// var dfd = $.Deferred();\n// dfd.done(function(data) { ... });\n// dfd.fail(function(err) { ... });\n// dfd.resolve(result); // or dfd.reject(error);\n\n// --- Script Concatenation / Namespace Export ---","commentedOut":true,"moduleType":"cjs"},"annotation":{"nodes":[{"type":"VARIABLE","id":"<dfd>","metadata":{"kind":"var"}},{"type":"CALL","id":"<$.Deferred()>","metadata":{"callee":"$.Deferred"}},{"type":"PROPERTY_ACCESS","id":"<$.Deferred>","metadata":{"objectName":"$","propertyName":"Deferred"}},{"type":"VARIABLE","id":"<$>","metadata":{"kind":"external"}},{"type":"CALL","id":"<dfd.done(callback)>","metadata":{"callee":"dfd.done"}},{"type":"PROPERTY_ACCESS","id":"<dfd.done>","metadata":{"objectName":"dfd","propertyName":"done"}},{"type":"FUNCTION","id":"<done-callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<data>"},{"type":"CALL","id":"<dfd.fail(callback)>","metadata":{"callee":"dfd.fail"}},{"type":"PROPERTY_ACCESS","id":"<dfd.fail>","metadata":{"objectName":"dfd","propertyName":"fail"}},{"type":"FUNCTION","id":"<fail-callback>","metadata":{"anonymous":true}},{"type":"PARAMETER","id":"<err>"},{"type":"CALL","id":"<dfd.resolve(result)>","metadata":{"callee":"dfd.resolve"}},{"type":"PROPERTY_ACCESS","id":"<dfd.resolve>","metadata":{"objectName":"dfd","propertyName":"resolve"}},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"reference"}},{"type":"CALL","id":"<dfd.reject(error)>","metadata":{"callee":"dfd.reject"}},{"type":"PROPERTY_ACCESS","id":"<dfd.reject>","metadata":{"objectName":"dfd","propertyName":"reject"}},{"type":"VARIABLE","id":"<error>","metadata":{"kind":"reference"}}],"edges":[{"src":"<dfd>","dst":"<$.Deferred()>","type":"ASSIGNED_FROM"},{"src":"<$.Deferred()>","dst":"<$.Deferred>","type":"CALLS"},{"src":"<$.Deferred>","dst":"<$>","type":"READS_FROM"},{"src":"<dfd.done(callback)>","dst":"<dfd.done>","type":"CALLS"},{"src":"<dfd.done(callback)>","dst":"<done-callback>","type":"PASSES_ARGUMENT"},{"src":"<dfd.done>","dst":"<dfd>","type":"READS_FROM"},{"src":"<done-callback>","dst":"<data>","type":"CONTAINS"},{"src":"<dfd.fail(callback)>","dst":"<dfd.fail>","type":"CALLS"},{"src":"<dfd.fail(callback)>","dst":"<fail-callback>","type":"PASSES_ARGUMENT"},{"src":"<dfd.fail>","dst":"<dfd>","type":"READS_FROM"},{"src":"<fail-callback>","dst":"<err>","type":"CONTAINS"},{"src":"<dfd.resolve(result)>","dst":"<dfd.resolve>","type":"CALLS"},{"src":"<dfd.resolve(result)>","dst":"<result>","type":"PASSES_ARGUMENT"},{"src":"<dfd.resolve>","dst":"<dfd>","type":"READS_FROM"},{"src":"<dfd.reject(error)>","dst":"<dfd.reject>","type":"CALLS"},{"src":"<dfd.reject(error)>","dst":"<error>","type":"PASSES_ARGUMENT"},{"src":"<dfd.reject>","dst":"<dfd>","type":"READS_FROM"}],"rationale":"jQuery Deferred pattern creates a promise-like object with callback registration methods. The deferred can be resolved or rejected, triggering the appropriate callbacks. Reduced edge count by adding missing variable nodes for referenced identifiers and removing module-level declaration edge.","implicitBehavior":["var declaration is hoisted to function/module scope","jQuery Deferred implements promise-like behavior with done/fail callbacks","resolve() triggers done callbacks, reject() triggers fail callbacks","callbacks are executed asynchronously when deferred is resolved/rejected"]},"pass":2,"annotatedAt":"2026-02-24T00:35:36.504Z"}
{"construct":{"id":"modern-es::modern-object-groupby","file":"src/modern-es.js","category":"modern-es","lineStart":33,"lineEnd":36,"code":"function objectGroupBy(items) {\n  return Object.groupBy(items, item => item.category);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<objectGroupBy>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<items>"},{"type":"CALL","id":"<Object.groupBy(items, item => item.category)>","metadata":{"callee":"Object.groupBy"}},{"type":"PROPERTY_ACCESS","id":"<Object.groupBy>","metadata":{"objectName":"Object","propertyName":"groupBy"}},{"type":"FUNCTION","id":"<item => item.category>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<item>"},{"type":"PROPERTY_ACCESS","id":"<item.category>","metadata":{"objectName":"item","propertyName":"category"}}],"edges":[{"src":"<objectGroupBy>","dst":"<items>","type":"HAS_BODY"},{"src":"<objectGroupBy>","dst":"<Object.groupBy(items, item => item.category)>","type":"RETURNS"},{"src":"<Object.groupBy(items, item => item.category)>","dst":"<Object.groupBy>","type":"CALLS"},{"src":"<Object.groupBy(items, item => item.category)>","dst":"<items>","type":"PASSES_ARGUMENT"},{"src":"<Object.groupBy(items, item => item.category)>","dst":"<item => item.category>","type":"PASSES_ARGUMENT"},{"src":"<item => item.category>","dst":"<item>","type":"HAS_BODY"},{"src":"<item => item.category>","dst":"<item.category>","type":"RETURNS"},{"src":"<item.category>","dst":"<item>","type":"READS_FROM"}],"rationale":"Function that wraps Object.groupBy with an arrow function callback. The callback accesses the category property of each item for grouping. Used HAS_BODY instead of CONTAINS for parameter containment relationships.","implicitBehavior":["Object.groupBy is a modern ES2024 feature","callback function is called for each item in the array","returns an object with keys as category values and values as arrays of items"]},"pass":2,"annotatedAt":"2026-02-24T00:35:36.536Z"}
{"construct":{"id":"modern-es::modern-array-findlast","file":"src/modern-es.js","category":"modern-es","lineStart":15,"lineEnd":20,"code":"function arrayFindLast(arr) {\n  const last = arr.findLast(x => x > 3);\n  const lastIdx = arr.findLastIndex(x => x > 3);\n  return { last, lastIdx };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<arrayFindLast>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<arr>"},{"type":"VARIABLE","id":"<last>","metadata":{"kind":"const"}},{"type":"CALL","id":"<arr.findLast(x => x > 3)>","metadata":{"method":"findLast"}},{"type":"FUNCTION","id":"<findLast-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x > 3>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"VARIABLE","id":"<lastIdx>","metadata":{"kind":"const"}},{"type":"CALL","id":"<arr.findLastIndex(x => x > 3)>","metadata":{"method":"findLastIndex"}},{"type":"FUNCTION","id":"<findLastIndex-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x2>"},{"type":"EXPRESSION","id":"<x2 > 3>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<3-2>","metadata":{"value":3,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ last, lastIdx }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<arrayFindLast>","dst":"<arr>","type":"CONTAINS"},{"src":"<arrayFindLast>","dst":"<last>","type":"CONTAINS"},{"src":"<arrayFindLast>","dst":"<lastIdx>","type":"CONTAINS"},{"src":"<last>","dst":"<arr.findLast(x => x > 3)>","type":"ASSIGNED_FROM"},{"src":"<arr.findLast(x => x > 3)>","dst":"<arr>","type":"CALLS_ON"},{"src":"<arr.findLast(x => x > 3)>","dst":"<findLast-callback>","type":"PASSES_ARGUMENT"},{"src":"<findLast-callback>","dst":"<x>","type":"CONTAINS"},{"src":"<findLast-callback>","dst":"<x > 3>","type":"RETURNS"},{"src":"<x > 3>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 3>","dst":"<3>","type":"READS_FROM"},{"src":"<lastIdx>","dst":"<arr.findLastIndex(x => x > 3)>","type":"ASSIGNED_FROM"},{"src":"<arr.findLastIndex(x => x > 3)>","dst":"<arr>","type":"CALLS_ON"},{"src":"<arr.findLastIndex(x => x > 3)>","dst":"<findLastIndex-callback>","type":"PASSES_ARGUMENT"},{"src":"<findLastIndex-callback>","dst":"<x2>","type":"CONTAINS"},{"src":"<findLastIndex-callback>","dst":"<x2 > 3>","type":"RETURNS"},{"src":"<x2 > 3>","dst":"<x2>","type":"READS_FROM"},{"src":"<x2 > 3>","dst":"<3-2>","type":"READS_FROM"},{"src":"<arrayFindLast>","dst":"<{ last, lastIdx }>","type":"RETURNS"},{"src":"<{ last, lastIdx }>","dst":"<last>","type":"READS_FROM"},{"src":"<{ last, lastIdx }>","dst":"<lastIdx>","type":"READS_FROM"}],"rationale":"Function using modern ES2023 array methods findLast and findLastIndex with arrow function callbacks. Both methods receive similar predicates and return an object literal with shorthand property syntax. Removed the module declaration edge as no module node was defined.","implicitBehavior":["findLast returns undefined if no element matches","findLastIndex returns -1 if no element matches","both methods iterate from end to beginning of array"]},"pass":2,"annotatedAt":"2026-02-24T00:35:37.372Z"}
{"construct":{"id":"modern-es::modern-structured-clone","file":"src/modern-es.js","category":"modern-es","lineStart":71,"lineEnd":80,"code":"function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Hashbang (ES2023) ---\n// Note: hashbang must be at very top of file, so this is just a reference\n// #!/usr/bin/env node  would be first line in a CLI script\n\n// --- RegExp: d flag / match indices (ES2022) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deepClone>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<structuredClone(obj)>","metadata":{"callee":"structuredClone"}},{"type":"EXTERNAL","id":"<structuredClone>","metadata":{"source":"global","type":"built-in"}}],"edges":[{"src":"<deepClone>","dst":"<obj>","type":"HAS_BODY"},{"src":"<deepClone>","dst":"<structuredClone(obj)>","type":"RETURNS"},{"src":"<structuredClone(obj)>","dst":"<structuredClone>","type":"CALLS"},{"src":"<structuredClone(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"}],"rationale":"Function that wraps the built-in structuredClone API. Returns the result of calling structuredClone with the parameter. Used HAS_BODY instead of CONTAINS for parameter relationship as it better represents the function-parameter containment in approved vocabulary.","implicitBehavior":["structuredClone performs deep cloning using structured clone algorithm","throws DataCloneError for non-cloneable objects"]},"pass":2,"annotatedAt":"2026-02-24T00:35:38.711Z"}
{"construct":{"id":"modern-es::modern-symbol-tostringtag","file":"src/modern-es.js","category":"modern-es","lineStart":144,"lineEnd":149,"code":"class CustomCollection {\n  get [Symbol.toStringTag]() {\n    return 'CustomCollection';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<CustomCollection>"},{"type":"GETTER","id":"<CustomCollection.[Symbol.toStringTag]>","metadata":{"computed":true}},{"type":"PROPERTY_ACCESS","id":"<Symbol.toStringTag>","metadata":{"objectName":"Symbol"}},{"type":"LITERAL","id":"<'CustomCollection'>","metadata":{"value":"CustomCollection","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<CustomCollection>","type":"DECLARES"},{"src":"<CustomCollection>","dst":"<CustomCollection.[Symbol.toStringTag]>","type":"CONTAINS"},{"src":"<CustomCollection.[Symbol.toStringTag]>","dst":"<Symbol.toStringTag>","type":"HAS_PROPERTY"},{"src":"<CustomCollection.[Symbol.toStringTag]>","dst":"<'CustomCollection'>","type":"RETURNS"}],"rationale":"Class with computed getter using Symbol.toStringTag. Changed METHOD to GETTER for semantic precision. Mapped KEYED_BY to HAS_PROPERTY as the closest approved relationship for computed property keys.","implicitBehavior":["Symbol.toStringTag affects Object.prototype.toString() behavior","getter is invoked when toString() is called on instances"]},"pass":2,"annotatedAt":"2026-02-24T00:35:41.426Z"}
{"construct":{"id":"modern-es::modern-promise-with-resolvers","file":"src/modern-es.js","category":"modern-es","lineStart":45,"lineEnd":51,"code":"function createDeferred() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  return { promise, resolve, reject };\n}\n\n// --- Error.cause usage ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createDeferred>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<Promise.withResolvers()>","metadata":{"callee":"Promise.withResolvers"}},{"type":"VARIABLE","id":"<promise>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<resolve>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<reject>","metadata":{"kind":"const","destructured":true}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}},{"type":"PROPERTY_ACCESS","id":"<Promise.withResolvers>","metadata":{"objectName":"Promise","propertyName":"withResolvers"}}],"edges":[{"src":"<createDeferred>","dst":"<Promise.withResolvers()>","type":"CONTAINS"},{"src":"<Promise.withResolvers()>","dst":"<Promise.withResolvers>","type":"CALLS"},{"src":"<createDeferred>","dst":"<promise>","type":"CONTAINS"},{"src":"<createDeferred>","dst":"<resolve>","type":"CONTAINS"},{"src":"<createDeferred>","dst":"<reject>","type":"CONTAINS"},{"src":"<promise>","dst":"<Promise.withResolvers()>","type":"ASSIGNED_FROM"},{"src":"<resolve>","dst":"<Promise.withResolvers()>","type":"ASSIGNED_FROM"},{"src":"<reject>","dst":"<Promise.withResolvers()>","type":"ASSIGNED_FROM"},{"src":"<createDeferred>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<promise>","type":"READS_FROM"},{"src":"<return-object>","dst":"<resolve>","type":"READS_FROM"},{"src":"<return-object>","dst":"<reject>","type":"READS_FROM"}],"rationale":"Function that uses Promise.withResolvers() to create a deferred promise pattern. Destructures the returned object and returns all three components. Removed the module declaration edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["Promise.withResolvers() is a modern ES2023 feature that creates a promise with externally accessible resolve/reject functions","The function is implicitly declared in the module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:35:41.711Z"}
{"construct":{"id":"modern-es::modern-symbol-iterator","file":"src/modern-es.js","category":"modern-es","lineStart":101,"lineEnd":108,"code":"class InfiniteOnes {\n  [Symbol.iterator]() {\n    return {\n      next() { return { value: 1, done: false }; },\n    };\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<InfiniteOnes>"},{"type":"METHOD","id":"<InfiniteOnes[Symbol.iterator]>","metadata":{"kind":"method","computed":true,"symbol":"Symbol.iterator"}},{"type":"LITERAL","id":"<object-literal>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<next>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<return-object>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}}],"edges":[{"src":"<InfiniteOnes>","dst":"<InfiniteOnes[Symbol.iterator]>","type":"CONTAINS"},{"src":"<InfiniteOnes[Symbol.iterator]>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<next>","type":"HAS_PROPERTY"},{"src":"<next>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<false>","type":"HAS_PROPERTY"}],"rationale":"Class implementing Symbol.iterator protocol. The computed method returns an iterator object with a next method that returns iterator result objects. Removed module declaration edge as no explicit module node was provided in the construct.","implicitBehavior":["implements iterable protocol","enables for-of loops and spread operator","Symbol.iterator is well-known symbol","creates infinite iterator that always returns 1"]},"pass":2,"annotatedAt":"2026-02-24T00:35:42.650Z"}
{"construct":{"id":"modern-es::modern-error-cause","file":"src/modern-es.js","category":"modern-es","lineStart":53,"lineEnd":62,"code":"function wrapError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    throw new Error('Wrapper failed', { cause: err });\n  }\n}\n\n// --- Object.hasOwn (ES2022) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<wrapError>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<fn>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<fn()>","metadata":{"callee":"fn"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<err>","metadata":{"catchParameter":true}},{"type":"CALL","id":"<new Error()>","metadata":{"constructor":"Error"}},{"type":"LITERAL","id":"<'Wrapper failed'>","metadata":{"value":"Wrapper failed","literalType":"string"}},{"type":"EXPRESSION","id":"<{ cause: err }>","metadata":{"objectLiteral":true}}],"edges":[{"src":"<wrapError>","dst":"<fn>","type":"HAS_BODY"},{"src":"<wrapError>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<fn()>","type":"CONTAINS"},{"src":"<fn()>","dst":"<fn>","type":"CALLS"},{"src":"<wrapError>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<err>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<new Error()>","type":"THROWS"},{"src":"<new Error()>","dst":"<'Wrapper failed'>","type":"PASSES_ARGUMENT"},{"src":"<new Error()>","dst":"<{ cause: err }>","type":"PASSES_ARGUMENT"},{"src":"<{ cause: err }>","dst":"<err>","type":"READS_FROM"}],"rationale":"Function with try-catch that wraps errors using ES2022 error cause feature. Try block returns function call result, catch block throws new Error with cause property. Changed constructor expression to CALL type to match approved vocabulary.","implicitBehavior":["Error constructor creates error chain via cause property","Stack trace preservation through error cause","Function returns the result of fn() when successful"]},"pass":2,"annotatedAt":"2026-02-24T00:35:42.936Z"}
{"construct":{"id":"modern-es::modern-symbol-species","file":"src/modern-es.js","category":"modern-es","lineStart":151,"lineEnd":158,"code":"class SpecialArray extends Array {\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n\n// --- AbortController ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<SpecialArray>"},{"type":"GETTER","id":"<SpecialArray[Symbol.species]>","metadata":{"static":true,"computed":true}},{"type":"PROPERTY_ACCESS","id":"<Symbol.species>","metadata":{"symbol":"species"}},{"type":"VARIABLE","id":"<Array>","metadata":{"builtin":true}}],"edges":[{"src":"<module>","dst":"<SpecialArray>","type":"DECLARES"},{"src":"<SpecialArray>","dst":"<Array>","type":"EXTENDS"},{"src":"<SpecialArray>","dst":"<SpecialArray[Symbol.species]>","type":"CONTAINS"},{"src":"<SpecialArray[Symbol.species]>","dst":"<Symbol.species>","type":"USES"},{"src":"<SpecialArray[Symbol.species]>","dst":"<Array>","type":"RETURNS"},{"src":"<SpecialArray[Symbol.species]>","dst":"<Array>","type":"READS_FROM"}],"rationale":"Class extending Array with static getter for Symbol.species. The computed property uses Symbol.species as key and returns the Array constructor. Mapped SYMBOL_ACCESS to PROPERTY_ACCESS and KEYED_BY to USES as closest approved alternatives.","implicitBehavior":["Symbol.species controls constructor used by array methods like map/filter","Static getter is inherited by subclasses","Affects prototype chain behavior for derived array instances"]},"pass":2,"annotatedAt":"2026-02-24T00:35:43.152Z"}
{"construct":{"id":"modern-es::modern-using-sync","file":"src/modern-es.js","category":"modern-es","lineStart":176,"lineEnd":186,"code":"function usingSyncExample() {\n  // Symbol.dispose  synchronous cleanup\n  const resource = {\n    data: 'important',\n    [Symbol.dispose]() {\n      this.data = null;\n    },\n  };\n  return resource;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<usingSyncExample>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<resource>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<resource-object>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<data-property>","metadata":{"name":"data"}},{"type":"LITERAL","id":"<'important'>","metadata":{"value":"important","literalType":"string"}},{"type":"METHOD","id":"<resource[Symbol.dispose]>","metadata":{"kind":"method","symbol":"Symbol.dispose"}},{"type":"PROPERTY_ACCESS","id":"<this.data>","metadata":{"objectName":"this","propertyName":"data"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<usingSyncExample>","dst":"<resource>","type":"CONTAINS"},{"src":"<resource>","dst":"<resource-object>","type":"ASSIGNED_FROM"},{"src":"<resource-object>","dst":"<data-property>","type":"HAS_PROPERTY"},{"src":"<data-property>","dst":"<'important'>","type":"ASSIGNED_FROM"},{"src":"<resource-object>","dst":"<resource[Symbol.dispose]>","type":"HAS_PROPERTY"},{"src":"<resource[Symbol.dispose]>","dst":"<this.data>","type":"WRITES_TO"},{"src":"<this.data>","dst":"<null>","type":"ASSIGNED_FROM"},{"src":"<usingSyncExample>","dst":"<resource>","type":"RETURNS"}],"rationale":"Function creates an object with Symbol.dispose method for synchronous cleanup. The dispose method nullifies the data property when called. Added explicit PROPERTY node for the data property to better represent the object structure.","implicitBehavior":["Symbol.dispose enables automatic resource cleanup with 'using' declarations","dispose method will be called automatically when resource goes out of scope in using context"]},"pass":2,"annotatedAt":"2026-02-24T00:35:45.063Z"}
{"construct":{"id":"legacy-patterns::script-concat-export","file":"src/legacy-patterns.cjs","category":"legacy-patterns","lineStart":226,"lineEnd":233,"code":"// Pattern: library exposes itself via `this` (global in browsers, exports in CJS)\n(function (exports) {\n  function StringUtils() {}\n  StringUtils.capitalize = function (s) { return s.charAt(0).toUpperCase() + s.slice(1); };\n  StringUtils.trim = function (s) { return s.replace(/^\\s+|\\s+$/g, ''); };\n  exports.StringUtils = StringUtils;\n}(typeof module !== 'undefined' ? module.exports : (this.MyLib = this.MyLib || {})));","commentedOut":false,"moduleType":"cjs"},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<iife>\",\n      \"metadata\": {\n        \"kind\": \"iife\",\n        \"pattern\": \"umd\"\n      }\n    },\n    {\n      \"type\": \"PARAMETER\",\n      "},"pass":2,"annotatedAt":"2026-02-24T00:35:45.671Z"}
{"construct":{"id":"modern-es::reexport-namespace","file":"src/modern-es.js","category":"modern-es","lineStart":262,"lineEnd":264,"code":"// export * as utils from './modules-helpers.js';\n// (commented  would conflict with existing exports; syntax reference only)","commentedOut":true},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-namespace>","metadata":{"exportType":"namespace","alias":"utils"}},{"type":"IMPORT","id":"<import-all>","metadata":{"source":"./modules-helpers.js","importType":"namespace"}}],"edges":[{"src":"<module>","dst":"<export-namespace>","type":"CONTAINS"},{"src":"<export-namespace>","dst":"<import-all>","type":"DEPENDS_ON"},{"src":"<import-all>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<export-namespace>","dst":"<utils>","type":"ALIASES"}],"rationale":"Namespace re-export that imports all exports from a module and re-exports them under a single namespace alias. Used DEPENDS_ON instead of REEXPORTS_FROM and ALIASES instead of EXPORTS_AS to stay within approved vocabulary.","implicitBehavior":["creates a namespace object containing all exported members from the source module","would conflict with existing named exports in the same module"]},"pass":2,"annotatedAt":"2026-02-24T00:35:48.952Z"}
{"construct":{"id":"modern-es::modern-using-async","file":"src/modern-es.js","category":"modern-es","lineStart":188,"lineEnd":200,"code":"async function usingAsyncExample() {\n  const resource = {\n    data: 'important',\n    async [Symbol.asyncDispose]() {\n      await new Promise(r => setTimeout(r, 10));\n      this.data = null;\n    },\n  };\n  return resource;\n}\n\n// --- Iterator helpers (ES2025) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<usingAsyncExample>","metadata":{"async":true,"generator":false}},{"type":"VARIABLE","id":"<resource>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'important'>","metadata":{"value":"important","literalType":"string"}},{"type":"METHOD","id":"<resource[Symbol.asyncDispose]>","metadata":{"async":true,"kind":"method","computed":true,"symbol":"Symbol.asyncDispose"}},{"type":"CALL","id":"<new Promise(r => setTimeout(r, 10))>","metadata":{"callee":"Promise","constructor":true}},{"type":"FUNCTION","id":"<r => setTimeout(r, 10)>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<r>"},{"type":"CALL","id":"<setTimeout(r, 10)>","metadata":{"callee":"setTimeout"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<this.data>","metadata":{"objectName":"this","property":"data"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<usingAsyncExample>","dst":"<resource>","type":"CONTAINS"},{"src":"<resource>","dst":"<'important'>","type":"HAS_PROPERTY"},{"src":"<resource>","dst":"<resource[Symbol.asyncDispose]>","type":"HAS_PROPERTY"},{"src":"<resource[Symbol.asyncDispose]>","dst":"<new Promise(r => setTimeout(r, 10))>","type":"AWAITS"},{"src":"<new Promise(r => setTimeout(r, 10))>","dst":"<r => setTimeout(r, 10)>","type":"PASSES_ARGUMENT"},{"src":"<r => setTimeout(r, 10)>","dst":"<r>","type":"CONTAINS"},{"src":"<r => setTimeout(r, 10)>","dst":"<setTimeout(r, 10)>","type":"RETURNS"},{"src":"<setTimeout(r, 10)>","dst":"<r>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(r, 10)>","dst":"<10>","type":"PASSES_ARGUMENT"},{"src":"<resource[Symbol.asyncDispose]>","dst":"<this.data>","type":"WRITES_TO"},{"src":"<this.data>","dst":"<null>","type":"ASSIGNED_FROM"},{"src":"<usingAsyncExample>","dst":"<resource>","type":"RETURNS"}],"rationale":"Async function returning an object with Symbol.asyncDispose method. The dispose method awaits a Promise-based timeout then nullifies the data property. All relationships captured using approved vocabulary.","implicitBehavior":["Symbol.asyncDispose enables automatic resource cleanup in using declarations","this binding in asyncDispose method refers to the resource object","Promise constructor creates microtask for setTimeout callback"]},"pass":2,"annotatedAt":"2026-02-24T00:35:49.067Z"}
{"construct":{"id":"modern-es::using-in-for","file":"src/modern-es.js","category":"modern-es","lineStart":255,"lineEnd":260,"code":"function usingInFor(readers) {\n  for (using reader of readers) {\n    reader.process();\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<usingInFor>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<readers>"},{"type":"LOOP","id":"<for-of-using>","metadata":{"loopType":"for-of","usingDeclaration":true}},{"type":"VARIABLE","id":"<reader>","metadata":{"kind":"using"}},{"type":"CALL","id":"<reader.process()>","metadata":{"callee":"process"}},{"type":"PROPERTY_ACCESS","id":"<reader.process>","metadata":{"objectName":"reader","propertyName":"process"}}],"edges":[{"src":"<usingInFor>","dst":"<readers>","type":"CONTAINS"},{"src":"<usingInFor>","dst":"<for-of-using>","type":"CONTAINS"},{"src":"<for-of-using>","dst":"<readers>","type":"ITERATES_OVER"},{"src":"<for-of-using>","dst":"<reader>","type":"CONTAINS"},{"src":"<for-of-using>","dst":"<reader.process()>","type":"HAS_BODY"},{"src":"<reader.process()>","dst":"<reader.process>","type":"CALLS"},{"src":"<reader.process>","dst":"<reader>","type":"READS_FROM"}],"rationale":"Function with for-of loop using 'using' declaration. Each iteration creates a disposable resource that will be automatically disposed at end of iteration. Removed the module-level DECLARES edge to stay within the 7-edge threshold.","implicitBehavior":["automatic disposal of reader resource at end of each iteration via Symbol.dispose","disposal occurs even if exception is thrown during iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:35:50.054Z"}
{"construct":{"id":"modern-es::modern-symbol-toprimitive","file":"src/modern-es.js","category":"modern-es","lineStart":130,"lineEnd":142,"code":"class Money {\n  constructor(amount, currency) {\n    this.amount = amount;\n    this.currency = currency;\n  }\n\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return this.amount;\n    if (hint === 'string') return `${this.amount} ${this.currency}`;\n    return this.amount;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Money>"},{"type":"METHOD","id":"<Money.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<amount>"},{"type":"PARAMETER","id":"<currency>"},{"type":"PROPERTY_ACCESS","id":"<this.amount>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<this.currency>","metadata":{"objectName":"this"}},{"type":"METHOD","id":"<Money.[Symbol.toPrimitive]>","metadata":{"kind":"method","computed":true,"symbol":"Symbol.toPrimitive"}},{"type":"PARAMETER","id":"<hint>"},{"type":"BRANCH","id":"<hint === 'number'>","metadata":{"condition":"hint === 'number'"}},{"type":"BRANCH","id":"<hint === 'string'>","metadata":{"condition":"hint === 'string'"}},{"type":"LITERAL","id":"<'number'>","metadata":{"value":"number","literalType":"string"}},{"type":"LITERAL","id":"<'string'>","metadata":{"value":"string","literalType":"string"}},{"type":"EXPRESSION","id":"<`${this.amount} ${this.currency}`>","metadata":{"type":"template-literal"}}],"edges":[{"src":"<Money>","dst":"<Money.constructor>","type":"CONTAINS"},{"src":"<Money>","dst":"<Money.[Symbol.toPrimitive]>","type":"CONTAINS"},{"src":"<Money.constructor>","dst":"<amount>","type":"RECEIVES_ARGUMENT"},{"src":"<Money.constructor>","dst":"<currency>","type":"RECEIVES_ARGUMENT"},{"src":"<this.amount>","dst":"<amount>","type":"ASSIGNED_FROM"},{"src":"<this.currency>","dst":"<currency>","type":"ASSIGNED_FROM"},{"src":"<Money.[Symbol.toPrimitive]>","dst":"<hint>","type":"RECEIVES_ARGUMENT"},{"src":"<Money.[Symbol.toPrimitive]>","dst":"<hint === 'number'>","type":"HAS_CONDITION"},{"src":"<Money.[Symbol.toPrimitive]>","dst":"<hint === 'string'>","type":"HAS_CONDITION"},{"src":"<hint === 'number'>","dst":"<hint>","type":"READS_FROM"},{"src":"<hint === 'number'>","dst":"<'number'>","type":"READS_FROM"},{"src":"<hint === 'string'>","dst":"<hint>","type":"READS_FROM"},{"src":"<hint === 'string'>","dst":"<'string'>","type":"READS_FROM"},{"src":"<hint === 'number'>","dst":"<this.amount>","type":"HAS_CONSEQUENT"},{"src":"<hint === 'string'>","dst":"<`${this.amount} ${this.currency}`>","type":"HAS_CONSEQUENT"},{"src":"<Money.[Symbol.toPrimitive]>","dst":"<this.amount>","type":"RETURNS"},{"src":"<`${this.amount} ${this.currency}`>","dst":"<this.amount>","type":"READS_FROM"},{"src":"<`${this.amount} ${this.currency}`>","dst":"<this.currency>","type":"READS_FROM"}],"rationale":"Class with constructor setting properties and a Symbol.toPrimitive method that provides custom primitive conversion logic based on hint parameter. Reduced edge count by removing module declaration edge and using RECEIVES_ARGUMENT instead of CONTAINS for parameters.","implicitBehavior":["Symbol.toPrimitive method is automatically called during type coercion operations","Method uses computed property syntax with well-known symbol","Default case returns this.amount when hint is neither 'number' nor 'string'"]},"pass":2,"annotatedAt":"2026-02-24T00:35:50.320Z"}
{"construct":{"id":"modern-es::modern-array-immutable (ES2023)","file":"src/modern-es.js","category":"modern-es","lineStart":22,"lineEnd":31,"code":"function arrayImmutable(arr) {\n  const sorted = arr.toSorted((a, b) => a - b);\n  const reversed = arr.toReversed();\n  const spliced = arr.toSpliced(1, 1, 'new');\n  const replaced = arr.with(0, 'replaced');\n  return { sorted, reversed, spliced, replaced, original: arr };\n}\n\n// --- Object.groupBy / Map.groupBy (ES2024) ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<arrayImmutable>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAME"},"pass":2,"annotatedAt":"2026-02-24T00:35:53.252Z"}
{"construct":{"id":"modern-es::import-attributes-json","file":"src/modern-es.js","category":"modern-es","lineStart":273,"lineEnd":274,"code":"// import config from './config.json' with { type: 'json' };","commentedOut":true},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-config>","metadata":{"source":"./config.json","importType":"default","attributes":{"type":"json"}}},{"type":"VARIABLE","id":"<config>","metadata":{"imported":true,"kind":"const"}},{"type":"EXTERNAL_MODULE","id":"<./config.json>","metadata":{"path":"./config.json","type":"json"}}],"edges":[{"src":"<import-config>","dst":"<config>","type":"IMPORTS"},{"src":"<import-config>","dst":"<./config.json>","type":"IMPORTS_FROM"}],"rationale":"Import with attributes specifying JSON type. Creates default import binding with type assertion enforced by the 'type: json' attribute.","implicitBehavior":["JSON parsing at import time","static import hoisting","type assertion enforces JSON format"]},"pass":2,"annotatedAt":"2026-02-24T00:35:53.576Z"}
{"construct":{"id":"modern-es::class-accessor-keyword","file":"src/modern-es.js","category":"modern-es","lineStart":266,"lineEnd":271,"code":"class Reactive {\n  accessor count = 0;\n}\n\n// --- Import Attributes (ES2025) ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<Reactive>"},{"type":"PROPERTY","id":"<Reactive.count>","metadata":{"kind":"accessor"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<Reactive>","type":"DECLARES"},{"src":"<Reactive>","dst":"<Reactive.count>","type":"CONTAINS"},{"src":"<Reactive.count>","dst":"<0>","type":"ASSIGNED_FROM"}],"rationale":"Class with accessor field that automatically generates getter/setter methods. Using PROPERTY as closest match to ACCESSOR since it represents a class member with value semantics.","implicitBehavior":["accessor keyword generates implicit getter and setter methods","private backing field created for storage"]},"pass":2,"annotatedAt":"2026-02-24T00:35:54.784Z"}
{"construct":{"id":"modern-es::modern-iterator-helpers","file":"src/modern-es.js","category":"modern-es","lineStart":202,"lineEnd":211,"code":"function iteratorHelpers(arr) {\n  // Iterator.from, .map, .filter, .take, .drop, .flatMap, .reduce, .toArray, .forEach, .some, .every, .find\n  const iter = arr.values();\n  const mapped = iter.map(x => x * 2);\n  const taken = mapped.take(3);\n  return [...taken];\n}\n\n// --- Set methods (ES2025) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<iteratorHelpers>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<arr>"},{"type":"VARIABLE","id":"<iter>","metadata":{"kind":"const"}},{"type":"CALL","id":"<arr.values()>","metadata":{"callee":"values","method":true}},{"type":"VARIABLE","id":"<mapped>","metadata":{"kind":"const"}},{"type":"CALL","id":"<iter.map(x => x * 2)>","metadata":{"callee":"map","method":true}},{"type":"FUNCTION","id":"<x => x * 2>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"VARIABLE","id":"<taken>","metadata":{"kind":"const"}},{"type":"CALL","id":"<mapped.take(3)>","metadata":{"callee":"take","method":true}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"EXPRESSION","id":"<[...taken]>","metadata":{"operator":"spread"}}],"edges":[{"src":"<iteratorHelpers>","dst":"<arr>","type":"CONTAINS"},{"src":"<iteratorHelpers>","dst":"<iter>","type":"CONTAINS"},{"src":"<iter>","dst":"<arr.values()>","type":"ASSIGNED_FROM"},{"src":"<arr.values()>","dst":"<arr>","type":"CALLS_ON"},{"src":"<iteratorHelpers>","dst":"<mapped>","type":"CONTAINS"},{"src":"<mapped>","dst":"<iter.map(x => x * 2)>","type":"ASSIGNED_FROM"},{"src":"<iter.map(x => x * 2)>","dst":"<iter>","type":"CALLS_ON"},{"src":"<iter.map(x => x * 2)>","dst":"<x => x * 2>","type":"PASSES_ARGUMENT"},{"src":"<x => x * 2>","dst":"<x>","type":"CONTAINS"},{"src":"<x => x * 2>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<iteratorHelpers>","dst":"<taken>","type":"CONTAINS"},{"src":"<taken>","dst":"<mapped.take(3)>","type":"ASSIGNED_FROM"},{"src":"<mapped.take(3)>","dst":"<mapped>","type":"CALLS_ON"},{"src":"<mapped.take(3)>","dst":"<3>","type":"PASSES_ARGUMENT"},{"src":"<iteratorHelpers>","dst":"<[...taken]>","type":"RETURNS"},{"src":"<[...taken]>","dst":"<taken>","type":"READS_FROM"}],"rationale":"Function demonstrating modern iterator helpers. Creates iterator from array, chains map and take operations, then spreads result into array. Used CALLS_ON instead of CALLS to better capture method invocation semantics.","implicitBehavior":["Iterator helpers create lazy evaluation chains","Spread operator consumes iterator to create array","Iterator methods return new iterator instances"]},"pass":2,"annotatedAt":"2026-02-24T00:35:55.637Z"}
{"construct":{"id":"builtins::builtin-regex-named-groups","file":"src/builtins.js","category":"builtins","lineStart":191,"lineEnd":200,"code":"function regexNamedGroups(dateStr) {\n  const pattern = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n  const match = dateStr.match(pattern);\n  if (!match) return null;\n  const { year, month, day } = match.groups;\n  return { year, month, day };\n}\n\n// --- Date ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<regexNamedGroups>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<dateStr>"},{"type":"VARIABLE","id":"<pattern>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>","metadata":{"value":"/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/","literalType":"regex","namedGroups":["year","month","day"]}},{"type":"VARIABLE","id":"<match>","metadata":{"kind":"const"}},{"type":"CALL","id":"<dateStr.match(pattern)>","metadata":{"callee":"match","method":true}},{"type":"BRANCH","id":"<if (!match)>","metadata":{"condition":"!match"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"VARIABLE","id":"<year>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<month>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<day>","metadata":{"kind":"const","destructured":true}},{"type":"PROPERTY_ACCESS","id":"<match.groups>","metadata":{"objectName":"match","propertyName":"groups"}},{"type":"EXPRESSION","id":"<{ year, month, day }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<regexNamedGroups>","dst":"<dateStr>","type":"CONTAINS"},{"src":"<regexNamedGroups>","dst":"<pattern>","type":"CONTAINS"},{"src":"<pattern>","dst":"</(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/>","type":"ASSIGNED_FROM"},{"src":"<regexNamedGroups>","dst":"<match>","type":"CONTAINS"},{"src":"<match>","dst":"<dateStr.match(pattern)>","type":"ASSIGNED_FROM"},{"src":"<dateStr.match(pattern)>","dst":"<dateStr>","type":"READS_FROM"},{"src":"<dateStr.match(pattern)>","dst":"<pattern>","type":"PASSES_ARGUMENT"},{"src":"<regexNamedGroups>","dst":"<if (!match)>","type":"CONTAINS"},{"src":"<if (!match)>","dst":"<match>","type":"HAS_CONDITION"},{"src":"<if (!match)>","dst":"<null>","type":"HAS_CONSEQUENT"},{"src":"<regexNamedGroups>","dst":"<year>","type":"CONTAINS"},{"src":"<regexNamedGroups>","dst":"<month>","type":"CONTAINS"},{"src":"<regexNamedGroups>","dst":"<day>","type":"CONTAINS"},{"src":"<year>","dst":"<match.groups>","type":"ASSIGNED_FROM"},{"src":"<month>","dst":"<match.groups>","type":"ASSIGNED_FROM"},{"src":"<day>","dst":"<match.groups>","type":"ASSIGNED_FROM"},{"src":"<match.groups>","dst":"<match>","type":"READS_FROM"},{"src":"<regexNamedGroups>","dst":"<{ year, month, day }>","type":"RETURNS"},{"src":"<{ year, month, day }>","dst":"<year>","type":"READS_FROM"},{"src":"<{ year, month, day }>","dst":"<month>","type":"READS_FROM"},{"src":"<{ year, month, day }>","dst":"<day>","type":"READS_FROM"}],"rationale":"Function using regex with named capture groups. Pattern matches date format, result destructured from match.groups property, then returned as object literal. Used ASSIGNED_FROM for destructuring since DESTRUCTURED_FROM is not in approved vocabulary.","implicitBehavior":["regex named groups create properties on match.groups object","destructuring assignment extracts properties by name","match() returns null for non-matches"]},"pass":2,"annotatedAt":"2026-02-24T00:35:57.176Z"}
{"construct":{"id":"modern-es::modern-regex-indices","file":"src/modern-es.js","category":"modern-es","lineStart":82,"lineEnd":99,"code":"function regexIndices(str) {\n  const regex = /(?<word>\\w+)/gd;\n  const match = regex.exec(str);\n  if (!match) return null;\n  const { indices } = match;\n  return { match: match[0], start: indices[0][0], end: indices[0][1], groups: indices.groups };\n}\n\n// --- Top-level await (ES2022)  already in async-generators.js, reference only ---\n\n// --- Logical assignment already in expressions.js (&&=, ||=, ??=) ---\n\n// --- Private class fields / methods already in classes.js ---\n\n// --- Class static block already in classes.js ---\n\n// --- Symbols: well-known symbols ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<regexIndices>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<str>"},{"type":"VARIABLE","id":"<regex>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<word>\\w+)/gd>","metadata":{"value":"/(?<word>\\w+)/gd","literalType":"regex","flags":"gd","namedGroups":["word"]}},{"type":"VARIABLE","id":"<match>","metadata":{"kind":"const"}},{"type":"CALL","id":"<regex.exec(str)>","metadata":{"callee":"exec"}},{"type":"BRANCH","id":"<if (!match)>","metadata":{"condition":"!match"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"VARIABLE","id":"<indices>","metadata":{"kind":"const","destructured":true}},{"type":"PROPERTY_ACCESS","id":"<match.indices>","metadata":{"property":"indices"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}},{"type":"PROPERTY_ACCESS","id":"<match[0]>","metadata":{"property":"0","computed":true}},{"type":"PROPERTY_ACCESS","id":"<indices[0][0]>","metadata":{"property":"0","computed":true,"chained":true}},{"type":"PROPERTY_ACCESS","id":"<indices[0][1]>","metadata":{"property":"1","computed":true,"chained":true}},{"type":"PROPERTY_ACCESS","id":"<indices.groups>","metadata":{"property":"groups"}}],"edges":[{"src":"<regexIndices>","dst":"<str>","type":"CONTAINS"},{"src":"<regexIndices>","dst":"<regex>","type":"CONTAINS"},{"src":"<regex>","dst":"</(?<word>\\w+)/gd>","type":"ASSIGNED_FROM"},{"src":"<regexIndices>","dst":"<match>","type":"CONTAINS"},{"src":"<match>","dst":"<regex.exec(str)>","type":"ASSIGNED_FROM"},{"src":"<regex.exec(str)>","dst":"<regex>","type":"CALLS_ON"},{"src":"<regex.exec(str)>","dst":"<str>","type":"PASSES_ARGUMENT"},{"src":"<regexIndices>","dst":"<if (!match)>","type":"CONTAINS"},{"src":"<if (!match)>","dst":"<match>","type":"READS_FROM"},{"src":"<if (!match)>","dst":"<null>","type":"HAS_CONSEQUENT"},{"src":"<regexIndices>","dst":"<indices>","type":"CONTAINS"},{"src":"<indices>","dst":"<match.indices>","type":"ASSIGNED_FROM"},{"src":"<match.indices>","dst":"<match>","type":"READS_FROM"},{"src":"<regexIndices>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<match[0]>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<indices[0][0]>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<indices[0][1]>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<indices.groups>","type":"HAS_PROPERTY"},{"src":"<match[0]>","dst":"<match>","type":"READS_FROM"},{"src":"<indices[0][0]>","dst":"<indices>","type":"READS_FROM"},{"src":"<indices[0][1]>","dst":"<indices>","type":"READS_FROM"},{"src":"<indices.groups>","dst":"<indices>","type":"READS_FROM"}],"rationale":"Function demonstrating ES2022 regex indices feature. Uses regex with 'd' flag to enable indices property on match results. Destructures indices from match object and returns structured data with match text and position information.","implicitBehavior":["regex 'd' flag enables indices property on match results","named capture groups create indices.groups object","indices array contains [start, end] pairs for each capture group"]},"pass":2,"annotatedAt":"2026-02-24T00:35:57.541Z"}
{"construct":{"id":"modules-default-anon::export-default-anonymous-function","file":"src/modules-default-anon.js","category":"modules-default-anon","lineStart":5,"lineEnd":10,"code":"export default function() {\n  return 'anonymous but hoisted';\n}\n\n// Only one `export default` per module  other forms as comments:","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<anonymous-default-function>","metadata":{"anonymous":true,"hoisted":true}},{"type":"EXPORT","id":"<default-export>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<'anonymous but hoisted'>","metadata":{"value":"anonymous but hoisted","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<default-export>","type":"CONTAINS"},{"src":"<default-export>","dst":"<anonymous-default-function>","type":"EXPORTS"},{"src":"<anonymous-default-function>","dst":"<'anonymous but hoisted'>","type":"RETURNS"}],"rationale":"Anonymous function declaration exported as default. Function is hoisted and becomes the module's default export. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["function declaration is hoisted to module scope","default export creates implicit binding for importing modules"]},"pass":2,"annotatedAt":"2026-02-24T00:35:59.089Z"}
{"construct":{"id":"modern-es::import-attributes-reexport","file":"src/modern-es.js","category":"modern-es","lineStart":282,"lineEnd":285,"code":"// export { default as schema } from './schema.json' with { type: 'json' };\n\n// --- import.meta.resolve() (ES2025) ---","commentedOut":true},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-schema>","metadata":{"exportType":"named","reexport":true}},{"type":"VARIABLE","id":"<schema>","metadata":{"exported":true,"importedAs":"default"}},{"type":"IMPORT","id":"<import-schema.json>","metadata":{"source":"./schema.json","attributes":{"type":"json"}}},{"type":"EXTERNAL_MODULE","id":"<./schema.json>","metadata":{"path":"./schema.json","type":"json"}}],"edges":[{"src":"<export-schema>","dst":"<schema>","type":"EXPORTS"},{"src":"<import-schema.json>","dst":"<schema>","type":"IMPORTS"},{"src":"<import-schema.json>","dst":"<./schema.json>","type":"IMPORTS_FROM"},{"src":"<export-schema>","dst":"<import-schema.json>","type":"DEPENDS_ON"}],"rationale":"Re-export with import attributes using approved vocabulary. The import brings in the default export from a JSON module with type assertion, then exports it as a named export 'schema'. Used DEPENDS_ON instead of REEXPORTS_FROM since that's not in approved vocabulary.","implicitBehavior":["JSON module loaded with type assertion","default export aliased to named export","single-statement import-export pattern"]},"pass":2,"annotatedAt":"2026-02-24T00:36:00.416Z"}
{"construct":{"id":"modern-es::import-attributes-css","file":"src/modern-es.js","category":"modern-es","lineStart":276,"lineEnd":277,"code":"// import styles from './app.css' with { type: 'css' };","commentedOut":true},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-styles>","metadata":{"source":"./app.css","importType":"default"}},{"type":"VARIABLE","id":"<styles>","metadata":{"imported":true,"kind":"const"}},{"type":"LITERAL","id":"<type-css>","metadata":{"value":"css","context":"import_attribute_value"}}],"edges":[{"src":"<module>","dst":"<import-styles>","type":"CONTAINS"},{"src":"<import-styles>","dst":"<styles>","type":"IMPORTS"},{"src":"<import-styles>","dst":"<type-css>","type":"HAS_PROPERTY"},{"src":"<module>","dst":"<./app.css>","type":"IMPORTS_FROM"}],"rationale":"Default import with import attributes specifying CSS type. Using LITERAL for the attribute value and HAS_PROPERTY to represent the attribute relationship, as these are the closest approved types.","implicitBehavior":["import attributes affect module loading behavior","CSS modules may be processed differently than JS modules","creates const binding in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:36:01.231Z"}
{"construct":{"id":"modules-helpers::export-inline-function","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":8,"lineEnd":11,"code":"export function helperFunction() {\n  return 'help';\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<helperFunction>","metadata":{"async":false,"generator":false,"exported":true}},{"type":"LITERAL","id":"<'help'>","metadata":{"value":"help","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<helperFunction>","type":"DECLARES"},{"src":"<module>","dst":"<helperFunction>","type":"EXPORTS"},{"src":"<helperFunction>","dst":"<'help'>","type":"RETURNS"}],"rationale":"Inline export function declaration. Module both declares and exports the function, which returns a string literal. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["function declaration is hoisted to module scope","export creates named binding in module's export object"]},"pass":2,"annotatedAt":"2026-02-24T00:36:01.720Z"}
{"construct":{"id":"modern-es::modern-abort-controller","file":"src/modern-es.js","category":"modern-es","lineStart":160,"lineEnd":174,"code":"async function fetchWithAbort(url, timeoutMs) {\n  const controller = new AbortController();\n  const { signal } = controller;\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal });\n    return await response.json();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// --- Disposable resources (ES2025) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fetchWithAbort>","metadata":{"async":true,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"PARAMETER","id":"<timeoutMs>"},{"type":"VARIABLE","id":"<controller>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new AbortController()>","metadata":{"callee":"AbortController","constructor":true}},{"type":"VARIABLE","id":"<signal>","metadata":{"kind":"const","destructured":true}},{"type":"PROPERTY_ACCESS","id":"<controller.signal>","metadata":{"objectName":"controller","propertyName":"signal"}},{"type":"VARIABLE","id":"<timeoutId>","metadata":{"kind":"const"}},{"type":"CALL","id":"<setTimeout(...)>","metadata":{"callee":"setTimeout"}},{"type":"FUNCTION","id":"<timeout-callback>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"CALL","id":"<controller.abort()>","metadata":{"callee":"abort","method":true}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"VARIABLE","id":"<response>","metadata":{"kind":"const"}},{"type":"CALL","id":"<fetch(url, { signal })>","metadata":{"callee":"fetch","async":true}},{"type":"LITERAL","id":"<{ signal }>","metadata":{"literalType":"object"}},{"type":"CALL","id":"<response.json()>","metadata":{"callee":"json","method":true,"async":true}},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"CALL","id":"<clearTimeout(timeoutId)>","metadata":{"callee":"clearTimeout"}}],"edges":[{"src":"<fetchWithAbort>","dst":"<url>","type":"CONTAINS"},{"src":"<fetchWithAbort>","dst":"<timeoutMs>","type":"CONTAINS"},{"src":"<fetchWithAbort>","dst":"<controller>","type":"CONTAINS"},{"src":"<controller>","dst":"<new AbortController()>","type":"ASSIGNED_FROM"},{"src":"<new AbortController()>","dst":"AbortController","type":"CALLS"},{"src":"<fetchWithAbort>","dst":"<signal>","type":"CONTAINS"},{"src":"<signal>","dst":"<controller.signal>","type":"ASSIGNED_FROM"},{"src":"<controller.signal>","dst":"<controller>","type":"READS_FROM"},{"src":"<fetchWithAbort>","dst":"<timeoutId>","type":"CONTAINS"},{"src":"<timeoutId>","dst":"<setTimeout(...)>","type":"ASSIGNED_FROM"},{"src":"<setTimeout(...)>","dst":"setTimeout","type":"CALLS"},{"src":"<setTimeout(...)>","dst":"<timeout-callback>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(...)>","dst":"<timeoutMs>","type":"PASSES_ARGUMENT"},{"src":"<timeout-callback>","dst":"<controller.abort()>","type":"CONTAINS"},{"src":"<controller.abort()>","dst":"<controller>","type":"CALLS_ON"},{"src":"<fetchWithAbort>","dst":"<try-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<response>","type":"CONTAINS"},{"src":"<response>","dst":"<fetch(url, { signal })>","type":"ASSIGNED_FROM"},{"src":"<fetch(url, { signal })>","dst":"fetch","type":"CALLS"},{"src":"<fetch(url, { signal })>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<fetch(url, { signal })>","dst":"<{ signal }>","type":"PASSES_ARGUMENT"},{"src":"<{ signal }>","dst":"<signal>","type":"READS_FROM"},{"src":"<try-block>","dst":"<response.json()>","type":"RETURNS"},{"src":"<response.json()>","dst":"<response>","type":"CALLS_ON"},{"src":"<fetchWithAbort>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<finally-block>","dst":"<clearTimeout(timeoutId)>","type":"CONTAINS"},{"src":"<clearTimeout(timeoutId)>","dst":"clearTimeout","type":"CALLS"},{"src":"<clearTimeout(timeoutId)>","dst":"<timeoutId>","type":"PASSES_ARGUMENT"}],"rationale":"Async function using AbortController for timeout-based request cancellation. Creates controller, sets timeout to abort, fetches with signal, and cleans up timeout in finally block. Used CALLS_ON for method calls on objects to distinguish from regular function calls.","implicitBehavior":["AbortController.signal can be passed to multiple abortable operations","setTimeout callback captures controller in closure","fetch request will be aborted if controller.abort() is called","finally block executes regardless of try block success/failure","await expressions suspend function execution until promise resolves"]},"pass":2,"annotatedAt":"2026-02-24T00:36:02.286Z"}
{"construct":{"id":"modern-es::modern-symbol-async-iterator","file":"src/modern-es.js","category":"modern-es","lineStart":110,"lineEnd":128,"code":"class AsyncSequence {\n  constructor(values) {\n    this.values = values;\n  }\n\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    const values = this.values;\n    return {\n      async next() {\n        if (i < values.length) {\n          return { value: values[i++], done: false };\n        }\n        return { value: undefined, done: true };\n      },\n    };\n  }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"CLASS\",\n      \"id\": \"<AsyncSequence>\"\n    },\n    {\n      \"type\": \"METHOD\",\n      \"id\": \"<AsyncSequence.constructor>\",\n      \"metadata\": {\n        \"kind\": \"c"},"pass":2,"annotatedAt":"2026-02-24T00:36:02.301Z"}
{"construct":{"id":"modules-default-anon::export-default-anonymous-class","file":"src/modules-default-anon.js","category":"modules-default-anon","lineStart":12,"lineEnd":13,"code":"// export default class { run() { return 'anonymous class'; } }","commentedOut":true},"annotation":{"nodes":[{"type":"EXPORT","id":"<default-export>","metadata":{"exportType":"default"}},{"type":"CLASS","id":"<anonymous-class>","metadata":{"anonymous":true}},{"type":"METHOD","id":"<anonymous-class.run>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'anonymous class'>","metadata":{"value":"anonymous class","literalType":"string"}}],"edges":[{"src":"<default-export>","dst":"<anonymous-class>","type":"EXPORTS"},{"src":"<anonymous-class>","dst":"<anonymous-class.run>","type":"CONTAINS"},{"src":"<anonymous-class.run>","dst":"<'anonymous class'>","type":"RETURNS"}],"rationale":"Default export of an anonymous class with a method that returns a string literal. The class has no name binding in the module scope. Removed the module-to-export edge as the module context is implicit.","implicitBehavior":["anonymous class would be the default export value","class constructor implicitly exists even though not defined","module implicitly contains the default export"]},"pass":2,"annotatedAt":"2026-02-24T00:36:02.371Z"}
{"construct":{"id":"modern-es::using-declaration","file":"src/modern-es.js","category":"modern-es","lineStart":229,"lineEnd":240,"code":"function usingDeclaration() {\n  function openFile(path) {\n    return {\n      path,\n      read() { return `contents of ${path}`; },\n      [Symbol.dispose]() { console.log(`closed ${path}`); },\n    };\n  }\n  using handle = openFile('/tmp/test');\n  return handle.read();\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<usingDeclaration>","metadata":{"async":false,"generator":false}},{"type":"FUNCTION","id":"<openFile>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<path>"},{"type":"LITERAL","id":"<object-literal>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<path-property>","metadata":{"key":"path","shorthand":true}},{"type":"METHOD","id":"<read>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template"}},{"type":"METHOD","id":"<Symbol.dispose>","metadata":{"kind":"method","computed":true}},{"type":"CALL","id":"<console.log>","metadata":{"callee":"console.log"}},{"type":"EXPRESSION","id":"<dispose-template>","metadata":{"type":"template"}},{"type":"VARIABLE","id":"<handle>","metadata":{"kind":"using"}},{"type":"CALL","id":"<openFile('/tmp/test')>","metadata":{"callee":"openFile"}},{"type":"LITERAL","id":"<'/tmp/test'>","metadata":{"value":"/tmp/test","literalType":"string"}},{"type":"CALL","id":"<handle.read()>","metadata":{"callee":"handle.read"}}],"edges":[{"src":"<usingDeclaration>","dst":"<openFile>","type":"CONTAINS"},{"src":"<openFile>","dst":"<path>","type":"CONTAINS"},{"src":"<openFile>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<path-property>","type":"HAS_PROPERTY"},{"src":"<path-property>","dst":"<path>","type":"READS_FROM"},{"src":"<object-literal>","dst":"<read>","type":"HAS_PROPERTY"},{"src":"<read>","dst":"<template-literal>","type":"RETURNS"},{"src":"<template-literal>","dst":"<path>","type":"READS_FROM"},{"src":"<object-literal>","dst":"<Symbol.dispose>","type":"HAS_PROPERTY"},{"src":"<Symbol.dispose>","dst":"<console.log>","type":"CONTAINS"},{"src":"<console.log>","dst":"<dispose-template>","type":"PASSES_ARGUMENT"},{"src":"<dispose-template>","dst":"<path>","type":"READS_FROM"},{"src":"<usingDeclaration>","dst":"<handle>","type":"DECLARES"},{"src":"<handle>","dst":"<openFile('/tmp/test')>","type":"ASSIGNED_FROM"},{"src":"<openFile('/tmp/test')>","dst":"<openFile>","type":"CALLS"},{"src":"<openFile('/tmp/test')>","dst":"<'/tmp/test'>","type":"PASSES_ARGUMENT"},{"src":"<usingDeclaration>","dst":"<handle.read()>","type":"RETURNS"},{"src":"<handle.read()>","dst":"<handle>","type":"READS_FROM"},{"src":"<handle.read()>","dst":"<read>","type":"CALLS"}],"rationale":"Using declaration creates a resource that will be automatically disposed when leaving scope. The variable is bound to a disposable object with Symbol.dispose method. All relationships are captured using approved vocabulary.","implicitBehavior":["using variable automatically calls Symbol.dispose when leaving scope","disposal happens even if exceptions are thrown","disposal order is reverse of declaration order for multiple using declarations"]},"pass":2,"annotatedAt":"2026-02-24T00:36:03.409Z"}
{"construct":{"id":"modern-es::import-attributes-dynamic","file":"src/modern-es.js","category":"modern-es","lineStart":279,"lineEnd":280,"code":"// const data = await import('./data.json', { with: { type: 'json' } });","commentedOut":true},"annotation":{"nodes":[{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<await import('./data.json', { with: { type: 'json' } })>","metadata":{"async":true,"operator":"await"}},{"type":"CALL","id":"<import('./data.json', { with: { type: 'json' } })>","metadata":{"callee":"import","dynamic":true}},{"type":"LITERAL","id":"<'./data.json'>","metadata":{"value":"./data.json","literalType":"string"}},{"type":"LITERAL","id":"<{ with: { type: 'json' } }>","metadata":{"literalType":"object","importAttributes":true}}],"edges":[{"src":"<module>","dst":"<data>","type":"DECLARES"},{"src":"<data>","dst":"<await import('./data.json', { with: { type: 'json' } })>","type":"ASSIGNED_FROM"},{"src":"<await import('./data.json', { with: { type: 'json' } })>","dst":"<import('./data.json', { with: { type: 'json' } })>","type":"AWAITS"},{"src":"<import('./data.json', { with: { type: 'json' } })>","dst":"<'./data.json'>","type":"IMPORTS_FROM"},{"src":"<import('./data.json', { with: { type: 'json' } })>","dst":"<{ with: { type: 'json' } }>","type":"USES"}],"rationale":"Dynamic import with import attributes. The await expression waits for the import call, which loads a module with JSON type assertion. Used USES instead of USES_ATTRIBUTES as the latter is not in approved vocabulary.","implicitBehavior":["dynamic import returns a Promise","import attributes provide type hints to the module loader","JSON modules are parsed as JSON objects"]},"pass":2,"annotatedAt":"2026-02-24T00:36:03.413Z"}
{"construct":{"id":"modern-es::using-await-declaration","file":"src/modern-es.js","category":"modern-es","lineStart":242,"lineEnd":253,"code":"async function usingAwaitDeclaration() {\n  function openStream(url) {\n    return {\n      url,\n      async readAll() { return 'data'; },\n      async [Symbol.asyncDispose]() { console.log(`closed ${url}`); },\n    };\n  }\n  await using stream = await openStream('http://example.com');\n  return stream.readAll();\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<usingAwaitDeclaration>","metadata":{"async":true,"generator":false}},{"type":"FUNCTION","id":"<openStream>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<url>"},{"type":"LITERAL","id":"<'data'>","metadata":{"value":"data","literalType":"string"}},{"type":"LITERAL","id":"<'http://example.com'>","metadata":{"value":"http://example.com","literalType":"string"}},{"type":"LITERAL","id":"<'closed '>","metadata":{"value":"closed ","literalType":"string"}},{"type":"METHOD","id":"<readAll>","metadata":{"async":true}},{"type":"METHOD","id":"<Symbol.asyncDispose>","metadata":{"async":true,"symbol":"Symbol.asyncDispose"}},{"type":"EXPRESSION","id":"<object-literal>","metadata":{"type":"object"}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template"}},{"type":"VARIABLE","id":"<stream>","metadata":{"kind":"await using","disposable":true}},{"type":"CALL","id":"<openStream('http://example.com')>","metadata":{"callee":"openStream","awaited":true}},{"type":"CALL","id":"<stream.readAll()>","metadata":{"callee":"readAll","awaited":false}},{"type":"CALL","id":"<console.log(template)>","metadata":{"callee":"console.log"}}],"edges":[{"src":"<usingAwaitDeclaration>","dst":"<openStream>","type":"CONTAINS"},{"src":"<openStream>","dst":"<url>","type":"CONTAINS"},{"src":"<openStream>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<url>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<readAll>","type":"HAS_PROPERTY"},{"src":"<object-literal>","dst":"<Symbol.asyncDispose>","type":"HAS_PROPERTY"},{"src":"<readAll>","dst":"<'data'>","type":"RETURNS"},{"src":"<Symbol.asyncDispose>","dst":"<console.log(template)>","type":"CONTAINS"},{"src":"<template-literal>","dst":"<'closed '>","type":"HAS_ELEMENT"},{"src":"<template-literal>","dst":"<url>","type":"HAS_ELEMENT"},{"src":"<console.log(template)>","dst":"<template-literal>","type":"PASSES_ARGUMENT"},{"src":"<usingAwaitDeclaration>","dst":"<stream>","type":"DECLARES"},{"src":"<stream>","dst":"<openStream('http://example.com')>","type":"ASSIGNED_FROM"},{"src":"<openStream('http://example.com')>","dst":"<openStream>","type":"CALLS"},{"src":"<openStream('http://example.com')>","dst":"<'http://example.com'>","type":"PASSES_ARGUMENT"},{"src":"<usingAwaitDeclaration>","dst":"<stream.readAll()>","type":"RETURNS"},{"src":"<stream.readAll()>","dst":"<stream>","type":"READS_FROM"},{"src":"<stream.readAll()>","dst":"<readAll>","type":"CALLS"}],"rationale":"Async function using 'await using' declaration for automatic resource disposal. The stream variable is bound to an awaited call result and will be automatically disposed via Symbol.asyncDispose when leaving scope. Reduced edge count by removing module-level declaration and console.log call edges.","implicitBehavior":["await using triggers automatic disposal via Symbol.asyncDispose at end of scope","disposal happens even if function exits via exception","disposal is awaited before scope exit completes"]},"pass":2,"annotatedAt":"2026-02-24T00:36:03.921Z"}
{"construct":{"id":"modules-helpers::export-inline-class","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":13,"lineEnd":18,"code":"export class HelperClass {\n  method() {\n    return true;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<HelperClass>"},{"type":"METHOD","id":"<HelperClass.method>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<module>","dst":"<HelperClass>","type":"DECLARES"},{"src":"<module>","dst":"<HelperClass>","type":"EXPORTS"},{"src":"<HelperClass>","dst":"<HelperClass.method>","type":"CONTAINS"},{"src":"<HelperClass.method>","dst":"<true>","type":"RETURNS"}],"rationale":"Inline export of a class declaration. Module both declares and exports the class, which contains a method that returns a boolean literal. All types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["class declaration is hoisted","export creates binding in module's export object"]},"pass":2,"annotatedAt":"2026-02-24T00:36:05.335Z"}
{"construct":{"id":"modules-helpers::export-default-function","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":20,"lineEnd":23,"code":"export default function defaultHelper() {\n  return 'default';\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<defaultHelper>","metadata":{"async":false,"generator":false}},{"type":"EXPORT","id":"<export-default>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<'default'>","metadata":{"value":"default","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<defaultHelper>","type":"DECLARES"},{"src":"<module>","dst":"<export-default>","type":"CONTAINS"},{"src":"<export-default>","dst":"<defaultHelper>","type":"EXPORTS"},{"src":"<defaultHelper>","dst":"<'default'>","type":"RETURNS"}],"rationale":"Default export of a function declaration. Module declares the function and exports it as default, function returns a string literal. All types from Pass 1 are in the approved vocabulary.","implicitBehavior":["function declaration is hoisted","default export creates module.default binding"]},"pass":2,"annotatedAt":"2026-02-24T00:36:05.843Z"}
{"construct":{"id":"modules-helpers::export-inline-const","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":5,"lineEnd":6,"code":"export const HELPER_CONST = 42;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<HELPER_CONST>","metadata":{"kind":"const","exported":true}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"EXPORT","id":"<export-HELPER_CONST>","metadata":{"exportType":"named"}}],"edges":[{"src":"<module>","dst":"<HELPER_CONST>","type":"DECLARES"},{"src":"<HELPER_CONST>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<export-HELPER_CONST>","dst":"<HELPER_CONST>","type":"EXPORTS"},{"src":"<module>","dst":"<export-HELPER_CONST>","type":"CONTAINS"}],"rationale":"Inline export of a const variable. The export declaration simultaneously declares the variable and makes it available to importers. Using approved vocabulary, ASSIGNED_FROM captures the initialization relationship.","implicitBehavior":["const binding is immutable after initialization","exported binding is live - importers see updates to the binding itself"]},"pass":2,"annotatedAt":"2026-02-24T00:36:07.686Z"}
{"construct":{"id":"modules-helpers::export-default-class","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":30,"lineEnd":33,"code":"// export default class Router { navigate() { return '/'; } }\n// Also valid: export default class { anonymous() {} }\n// (Only one default export per module  shown above as function)","commentedOut":true},"annotation":{"nodes":[{"type":"CLASS","id":"<Router>","metadata":{"exported":true,"exportType":"default"}},{"type":"METHOD","id":"<Router.navigate>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'/'>","metadata":{"value":"/","literalType":"string"}},{"type":"EXPORT","id":"<default-export>","metadata":{"exportType":"default"}}],"edges":[{"src":"<module>","dst":"<default-export>","type":"CONTAINS"},{"src":"<default-export>","dst":"<Router>","type":"EXPORTS"},{"src":"<Router>","dst":"<Router.navigate>","type":"CONTAINS"},{"src":"<Router.navigate>","dst":"<'/'>","type":"RETURNS"}],"rationale":"Default export of a class with a method that returns a string literal. The export creates a binding that other modules can import with any name.","implicitBehavior":["only one default export allowed per module","default export can be imported with any name","class declaration is hoisted within module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:36:07.939Z"}
{"construct":{"id":"modules-helpers::export-as-default","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":25,"lineEnd":28,"code":"// Alternative syntax for default export:\n// export { someFunction as default };\n// Semantically equivalent to export default, but uses named export syntax","commentedOut":true},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-as-default>","metadata":{"exportType":"named","isDefault":true}},{"type":"VARIABLE","id":"<someFunction>","metadata":{"exported":true,"exportedAs":"default"}}],"edges":[{"src":"<module>","dst":"<export-as-default>","type":"CONTAINS"},{"src":"<export-as-default>","dst":"<someFunction>","type":"EXPORTS"},{"src":"<someFunction>","dst":"<default>","type":"ALIASES"}],"rationale":"Named export syntax that creates a default export by aliasing an identifier to 'default'. The EXPORT node represents the export statement, and ALIASES captures the renaming relationship from someFunction to default.","implicitBehavior":["creates default export binding","allows importing with default import syntax","identifier must already exist in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:36:08.002Z"}
{"construct":{"id":"modules-default-anon::export-default-expression","file":"src/modules-default-anon.js","category":"modules-default-anon","lineStart":15,"lineEnd":18,"code":"// export default [1, 2, 3];\n// export default { key: 'value' };\n// export default 42;","commentedOut":true},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-default-array>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"value":"[1, 2, 3]","literalType":"array"}},{"type":"EXPORT","id":"<export-default-object>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<{ key: 'value' }>","metadata":{"value":"{ key: 'value' }","literalType":"object"}},{"type":"EXPORT","id":"<export-default-number>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<42>","metadata":{"value":"42","literalType":"number"}}],"edges":[{"src":"<export-default-array>","dst":"<[1, 2, 3]>","type":"EXPORTS"},{"src":"<export-default-object>","dst":"<{ key: 'value' }>","type":"EXPORTS"},{"src":"<export-default-number>","dst":"<42>","type":"EXPORTS"}],"rationale":"Three default export statements, each exporting a literal value directly. Each export creates its own export node that exports the literal. Removed the module containment edges as they are implicit in the module context.","implicitBehavior":["only one default export allowed per module - these would conflict if uncommented","default exports are accessible via import statements without destructuring","each export statement is contained within the module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:36:08.725Z"}
{"construct":{"id":"modern-es::import-meta-resolve","file":"src/modern-es.js","category":"modern-es","lineStart":287,"lineEnd":299,"code":"const workerUrl = import.meta.resolve('./modules-helpers.js');\n\nasync function loadOptional(specifier) {\n  try {\n    const url = import.meta.resolve(specifier);\n    return await import(url);\n  } catch {\n    return null;\n  }\n}\n\n// --- WeakRef and FinalizationRegistry ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<workerUrl>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import.meta.resolve('./modules-helpers.js')>","metadata":{"callee":"import.meta.resolve"}},{"type":"LITERAL","id":"<'./modules-helpers.js'>","metadata":{"value":"./modules-helpers.js","literalType":"string"}},{"type":"FUNCTION","id":"<loadOptional>","metadata":{"async":true}},{"type":"PARAMETER","id":"<specifier>"},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"VARIABLE","id":"<url>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import.meta.resolve(specifier)>","metadata":{"callee":"import.meta.resolve"}},{"type":"CALL","id":"<import(url)>","metadata":{"callee":"import","dynamic":true}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}}],"edges":[{"src":"<workerUrl>","dst":"<import.meta.resolve('./modules-helpers.js')>","type":"ASSIGNED_FROM"},{"src":"<import.meta.resolve('./modules-helpers.js')>","dst":"<'./modules-helpers.js'>","type":"PASSES_ARGUMENT"},{"src":"<loadOptional>","dst":"<specifier>","type":"CONTAINS"},{"src":"<loadOptional>","dst":"<try-block>","type":"HAS_BODY"},{"src":"<loadOptional>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<url>","dst":"<import.meta.resolve(specifier)>","type":"ASSIGNED_FROM"},{"src":"<import.meta.resolve(specifier)>","dst":"<specifier>","type":"PASSES_ARGUMENT"},{"src":"<try-block>","dst":"<import(url)>","type":"RETURNS"},{"src":"<import(url)>","dst":"<url>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<null>","type":"RETURNS"}],"rationale":"ES module meta import resolution. Top-level const uses import.meta.resolve to get URL. Async function uses try-catch with dynamic import after resolving specifier. Removed module-level DECLARES edges to reduce edge count while preserving core semantic relationships.","implicitBehavior":["import.meta.resolve returns absolute URL","dynamic import() returns Promise","catch block catches any error from resolve or import"]},"pass":2,"annotatedAt":"2026-02-24T00:36:08.962Z"}
{"construct":{"id":"modules-helpers::export-default-expression","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":35,"lineEnd":38,"code":"// export default [1, 2, 3];\n// export default 42;\n// Any expression can be a default export","commentedOut":true},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-default-array>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"value":"[1, 2, 3]","literalType":"array"}},{"type":"EXPORT","id":"<export-default-number>","metadata":{"exportType":"default"}},{"type":"LITERAL","id":"<42>","metadata":{"value":"42","literalType":"number"}}],"edges":[{"src":"<export-default-array>","dst":"<[1, 2, 3]>","type":"EXPORTS"},{"src":"<export-default-number>","dst":"<42>","type":"EXPORTS"}],"rationale":"Default exports of literal expressions. Each export statement creates an EXPORT node that exports the literal value as the module's default. Removed the CONTAINS edges from module since no explicit module node is present in the construct.","implicitBehavior":["only one default export allowed per module","default exports can be imported with any name"]},"pass":2,"annotatedAt":"2026-02-24T00:36:08.982Z"}
{"construct":{"id":"modules-reexport::reexport-named","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":5,"lineEnd":6,"code":"export { helperFunction } from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-helperFunction>","metadata":{"exportType":"named","reexport":true}},{"type":"VARIABLE","id":"<helperFunction>","metadata":{"reexported":true}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}},{"type":"MODULE","id":"<module>","metadata":{"implicit":true}}],"edges":[{"src":"<module>","dst":"<export-helperFunction>","type":"CONTAINS"},{"src":"<export-helperFunction>","dst":"<helperFunction>","type":"EXPORTS"},{"src":"<export-helperFunction>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<module>","dst":"<./modules-helpers.js>","type":"DEPENDS_ON"}],"rationale":"Re-export statement that imports a named binding from another module and immediately exports it. Creates dependency on source module without making the binding available in current module scope.","implicitBehavior":["binding is not available in current module scope","creates transitive dependency chain"]},"pass":2,"annotatedAt":"2026-02-24T00:36:11.272Z"}
{"construct":{"id":"modules-reexport::reexport-aliased","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":8,"lineEnd":9,"code":"export { HELPER_CONST as RENAMED_CONST } from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<reexport-aliased>","metadata":{"source":"./modules-helpers.js","kind":"reexport"}},{"type":"VARIABLE","id":"<RENAMED_CONST>","metadata":{"exported":true,"reexportedAs":"HELPER_CONST"}}],"edges":[{"src":"<module>","dst":"<reexport-aliased>","type":"CONTAINS"},{"src":"<reexport-aliased>","dst":"<RENAMED_CONST>","type":"EXPORTS"},{"src":"<module>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<reexport-aliased>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"}],"rationale":"Re-export with alias from external module. Creates a new exported binding with different name than the original.","implicitBehavior":["does not create local binding in current module","original export must exist in source module"]},"pass":2,"annotatedAt":"2026-02-24T00:36:13.090Z"}
{"construct":{"id":"modern-es::finalization-registry","file":"src/modern-es.js","category":"modern-es","lineStart":316,"lineEnd":323,"code":"const cleanupRegistry = new FinalizationRegistry((key) => {\n  console.log(`Object for key \"${key}\" was garbage collected`);\n});\n\nfunction trackObject(key, obj) {\n  cleanupRegistry.register(obj, key);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<cleanupRegistry>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new FinalizationRegistry>","metadata":{"constructor":"FinalizationRegistry"}},{"type":"FUNCTION","id":"<cleanup-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<key>"},{"type":"CALL","id":"<console.log>","metadata":{"callee":"console.log"}},{"type":"LITERAL","id":"<template-literal>","metadata":{"value":"Object for key \"${key}\" was garbage collected","literalType":"template"}},{"type":"FUNCTION","id":"<trackObject>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<trackObject.key>"},{"type":"PARAMETER","id":"<trackObject.obj>"},{"type":"CALL","id":"<cleanupRegistry.register>","metadata":{"method":"register"}}],"edges":[{"src":"<cleanupRegistry>","dst":"<new FinalizationRegistry>","type":"ASSIGNED_FROM"},{"src":"<new FinalizationRegistry>","dst":"<cleanup-callback>","type":"PASSES_ARGUMENT"},{"src":"<cleanup-callback>","dst":"<key>","type":"HAS_BODY"},{"src":"<cleanup-callback>","dst":"<console.log>","type":"HAS_BODY"},{"src":"<console.log>","dst":"<template-literal>","type":"PASSES_ARGUMENT"},{"src":"<template-literal>","dst":"<key>","type":"READS_FROM"},{"src":"<trackObject>","dst":"<trackObject.key>","type":"HAS_BODY"},{"src":"<trackObject>","dst":"<trackObject.obj>","type":"HAS_BODY"},{"src":"<trackObject>","dst":"<cleanupRegistry.register>","type":"HAS_BODY"},{"src":"<cleanupRegistry.register>","dst":"<cleanupRegistry>","type":"CALLS_ON"},{"src":"<cleanupRegistry.register>","dst":"<trackObject.obj>","type":"PASSES_ARGUMENT"},{"src":"<cleanupRegistry.register>","dst":"<trackObject.key>","type":"PASSES_ARGUMENT"}],"rationale":"FinalizationRegistry constructor creates a cleanup registry with a callback function. The trackObject function registers objects for cleanup tracking using the registry's register method.","implicitBehavior":["FinalizationRegistry callback is invoked asynchronously by garbage collector","Weak reference semantics - registered objects can be collected independently","Cleanup callback execution timing is non-deterministic"]},"pass":2,"annotatedAt":"2026-02-24T00:36:13.193Z"}
{"construct":{"id":"modules-reexport::reexport-default-as-named","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":14,"lineEnd":15,"code":"export { default as defaultFn } from './modules-helpers.js';","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-default-as-named>","metadata":{"exportType":"named","source":"./modules-helpers.js"}},{"type":"VARIABLE","id":"<defaultFn>","metadata":{"exported":true,"reexported":true,"originalName":"default"}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}},{"type":"EXTERNAL","id":"<./modules-helpers.js:default>","metadata":{"module":"./modules-helpers.js","exportName":"default"}}],"edges":[{"src":"<export-default-as-named>","dst":"<defaultFn>","type":"EXPORTS"},{"src":"<export-default-as-named>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<defaultFn>","dst":"<./modules-helpers.js:default>","type":"ALIASES"},{"src":"<./modules-helpers.js>","dst":"<./modules-helpers.js:default>","type":"EXPORTS"}],"rationale":"Re-export statement that imports the default export from another module and re-exports it as a named export with alias. The ALIASES edge captures that defaultFn is an alias for the external default export.","implicitBehavior":["creates a binding without importing into local scope","module dependency established at parse time"]},"pass":2,"annotatedAt":"2026-02-24T00:36:14.143Z"}
{"construct":{"id":"modules-reexport::reexport-star","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":11,"lineEnd":12,"code":"export * from './declarations.js';","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-star>","metadata":{"exportType":"star"}},{"type":"EXTERNAL_MODULE","id":"<./declarations.js>","metadata":{"path":"./declarations.js"}}],"edges":[{"src":"<module>","dst":"<export-star>","type":"CONTAINS"},{"src":"<export-star>","dst":"<./declarations.js>","type":"IMPORTS_FROM"},{"src":"<module>","dst":"<./declarations.js>","type":"DEPENDS_ON"}],"rationale":"Star re-export that forwards all exports from another module. Creates dependency on source module and makes all its exports available through this module.","implicitBehavior":["all named exports from source module become available as named exports","default export from source module is not re-exported by star export","creates transitive dependency chain for consumers"]},"pass":2,"annotatedAt":"2026-02-24T00:36:14.234Z"}
{"construct":{"id":"modules-helpers::export-multiple-names-same-binding","file":"src/modules-helpers.js","category":"modules-helpers","lineStart":40,"lineEnd":42,"code":"const sharedValue = 'shared';\nexport { sharedValue, sharedValue as sharedAlias, sharedValue as sharedOther };","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<sharedValue>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'shared'>","metadata":{"value":"shared","literalType":"string"}},{"type":"EXPORT","id":"<export-sharedValue>","metadata":{"exportName":"sharedValue"}},{"type":"EXPORT","id":"<export-sharedAlias>","metadata":{"exportName":"sharedAlias","localName":"sharedValue"}},{"type":"EXPORT","id":"<export-sharedOther>","metadata":{"exportName":"sharedOther","localName":"sharedValue"}}],"edges":[{"src":"<sharedValue>","dst":"<'shared'>","type":"ASSIGNED_FROM"},{"src":"<export-sharedValue>","dst":"<sharedValue>","type":"EXPORTS"},{"src":"<export-sharedAlias>","dst":"<sharedValue>","type":"EXPORTS"},{"src":"<export-sharedOther>","dst":"<sharedValue>","type":"EXPORTS"}],"rationale":"Single variable exported under three different names. Each export creates a distinct binding that references the same local variable. Removed module containment edges to stay under threshold while preserving core semantic relationships.","implicitBehavior":["all three exports reference the same memory location","importing modules can access the same value through different names","module implicitly contains all declarations and exports"]},"pass":2,"annotatedAt":"2026-02-24T00:36:15.416Z"}
{"construct":{"id":"modules-reexport::reexport-namespace","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":17,"lineEnd":20,"code":"export * as helpers from './modules-helpers.js';\n\n// --- Multi-file module patterns (construct references only) ---","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-namespace>","metadata":{"exportType":"namespace","alias":"helpers"}},{"type":"IMPORT","id":"<import-all>","metadata":{"source":"./modules-helpers.js","importType":"namespace"}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}}],"edges":[{"src":"<export-namespace>","dst":"<import-all>","type":"EXPORTS"},{"src":"<import-all>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"}],"rationale":"Namespace re-export that imports all exports from a module and re-exports them under a single namespace alias. Using EXPORTS to represent the re-export relationship between the export and import nodes.","implicitBehavior":["creates a namespace object containing all exported members from the source module","preserves original export names within the namespace"]},"pass":2,"annotatedAt":"2026-02-24T00:36:15.776Z"}
{"construct":{"id":"modern-es::weakref-cache","file":"src/modern-es.js","category":"modern-es","lineStart":301,"lineEnd":314,"code":"function createWeakCache() {\n  const cache = new Map();\n  return {\n    get(key, factory) {\n      const ref = cache.get(key);\n      const cached = ref?.deref();\n      if (cached) return cached;\n      const fresh = factory();\n      cache.set(key, new WeakRef(fresh));\n      return fresh;\n    },\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createWeakCache>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<cache>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Map()>","metadata":{"callee":"Map","constructor":true}},{"type":"LITERAL","id":"<object-literal>","metadata":{"literalType":"object"}},{"type":"METHOD","id":"<get>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<factory>"},{"type":"VARIABLE","id":"<ref>","metadata":{"kind":"const"}},{"type":"CALL","id":"<cache.get(key)>","metadata":{"callee":"get"}},{"type":"VARIABLE","id":"<cached>","metadata":{"kind":"const"}},{"type":"CALL","id":"<ref?.deref()>","metadata":{"callee":"deref","optional":true}},{"type":"BRANCH","id":"<if-cached>","metadata":{"branchType":"if"}},{"type":"VARIABLE","id":"<fresh>","metadata":{"kind":"const"}},{"type":"CALL","id":"<factory()>","metadata":{"callee":"factory"}},{"type":"CALL","id":"<cache.set(key, new WeakRef(fresh))>","metadata":{"callee":"set"}},{"type":"CALL","id":"<new WeakRef(fresh)>","metadata":{"callee":"WeakRef","constructor":true}}],"edges":[{"src":"<createWeakCache>","dst":"<cache>","type":"CONTAINS"},{"src":"<cache>","dst":"<new Map()>","type":"ASSIGNED_FROM"},{"src":"<createWeakCache>","dst":"<object-literal>","type":"RETURNS"},{"src":"<object-literal>","dst":"<get>","type":"HAS_PROPERTY"},{"src":"<get>","dst":"<key>","type":"CONTAINS"},{"src":"<get>","dst":"<factory>","type":"CONTAINS"},{"src":"<get>","dst":"<ref>","type":"CONTAINS"},{"src":"<ref>","dst":"<cache.get(key)>","type":"ASSIGNED_FROM"},{"src":"<cache.get(key)>","dst":"<cache>","type":"READS_FROM"},{"src":"<cache.get(key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<get>","dst":"<cached>","type":"CONTAINS"},{"src":"<cached>","dst":"<ref?.deref()>","type":"ASSIGNED_FROM"},{"src":"<ref?.deref()>","dst":"<ref>","type":"READS_FROM"},{"src":"<get>","dst":"<if-cached>","type":"CONTAINS"},{"src":"<if-cached>","dst":"<cached>","type":"HAS_CONDITION"},{"src":"<if-cached>","dst":"<cached>","type":"RETURNS"},{"src":"<get>","dst":"<fresh>","type":"CONTAINS"},{"src":"<fresh>","dst":"<factory()>","type":"ASSIGNED_FROM"},{"src":"<factory()>","dst":"<factory>","type":"CALLS"},{"src":"<get>","dst":"<cache.set(key, new WeakRef(fresh))>","type":"CONTAINS"},{"src":"<cache.set(key, new WeakRef(fresh))>","dst":"<cache>","type":"WRITES_TO"},{"src":"<cache.set(key, new WeakRef(fresh))>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<cache.set(key, new WeakRef(fresh))>","dst":"<new WeakRef(fresh)>","type":"PASSES_ARGUMENT"},{"src":"<new WeakRef(fresh)>","dst":"<fresh>","type":"PASSES_ARGUMENT"},{"src":"<get>","dst":"<fresh>","type":"RETURNS"}],"rationale":"Factory function creating a weak reference cache. Returns object with get method that checks for cached weak references, creates new ones if needed, and handles garbage collection through WeakRef. All Pass 1 types and edges were already in the approved vocabulary.","implicitBehavior":["WeakRef allows cached objects to be garbage collected","Optional chaining handles null/undefined refs gracefully","Map stores weak references as values, not the actual cached objects"]},"pass":2,"annotatedAt":"2026-02-24T00:36:18.311Z"}
{"construct":{"id":"patterns::obj-destructuring-nested","file":"src/patterns.js","category":"patterns","lineStart":17,"lineEnd":22,"code":"function objectDestructuringNested() {\n  const data = { outer: { inner: { deep: 42 } } };\n  const { outer: { inner: { deep } } } = data;\n  return deep;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<objectDestructuringNested>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<data>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ outer: { inner: { deep: 42 } } }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ outer: { inner: { deep } } }>","metadata":{"expressionType":"destructuring","nested":true}},{"type":"VARIABLE","id":"<deep>","metadata":{"kind":"const","destructured":true}}],"edges":[{"src":"<objectDestructuringNested>","dst":"<data>","type":"CONTAINS"},{"src":"<data>","dst":"<{ outer: { inner: { deep: 42 } } }>","type":"ASSIGNED_FROM"},{"src":"<{ outer: { inner: { deep: 42 } } }>","dst":"<42>","type":"HAS_PROPERTY"},{"src":"<objectDestructuringNested>","dst":"<{ outer: { inner: { deep } } }>","type":"CONTAINS"},{"src":"<{ outer: { inner: { deep } } }>","dst":"<data>","type":"READS_FROM"},{"src":"<{ outer: { inner: { deep } } }>","dst":"<deep>","type":"ASSIGNED_FROM"},{"src":"<objectDestructuringNested>","dst":"<deep>","type":"RETURNS"}],"rationale":"Function with nested object destructuring mapped to approved vocabulary. The destructuring pattern is represented as an EXPRESSION that READS_FROM the source object and creates assignments to extracted variables.","implicitBehavior":["nested destructuring creates intermediate property access chain","destructuring assignment creates const binding"]},"pass":2,"annotatedAt":"2026-02-24T00:36:21.012Z"}
{"construct":{"id":"builtins::builtin-date","file":"src/builtins.js","category":"builtins","lineStart":202,"lineEnd":216,"code":"function dateOperations() {\n  const now = new Date();\n  const specific = new Date(2024, 0, 15);\n  const fromISO = new Date('2024-01-15T10:30:00Z');\n  const timestamp = Date.now();\n\n  const year = now.getFullYear();\n  const month = now.getMonth();\n  const iso = now.toISOString();\n\n  return { now, specific, fromISO, timestamp, year, month, iso };\n}\n\n// --- Math ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<dateOperations>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIAB"},"pass":2,"annotatedAt":"2026-02-24T00:36:21.921Z"}
{"construct":{"id":"modules-reexport::star-import-namespace","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":27,"lineEnd":31,"code":"// import * as utils from './modules-helpers.js';\n// utils.helperFunction();          // method on namespace object\n// const { helperFunction } = utils; // destructured from namespace\n// const fn = utils['helperFunction']; // bracket access on namespace","commentedOut":true},"annotation":{"nodes":[{"type":"IMPORT","id":"<import-utils>","metadata":{"source":"./modules-helpers.js","importType":"namespace"}},{"type":"VARIABLE","id":"<utils>","metadata":{"imported":true,"namespaceImport":true}},{"type":"CALL","id":"<utils.helperFunction()>","metadata":{"callee":"helperFunction"}},{"type":"PROPERTY_ACCESS","id":"<utils.helperFunction>","metadata":{"objectName":"utils","propertyName":"helperFunction"}},{"type":"VARIABLE","id":"<helperFunction>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<fn>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<utils['helperFunction']>","metadata":{"objectName":"utils","propertyName":"helperFunction","accessType":"bracket"}},{"type":"EXTERNAL_MODULE","id":"<./modules-helpers.js>","metadata":{"path":"./modules-helpers.js"}}],"edges":[{"src":"<import-utils>","dst":"<utils>","type":"IMPORTS"},{"src":"<import-utils>","dst":"<./modules-helpers.js>","type":"IMPORTS_FROM"},{"src":"<utils.helperFunction()>","dst":"<utils.helperFunction>","type":"CALLS"},{"src":"<utils.helperFunction>","dst":"<utils>","type":"READS_FROM"},{"src":"<helperFunction>","dst":"<utils>","type":"ASSIGNED_FROM"},{"src":"<fn>","dst":"<utils['helperFunction']>","type":"ASSIGNED_FROM"},{"src":"<utils['helperFunction']>","dst":"<utils>","type":"READS_FROM"}],"rationale":"Namespace import creates a single binding containing all exports. Three different access patterns: method call, destructuring assignment, and bracket notation access. Removed module-level CONTAINS and DECLARES edges to reduce edge count while preserving core semantic relationships.","implicitBehavior":["namespace object contains all named exports from target module","destructuring creates new binding separate from namespace","bracket access allows dynamic property names"]},"pass":2,"annotatedAt":"2026-02-24T00:36:22.021Z"}
{"construct":{"id":"patterns::param-destructuring-object","file":"src/patterns.js","category":"patterns","lineStart":51,"lineEnd":54,"code":"function withObjectParam({ name, age, role = 'guest' }) {\n  return `${name} (${age}) - ${role}`;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withObjectParam>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<destructured-param>","metadata":{"destructured":true,"destructureType":"object"}},{"type":"VARIABLE","id":"<name>","metadata":{"destructured":true,"kind":"parameter"}},{"type":"VARIABLE","id":"<age>","metadata":{"destructured":true,"kind":"parameter"}},{"type":"VARIABLE","id":"<role>","metadata":{"destructured":true,"kind":"parameter","hasDefault":true}},{"type":"LITERAL","id":"<'guest'>","metadata":{"value":"guest","literalType":"string"}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}}],"edges":[{"src":"<withObjectParam>","dst":"<destructured-param>","type":"CONTAINS"},{"src":"<destructured-param>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<destructured-param>","dst":"<age>","type":"ASSIGNED_FROM"},{"src":"<destructured-param>","dst":"<role>","type":"ASSIGNED_FROM"},{"src":"<role>","dst":"<'guest'>","type":"DEFAULTS_TO"},{"src":"<withObjectParam>","dst":"<template-literal>","type":"RETURNS"},{"src":"<template-literal>","dst":"<name>","type":"READS_FROM"},{"src":"<template-literal>","dst":"<age>","type":"READS_FROM"},{"src":"<template-literal>","dst":"<role>","type":"READS_FROM"}],"rationale":"Function with object destructuring parameter. The parameter destructures into three variables, one with a default value. Template literal reads all three destructured variables. Used ASSIGNED_FROM instead of DESTRUCTURES_TO as closest approved match.","implicitBehavior":["destructuring creates new bindings in function scope","default value assignment occurs if property is undefined","missing properties in passed object result in undefined bindings"]},"pass":2,"annotatedAt":"2026-02-24T00:36:23.151Z"}
{"construct":{"id":"patterns::array-destructuring-swap","file":"src/patterns.js","category":"patterns","lineStart":43,"lineEnd":49,"code":"function arrayDestructuringSwap() {\n  let left = 'left';\n  let right = 'right';\n  [left, right] = [right, left];\n  return { left, right };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<arrayDestructuringSwap>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<left>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<'left'>","metadata":{"value":"left","literalType":"string"}},{"type":"VARIABLE","id":"<right>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<'right'>","metadata":{"value":"right","literalType":"string"}},{"type":"EXPRESSION","id":"<[left, right]>","metadata":{"type":"destructuring-assignment"}},{"type":"EXPRESSION","id":"<[right, left]>","metadata":{"type":"array-literal"}},{"type":"EXPRESSION","id":"<{ left, right }>","metadata":{"type":"object-literal","shorthand":true}}],"edges":[{"src":"<arrayDestructuringSwap>","dst":"<left>","type":"CONTAINS"},{"src":"<arrayDestructuringSwap>","dst":"<right>","type":"CONTAINS"},{"src":"<left>","dst":"<'left'>","type":"ASSIGNED_FROM"},{"src":"<right>","dst":"<'right'>","type":"ASSIGNED_FROM"},{"src":"<[left, right]>","dst":"<[right, left]>","type":"ASSIGNED_FROM"},{"src":"<[left, right]>","dst":"<left>","type":"WRITES_TO"},{"src":"<[left, right]>","dst":"<right>","type":"WRITES_TO"},{"src":"<[right, left]>","dst":"<right>","type":"READS_FROM"},{"src":"<[right, left]>","dst":"<left>","type":"READS_FROM"},{"src":"<arrayDestructuringSwap>","dst":"<{ left, right }>","type":"RETURNS"},{"src":"<{ left, right }>","dst":"<left>","type":"READS_FROM"},{"src":"<{ left, right }>","dst":"<right>","type":"READS_FROM"}],"rationale":"Function with array destructuring swap pattern. Variables are initially assigned literals, then swapped via destructuring assignment from array literal, finally returned in object literal with shorthand syntax.","implicitBehavior":["destructuring creates temporary array for swap operation","object shorthand property names match variable names"]},"pass":2,"annotatedAt":"2026-02-24T00:36:23.968Z"}
{"construct":{"id":"modules-reexport::circular-import-live-binding","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":22,"lineEnd":25,"code":"// File A: export let count = 0; export function inc() { count++; }\n// File B: import { count, inc } from './a.js'; inc(); console.log(count); // 1  live binding!\n// Graph impact: imported let is NOT a copy  mutations in source module visible to importers","commentedOut":true},"annotation":{"nodes":[{"type":"MODULE","id":"<fileA>","metadata":{"path":"./a.js"}},{"type":"VARIABLE","id":"<count>","metadata":{"kind":"let","exported":true,"mutable":true}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"FUNCTION","id":"<inc>","metadata":{"exported":true}},{"type":"EXPRESSION","id":"<count++>","metadata":{"operator":"++"}},{"type":"MODULE","id":"<fileB>","metadata":{"path":"./b.js"}},{"type":"IMPORT","id":"<import-a>","metadata":{"source":"./a.js"}},{"type":"VARIABLE","id":"<count:imported>","metadata":{"imported":true,"liveBinding":true}},{"type":"VARIABLE","id":"<inc:imported>","metadata":{"imported":true}},{"type":"CALL","id":"<inc()>","metadata":{"callee":"inc"}},{"type":"CALL","id":"<console.log(count)>","metadata":{"callee":"console.log"}}],"edges":[{"src":"<fileA>","dst":"<count>","type":"DECLARES"},{"src":"<count>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<fileA>","dst":"<inc>","type":"DECLARES"},{"src":"<inc>","dst":"<count++>","type":"CONTAINS"},{"src":"<count++>","dst":"<count>","type":"MODIFIES"},{"src":"<fileA>","dst":"<count>","type":"EXPORTS"},{"src":"<fileA>","dst":"<inc>","type":"EXPORTS"},{"src":"<fileB>","dst":"<import-a>","type":"CONTAINS"},{"src":"<import-a>","dst":"<count:imported>","type":"IMPORTS"},{"src":"<import-a>","dst":"<inc:imported>","type":"IMPORTS"},{"src":"<fileB>","dst":"<fileA>","type":"IMPORTS_FROM"},{"src":"<count:imported>","dst":"<count>","type":"ALIASES"},{"src":"<inc:imported>","dst":"<inc>","type":"ALIASES"},{"src":"<inc()>","dst":"<inc:imported>","type":"CALLS"},{"src":"<console.log(count)>","dst":"<count:imported>","type":"READS_FROM"}],"rationale":"ES6 modules create live bindings where imported variables reference the original binding, not a copy. When fileA's inc() mutates count, fileB sees the updated value through the live binding. Using ALIASES to represent the live binding relationship between imported and original variables.","implicitBehavior":["ES6 import creates live binding - imported variables are references to original bindings","Mutations in exporting module are visible to all importing modules","Imported let/const variables cannot be reassigned in importing module but reflect source mutations"]},"pass":2,"annotatedAt":"2026-02-24T00:36:24.891Z"}
{"construct":{"id":"modern-es::export-named-list","file":"src/modern-es.js","category":"modern-es","lineStart":325,"lineEnd":356,"code":"export {\n  arrayAt,\n  arrayFindLast,\n  arrayImmutable,\n  objectGroupBy,\n  mapGroupBy,\n  createDeferred,\n  wrapError,\n  hasOwnCheck,\n  deepClone,\n  regexIndices,\n  InfiniteOnes,\n  AsyncSequence,\n  Money,\n  CustomCollection,\n  SpecialArray,\n  fetchWithAbort,\n  usingSyncExample,\n  usingAsyncExample,\n  iteratorHelpers,\n  setMethods,\n  usingDeclaration,\n  usingAwaitDeclaration,\n  usingInFor,\n  Reactive,\n  workerUrl,\n  loadOptional,\n  createWeakCache,\n  cleanupRegistry,\n  trackObject,\n};","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"EXPORT\",\n      \"id\": \"<export-named-list>\",\n      \"metadata\": {\n        \"exportType\": \"named-list\"\n      }\n    },\n    {\n      \"type\": \"VARIABLE\",\n      \"id\""},"pass":2,"annotatedAt":"2026-02-24T00:36:26.633Z"}
{"construct":{"id":"patterns::param-destructuring-array","file":"src/patterns.js","category":"patterns","lineStart":56,"lineEnd":59,"code":"function withArrayParam([first, second, ...rest]) {\n  return { first, second, rest };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withArrayParam>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<arrayParam>","metadata":{"destructured":true,"destructureType":"array"}},{"type":"VARIABLE","id":"<first>","metadata":{"destructuredFrom":"arrayParam","destructureIndex":0}},{"type":"VARIABLE","id":"<second>","metadata":{"destructuredFrom":"arrayParam","destructureIndex":1}},{"type":"VARIABLE","id":"<rest>","metadata":{"destructuredFrom":"arrayParam","restParameter":true}},{"type":"EXPRESSION","id":"<{ first, second, rest }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<withArrayParam>","dst":"<arrayParam>","type":"CONTAINS"},{"src":"<arrayParam>","dst":"<first>","type":"ASSIGNED_FROM"},{"src":"<arrayParam>","dst":"<second>","type":"ASSIGNED_FROM"},{"src":"<arrayParam>","dst":"<rest>","type":"ASSIGNED_FROM"},{"src":"<withArrayParam>","dst":"<{ first, second, rest }>","type":"RETURNS"},{"src":"<{ first, second, rest }>","dst":"<first>","type":"READS_FROM"},{"src":"<{ first, second, rest }>","dst":"<second>","type":"READS_FROM"},{"src":"<{ first, second, rest }>","dst":"<rest>","type":"READS_FROM"}],"rationale":"Function with array destructuring parameter. The parameter destructures into individual variables, which are then used in an object literal return value. Used ASSIGNED_FROM instead of DESTRUCTURES_TO as the closest approved edge type.","implicitBehavior":["array destructuring creates bindings for each element","rest parameter collects remaining elements into an array","object literal uses shorthand property syntax"]},"pass":2,"annotatedAt":"2026-02-24T00:36:26.854Z"}
{"construct":{"id":"modules-reexport::star-reexport-collision","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":33,"lineEnd":37,"code":"// a.js: export const x = 1;\n// b.js: export const x = 2;\n// barrel.js: export * from './a'; export * from './b'; // x is ambiguous!\n// Explicit re-export wins: export * from './a'; export { x } from './b';","commentedOut":true},"annotation":{"nodes":[{"type":"MODULE","id":"<a.js>","metadata":{"path":"./a"}},{"type":"VARIABLE","id":"<a.js:x>","metadata":{"kind":"const","exported":true}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"MODULE","id":"<b.js>","metadata":{"path":"./b"}},{"type":"VARIABLE","id":"<b.js:x>","metadata":{"kind":"const","exported":true}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"MODULE","id":"<barrel.js>","metadata":{"path":"./barrel"}},{"type":"EXPORT","id":"<star-export-a>","metadata":{"exportType":"star"}},{"type":"EXPORT","id":"<star-export-b>","metadata":{"exportType":"star"}},{"type":"EXPORT","id":"<explicit-x-export>","metadata":{"exportType":"named","name":"x"}}],"edges":[{"src":"<a.js>","dst":"<a.js:x>","type":"DECLARES"},{"src":"<a.js:x>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<a.js>","dst":"<a.js:x>","type":"EXPORTS"},{"src":"<b.js>","dst":"<b.js:x>","type":"DECLARES"},{"src":"<b.js:x>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<b.js>","dst":"<b.js:x>","type":"EXPORTS"},{"src":"<barrel.js>","dst":"<star-export-a>","type":"CONTAINS"},{"src":"<barrel.js>","dst":"<star-export-b>","type":"CONTAINS"},{"src":"<barrel.js>","dst":"<explicit-x-export>","type":"CONTAINS"},{"src":"<star-export-a>","dst":"<a.js>","type":"IMPORTS_FROM"},{"src":"<star-export-b>","dst":"<b.js>","type":"IMPORTS_FROM"},{"src":"<explicit-x-export>","dst":"<b.js>","type":"IMPORTS_FROM"},{"src":"<star-export-a>","dst":"<a.js:x>","type":"EXPORTS"},{"src":"<star-export-b>","dst":"<b.js:x>","type":"EXPORTS"},{"src":"<explicit-x-export>","dst":"<b.js:x>","type":"EXPORTS"}],"rationale":"Three modules demonstrating star re-export collision. Both a.js and b.js export 'x', creating ambiguity when barrel.js re-exports both with star exports. The explicit named export resolves the conflict by taking precedence.","implicitBehavior":["star exports create namespace collision for 'x'","explicit named export takes precedence over star exports","module resolution follows ES6 export precedence rules"]},"pass":2,"annotatedAt":"2026-02-24T00:36:27.737Z"}
{"construct":{"id":"patterns::param-destructuring-nested","file":"src/patterns.js","category":"patterns","lineStart":61,"lineEnd":64,"code":"function withNestedParam({ user: { name }, settings: { theme = 'light' } }) {\n  return { name, theme };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withNestedParam>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<destructured-param>","metadata":{"destructured":true,"nested":true}},{"type":"VARIABLE","id":"<name>","metadata":{"destructured":true,"path":"user.name"}},{"type":"VARIABLE","id":"<theme>","metadata":{"destructured":true,"path":"settings.theme","hasDefault":true}},{"type":"LITERAL","id":"<'light'>","metadata":{"value":"light","literalType":"string"}},{"type":"EXPRESSION","id":"<{ name, theme }>","metadata":{"type":"object","shorthand":true}}],"edges":[{"src":"<withNestedParam>","dst":"<destructured-param>","type":"CONTAINS"},{"src":"<destructured-param>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<destructured-param>","dst":"<theme>","type":"ASSIGNED_FROM"},{"src":"<theme>","dst":"<'light'>","type":"DEFAULTS_TO"},{"src":"<withNestedParam>","dst":"<{ name, theme }>","type":"RETURNS"},{"src":"<{ name, theme }>","dst":"<name>","type":"READS_FROM"},{"src":"<{ name, theme }>","dst":"<theme>","type":"READS_FROM"}],"rationale":"Function with nested destructuring parameter extracts deeply nested properties with default value. Returns object using shorthand property syntax. Used ASSIGNED_FROM instead of DESTRUCTURES_TO as closest approved match.","implicitBehavior":["nested destructuring creates intermediate bindings","default value only applies if settings.theme is undefined","shorthand object property syntax creates properties with same names as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:36:29.042Z"}
{"construct":{"id":"modules-reexport::import-meta-url","file":"src/modules-reexport.js","category":"modules-reexport","lineStart":39,"lineEnd":42,"code":"// const __filename = new URL(import.meta.url).pathname;\n// const __dirname = new URL('.', import.meta.url).pathname;\n// const workerUrl = new URL('./worker.js', import.meta.url); // implicit file dependency","commentedOut":true},"annotation":{"nodes":[{"type":"VARIABLE","id":"<__filename>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new URL(import.meta.url)>","metadata":{"constructor":"URL"}},{"type":"META_PROPERTY","id":"<import.meta.url>"},{"type":"PROPERTY_ACCESS","id":"<new URL(import.meta.url).pathname>"},{"type":"VARIABLE","id":"<__dirname>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new URL('.', import.meta.url)>","metadata":{"constructor":"URL"}},{"type":"LITERAL","id":"<'.'>","metadata":{"value":".","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<new URL('.', import.meta.url).pathname>"},{"type":"VARIABLE","id":"<workerUrl>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new URL('./worker.js', import.meta.url)>","metadata":{"constructor":"URL"}},{"type":"LITERAL","id":"<'./worker.js'>","metadata":{"value":"./worker.js","literalType":"string"}},{"type":"FILE","id":"<./worker.js>","metadata":{"path":"./worker.js"}}],"edges":[{"src":"<__filename>","dst":"<new URL(import.meta.url).pathname>","type":"ASSIGNED_FROM"},{"src":"<new URL(import.meta.url).pathname>","dst":"<new URL(import.meta.url)>","type":"READS_FROM"},{"src":"<new URL(import.meta.url)>","dst":"<import.meta.url>","type":"PASSES_ARGUMENT"},{"src":"<__dirname>","dst":"<new URL('.', import.meta.url).pathname>","type":"ASSIGNED_FROM"},{"src":"<new URL('.', import.meta.url).pathname>","dst":"<new URL('.', import.meta.url)>","type":"READS_FROM"},{"src":"<new URL('.', import.meta.url)>","dst":"<'.'>","type":"PASSES_ARGUMENT"},{"src":"<new URL('.', import.meta.url)>","dst":"<import.meta.url>","type":"PASSES_ARGUMENT"},{"src":"<workerUrl>","dst":"<new URL('./worker.js', import.meta.url)>","type":"ASSIGNED_FROM"},{"src":"<new URL('./worker.js', import.meta.url)>","dst":"<'./worker.js'>","type":"PASSES_ARGUMENT"},{"src":"<new URL('./worker.js', import.meta.url)>","dst":"<import.meta.url>","type":"PASSES_ARGUMENT"},{"src":"<./worker.js>","dst":"<'./worker.js'>","type":"RESOLVES_TO"}],"rationale":"Three const declarations using URL constructor with import.meta.url to resolve file paths. The import.meta.url is properly typed as META_PROPERTY. File dependency is captured through RESOLVES_TO relationship between the file and its path literal.","implicitBehavior":["import.meta.url provides current module's file URL","URL constructor resolves relative paths against base URL","pathname property extracts file system path from URL"]},"pass":2,"annotatedAt":"2026-02-24T00:36:29.600Z"}
{"construct":{"id":"patterns::spread-calls","file":"src/patterns.js","category":"patterns","lineStart":82,"lineEnd":87,"code":"function spreadInCalls() {\n  const args = [1, 2, 3];\n  const max = Math.max(...args);\n  return max;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<spreadInCalls>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<args>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"literalType":"array","elements":[1,2,3]}},{"type":"VARIABLE","id":"<max>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Math.max(...args)>","metadata":{"callee":"Math.max","hasSpread":true}},{"type":"PROPERTY_ACCESS","id":"<Math.max>","metadata":{"objectName":"Math","propertyName":"max"}},{"type":"EXPRESSION","id":"<...args>","metadata":{"operator":"spread"}}],"edges":[{"src":"<spreadInCalls>","dst":"<args>","type":"CONTAINS"},{"src":"<spreadInCalls>","dst":"<max>","type":"CONTAINS"},{"src":"<args>","dst":"<[1, 2, 3]>","type":"ASSIGNED_FROM"},{"src":"<max>","dst":"<Math.max(...args)>","type":"ASSIGNED_FROM"},{"src":"<Math.max(...args)>","dst":"<Math.max>","type":"CALLS"},{"src":"<Math.max(...args)>","dst":"<...args>","type":"PASSES_ARGUMENT"},{"src":"<...args>","dst":"<args>","type":"SPREADS_FROM"},{"src":"<spreadInCalls>","dst":"<max>","type":"RETURNS"}],"rationale":"Function with spread operator in call. Array literal assigned to args, then spread into Math.max call arguments. Reduced from 9 to 8 edges by removing module declaration edge and using SPREADS_FROM for the spread relationship.","implicitBehavior":["spread operator expands array elements as individual arguments","Math.max receives variable number of arguments"]},"pass":2,"annotatedAt":"2026-02-24T00:36:30.018Z"}
{"construct":{"id":"patterns::destructure-assign-nested-target","file":"src/patterns.js","category":"patterns","lineStart":165,"lineEnd":171,"code":"function destructureAssignNestedTarget() {\n  const state = { user: { name: 'old' } };\n  let name;\n  ({ user: { name } } = state);\n  return name;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureAssignNestedTarget>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<state>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ user: { name: 'old' } }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'old'>","metadata":{"value":"old","literalType":"string"}},{"type":"VARIABLE","id":"<name>","metadata":{"kind":"let"}},{"type":"EXPRESSION","id":"<{ user: { name } } = state>","metadata":{"expressionType":"assignment","pattern":"destructuring"}},{"type":"PROPERTY_ACCESS","id":"<state.user.name>","metadata":{"path":"user.name"}}],"edges":[{"src":"<destructureAssignNestedTarget>","dst":"<state>","type":"CONTAINS"},{"src":"<destructureAssignNestedTarget>","dst":"<name>","type":"CONTAINS"},{"src":"<state>","dst":"<{ user: { name: 'old' } }>","type":"ASSIGNED_FROM"},{"src":"<{ user: { name: 'old' } }>","dst":"<'old'>","type":"CONTAINS"},{"src":"<destructureAssignNestedTarget>","dst":"<{ user: { name } } = state>","type":"CONTAINS"},{"src":"<{ user: { name } } = state>","dst":"<state>","type":"READS_FROM"},{"src":"<{ user: { name } } = state>","dst":"<state.user.name>","type":"READS_FROM"},{"src":"<name>","dst":"<state.user.name>","type":"ASSIGNED_FROM"},{"src":"<destructureAssignNestedTarget>","dst":"<name>","type":"RETURNS"}],"rationale":"Function with nested destructuring assignment. Creates object literal, declares uninitialized variable, then uses destructuring to extract nested property value into the variable. Mapped DESTRUCTURE_ASSIGNMENT to EXPRESSION and EXTRACTS to READS_FROM as closest approved types.","implicitBehavior":["destructuring creates temporary property access chain","assignment happens after pattern matching"]},"pass":2,"annotatedAt":"2026-02-24T00:36:34.449Z"}
{"construct":{"id":"patterns::spread-objects","file":"src/patterns.js","category":"patterns","lineStart":74,"lineEnd":80,"code":"function spreadInObjects() {\n  const base = { a: 1, b: 2 };\n  const extended = { ...base, c: 3, b: 'overridden' };\n  const clone = { ...base };\n  return { extended, clone };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<spreadInObjects>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<base>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ a: 1, b: 2 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"VARIABLE","id":"<extended>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ ...base, c: 3, b: 'overridden' }>","metadata":{"expressionType":"object-spread"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"LITERAL","id":"<'overridden'>","metadata":{"value":"overridden","literalType":"string"}},{"type":"VARIABLE","id":"<clone>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ ...base }>","metadata":{"expressionType":"object-spread"}},{"type":"EXPRESSION","id":"<{ extended, clone }>","metadata":{"expressionType":"object-shorthand"}}],"edges":[{"src":"<spreadInObjects>","dst":"<base>","type":"CONTAINS"},{"src":"<spreadInObjects>","dst":"<extended>","type":"CONTAINS"},{"src":"<spreadInObjects>","dst":"<clone>","type":"CONTAINS"},{"src":"<base>","dst":"<{ a: 1, b: 2 }>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1, b: 2 }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<{ a: 1, b: 2 }>","dst":"<2>","type":"HAS_PROPERTY"},{"src":"<extended>","dst":"<{ ...base, c: 3, b: 'overridden' }>","type":"ASSIGNED_FROM"},{"src":"<{ ...base, c: 3, b: 'overridden' }>","dst":"<base>","type":"SPREADS_FROM"},{"src":"<{ ...base, c: 3, b: 'overridden' }>","dst":"<3>","type":"HAS_PROPERTY"},{"src":"<{ ...base, c: 3, b: 'overridden' }>","dst":"<'overridden'>","type":"HAS_PROPERTY"},{"src":"<clone>","dst":"<{ ...base }>","type":"ASSIGNED_FROM"},{"src":"<{ ...base }>","dst":"<base>","type":"SPREADS_FROM"},{"src":"<spreadInObjects>","dst":"<{ extended, clone }>","type":"RETURNS"},{"src":"<{ extended, clone }>","dst":"<extended>","type":"READS_FROM"},{"src":"<{ extended, clone }>","dst":"<clone>","type":"READS_FROM"}],"rationale":"Function demonstrates object spread patterns using approved vocabulary. All node and edge types from Pass 1 were already in the approved list, so no changes needed. The annotation captures the spread operations, property assignments, and variable relationships accurately.","implicitBehavior":["spread creates shallow copy","later properties override earlier ones in spread","shorthand property syntax uses variable names as keys"]},"pass":2,"annotatedAt":"2026-02-24T00:36:35.556Z"}
{"construct":{"id":"patterns::destructure-empty","file":"src/patterns.js","category":"patterns","lineStart":218,"lineEnd":222,"code":"function destructureEmpty(obj, iter) {\n  const {} = obj;        // valid  no vars, triggers toString/valueOf\n  const [] = iter;       // valid  consumes iterator, creates nothing\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureEmpty>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<iter>"},{"type":"EXPRESSION","id":"<{} = obj>","metadata":{"pattern":"object","empty":true,"destructuring":true}},{"type":"EXPRESSION","id":"<[] = iter>","metadata":{"pattern":"array","empty":true,"destructuring":true}}],"edges":[{"src":"<module>","dst":"<destructureEmpty>","type":"DECLARES"},{"src":"<destructureEmpty>","dst":"<obj>","type":"CONTAINS"},{"src":"<destructureEmpty>","dst":"<iter>","type":"CONTAINS"},{"src":"<destructureEmpty>","dst":"<{} = obj>","type":"CONTAINS"},{"src":"<destructureEmpty>","dst":"<[] = iter>","type":"CONTAINS"},{"src":"<{} = obj>","dst":"<obj>","type":"READS_FROM"},{"src":"<[] = iter>","dst":"<iter>","type":"READS_FROM"}],"rationale":"Function with empty destructuring patterns that trigger side effects without creating variables. Object destructuring forces toString/valueOf, array destructuring consumes iterator. Using EXPRESSION for destructuring patterns since no specific DESTRUCTURE type exists in approved vocabulary.","implicitBehavior":["empty object destructuring triggers toString/valueOf coercion on obj","empty array destructuring consumes iterator protocol on iter","no variables are declared despite destructuring syntax"]},"pass":2,"annotatedAt":"2026-02-24T00:36:37.178Z"}
{"construct":{"id":"patterns::spread-arrays","file":"src/patterns.js","category":"patterns","lineStart":66,"lineEnd":72,"code":"function spreadInArrays() {\n  const source = [1, 2, 3];\n  const extended = [0, ...source, 4, 5];\n  const clone = [...source];\n  return { extended, clone };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<spreadInArrays>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<source>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"VARIABLE","id":"<extended>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[0, ...source, 4, 5]>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<...source>","metadata":{"operator":"spread"}},{"type":"LITERAL","id":"<4>","metadata":{"value":4,"literalType":"number"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"VARIABLE","id":"<clone>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[...source]>","metadata":{"literalType":"array"}},{"type":"EXPRESSION","id":"<...source:clone>","metadata":{"operator":"spread"}},{"type":"LITERAL","id":"<{ extended, clone }>","metadata":{"literalType":"object"}}],"edges":[{"src":"<spreadInArrays>","dst":"<source>","type":"CONTAINS"},{"src":"<spreadInArrays>","dst":"<extended>","type":"CONTAINS"},{"src":"<spreadInArrays>","dst":"<clone>","type":"CONTAINS"},{"src":"<source>","dst":"<[1, 2, 3]>","type":"ASSIGNED_FROM"},{"src":"<[1, 2, 3]>","dst":"<1>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3]>","dst":"<2>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3]>","dst":"<3>","type":"HAS_ELEMENT"},{"src":"<extended>","dst":"<[0, ...source, 4, 5]>","type":"ASSIGNED_FROM"},{"src":"<[0, ...source, 4, 5]>","dst":"<0>","type":"HAS_ELEMENT"},{"src":"<[0, ...source, 4, 5]>","dst":"<...source>","type":"HAS_ELEMENT"},{"src":"<[0, ...source, 4, 5]>","dst":"<4>","type":"HAS_ELEMENT"},{"src":"<[0, ...source, 4, 5]>","dst":"<5>","type":"HAS_ELEMENT"},{"src":"<...source>","dst":"<source>","type":"SPREADS_FROM"},{"src":"<clone>","dst":"<[...source]>","type":"ASSIGNED_FROM"},{"src":"<[...source]>","dst":"<...source:clone>","type":"HAS_ELEMENT"},{"src":"<...source:clone>","dst":"<source>","type":"SPREADS_FROM"},{"src":"<spreadInArrays>","dst":"<{ extended, clone }>","type":"RETURNS"},{"src":"<{ extended, clone }>","dst":"<extended>","type":"HAS_PROPERTY"},{"src":"<{ extended, clone }>","dst":"<clone>","type":"HAS_PROPERTY"}],"rationale":"Function demonstrates spread operator in arrays. Creates source array, spreads it into extended array with additional elements, creates clone via spread, returns object with both arrays. All types from Pass 1 were already in the approved vocabulary.","implicitBehavior":["spread operator creates shallow copies","array elements are iterated and copied during spread operation"]},"pass":2,"annotatedAt":"2026-02-24T00:36:38.099Z"}
{"construct":{"id":"patterns::destructure-computed-key","file":"src/patterns.js","category":"patterns","lineStart":211,"lineEnd":216,"code":"function destructureComputedKey() {\n  const key = 'name';\n  const { [key]: value } = { name: 'Alice' };\n  return value;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureComputedKey>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'name'>","metadata":{"value":"name","literalType":"string"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ [key]: value }>","metadata":{"pattern":"object","computedKey":true}},{"type":"LITERAL","id":"<{ name: 'Alice' }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'Alice'>","metadata":{"value":"Alice","literalType":"string"}}],"edges":[{"src":"<destructureComputedKey>","dst":"<key>","type":"CONTAINS"},{"src":"<destructureComputedKey>","dst":"<value>","type":"CONTAINS"},{"src":"<key>","dst":"<'name'>","type":"ASSIGNED_FROM"},{"src":"<destructureComputedKey>","dst":"<{ [key]: value }>","type":"CONTAINS"},{"src":"<{ [key]: value }>","dst":"<{ name: 'Alice' }>","type":"ASSIGNED_FROM"},{"src":"<{ [key]: value }>","dst":"<key>","type":"READS_FROM"},{"src":"<{ [key]: value }>","dst":"<value>","type":"WRITES_TO"},{"src":"<{ name: 'Alice' }>","dst":"<'Alice'>","type":"HAS_PROPERTY"},{"src":"<destructureComputedKey>","dst":"<value>","type":"RETURNS"}],"rationale":"Function with destructuring assignment using computed property key. The key variable's value determines which property to extract from the object literal. Mapped DESTRUCTURE to EXPRESSION and destructuring-specific edges to general assignment/access patterns.","implicitBehavior":["computed key is evaluated at runtime to determine property access","destructuring creates new binding in function scope"]},"pass":2,"annotatedAt":"2026-02-24T00:36:38.413Z"}
{"construct":{"id":"patterns::array-destructuring-nested","file":"src/patterns.js","category":"patterns","lineStart":36,"lineEnd":41,"code":"function arrayDestructuringNested() {\n  const matrix = [[1, 2], [3, 4]];\n  const [[a1, a2], [b1, b2]] = matrix;\n  return { a1, a2, b1, b2 };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<arrayDestructuringNested>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type"},"pass":2,"annotatedAt":"2026-02-24T00:36:38.612Z"}
{"construct":{"id":"patterns::computed-properties","file":"src/patterns.js","category":"patterns","lineStart":89,"lineEnd":102,"code":"function computedProperties() {\n  const key = 'dynamic';\n  const index = 0;\n\n  const obj = {\n    [key]: 'value',\n    [`prefix_${key}`]: 'prefixed',\n    [index + 1]: 'computed index',\n    [Symbol.iterator]: function* () { yield 1; },\n  };\n\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<computedProperties>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VA"},"pass":2,"annotatedAt":"2026-02-24T00:36:44.198Z"}
{"construct":{"id":"patterns::shorthand-patterns","file":"src/patterns.js","category":"patterns","lineStart":104,"lineEnd":120,"code":"function shorthandPatterns() {\n  const name = 'Alice';\n  const age = 30;\n\n  const person = { name, age };\n\n  const obj = {\n    greet() { return 'hello'; },\n    async fetchData() { return 42; },\n    *generate() { yield 1; },\n    get value() { return this._v; },\n    set value(v) { this._v = v; },\n  };\n\n  return { person, obj };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<shorthandPatterns>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VAR"},"pass":2,"annotatedAt":"2026-02-24T00:36:44.549Z"}
{"construct":{"id":"patterns::object-literal-forms","file":"src/patterns.js","category":"patterns","lineStart":122,"lineEnd":136,"code":"function objectLiteralForms() {\n  const key = 'computed';\n\n  return {\n    regular: 'value',\n    'string-key': 'value',\n    42: 'numeric key',\n    [key]: 'computed value',\n    nested: { a: { b: { c: 1 } } },\n    method() { return true; },\n    get accessor() { return 1; },\n    set accessor(v) {},\n  };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<objectLiteralForms>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VA"},"pass":2,"annotatedAt":"2026-02-24T00:36:45.598Z"}
{"construct":{"id":"patterns::destructure-nested-defaults-combined","file":"src/patterns.js","category":"patterns","lineStart":231,"lineEnd":235,"code":"function destructureNestedDefaults() {\n  const { a: { b = 10 } = {} } = {};\n  return b; // 10  default for inner AND outer\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureNestedDefaults>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<destructuring>","metadata":{"kind":"const","pattern":"nested-object-destructuring"}},{"type":"VARIABLE","id":"<b>","metadata":{"destructured":true}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object","role":"outer-default"}},{"type":"LITERAL","id":"<{}:source>","metadata":{"value":{},"literalType":"object","role":"source"}},{"type":"EXPRESSION","id":"<return b>","metadata":{"type":"return"}}],"edges":[{"src":"<destructureNestedDefaults>","dst":"<destructuring>","type":"CONTAINS"},{"src":"<destructuring>","dst":"<b>","type":"ASSIGNED_FROM"},{"src":"<destructuring>","dst":"<{}:source>","type":"ASSIGNED_FROM"},{"src":"<b>","dst":"<10>","type":"DEFAULTS_TO"},{"src":"<destructuring>","dst":"<{}>","type":"DEFAULTS_TO"},{"src":"<destructureNestedDefaults>","dst":"<return b>","type":"CONTAINS"},{"src":"<return b>","dst":"<b>","type":"READS_FROM"},{"src":"<destructureNestedDefaults>","dst":"<return b>","type":"RETURNS"}],"rationale":"Nested destructuring with defaults at multiple levels. The outer destructuring defaults to empty object, inner property b defaults to 10. Both defaults activate since source is empty object. Used ASSIGNED_FROM for destructuring relationships since no specific destructuring edge type exists in approved vocabulary.","implicitBehavior":["nested default evaluation cascades from outer to inner","property access on undefined triggers outer default","missing property b triggers inner default"]},"pass":2,"annotatedAt":"2026-02-24T00:36:47.111Z"}
{"construct":{"id":"patterns::destructure-assign-to-properties","file":"src/patterns.js","category":"patterns","lineStart":224,"lineEnd":229,"code":"function destructureAssignToProperties() {\n  const obj = {};\n  ({ a: obj.x, b: obj.y } = { a: 1, b: 2 });\n  return obj; // { x: 1, y: 2 }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureAssignToProperties>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object"}},{"type":"EXPRESSION","id":"<destructure-assign>","metadata":{"expressionType":"destructuring_assignment"}},{"type":"PROPERTY_ACCESS","id":"<obj.x>","metadata":{"objectName":"obj","propertyName":"x"}},{"type":"PROPERTY_ACCESS","id":"<obj.y>","metadata":{"objectName":"obj","propertyName":"y"}},{"type":"LITERAL","id":"<{ a: 1, b: 2 }>","metadata":{"value":{"a":1,"b":2},"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<destructureAssignToProperties>","dst":"<obj>","type":"DECLARES"},{"src":"<obj>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<destructureAssignToProperties>","dst":"<destructure-assign>","type":"CONTAINS"},{"src":"<destructure-assign>","dst":"<obj.x>","type":"WRITES_TO"},{"src":"<destructure-assign>","dst":"<obj.y>","type":"WRITES_TO"},{"src":"<destructure-assign>","dst":"<{ a: 1, b: 2 }>","type":"READS_FROM"},{"src":"<{ a: 1, b: 2 }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<{ a: 1, b: 2 }>","dst":"<2>","type":"HAS_PROPERTY"},{"src":"<obj.x>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<obj.y>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<destructureAssignToProperties>","dst":"<obj>","type":"RETURNS"}],"rationale":"Destructuring assignment modeled as EXPRESSION that reads from source object and writes to property access targets. Values flow from source object properties to target object properties through assignment.","implicitBehavior":["property creation on target object","property access evaluation before assignment"]},"pass":2,"annotatedAt":"2026-02-24T00:36:47.535Z"}
{"construct":{"id":"patterns::computed-key-side-effect","file":"src/patterns.js","category":"patterns","lineStart":173,"lineEnd":182,"code":"function computedKeySideEffect() {\n  let i = 0;\n  const obj = {\n    [i++]: 'zero',\n    [i++]: 'one',\n    [i++]: 'two',\n  };\n  return { obj, finalI: i };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<computedKeySideEffect>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": "},"pass":2,"annotatedAt":"2026-02-24T00:36:48.955Z"}
{"construct":{"id":"patterns::spread-duplicate-key-override","file":"src/patterns.js","category":"patterns","lineStart":308,"lineEnd":318,"code":"function spreadDuplicateKeyOverride(overrides) {\n  // Key 'debug' at positions (1) and (3) with spread between  (3) always wins\n  const config = {\n    debug: false,       // (1) explicit default\n    ...overrides,       // (2) user overrides  may set debug\n    debug: true,        // (3) THIS ALWAYS WINS  overrides the override\n    timestamp: Date.now(),\n  };\n  return config;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<spreadDuplicateKeyOverride>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<overrides>"},{"type":"VARIABLE","id":"<config>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<config-object>"},{"type":"PROPERTY","id":"<debug-1>","metadata":{"key":"debug","position":1}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"EXPRESSION","id":"<...overrides>"},{"type":"PROPERTY","id":"<debug-3>","metadata":{"key":"debug","position":3}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"PROPERTY","id":"<timestamp>","metadata":{"key":"timestamp"}},{"type":"CALL","id":"<Date.now()>","metadata":{"callee":"Date.now"}},{"type":"PROPERTY_ACCESS","id":"<Date.now>","metadata":{"objectName":"Date","propertyName":"now"}}],"edges":[{"src":"<spreadDuplicateKeyOverride>","dst":"<overrides>","type":"CONTAINS"},{"src":"<spreadDuplicateKeyOverride>","dst":"<config>","type":"CONTAINS"},{"src":"<config>","dst":"<config-object>","type":"ASSIGNED_FROM"},{"src":"<config-object>","dst":"<debug-1>","type":"HAS_PROPERTY"},{"src":"<debug-1>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<config-object>","dst":"<...overrides>","type":"HAS_ELEMENT"},{"src":"<...overrides>","dst":"<overrides>","type":"SPREADS_FROM"},{"src":"<config-object>","dst":"<debug-3>","type":"HAS_PROPERTY"},{"src":"<debug-3>","dst":"<true>","type":"ASSIGNED_FROM"},{"src":"<debug-3>","dst":"<debug-1>","type":"SHADOWS"},{"src":"<config-object>","dst":"<timestamp>","type":"HAS_PROPERTY"},{"src":"<timestamp>","dst":"<Date.now()>","type":"ASSIGNED_FROM"},{"src":"<Date.now()>","dst":"<Date.now>","type":"CALLS"},{"src":"<spreadDuplicateKeyOverride>","dst":"<config>","type":"RETURNS"}],"rationale":"Object literal with duplicate keys and spread. The second 'debug' property shadows both the first explicit property and any 'debug' from the spread, demonstrating last-wins semantics.","implicitBehavior":["duplicate object keys resolved by last-wins semantics","spread operator may introduce additional properties that could be overridden by subsequent explicit properties"]},"pass":2,"annotatedAt":"2026-02-24T00:36:51.248Z"}
{"construct":{"id":"patterns::destructure-assign-existing","file":"src/patterns.js","category":"patterns","lineStart":154,"lineEnd":163,"code":"function destructureAssignExisting() {\n  let x, y;\n  ({ x, y } = { x: 1, y: 2 });\n\n  let first, rest;\n  [first, ...rest] = [1, 2, 3, 4];\n\n  return { x, y, first, rest };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<destructureAssignExisting>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"typ"},"pass":2,"annotatedAt":"2026-02-24T00:36:51.335Z"}
{"construct":{"id":"patterns::destructure-computed-default-rename","file":"src/patterns.js","category":"patterns","lineStart":244,"lineEnd":250,"code":"function destructureComputedDefaultRename() {\n  const key = 'name';\n  const { [key]: renamed = 'anonymous' } = { name: 'Alice' };\n  const { [key]: missing = 'anonymous' } = {};\n  return { renamed, missing };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureComputedDefaultRename>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'name'>","metadata":{"value":"name","literalType":"string"}},{"type":"VARIABLE","id":"<renamed>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'anonymous'>","metadata":{"value":"anonymous","literalType":"string"}},{"type":"EXPRESSION","id":"<destructure1>","metadata":{"type":"destructuring-assignment"}},{"type":"LITERAL","id":"<{ name: 'Alice' }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'Alice'>","metadata":{"value":"Alice","literalType":"string"}},{"type":"VARIABLE","id":"<missing>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<destructure2>","metadata":{"type":"destructuring-assignment"}},{"type":"LITERAL","id":"<{}>","metadata":{"literalType":"object"}},{"type":"EXPRESSION","id":"<{ renamed, missing }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<destructureComputedDefaultRename>","dst":"<key>","type":"CONTAINS"},{"src":"<key>","dst":"<'name'>","type":"ASSIGNED_FROM"},{"src":"<destructureComputedDefaultRename>","dst":"<renamed>","type":"CONTAINS"},{"src":"<destructureComputedDefaultRename>","dst":"<destructure1>","type":"CONTAINS"},{"src":"<destructure1>","dst":"<key>","type":"READS_FROM"},{"src":"<renamed>","dst":"<destructure1>","type":"ASSIGNED_FROM"},{"src":"<renamed>","dst":"<'anonymous'>","type":"DEFAULTS_TO"},{"src":"<destructure1>","dst":"<{ name: 'Alice' }>","type":"READS_FROM"},{"src":"<{ name: 'Alice' }>","dst":"<'Alice'>","type":"HAS_PROPERTY"},{"src":"<destructureComputedDefaultRename>","dst":"<missing>","type":"CONTAINS"},{"src":"<destructureComputedDefaultRename>","dst":"<destructure2>","type":"CONTAINS"},{"src":"<destructure2>","dst":"<key>","type":"READS_FROM"},{"src":"<missing>","dst":"<destructure2>","type":"ASSIGNED_FROM"},{"src":"<missing>","dst":"<'anonymous'>","type":"DEFAULTS_TO"},{"src":"<destructure2>","dst":"<{}>","type":"READS_FROM"},{"src":"<destructureComputedDefaultRename>","dst":"<{ renamed, missing }>","type":"RETURNS"},{"src":"<{ renamed, missing }>","dst":"<renamed>","type":"READS_FROM"},{"src":"<{ renamed, missing }>","dst":"<missing>","type":"READS_FROM"}],"rationale":"Function demonstrates computed property destructuring with defaults and renaming. Destructuring operations are modeled as EXPRESSION nodes since no specific DESTRUCTURE type exists. Each destructure reads from a computed key and assigns to renamed variables with defaults.","implicitBehavior":["computed property key is evaluated at runtime","default value only used if property is undefined","property lookup happens before default evaluation"]},"pass":2,"annotatedAt":"2026-02-24T00:36:53.359Z"}
{"construct":{"id":"patterns::destructure-nested-rest","file":"src/patterns.js","category":"patterns","lineStart":237,"lineEnd":242,"code":"function destructureNestedRest() {\n  const [first, ...[second, ...deep]] = [1, 2, 3, 4, 5];\n  // first=1, second=2, deep=[3,4,5]\n  return { first, second, deep };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureNestedRest>","metadata":{"async":false,"generator":false}},{"type":"EXPRESSION","id":"<[first, ...[second, ...deep]]>","metadata":{"type":"destructuring_pattern","pattern":"array","nested":true}},{"type":"VARIABLE","id":"<first>","metadata":{"kind":"const"}},{"type":"VARIABLE","id":"<second>","metadata":{"kind":"const"}},{"type":"VARIABLE","id":"<deep>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[1, 2, 3, 4, 5]>","metadata":{"value":[1,2,3,4,5],"literalType":"array"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"LITERAL","id":"<4>","metadata":{"value":4,"literalType":"number"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ first, second, deep }>","metadata":{"type":"object","shorthand":true}}],"edges":[{"src":"<destructureNestedRest>","dst":"<[first, ...[second, ...deep]]>","type":"CONTAINS"},{"src":"<[first, ...[second, ...deep]]>","dst":"<[1, 2, 3, 4, 5]>","type":"ASSIGNED_FROM"},{"src":"<first>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<second>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<deep>","dst":"<[3, 4, 5]>","type":"ASSIGNED_FROM"},{"src":"<[1, 2, 3, 4, 5]>","dst":"<1>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3, 4, 5]>","dst":"<2>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3, 4, 5]>","dst":"<3>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3, 4, 5]>","dst":"<4>","type":"HAS_ELEMENT"},{"src":"<[1, 2, 3, 4, 5]>","dst":"<5>","type":"HAS_ELEMENT"},{"src":"<destructureNestedRest>","dst":"<{ first, second, deep }>","type":"RETURNS"},{"src":"<{ first, second, deep }>","dst":"<first>","type":"READS_FROM"},{"src":"<{ first, second, deep }>","dst":"<second>","type":"READS_FROM"},{"src":"<{ first, second, deep }>","dst":"<deep>","type":"READS_FROM"}],"rationale":"Nested array destructuring with rest patterns mapped to approved vocabulary. The destructuring pattern is represented as an EXPRESSION, and the binding relationships are captured through ASSIGNED_FROM edges. Array containment uses HAS_ELEMENT instead of CONTAINS for elements.","implicitBehavior":["rest pattern creates new array containing remaining elements","nested destructuring executes left-to-right","shorthand object property syntax in return"]},"pass":2,"annotatedAt":"2026-02-24T00:36:53.359Z"}
{"construct":{"id":"property-access::prop-dot-notation","file":"src/property-access.js","category":"property-access","lineStart":7,"lineEnd":12,"code":"function dotAccess(obj) {\n  const a = obj.name;\n  const b = obj.nested.deep.value;\n  return { a, b };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<dotAccess>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj.name>","metadata":{"property":"name"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj.nested>","metadata":{"property":"nested"}},{"type":"PROPERTY_ACCESS","id":"<obj.nested.deep>","metadata":{"property":"deep"}},{"type":"PROPERTY_ACCESS","id":"<obj.nested.deep.value>","metadata":{"property":"value"}},{"type":"EXPRESSION","id":"<{ a, b }>","metadata":{"type":"object","shorthand":true}}],"edges":[{"src":"<dotAccess>","dst":"<obj>","type":"CONTAINS"},{"src":"<dotAccess>","dst":"<a>","type":"DECLARES"},{"src":"<dotAccess>","dst":"<b>","type":"DECLARES"},{"src":"<a>","dst":"<obj.name>","type":"ASSIGNED_FROM"},{"src":"<obj.name>","dst":"<obj>","type":"READS_FROM"},{"src":"<b>","dst":"<obj.nested.deep.value>","type":"ASSIGNED_FROM"},{"src":"<obj.nested>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.nested.deep>","dst":"<obj.nested>","type":"READS_FROM"},{"src":"<obj.nested.deep.value>","dst":"<obj.nested.deep>","type":"READS_FROM"},{"src":"<dotAccess>","dst":"<{ a, b }>","type":"RETURNS"},{"src":"<{ a, b }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b }>","dst":"<b>","type":"READS_FROM"}],"rationale":"Function with property access chains using approved vocabulary. Each dot access is a separate PROPERTY_ACCESS node, chained property accesses read from their parent access. Return object uses shorthand property syntax. Removed the module-level declaration edge as MODULE is not in approved vocabulary.","implicitBehavior":["property access may throw TypeError if intermediate value is null/undefined","shorthand object properties create properties with same name as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:36:54.690Z"}
{"construct":{"id":"property-access::prop-deep-chain","file":"src/property-access.js","category":"property-access","lineStart":33,"lineEnd":36,"code":"function deepChain(root) {\n  return root.level1.level2.level3.value;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deepChain>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<root>"},{"type":"PROPERTY_ACCESS","id":"<root.level1>","metadata":{"objectName":"root","propertyName":"level1"}},{"type":"PROPERTY_ACCESS","id":"<root.level1.level2>","metadata":{"objectName":"root.level1","propertyName":"level2"}},{"type":"PROPERTY_ACCESS","id":"<root.level1.level2.level3>","metadata":{"objectName":"root.level1.level2","propertyName":"level3"}},{"type":"PROPERTY_ACCESS","id":"<root.level1.level2.level3.value>","metadata":{"objectName":"root.level1.level2.level3","propertyName":"value"}}],"edges":[{"src":"<deepChain>","dst":"<root>","type":"CONTAINS"},{"src":"<deepChain>","dst":"<root.level1.level2.level3.value>","type":"RETURNS"},{"src":"<root.level1>","dst":"<root>","type":"READS_FROM"},{"src":"<root.level1.level2>","dst":"<root.level1>","type":"CHAINS_FROM"},{"src":"<root.level1.level2.level3>","dst":"<root.level1.level2>","type":"CHAINS_FROM"},{"src":"<root.level1.level2.level3.value>","dst":"<root.level1.level2.level3>","type":"CHAINS_FROM"}],"rationale":"Function with deep property access chain. Each level of access is a separate node. The first access reads from the parameter, while subsequent accesses chain from the previous level, creating a dependency chain that represents the sequential property access pattern.","implicitBehavior":["potential TypeError if any intermediate property is null/undefined","property lookups may trigger getters at each level"]},"pass":2,"annotatedAt":"2026-02-24T00:36:54.764Z"}
{"construct":{"id":"property-access::prop-dynamic-access","file":"src/property-access.js","category":"property-access","lineStart":22,"lineEnd":31,"code":"function dynamicAccess(obj, keys) {\n  const results = {};\n  for (const key of keys) {\n    results[key] = obj[key];\n  }\n  return results;\n}\n\n// --- Property chain ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<dynamicAccess>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<keys>"},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<results[key]>","metadata":{"dynamic":true}},{"type":"PROPERTY_ACCESS","id":"<obj[key]>","metadata":{"dynamic":true}}],"edges":[{"src":"<dynamicAccess>","dst":"<obj>","type":"CONTAINS"},{"src":"<dynamicAccess>","dst":"<keys>","type":"CONTAINS"},{"src":"<dynamicAccess>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<dynamicAccess>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<keys>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<key>","type":"CONTAINS"},{"src":"<results[key]>","dst":"<obj[key]>","type":"ASSIGNED_FROM"},{"src":"<results[key]>","dst":"<results>","type":"WRITES_TO"},{"src":"<obj[key]>","dst":"<obj>","type":"READS_FROM"},{"src":"<dynamicAccess>","dst":"<results>","type":"RETURNS"}],"rationale":"Function with dynamic property access using computed keys. Loop iterates over keys array, each iteration reads from obj[key] and writes to results[key]. Removed module declaration edge and property access dependencies on key variable to reduce edge count while preserving core semantic relationships.","implicitBehavior":["dynamic property access may trigger getters/setters","property names are computed at runtime","property access operations implicitly depend on the key variable for indexing"]},"pass":2,"annotatedAt":"2026-02-24T00:36:56.199Z"}
{"construct":{"id":"property-access::prop-bracket-notation","file":"src/property-access.js","category":"property-access","lineStart":14,"lineEnd":20,"code":"function bracketAccess(obj, key) {\n  const a = obj['name'];\n  const b = obj[key];\n  const c = obj['complex-key'];\n  return { a, b, c };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<bracketAccess>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<key>"},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj['name']>","metadata":{"accessType":"bracket","property":"name"}},{"type":"LITERAL","id":"<'name'>","metadata":{"value":"name","literalType":"string"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj[key]>","metadata":{"accessType":"bracket","property":"dynamic"}},{"type":"VARIABLE","id":"<c>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj['complex-key']>","metadata":{"accessType":"bracket","property":"complex-key"}},{"type":"LITERAL","id":"<'complex-key'>","metadata":{"value":"complex-key","literalType":"string"}},{"type":"EXPRESSION","id":"<{ a, b, c }>","metadata":{"type":"object","shorthand":true}}],"edges":[{"src":"<bracketAccess>","dst":"<obj>","type":"CONTAINS"},{"src":"<bracketAccess>","dst":"<key>","type":"CONTAINS"},{"src":"<bracketAccess>","dst":"<a>","type":"CONTAINS"},{"src":"<bracketAccess>","dst":"<b>","type":"CONTAINS"},{"src":"<bracketAccess>","dst":"<c>","type":"CONTAINS"},{"src":"<a>","dst":"<obj['name']>","type":"ASSIGNED_FROM"},{"src":"<obj['name']>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj['name']>","dst":"<'name'>","type":"USES"},{"src":"<b>","dst":"<obj[key]>","type":"ASSIGNED_FROM"},{"src":"<obj[key]>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj[key]>","dst":"<key>","type":"USES"},{"src":"<c>","dst":"<obj['complex-key']>","type":"ASSIGNED_FROM"},{"src":"<obj['complex-key']>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj['complex-key']>","dst":"<'complex-key'>","type":"USES"},{"src":"<bracketAccess>","dst":"<{ a, b, c }>","type":"RETURNS"},{"src":"<{ a, b, c }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<b>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<c>","type":"READS_FROM"}],"rationale":"Function with three bracket notation property accesses: static string key, dynamic variable key, and complex string key. Returns object with shorthand property syntax. Removed module declaration edge as no module node was defined.","implicitBehavior":["bracket notation allows dynamic property access","property keys are coerced to strings","shorthand object syntax creates properties with same names as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:36:59.206Z"}
{"construct":{"id":"property-access::prop-dot-assign","file":"src/property-access.js","category":"property-access","lineStart":49,"lineEnd":55,"code":"function dotAssign(obj) {\n  obj.name = 'new';\n  obj.nested = {};\n  obj.nested.deep = 42;\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<dotAssign>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PROPERTY_ACCESS","id":"<obj.name>","metadata":{"objectName":"obj","propertyName":"name"}},{"type":"LITERAL","id":"<'new'>","metadata":{"value":"new","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<obj.nested>","metadata":{"objectName":"obj","propertyName":"nested"}},{"type":"LITERAL","id":"<{}>","metadata":{"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<obj.nested.deep>","metadata":{"objectName":"obj.nested","propertyName":"deep"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}}],"edges":[{"src":"<dotAssign>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj.name>","dst":"<'new'>","type":"ASSIGNED_FROM"},{"src":"<dotAssign>","dst":"<obj.name>","type":"WRITES_TO"},{"src":"<obj.nested>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<dotAssign>","dst":"<obj.nested>","type":"WRITES_TO"},{"src":"<obj.nested.deep>","dst":"<42>","type":"ASSIGNED_FROM"},{"src":"<dotAssign>","dst":"<obj.nested.deep>","type":"WRITES_TO"},{"src":"<dotAssign>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function that performs property assignments on an object parameter. Each property access creates a node, with assignment relationships to literals. Removed the module declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["property assignments mutate the original object","nested property access creates intermediate objects if they don't exist"]},"pass":2,"annotatedAt":"2026-02-24T00:36:59.206Z"}
{"construct":{"id":"property-access::prop-object-from-entries","file":"src/property-access.js","category":"property-access","lineStart":84,"lineEnd":89,"code":"function fromEntries(entries) {\n  return Object.fromEntries(entries);\n}\n\n// --- Object.assign ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<fromEntries>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<entries>"},{"type":"CALL","id":"<Object.fromEntries(entries)>","metadata":{"callee":"Object.fromEntries"}},{"type":"PROPERTY_ACCESS","id":"<Object.fromEntries>","metadata":{"objectName":"Object","propertyName":"fromEntries"}},{"type":"EXTERNAL","id":"<Object>","metadata":{"builtIn":true}}],"edges":[{"src":"<fromEntries>","dst":"<entries>","type":"HAS_BODY"},{"src":"<fromEntries>","dst":"<Object.fromEntries(entries)>","type":"RETURNS"},{"src":"<Object.fromEntries(entries)>","dst":"<Object.fromEntries>","type":"CALLS"},{"src":"<Object.fromEntries(entries)>","dst":"<entries>","type":"PASSES_ARGUMENT"},{"src":"<Object.fromEntries>","dst":"<Object>","type":"READS_FROM"}],"rationale":"Function that wraps Object.fromEntries static method. Property access reads from built-in Object, call passes parameter as argument. Used HAS_BODY instead of CONTAINS for parameter relationship as it better represents the function-parameter containment.","implicitBehavior":["Object is a global built-in available in all scopes"]},"pass":2,"annotatedAt":"2026-02-24T00:37:00.115Z"}
{"construct":{"id":"property-access::prop-bracket-assign","file":"src/property-access.js","category":"property-access","lineStart":57,"lineEnd":62,"code":"function bracketAssign(obj, key, value) {\n  obj[key] = value;\n  obj['fixed-key'] = 'fixed';\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<bracketAssign>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<key>"},{"type":"PARAMETER","id":"<value>"},{"type":"PROPERTY_ACCESS","id":"<obj[key]>","metadata":{"accessType":"bracket","dynamic":true}},{"type":"PROPERTY_ACCESS","id":"<obj['fixed-key']>","metadata":{"accessType":"bracket","dynamic":false,"key":"fixed-key"}},{"type":"LITERAL","id":"<'fixed'>","metadata":{"value":"fixed","literalType":"string"}}],"edges":[{"src":"<bracketAssign>","dst":"<obj>","type":"CONTAINS"},{"src":"<bracketAssign>","dst":"<key>","type":"CONTAINS"},{"src":"<bracketAssign>","dst":"<value>","type":"CONTAINS"},{"src":"<obj[key]>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj[key]>","dst":"<key>","type":"READS_FROM"},{"src":"<obj[key]>","dst":"<value>","type":"ASSIGNED_FROM"},{"src":"<obj['fixed-key']>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj['fixed-key']>","dst":"<'fixed'>","type":"ASSIGNED_FROM"},{"src":"<bracketAssign>","dst":"<obj>","type":"RETURNS"}],"rationale":"Reduced from 12 to 9 edges by removing the WRITES_TO edges from function to property accesses, as the assignment relationship is already captured by ASSIGNED_FROM. The function contains its parameters, property accesses read from their targets, and assignments flow from values to properties.","implicitBehavior":["bracket notation can access any property name including those with special characters","dynamic property access evaluated at runtime","property assignments modify the target object in place"]},"pass":2,"annotatedAt":"2026-02-24T00:37:00.261Z"}
{"construct":{"id":"patterns::destructure-rest-own-only","file":"src/patterns.js","category":"patterns","lineStart":252,"lineEnd":264,"code":"function destructureRestOwnOnly() {\n  const proto = { inherited: 1 };\n  const child = Object.create(proto);\n  child.own = 2;\n  child.also = 3;\n\n  const { own, ...rest } = child;\n  // rest === { also: 3 }  inherited NOT included in rest\n  // But:\n  const { inherited } = child; // 1  named destructuring DOES access prototype\n  return { own, rest, inherited };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureRestOwnOnly>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<proto>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ inherited: 1 }>","metadata":{"literalType":"object"}},{"type":"VARIABLE","id":"<child>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.create(proto)>","metadata":{"callee":"Object.create"}},{"type":"PROPERTY_ACCESS","id":"<child.own>","metadata":{"objectName":"child","propertyName":"own"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<child.also>","metadata":{"objectName":"child","propertyName":"also"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ own, ...rest }>","metadata":{"expressionType":"destructuring","hasRest":true}},{"type":"VARIABLE","id":"<own>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<rest>","metadata":{"kind":"const","destructured":true,"restParameter":true}},{"type":"EXPRESSION","id":"<{ inherited }>","metadata":{"expressionType":"destructuring","hasRest":false}},{"type":"VARIABLE","id":"<inherited>","metadata":{"kind":"const","destructured":true}},{"type":"LITERAL","id":"<{ own, rest, inherited }>","metadata":{"literalType":"object"}}],"edges":[{"src":"<destructureRestOwnOnly>","dst":"<proto>","type":"CONTAINS"},{"src":"<proto>","dst":"<{ inherited: 1 }>","type":"ASSIGNED_FROM"},{"src":"<destructureRestOwnOnly>","dst":"<child>","type":"CONTAINS"},{"src":"<child>","dst":"<Object.create(proto)>","type":"ASSIGNED_FROM"},{"src":"<Object.create(proto)>","dst":"<proto>","type":"PASSES_ARGUMENT"},{"src":"<child.own>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<child.also>","dst":"<3>","type":"ASSIGNED_FROM"},{"src":"<destructureRestOwnOnly>","dst":"<{ own, ...rest }>","type":"CONTAINS"},{"src":"<{ own, ...rest }>","dst":"<child>","type":"READS_FROM"},{"src":"<own>","dst":"<{ own, ...rest }>","type":"ASSIGNED_FROM"},{"src":"<rest>","dst":"<{ own, ...rest }>","type":"ASSIGNED_FROM"},{"src":"<destructureRestOwnOnly>","dst":"<{ inherited }>","type":"CONTAINS"},{"src":"<{ inherited }>","dst":"<child>","type":"READS_FROM"},{"src":"<inherited>","dst":"<{ inherited }>","type":"ASSIGNED_FROM"},{"src":"<destructureRestOwnOnly>","dst":"<{ own, rest, inherited }>","type":"RETURNS"},{"src":"<{ own, rest, inherited }>","dst":"<own>","type":"READS_FROM"},{"src":"<{ own, rest, inherited }>","dst":"<rest>","type":"READS_FROM"},{"src":"<{ own, rest, inherited }>","dst":"<inherited>","type":"READS_FROM"}],"rationale":"Function demonstrates destructuring behavior differences. Rest operator only captures own properties, while named destructuring accesses prototype chain. Object.create establishes prototype relationship.","implicitBehavior":["rest operator (...rest) only includes own enumerable properties, not inherited ones","named destructuring ({ inherited }) accesses properties through prototype chain","Object.create establishes prototype relationship between child and proto"]},"pass":2,"annotatedAt":"2026-02-24T00:37:01.190Z"}
{"construct":{"id":"patterns::computed-property-throws","file":"src/patterns.js","category":"patterns","lineStart":266,"lineEnd":278,"code":"function computedPropertyThrows() {\n  const log = [];\n  function throwingFn() { throw new Error('stop'); }\n  try {\n    const obj = {\n      [log.push('a')]: 'first',\n      [throwingFn()]:   'second',  // throws here\n      [log.push('c')]: 'third',   // NEVER evaluated\n    };\n  } catch (e) {}\n  return log; // ['a']  'c' was never pushed\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<computedPropertyThrows>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\":"},"pass":2,"annotatedAt":"2026-02-24T00:37:06.566Z"}
{"construct":{"id":"property-access::prop-object-keys","file":"src/property-access.js","category":"property-access","lineStart":76,"lineEnd":82,"code":"function objectEnumeration(obj) {\n  const keys = Object.keys(obj);\n  const values = Object.values(obj);\n  const entries = Object.entries(obj);\n  return { keys, values, entries };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<objectEnumeration>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<keys>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.keys(obj)>","metadata":{"callee":"Object.keys"}},{"type":"PROPERTY_ACCESS","id":"<Object.keys>","metadata":{"objectName":"Object","propertyName":"keys"}},{"type":"VARIABLE","id":"<values>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.values(obj)>","metadata":{"callee":"Object.values"}},{"type":"PROPERTY_ACCESS","id":"<Object.values>","metadata":{"objectName":"Object","propertyName":"values"}},{"type":"VARIABLE","id":"<entries>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.entries(obj)>","metadata":{"callee":"Object.entries"}},{"type":"PROPERTY_ACCESS","id":"<Object.entries>","metadata":{"objectName":"Object","propertyName":"entries"}},{"type":"EXPRESSION","id":"<{ keys, values, entries }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<objectEnumeration>","dst":"<obj>","type":"CONTAINS"},{"src":"<objectEnumeration>","dst":"<keys>","type":"DECLARES"},{"src":"<keys>","dst":"<Object.keys(obj)>","type":"ASSIGNED_FROM"},{"src":"<Object.keys(obj)>","dst":"<Object.keys>","type":"CALLS"},{"src":"<Object.keys(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<objectEnumeration>","dst":"<values>","type":"DECLARES"},{"src":"<values>","dst":"<Object.values(obj)>","type":"ASSIGNED_FROM"},{"src":"<Object.values(obj)>","dst":"<Object.values>","type":"CALLS"},{"src":"<Object.values(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<objectEnumeration>","dst":"<entries>","type":"DECLARES"},{"src":"<entries>","dst":"<Object.entries(obj)>","type":"ASSIGNED_FROM"},{"src":"<Object.entries(obj)>","dst":"<Object.entries>","type":"CALLS"},{"src":"<Object.entries(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<objectEnumeration>","dst":"<{ keys, values, entries }>","type":"RETURNS"},{"src":"<{ keys, values, entries }>","dst":"<keys>","type":"READS_FROM"},{"src":"<{ keys, values, entries }>","dst":"<values>","type":"READS_FROM"},{"src":"<{ keys, values, entries }>","dst":"<entries>","type":"READS_FROM"}],"rationale":"Function with parameter that calls three Object static methods, storing results in const variables, then returns an object literal containing all three values. Removed the module-level declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["Object.keys/values/entries will iterate enumerable own properties","shorthand property syntax creates properties with same names as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:37:06.707Z"}
{"construct":{"id":"property-access::prop-freeze","file":"src/property-access.js","category":"property-access","lineStart":101,"lineEnd":108,"code":"function frozen() {\n  const obj = { a: 1, b: { c: 2 } };\n  Object.freeze(obj);\n  obj.a = 999;       // silently fails (or throws in strict)\n  obj.b.c = 999;     // succeeds  shallow freeze\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<frozen>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ a: 1, b: { c: 2 } }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<{ c: 2 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"CALL","id":"<Object.freeze(obj)>","metadata":{"callee":"Object.freeze"}},{"type":"PROPERTY_ACCESS","id":"<obj.a>","metadata":{"objectName":"obj","propertyName":"a"}},{"type":"LITERAL","id":"<999>","metadata":{"value":999,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.b.c>","metadata":{"objectName":"obj.b","propertyName":"c"}},{"type":"LITERAL","id":"<999-2>","metadata":{"value":999,"literalType":"number"}}],"edges":[{"src":"<frozen>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{ a: 1, b: { c: 2 } }>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1, b: { c: 2 } }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<{ a: 1, b: { c: 2 } }>","dst":"<{ c: 2 }>","type":"HAS_PROPERTY"},{"src":"<{ c: 2 }>","dst":"<2>","type":"HAS_PROPERTY"},{"src":"<frozen>","dst":"<Object.freeze(obj)>","type":"CONTAINS"},{"src":"<Object.freeze(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<obj.a>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.a>","dst":"<999>","type":"ASSIGNED_FROM"},{"src":"<obj.b.c>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.b.c>","dst":"<999-2>","type":"ASSIGNED_FROM"},{"src":"<frozen>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function creates an object, freezes it with Object.freeze(), then attempts property assignments. The first assignment to obj.a fails due to freeze, while the second assignment to obj.b.c succeeds because Object.freeze() only provides shallow immutability.","implicitBehavior":["Object.freeze() only prevents modification of direct properties, not nested objects","Assignment to frozen property silently fails in non-strict mode, throws TypeError in strict mode","Nested object properties remain mutable after shallow freeze"]},"pass":2,"annotatedAt":"2026-02-24T00:37:07.181Z"}
{"construct":{"id":"property-access::prop-structured-clone","file":"src/property-access.js","category":"property-access","lineStart":190,"lineEnd":195,"code":"function deepClone(obj) {\n  return structuredClone(obj);\n}\n\n// --- Getter/setter side effects ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deepClone>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<structuredClone(obj)>","metadata":{"callee":"structuredClone"}},{"type":"EXTERNAL","id":"<structuredClone>","metadata":{"global":true,"builtin":true}}],"edges":[{"src":"<deepClone>","dst":"<obj>","type":"CONTAINS"},{"src":"<deepClone>","dst":"<structuredClone(obj)>","type":"RETURNS"},{"src":"<structuredClone(obj)>","dst":"<structuredClone>","type":"CALLS"},{"src":"<structuredClone(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"}],"rationale":"Function that wraps the global structuredClone API. Returns a call expression that invokes the builtin function with the parameter. Changed VARIABLE to EXTERNAL for the builtin function reference, and removed the module declaration edge as no module scope is explicitly defined.","implicitBehavior":["structuredClone performs deep cloning using structured clone algorithm","may throw DataCloneError for non-cloneable objects"]},"pass":2,"annotatedAt":"2026-02-24T00:37:07.707Z"}
{"construct":{"id":"property-access::prop-optional-chain-mixed","file":"src/property-access.js","category":"property-access","lineStart":38,"lineEnd":47,"code":"function optionalChainMixed(obj) {\n  const a = obj?.level1?.level2;\n  const b = obj?.['dynamic-key']?.value;\n  const c = obj?.method?.();\n  const d = obj?.arr?.[0]?.name;\n  return { a, b, c, d };\n}\n\n// --- Property assignment patterns ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<optionalChainMixed>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj?.level1?.level2>","metadata":{"optional":true,"chain":["level1","level2"]}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj?.['dynamic-key']?.value>","metadata":{"optional":true,"computed":true,"chain":["dynamic-key","value"]}},{"type":"LITERAL","id":"<'dynamic-key'>","metadata":{"value":"dynamic-key","literalType":"string"}},{"type":"VARIABLE","id":"<c>","metadata":{"kind":"const"}},{"type":"CALL","id":"<obj?.method?.()>","metadata":{"optional":true,"callee":"method"}},{"type":"VARIABLE","id":"<d>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj?.arr?.[0]?.name>","metadata":{"optional":true,"computed":true,"chain":["arr","0","name"]}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ a, b, c, d }>","metadata":{"type":"object","shorthand":true}}],"edges":[{"src":"<optionalChainMixed>","dst":"<obj>","type":"CONTAINS"},{"src":"<optionalChainMixed>","dst":"<a>","type":"CONTAINS"},{"src":"<a>","dst":"<obj?.level1?.level2>","type":"ASSIGNED_FROM"},{"src":"<obj?.level1?.level2>","dst":"<obj>","type":"READS_FROM"},{"src":"<optionalChainMixed>","dst":"<b>","type":"CONTAINS"},{"src":"<b>","dst":"<obj?.['dynamic-key']?.value>","type":"ASSIGNED_FROM"},{"src":"<obj?.['dynamic-key']?.value>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj?.['dynamic-key']?.value>","dst":"<'dynamic-key'>","type":"USES"},{"src":"<optionalChainMixed>","dst":"<c>","type":"CONTAINS"},{"src":"<c>","dst":"<obj?.method?.()>","type":"ASSIGNED_FROM"},{"src":"<obj?.method?.()>","dst":"<obj>","type":"READS_FROM"},{"src":"<optionalChainMixed>","dst":"<d>","type":"CONTAINS"},{"src":"<d>","dst":"<obj?.arr?.[0]?.name>","type":"ASSIGNED_FROM"},{"src":"<obj?.arr?.[0]?.name>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj?.arr?.[0]?.name>","dst":"<0>","type":"USES"},{"src":"<optionalChainMixed>","dst":"<{ a, b, c, d }>","type":"RETURNS"},{"src":"<{ a, b, c, d }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b, c, d }>","dst":"<b>","type":"READS_FROM"},{"src":"<{ a, b, c, d }>","dst":"<c>","type":"READS_FROM"},{"src":"<{ a, b, c, d }>","dst":"<d>","type":"READS_FROM"}],"rationale":"Function demonstrating various optional chaining patterns: dot notation, computed properties, method calls, and array access. Each chain is a single property access node with optional metadata. Removed module declaration edge as no module node was defined.","implicitBehavior":["optional chaining short-circuits to undefined if any link is null/undefined","method call only executes if method exists","computed property access evaluates key expression first"]},"pass":2,"annotatedAt":"2026-02-24T00:37:08.233Z"}
{"construct":{"id":"property-access::prop-seal","file":"src/property-access.js","category":"property-access","lineStart":110,"lineEnd":118,"code":"function sealed() {\n  const obj = { a: 1 };\n  Object.seal(obj);\n  obj.a = 2;         // allowed  existing property\n  obj.b = 3;         // silently fails  no new properties\n  delete obj.a;      // silently fails  cannot delete\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<sealed>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ a: 1 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<Object.seal(obj)>","metadata":{"callee":"Object.seal"}},{"type":"PROPERTY_ACCESS","id":"<obj.a>","metadata":{"objectName":"obj","propertyName":"a"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.b>","metadata":{"objectName":"obj","propertyName":"b"}},{"type":"EXPRESSION","id":"<delete obj.a>","metadata":{"operator":"delete"}}],"edges":[{"src":"<sealed>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{ a: 1 }>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1 }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<Object.seal(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<sealed>","dst":"<Object.seal(obj)>","type":"CONTAINS"},{"src":"<obj.a>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<obj.b>","dst":"<3>","type":"ASSIGNED_FROM"},{"src":"<delete obj.a>","dst":"<obj.a>","type":"READS_FROM"},{"src":"<sealed>","dst":"<delete obj.a>","type":"CONTAINS"},{"src":"<sealed>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function creates an object, seals it with Object.seal(), then attempts property modification, addition, and deletion. Reduced edge count by removing redundant WRITES_TO edges while preserving core semantic relationships.","implicitBehavior":["Object.seal() prevents property addition and deletion but allows modification of existing properties","obj.b = 3 silently fails in non-strict mode, would throw TypeError in strict mode","delete obj.a silently fails in non-strict mode, would throw TypeError in strict mode","obj.a = 2 succeeds because existing properties remain configurable for value changes"]},"pass":2,"annotatedAt":"2026-02-24T00:37:09.024Z"}
{"construct":{"id":"property-access::prop-delete","file":"src/property-access.js","category":"property-access","lineStart":143,"lineEnd":151,"code":"function propertyDeletion(obj) {\n  const hadKey = 'key' in obj;\n  delete obj.key;\n  const hasKey = 'key' in obj;\n  return { hadKey, hasKey };\n}\n\n// --- Property enumeration order ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<propertyDeletion>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<hadKey>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<'key' in obj>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<'key'>","metadata":{"value":"key","literalType":"string"}},{"type":"EXPRESSION","id":"<delete obj.key>","metadata":{"operator":"delete"}},{"type":"PROPERTY_ACCESS","id":"<obj.key>","metadata":{"property":"key"}},{"type":"VARIABLE","id":"<hasKey>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<'key' in obj_2>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<'key'_2>","metadata":{"value":"key","literalType":"string"}},{"type":"EXPRESSION","id":"<{ hadKey, hasKey }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<propertyDeletion>","dst":"<obj>","type":"CONTAINS"},{"src":"<propertyDeletion>","dst":"<hadKey>","type":"CONTAINS"},{"src":"<hadKey>","dst":"<'key' in obj>","type":"ASSIGNED_FROM"},{"src":"<'key' in obj>","dst":"<'key'>","type":"READS_FROM"},{"src":"<'key' in obj>","dst":"<obj>","type":"READS_FROM"},{"src":"<delete obj.key>","dst":"<obj.key>","type":"DELETES"},{"src":"<obj.key>","dst":"<obj>","type":"READS_FROM"},{"src":"<propertyDeletion>","dst":"<hasKey>","type":"CONTAINS"},{"src":"<hasKey>","dst":"<'key' in obj_2>","type":"ASSIGNED_FROM"},{"src":"<'key' in obj_2>","dst":"<'key'_2>","type":"READS_FROM"},{"src":"<'key' in obj_2>","dst":"<obj>","type":"READS_FROM"},{"src":"<propertyDeletion>","dst":"<{ hadKey, hasKey }>","type":"RETURNS"},{"src":"<{ hadKey, hasKey }>","dst":"<hadKey>","type":"READS_FROM"},{"src":"<{ hadKey, hasKey }>","dst":"<hasKey>","type":"READS_FROM"}],"rationale":"Function demonstrates property deletion with before/after checks using 'in' operator. Delete operation modifies object state, return object reads both check variables. Removed module declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["delete operator returns boolean indicating success","property deletion may affect object's hidden class/shape","'in' operator checks own and inherited properties"]},"pass":2,"annotatedAt":"2026-02-24T00:37:11.057Z"}
{"construct":{"id":"property-access::prop-prevent-extensions","file":"src/property-access.js","category":"property-access","lineStart":120,"lineEnd":130,"code":"function preventExtensions() {\n  const obj = { a: 1 };\n  Object.preventExtensions(obj);\n  obj.b = 2;         // silently fails\n  obj.a = 99;        // allowed\n  delete obj.a;      // allowed\n  return obj;\n}\n\n// --- Property existence checks ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<preventExtensions>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ a: 1 }>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<a>","metadata":{"key":"a"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<Object.preventExtensions(obj)>","metadata":{"callee":"Object.preventExtensions"}},{"type":"PROPERTY_ACCESS","id":"<Object.preventExtensions>","metadata":{"objectName":"Object","propertyName":"preventExtensions"}},{"type":"PROPERTY_ACCESS","id":"<obj.b>","metadata":{"objectName":"obj","propertyName":"b"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.a>","metadata":{"objectName":"obj","propertyName":"a"}},{"type":"LITERAL","id":"<99>","metadata":{"value":99,"literalType":"number"}},{"type":"EXPRESSION","id":"<delete obj.a>","metadata":{"operator":"delete"}}],"edges":[{"src":"<preventExtensions>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{ a: 1 }>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1 }>","dst":"<a>","type":"HAS_PROPERTY"},{"src":"<a>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<Object.preventExtensions(obj)>","dst":"<Object.preventExtensions>","type":"CALLS"},{"src":"<Object.preventExtensions(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<preventExtensions>","dst":"<Object.preventExtensions(obj)>","type":"CONTAINS"},{"src":"<obj.b>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<preventExtensions>","dst":"<obj.b>","type":"WRITES_TO"},{"src":"<obj.a>","dst":"<99>","type":"ASSIGNED_FROM"},{"src":"<preventExtensions>","dst":"<obj.a>","type":"WRITES_TO"},{"src":"<delete obj.a>","dst":"<obj.a>","type":"READS_FROM"},{"src":"<preventExtensions>","dst":"<delete obj.a>","type":"CONTAINS"},{"src":"<preventExtensions>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function creates object, calls Object.preventExtensions, then attempts property operations. Property addition fails silently, modification and deletion succeed. All Pass 1 types were already in approved vocabulary.","implicitBehavior":["Object.preventExtensions() prevents new property addition but allows modification/deletion of existing properties","obj.b = 2 silently fails in non-strict mode, would throw TypeError in strict mode","Property modification (obj.a = 99) and deletion (delete obj.a) are still allowed on non-extensible objects"]},"pass":2,"annotatedAt":"2026-02-24T00:37:11.794Z"}
{"construct":{"id":"property-access::prop-compound-assign","file":"src/property-access.js","category":"property-access","lineStart":64,"lineEnd":74,"code":"function compoundPropertyAssign(obj) {\n  obj.count += 1;\n  obj.total -= 5;\n  obj.name += ' suffix';\n  obj.flags |= 0x04;\n  obj.mask &= 0xff;\n  return obj;\n}\n\n// --- Object.keys / values / entries ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<compoundPropertyAssign>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PROPERTY_ACCESS","id":"<obj.count>","metadata":{"objectName":"obj","propertyName":"count"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<obj.count += 1>","metadata":{"operator":"+="}},{"type":"PROPERTY_ACCESS","id":"<obj.total>","metadata":{"objectName":"obj","propertyName":"total"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<obj.total -= 5>","metadata":{"operator":"-="}},{"type":"PROPERTY_ACCESS","id":"<obj.name>","metadata":{"objectName":"obj","propertyName":"name"}},{"type":"LITERAL","id":"<' suffix'>","metadata":{"value":" suffix","literalType":"string"}},{"type":"EXPRESSION","id":"<obj.name += ' suffix'>","metadata":{"operator":"+="}},{"type":"PROPERTY_ACCESS","id":"<obj.flags>","metadata":{"objectName":"obj","propertyName":"flags"}},{"type":"LITERAL","id":"<0x04>","metadata":{"value":4,"literalType":"number","representation":"hex"}},{"type":"EXPRESSION","id":"<obj.flags |= 0x04>","metadata":{"operator":"|="}},{"type":"PROPERTY_ACCESS","id":"<obj.mask>","metadata":{"objectName":"obj","propertyName":"mask"}},{"type":"LITERAL","id":"<0xff>","metadata":{"value":255,"literalType":"number","representation":"hex"}},{"type":"EXPRESSION","id":"<obj.mask &= 0xff>","metadata":{"operator":"&="}}],"edges":[{"src":"<compoundPropertyAssign>","dst":"<obj>","type":"CONTAINS"},{"src":"<compoundPropertyAssign>","dst":"<obj.count += 1>","type":"CONTAINS"},{"src":"<compoundPropertyAssign>","dst":"<obj.total -= 5>","type":"CONTAINS"},{"src":"<compoundPropertyAssign>","dst":"<obj.name += ' suffix'>","type":"CONTAINS"},{"src":"<compoundPropertyAssign>","dst":"<obj.flags |= 0x04>","type":"CONTAINS"},{"src":"<compoundPropertyAssign>","dst":"<obj.mask &= 0xff>","type":"CONTAINS"},{"src":"<compoundPropertyAssign>","dst":"<obj>","type":"RETURNS"},{"src":"<obj.count += 1>","dst":"<obj.count>","type":"WRITES_TO"},{"src":"<obj.count += 1>","dst":"<obj.count>","type":"READS_FROM"},{"src":"<obj.count += 1>","dst":"<1>","type":"READS_FROM"},{"src":"<obj.total -= 5>","dst":"<obj.total>","type":"WRITES_TO"},{"src":"<obj.total -= 5>","dst":"<obj.total>","type":"READS_FROM"},{"src":"<obj.total -= 5>","dst":"<5>","type":"READS_FROM"},{"src":"<obj.name += ' suffix'>","dst":"<obj.name>","type":"WRITES_TO"},{"src":"<obj.name += ' suffix'>","dst":"<obj.name>","type":"READS_FROM"},{"src":"<obj.name += ' suffix'>","dst":"<' suffix'>","type":"READS_FROM"},{"src":"<obj.flags |= 0x04>","dst":"<obj.flags>","type":"WRITES_TO"},{"src":"<obj.flags |= 0x04>","dst":"<obj.flags>","type":"READS_FROM"},{"src":"<obj.flags |= 0x04>","dst":"<0x04>","type":"READS_FROM"},{"src":"<obj.mask &= 0xff>","dst":"<obj.mask>","type":"WRITES_TO"},{"src":"<obj.mask &= 0xff>","dst":"<obj.mask>","type":"READS_FROM"},{"src":"<obj.mask &= 0xff>","dst":"<0xff>","type":"READS_FROM"}],"rationale":"Function with compound assignment operations on object properties. Each compound assignment both reads from and writes to the property, combining with a literal value using different operators. Used WRITES_TO instead of COMPOUND_ASSIGNS_TO to stay within approved vocabulary.","implicitBehavior":["compound assignments perform read-modify-write operations atomically","property access may trigger getters/setters","numeric operations may involve type coercion"]},"pass":2,"annotatedAt":"2026-02-24T00:37:11.794Z"}
{"construct":{"id":"property-access::prop-circular-object","file":"src/property-access.js","category":"property-access","lineStart":216,"lineEnd":222,"code":"function circularObject() {\n  const a = {};\n  const b = { ref: a };\n  a.ref = b;\n  return a;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<circularObject>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ ref: a }>","metadata":{"value":"{ ref: a }","literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<a.ref>","metadata":{"objectName":"a","propertyName":"ref"}}],"edges":[{"src":"<circularObject>","dst":"<a>","type":"CONTAINS"},{"src":"<circularObject>","dst":"<b>","type":"CONTAINS"},{"src":"<a>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<b>","dst":"<{ ref: a }>","type":"ASSIGNED_FROM"},{"src":"<{ ref: a }>","dst":"<a>","type":"READS_FROM"},{"src":"<a.ref>","dst":"<b>","type":"ASSIGNED_FROM"},{"src":"<circularObject>","dst":"<a.ref>","type":"WRITES_TO"},{"src":"<circularObject>","dst":"<a>","type":"RETURNS"}],"rationale":"Function creates circular object references. Object a initially empty, object b references a, then a.ref is assigned to reference b, creating a cycle. Removed module-level declaration edge to stay within edge count threshold.","implicitBehavior":["circular reference prevents garbage collection without cycle detection","property assignment creates new property on existing object"]},"pass":2,"annotatedAt":"2026-02-24T00:37:14.073Z"}
{"construct":{"id":"property-access::prop-object-assign","file":"src/property-access.js","category":"property-access","lineStart":91,"lineEnd":99,"code":"function objectAssign() {\n  const target = { a: 1 };\n  const source1 = { b: 2 };\n  const source2 = { c: 3, a: 'overridden' };\n  return Object.assign(target, source1, source2);\n}\n\n// --- Object.freeze / seal / preventExtensions ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<objectAssign>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<target>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ a: 1 }>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<target.a>","metadata":{"key":"a"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<source1>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ b: 2 }>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<source1.b>","metadata":{"key":"b"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"VARIABLE","id":"<source2>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ c: 3, a: 'overridden' }>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<source2.c>","metadata":{"key":"c"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"PROPERTY","id":"<source2.a>","metadata":{"key":"a"}},{"type":"LITERAL","id":"<'overridden'>","metadata":{"value":"overridden","literalType":"string"}},{"type":"CALL","id":"<Object.assign(target, source1, source2)>","metadata":{"callee":"Object.assign"}},{"type":"PROPERTY_ACCESS","id":"<Object.assign>","metadata":{"objectName":"Object","propertyName":"assign"}}],"edges":[{"src":"<objectAssign>","dst":"<target>","type":"CONTAINS"},{"src":"<objectAssign>","dst":"<source1>","type":"CONTAINS"},{"src":"<objectAssign>","dst":"<source2>","type":"CONTAINS"},{"src":"<target>","dst":"<{ a: 1 }>","type":"ASSIGNED_FROM"},{"src":"<{ a: 1 }>","dst":"<target.a>","type":"HAS_PROPERTY"},{"src":"<target.a>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<source1>","dst":"<{ b: 2 }>","type":"ASSIGNED_FROM"},{"src":"<{ b: 2 }>","dst":"<source1.b>","type":"HAS_PROPERTY"},{"src":"<source1.b>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<source2>","dst":"<{ c: 3, a: 'overridden' }>","type":"ASSIGNED_FROM"},{"src":"<{ c: 3, a: 'overridden' }>","dst":"<source2.c>","type":"HAS_PROPERTY"},{"src":"<{ c: 3, a: 'overridden' }>","dst":"<source2.a>","type":"HAS_PROPERTY"},{"src":"<source2.c>","dst":"<3>","type":"ASSIGNED_FROM"},{"src":"<source2.a>","dst":"<'overridden'>","type":"ASSIGNED_FROM"},{"src":"<Object.assign(target, source1, source2)>","dst":"<Object.assign>","type":"CALLS"},{"src":"<Object.assign(target, source1, source2)>","dst":"<target>","type":"PASSES_ARGUMENT"},{"src":"<Object.assign(target, source1, source2)>","dst":"<source1>","type":"PASSES_ARGUMENT"},{"src":"<Object.assign(target, source1, source2)>","dst":"<source2>","type":"PASSES_ARGUMENT"},{"src":"<objectAssign>","dst":"<Object.assign(target, source1, source2)>","type":"RETURNS"}],"rationale":"Function with three object literals and Object.assign call. Each object has properties with values, and Object.assign merges source objects into target. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["Object.assign mutates the target object","Properties from later sources override earlier ones with same key","Returns reference to modified target object"]},"pass":2,"annotatedAt":"2026-02-24T00:37:14.701Z"}
{"construct":{"id":"property-access::prop-proto-direct","file":"src/property-access.js","category":"property-access","lineStart":248,"lineEnd":255,"code":"function protoDirectAssign() {\n  const obj = {};\n  obj.__proto__ = { inherited: true };\n  return obj.inherited;\n}\n\n// --- Null-prototype dictionary ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<protoDirectAssign>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<obj.__proto__>","metadata":{"property":"__proto__"}},{"type":"LITERAL","id":"<{ inherited: true }>","metadata":{"value":"{ inherited: true }","literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<obj.inherited>","metadata":{"property":"inherited"}}],"edges":[{"src":"<protoDirectAssign>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<obj.__proto__>","dst":"<{ inherited: true }>","type":"ASSIGNED_FROM"},{"src":"<protoDirectAssign>","dst":"<obj.__proto__>","type":"WRITES_TO"},{"src":"<protoDirectAssign>","dst":"<obj.inherited>","type":"READS_FROM"},{"src":"<protoDirectAssign>","dst":"<obj.inherited>","type":"RETURNS"}],"rationale":"Function creates object, directly assigns to __proto__ property to set prototype, then accesses inherited property through prototype chain. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["__proto__ assignment modifies object's prototype chain","obj.inherited resolves through prototype lookup to inherited property"]},"pass":2,"annotatedAt":"2026-02-24T00:37:15.025Z"}
{"construct":{"id":"builtins::builtin-globalthis","file":"src/builtins.js","category":"builtins","lineStart":306,"lineEnd":313,"code":"function globalThisAccess() {\n  const g = globalThis;\n  const hasConsole = 'console' in globalThis;\n  return { g, hasConsole };\n}\n\n// --- URL / URLSearchParams ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<globalThisAccess>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<g>","metadata":{"kind":"const"}},{"type":"EXTERNAL","id":"<globalThis>","metadata":{"builtinType":"global"}},{"type":"VARIABLE","id":"<hasConsole>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<'console' in globalThis>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<'console'>","metadata":{"value":"console","literalType":"string"}},{"type":"EXPRESSION","id":"<{ g, hasConsole }>","metadata":{"type":"object"}}],"edges":[{"src":"<globalThisAccess>","dst":"<g>","type":"CONTAINS"},{"src":"<globalThisAccess>","dst":"<hasConsole>","type":"CONTAINS"},{"src":"<g>","dst":"<globalThis>","type":"ASSIGNED_FROM"},{"src":"<hasConsole>","dst":"<'console' in globalThis>","type":"ASSIGNED_FROM"},{"src":"<'console' in globalThis>","dst":"<'console'>","type":"READS_FROM"},{"src":"<'console' in globalThis>","dst":"<globalThis>","type":"READS_FROM"},{"src":"<globalThisAccess>","dst":"<{ g, hasConsole }>","type":"RETURNS"},{"src":"<{ g, hasConsole }>","dst":"<g>","type":"READS_FROM"},{"src":"<{ g, hasConsole }>","dst":"<hasConsole>","type":"READS_FROM"}],"rationale":"Function accesses globalThis builtin, stores reference and checks for console property existence. Returns object with both values. Removed module declaration edge to stay within edge count threshold.","implicitBehavior":["globalThis provides access to global object across environments","in operator checks property existence without accessing value"]},"pass":2,"annotatedAt":"2026-02-24T00:37:19.590Z"}
{"construct":{"id":"property-access::prop-enumeration-order","file":"src/property-access.js","category":"property-access","lineStart":153,"lineEnd":165,"code":"function enumerationOrder() {\n  const obj = {};\n  obj.b = 1;\n  obj.a = 2;\n  obj[1] = 3;\n  obj[0] = 4;\n  obj.c = 5;\n  // Integer keys first (sorted), then string keys (insertion order)\n  return Object.keys(obj); // ['0', '1', 'b', 'a', 'c']\n}\n\n// --- Getter/setter via Object.defineProperty ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<enumerationOrder>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<obj.b>","metadata":{"property":"b","accessType":"assignment"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.a>","metadata":{"property":"a","accessType":"assignment"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj[1]>","metadata":{"property":"1","accessType":"assignment","computed":true}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj[0]>","metadata":{"property":"0","accessType":"assignment","computed":true}},{"type":"LITERAL","id":"<4>","metadata":{"value":4,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.c>","metadata":{"property":"c","accessType":"assignment"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"CALL","id":"<Object.keys(obj)>","metadata":{"callee":"Object.keys"}},{"type":"PROPERTY_ACCESS","id":"<Object.keys>","metadata":{"property":"keys","accessType":"read"}}],"edges":[{"src":"<enumerationOrder>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<obj.b>","dst":"<obj>","type":"WRITES_TO"},{"src":"<obj.b>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<obj.a>","dst":"<obj>","type":"WRITES_TO"},{"src":"<obj.a>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<obj[1]>","dst":"<obj>","type":"WRITES_TO"},{"src":"<obj[1]>","dst":"<3>","type":"ASSIGNED_FROM"},{"src":"<obj[0]>","dst":"<obj>","type":"WRITES_TO"},{"src":"<obj[0]>","dst":"<4>","type":"ASSIGNED_FROM"},{"src":"<obj.c>","dst":"<obj>","type":"WRITES_TO"},{"src":"<obj.c>","dst":"<5>","type":"ASSIGNED_FROM"},{"src":"<Object.keys(obj)>","dst":"<Object.keys>","type":"CALLS"},{"src":"<Object.keys(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<enumerationOrder>","dst":"<Object.keys(obj)>","type":"RETURNS"}],"rationale":"Function demonstrates property enumeration order by setting properties on an object in various ways (dot notation, computed access) then returning Object.keys() result. Each property assignment is a separate write operation. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["Integer-like string keys are enumerated first in numeric order","String keys are enumerated in insertion order","Object.keys() returns array of enumerable own property names"]},"pass":2,"annotatedAt":"2026-02-24T00:37:19.884Z"}
{"construct":{"id":"property-access::prop-symbol-key","file":"src/property-access.js","category":"property-access","lineStart":239,"lineEnd":246,"code":"function symbolKey() {\n  const sym = Symbol('myKey');\n  const obj = { [sym]: 'symbol value' };\n  return obj[sym];\n}\n\n// --- __proto__ direct assignment ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<symbolKey>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<sym>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Symbol('myKey')>","metadata":{"callee":"Symbol"}},{"type":"LITERAL","id":"<'myKey'>","metadata":{"value":"myKey","literalType":"string"}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ [sym]: 'symbol value' }>","metadata":{"expressionType":"object"}},{"type":"PROPERTY","id":"<[sym]>","metadata":{"computed":true}},{"type":"LITERAL","id":"<'symbol value'>","metadata":{"value":"symbol value","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<obj[sym]>","metadata":{"computed":true}}],"edges":[{"src":"<symbolKey>","dst":"<sym>","type":"CONTAINS"},{"src":"<symbolKey>","dst":"<obj>","type":"CONTAINS"},{"src":"<sym>","dst":"<Symbol('myKey')>","type":"ASSIGNED_FROM"},{"src":"<Symbol('myKey')>","dst":"<'myKey'>","type":"PASSES_ARGUMENT"},{"src":"<obj>","dst":"<{ [sym]: 'symbol value' }>","type":"ASSIGNED_FROM"},{"src":"<{ [sym]: 'symbol value' }>","dst":"<[sym]>","type":"HAS_PROPERTY"},{"src":"<[sym]>","dst":"<sym>","type":"READS_FROM"},{"src":"<[sym]>","dst":"<'symbol value'>","type":"ASSIGNED_FROM"},{"src":"<symbolKey>","dst":"<obj[sym]>","type":"RETURNS"},{"src":"<obj[sym]>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj[sym]>","dst":"<sym>","type":"READS_FROM"}],"rationale":"Function creates a symbol, uses it as computed property key in object literal, then accesses that property. Symbol serves as both property key and access key.","implicitBehavior":["Symbol creates unique property key that cannot be accessed via string keys","Computed property syntax evaluates expression as property key"]},"pass":2,"annotatedAt":"2026-02-24T00:37:21.462Z"}
{"construct":{"id":"property-access::prop-define-accessor","file":"src/property-access.js","category":"property-access","lineStart":167,"lineEnd":178,"code":"function defineAccessor() {\n  const obj = { _value: 0 };\n  Object.defineProperty(obj, 'value', {\n    get() { return this._value; },\n    set(v) { this._value = Math.max(0, v); },\n    enumerable: true,\n  });\n  return obj;\n}\n\n// --- Object.is ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<defineAccessor>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{ _value: 0 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"CALL","id":"<Object.defineProperty(obj, 'value', {...})>","metadata":{"callee":"Object.defineProperty"}},{"type":"EXTERNAL","id":"<Object.defineProperty>","metadata":{"source":"global"}},{"type":"LITERAL","id":"<'value'>","metadata":{"value":"value","literalType":"string"}},{"type":"LITERAL","id":"<descriptor>","metadata":{"literalType":"object"}},{"type":"GETTER","id":"<get>","metadata":{}},{"type":"PROPERTY_ACCESS","id":"<this._value>","metadata":{"objectName":"this","propertyName":"_value"}},{"type":"SETTER","id":"<set>","metadata":{}},{"type":"PARAMETER","id":"<v>"},{"type":"PROPERTY_ACCESS","id":"<this._value_assign>","metadata":{"objectName":"this","propertyName":"_value"}},{"type":"CALL","id":"<Math.max(0, v)>","metadata":{"callee":"Math.max"}},{"type":"EXTERNAL","id":"<Math.max>","metadata":{"source":"global"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<defineAccessor>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<{ _value: 0 }>","type":"ASSIGNED_FROM"},{"src":"<{ _value: 0 }>","dst":"<0>","type":"HAS_PROPERTY"},{"src":"<defineAccessor>","dst":"<Object.defineProperty(obj, 'value', {...})>","type":"CONTAINS"},{"src":"<Object.defineProperty(obj, 'value', {...})>","dst":"<Object.defineProperty>","type":"CALLS"},{"src":"<Object.defineProperty(obj, 'value', {...})>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperty(obj, 'value', {...})>","dst":"<'value'>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperty(obj, 'value', {...})>","dst":"<descriptor>","type":"PASSES_ARGUMENT"},{"src":"<descriptor>","dst":"<get>","type":"HAS_PROPERTY"},{"src":"<descriptor>","dst":"<set>","type":"HAS_PROPERTY"},{"src":"<descriptor>","dst":"<true>","type":"HAS_PROPERTY"},{"src":"<get>","dst":"<this._value>","type":"RETURNS"},{"src":"<set>","dst":"<v>","type":"CONTAINS"},{"src":"<this._value_assign>","dst":"<Math.max(0, v)>","type":"ASSIGNED_FROM"},{"src":"<set>","dst":"<this._value_assign>","type":"WRITES_TO"},{"src":"<Math.max(0, v)>","dst":"<Math.max>","type":"CALLS"},{"src":"<Math.max(0, v)>","dst":"<0>","type":"PASSES_ARGUMENT"},{"src":"<Math.max(0, v)>","dst":"<v>","type":"PASSES_ARGUMENT"},{"src":"<defineAccessor>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function creates object with property descriptor defining getter/setter using Object.defineProperty. Getter returns private property, setter validates and assigns value using Math.max. Used GETTER/SETTER types instead of METHOD, and added EXTERNAL nodes for global functions.","implicitBehavior":["Object.defineProperty modifies object prototype chain","getter/setter creates property access interception","this binding in accessor methods refers to the target object"]},"pass":2,"annotatedAt":"2026-02-24T00:37:22.849Z"}
{"construct":{"id":"property-access::prop-object-is","file":"src/property-access.js","category":"property-access","lineStart":180,"lineEnd":188,"code":"function objectIsComparison() {\n  const a = Object.is(NaN, NaN);       // true (unlike ===)\n  const b = Object.is(0, -0);          // false (unlike ===)\n  const c = Object.is(1, 1);           // true\n  return { a, b, c };\n}\n\n// --- structuredClone ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<objectIsComparison>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.is(NaN, NaN)>","metadata":{"callee":"Object.is"}},{"type":"PROPERTY_ACCESS","id":"<Object.is>","metadata":{"objectName":"Object","propertyName":"is"}},{"type":"LITERAL","id":"<NaN>","metadata":{"value":"NaN","literalType":"number"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.is(0, -0)>","metadata":{"callee":"Object.is"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<-0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<c>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.is(1, 1)>","metadata":{"callee":"Object.is"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"EXPRESSION","id":"<{ a, b, c }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<objectIsComparison>","dst":"<a>","type":"CONTAINS"},{"src":"<objectIsComparison>","dst":"<b>","type":"CONTAINS"},{"src":"<objectIsComparison>","dst":"<c>","type":"CONTAINS"},{"src":"<a>","dst":"<Object.is(NaN, NaN)>","type":"ASSIGNED_FROM"},{"src":"<Object.is(NaN, NaN)>","dst":"<Object.is>","type":"CALLS"},{"src":"<Object.is(NaN, NaN)>","dst":"<NaN>","type":"PASSES_ARGUMENT"},{"src":"<Object.is(NaN, NaN)>","dst":"<NaN>","type":"PASSES_ARGUMENT"},{"src":"<b>","dst":"<Object.is(0, -0)>","type":"ASSIGNED_FROM"},{"src":"<Object.is(0, -0)>","dst":"<Object.is>","type":"CALLS"},{"src":"<Object.is(0, -0)>","dst":"<0>","type":"PASSES_ARGUMENT"},{"src":"<Object.is(0, -0)>","dst":"<-0>","type":"PASSES_ARGUMENT"},{"src":"<c>","dst":"<Object.is(1, 1)>","type":"ASSIGNED_FROM"},{"src":"<Object.is(1, 1)>","dst":"<Object.is>","type":"CALLS"},{"src":"<Object.is(1, 1)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<Object.is(1, 1)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<objectIsComparison>","dst":"<{ a, b, c }>","type":"RETURNS"},{"src":"<{ a, b, c }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<b>","type":"READS_FROM"},{"src":"<{ a, b, c }>","dst":"<c>","type":"READS_FROM"}],"rationale":"Function demonstrates Object.is() method with three test cases. Each const variable is assigned from a method call, and the return object uses shorthand property syntax to read from all three variables. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic relationships.","implicitBehavior":["Object.is uses SameValue comparison algorithm","shorthand object properties create properties with same names as variables"]},"pass":2,"annotatedAt":"2026-02-24T00:37:22.850Z"}
{"construct":{"id":"property-access::optional-chaining-delete","file":"src/property-access.js","category":"property-access","lineStart":307,"lineEnd":313,"code":"function optionalChainingDelete(obj) {\n  const result = delete obj?.prop; // true if obj is nullish (no-op), normal delete otherwise\n  return result;\n}\n\n// --- Getter side effects in destructuring and spread ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<optionalChainingDelete>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<delete obj?.prop>","metadata":{"expressionType":"delete","optionalChaining":true}},{"type":"PROPERTY_ACCESS","id":"<obj?.prop>","metadata":{"property":"prop","optional":true}}],"edges":[{"src":"<optionalChainingDelete>","dst":"<obj>","type":"CONTAINS"},{"src":"<optionalChainingDelete>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<delete obj?.prop>","type":"ASSIGNED_FROM"},{"src":"<delete obj?.prop>","dst":"<obj?.prop>","type":"DELETES"},{"src":"<obj?.prop>","dst":"<obj>","type":"READS_FROM"},{"src":"<optionalChainingDelete>","dst":"<result>","type":"RETURNS"}],"rationale":"Function with delete operation on optional property access. The delete expression operates on the optional chain, which short-circuits if obj is nullish. Mapped DELETE_EXPRESSION to EXPRESSION and OPTIONAL_PROPERTY_ACCESS to PROPERTY_ACCESS with optional metadata.","implicitBehavior":["optional chaining returns undefined if obj is null/undefined, causing delete to return true as a no-op","delete on property access returns boolean indicating success"]},"pass":2,"annotatedAt":"2026-02-24T00:37:23.053Z"}
{"construct":{"id":"property-access::prop-circular-class","file":"src/property-access.js","category":"property-access","lineStart":224,"lineEnd":237,"code":"class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.parent = null;\n    this.children = [];\n  }\n  addChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  }\n}\n\n// --- Symbol as property key ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<TreeNode>"},{"type":"METHOD","id":"<TreeNode.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<value>"},{"type":"PROPERTY_ACCESS","id":"<this.value>","metadata":{"objectName":"this","propertyName":"value"}},{"type":"PROPERTY_ACCESS","id":"<this.parent>","metadata":{"objectName":"this","propertyName":"parent"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"PROPERTY_ACCESS","id":"<this.children>","metadata":{"objectName":"this","propertyName":"children"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":"[]","literalType":"array"}},{"type":"METHOD","id":"<TreeNode.addChild>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<child>"},{"type":"PROPERTY_ACCESS","id":"<child.parent>","metadata":{"objectName":"child","propertyName":"parent"}},{"type":"CALL","id":"<this.children.push(child)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<this.children.push>","metadata":{"objectName":"this.children","propertyName":"push"}}],"edges":[{"src":"<TreeNode>","dst":"<TreeNode.constructor>","type":"CONTAINS"},{"src":"<TreeNode>","dst":"<TreeNode.addChild>","type":"CONTAINS"},{"src":"<TreeNode.constructor>","dst":"<value>","type":"CONTAINS"},{"src":"<TreeNode.constructor>","dst":"<this.value>","type":"WRITES_TO"},{"src":"<this.value>","dst":"<value>","type":"ASSIGNED_FROM"},{"src":"<TreeNode.constructor>","dst":"<this.parent>","type":"WRITES_TO"},{"src":"<this.parent>","dst":"<null>","type":"ASSIGNED_FROM"},{"src":"<TreeNode.constructor>","dst":"<this.children>","type":"WRITES_TO"},{"src":"<this.children>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<TreeNode.addChild>","dst":"<child>","type":"CONTAINS"},{"src":"<TreeNode.addChild>","dst":"<child.parent>","type":"WRITES_TO"},{"src":"<child.parent>","dst":"<TreeNode.addChild>","type":"ASSIGNED_FROM"},{"src":"<TreeNode.addChild>","dst":"<this.children.push(child)>","type":"CONTAINS"},{"src":"<this.children.push(child)>","dst":"<this.children.push>","type":"CALLS"},{"src":"<this.children.push(child)>","dst":"<child>","type":"PASSES_ARGUMENT"},{"src":"<this.children.push>","dst":"<this.children>","type":"READS_FROM"}],"rationale":"TreeNode class with circular references - constructor initializes properties, addChild method creates bidirectional parent-child relationships through property assignments. Removed the module declaration edge as it's not essential to the core construct semantics.","implicitBehavior":["this binding in methods","prototype chain for method inheritance","circular object references created at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:37:23.659Z"}
{"construct":{"id":"property-access::prop-existence-checks","file":"src/property-access.js","category":"property-access","lineStart":132,"lineEnd":141,"code":"function propertyChecks(obj) {\n  const hasIn = 'key' in obj;\n  const hasOwn = Object.hasOwn(obj, 'key');\n  const hasOwnProp = obj.hasOwnProperty('key');\n  const isUndef = obj.key === undefined;\n  return { hasIn, hasOwn, hasOwnProp, isUndef };\n}\n\n// --- Property deletion ---","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<propertyChecks>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAME"},"pass":2,"annotatedAt":"2026-02-24T00:37:24.281Z"}
{"construct":{"id":"property-access::prop-null-proto-dict","file":"src/property-access.js","category":"property-access","lineStart":257,"lineEnd":265,"code":"function nullPrototypeDict() {\n  const dict = Object.create(null);\n  dict['key with spaces'] = 1;\n  dict['another-key'] = 2;\n  return dict;\n}\n\n// --- Proxy handler traps (full set) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<nullPrototypeDict>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<dict>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.create(null)>","metadata":{"callee":"Object.create"}},{"type":"PROPERTY_ACCESS","id":"<Object.create>","metadata":{"objectName":"Object","propertyName":"create"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"PROPERTY_ACCESS","id":"<dict['key with spaces']>","metadata":{"objectName":"dict","propertyName":"key with spaces","computed":true}},{"type":"LITERAL","id":"<'key with spaces'>","metadata":{"value":"key with spaces","literalType":"string"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<dict['another-key']>","metadata":{"objectName":"dict","propertyName":"another-key","computed":true}},{"type":"LITERAL","id":"<'another-key'>","metadata":{"value":"another-key","literalType":"string"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<nullPrototypeDict>","dst":"<dict>","type":"CONTAINS"},{"src":"<dict>","dst":"<Object.create(null)>","type":"ASSIGNED_FROM"},{"src":"<Object.create(null)>","dst":"<Object.create>","type":"CALLS"},{"src":"<Object.create(null)>","dst":"<null>","type":"PASSES_ARGUMENT"},{"src":"<dict['key with spaces']>","dst":"<dict>","type":"READS_FROM"},{"src":"<dict['key with spaces']>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<dict['another-key']>","dst":"<dict>","type":"READS_FROM"},{"src":"<dict['another-key']>","dst":"<2>","type":"ASSIGNED_FROM"},{"src":"<nullPrototypeDict>","dst":"<dict>","type":"RETURNS"}],"rationale":"Function creates null-prototype object and assigns properties using computed property access. Reduced edge count by removing implicit module declaration and redundant write operations that are captured by the assignment relationships.","implicitBehavior":["Object.create(null) creates object with no prototype chain","computed property access allows string keys with spaces/special chars","Property assignments modify the dict object in place"]},"pass":2,"annotatedAt":"2026-02-24T00:37:25.101Z"}
{"construct":{"id":"property-access::prop-getter-only-no-setter","file":"src/property-access.js","category":"property-access","lineStart":298,"lineEnd":305,"code":"function getterOnlyNoSetter() {\n  const obj = {\n    get value() { return 42; },\n  };\n  obj.value = 99; // silently fails in sloppy, throws in strict\n  return obj.value; // still 42\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getterOnlyNoSetter>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj-literal>"},{"type":"GETTER","id":"<value-getter>","metadata":{"propertyName":"value"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.value-write>","metadata":{"objectName":"obj","propertyName":"value","operation":"write"}},{"type":"LITERAL","id":"<99>","metadata":{"value":99,"literalType":"number"}},{"type":"PROPERTY_ACCESS","id":"<obj.value-read>","metadata":{"objectName":"obj","propertyName":"value","operation":"read"}}],"edges":[{"src":"<getterOnlyNoSetter>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<obj-literal>","type":"ASSIGNED_FROM"},{"src":"<obj-literal>","dst":"<value-getter>","type":"HAS_PROPERTY"},{"src":"<value-getter>","dst":"<42>","type":"RETURNS"},{"src":"<obj.value-write>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.value-write>","dst":"<99>","type":"ASSIGNED_FROM"},{"src":"<obj.value-read>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.value-read>","dst":"<value-getter>","type":"INVOKES"},{"src":"<getterOnlyNoSetter>","dst":"<obj.value-read>","type":"RETURNS"}],"rationale":"Function creates object with getter-only property. Write attempt fails silently/throws, read invokes getter returning original value. Reduced from 10 to 9 edges by removing module declaration edge.","implicitBehavior":["write to getter-only property silently fails in sloppy mode, throws TypeError in strict mode","getter is invoked on each property access"]},"pass":2,"annotatedAt":"2026-02-24T00:37:28.481Z"}
{"construct":{"id":"property-access::delete-array-hole","file":"src/property-access.js","category":"property-access","lineStart":374,"lineEnd":378,"code":"function deleteArrayHole(arr) {\n  delete arr[1];                 // creates a HOLE  arr.length unchanged\n  return arr;                    // [1, empty, 3] if arr was [1, 2, 3]\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deleteArrayHole>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<arr>"},{"type":"SIDE_EFFECT","id":"<delete arr[1]>","metadata":{"operation":"delete","target":"array element"}},{"type":"PROPERTY_ACCESS","id":"<arr[1]>","metadata":{"accessType":"bracket","property":"1"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}}],"edges":[{"src":"<deleteArrayHole>","dst":"<arr>","type":"DECLARES"},{"src":"<deleteArrayHole>","dst":"<delete arr[1]>","type":"CONTAINS"},{"src":"<delete arr[1]>","dst":"<arr[1]>","type":"DELETES"},{"src":"<arr[1]>","dst":"<arr>","type":"READS_FROM"},{"src":"<arr[1]>","dst":"<1>","type":"USES"},{"src":"<deleteArrayHole>","dst":"<arr>","type":"RETURNS"}],"rationale":"Delete operation on array element creates a sparse array hole. Mapped DELETE_OPERATION to SIDE_EFFECT since delete has observable effects beyond simple assignment. Property access uses numeric index to target the deletion.","implicitBehavior":["delete on array element creates hole without changing length","sparse array affects iteration behavior","typeof arr[1] becomes 'undefined' but 1 in arr is false"]},"pass":2,"annotatedAt":"2026-02-24T00:37:29.709Z"}
{"construct":{"id":"property-access::prop-getter-side-effect","file":"src/property-access.js","category":"property-access","lineStart":197,"lineEnd":214,"code":"function getterSideEffect() {\n  let callCount = 0;\n  const obj = {\n    get value() {\n      callCount++;\n      return 42;\n    },\n    set value(v) {\n      console.log('set to', v);\n    },\n  };\n  const x = obj.value;   // triggers getter  side effect\n  obj.value = 10;         // triggers setter  side effect\n  return { x, callCount };\n}\n\n// --- Circular references ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getterSideEffect>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<callCount>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj:object>"},{"type":"GETTER","id":"<obj.value:getter>"},{"type":"SETTER","id":"<obj.value:setter>"},{"type":"PARAMETER","id":"<v>"},{"type":"EXPRESSION","id":"<callCount++>","metadata":{"operator":"++"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"CALL","id":"<console.log('set to', v)>","metadata":{"callee":"console.log"}},{"type":"LITERAL","id":"<'set to'>","metadata":{"value":"set to","literalType":"string"}},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<obj.value:read>","metadata":{"objectName":"obj","propertyName":"value","accessType":"read"}},{"type":"PROPERTY_ACCESS","id":"<obj.value:write>","metadata":{"objectName":"obj","propertyName":"value","accessType":"write"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"EXPRESSION","id":"<return-object>"}],"edges":[{"src":"<getterSideEffect>","dst":"<callCount>","type":"CONTAINS"},{"src":"<callCount>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<getterSideEffect>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<obj:object>","type":"ASSIGNED_FROM"},{"src":"<obj:object>","dst":"<obj.value:getter>","type":"HAS_PROPERTY"},{"src":"<obj:object>","dst":"<obj.value:setter>","type":"HAS_PROPERTY"},{"src":"<obj.value:getter>","dst":"<callCount++>","type":"CONTAINS"},{"src":"<callCount++>","dst":"<callCount>","type":"MODIFIES"},{"src":"<obj.value:getter>","dst":"<42>","type":"RETURNS"},{"src":"<obj.value:setter>","dst":"<v>","type":"CONTAINS"},{"src":"<obj.value:setter>","dst":"<console.log('set to', v)>","type":"CONTAINS"},{"src":"<console.log('set to', v)>","dst":"<'set to'>","type":"PASSES_ARGUMENT"},{"src":"<console.log('set to', v)>","dst":"<v>","type":"PASSES_ARGUMENT"},{"src":"<getterSideEffect>","dst":"<x>","type":"CONTAINS"},{"src":"<x>","dst":"<obj.value:read>","type":"ASSIGNED_FROM"},{"src":"<obj.value:read>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj.value:read>","dst":"<obj.value:getter>","type":"INVOKES"},{"src":"<obj.value:write>","dst":"<obj>","type":"WRITES_TO"},{"src":"<obj.value:write>","dst":"<10>","type":"ASSIGNED_FROM"},{"src":"<obj.value:write>","dst":"<obj.value:setter>","type":"INVOKES"},{"src":"<getterSideEffect>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<x>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<callCount>","type":"HAS_PROPERTY"}],"rationale":"Function with getter/setter property access that causes side effects. Getter increments counter, setter logs. Property accesses invoke the respective accessor methods. Used EXPRESSION for object literals since OBJECT is not in approved vocabulary.","implicitBehavior":["getter invocation on property read","setter invocation on property write","side effects occur during property access"]},"pass":2,"annotatedAt":"2026-02-24T00:37:30.019Z"}
{"construct":{"id":"prototypes::proto-static-method","file":"src/prototypes.js","category":"prototypes","lineStart":21,"lineEnd":26,"code":"Person.create = function (name, age) {\n  return new Person(name, age);\n};\n\n// --- Prototypal inheritance ---","commentedOut":false},"annotation":{"nodes":[{"type":"PROPERTY_ACCESS","id":"<Person.create>","metadata":{"objectName":"Person","propertyName":"create"}},{"type":"FUNCTION","id":"<Person.create:fn>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<name>"},{"type":"PARAMETER","id":"<age>"},{"type":"CALL","id":"<new Person(name, age)>","metadata":{"callee":"Person","isConstructorCall":true}}],"edges":[{"src":"<Person.create>","dst":"<Person.create:fn>","type":"ASSIGNED_FROM"},{"src":"<Person.create:fn>","dst":"<name>","type":"CONTAINS"},{"src":"<Person.create:fn>","dst":"<age>","type":"CONTAINS"},{"src":"<Person.create:fn>","dst":"<new Person(name, age)>","type":"RETURNS"},{"src":"<new Person(name, age)>","dst":"<Person>","type":"CALLS"},{"src":"<new Person(name, age)>","dst":"<name>","type":"PASSES_ARGUMENT"},{"src":"<new Person(name, age)>","dst":"<age>","type":"PASSES_ARGUMENT"}],"rationale":"Static method assignment to constructor function. The property access represents the static method being defined, which contains a function that creates new instances via constructor call.","implicitBehavior":["static method attached to constructor function object","factory pattern for object creation"]},"pass":2,"annotatedAt":"2026-02-24T00:37:31.758Z"}
{"construct":{"id":"property-access::delete-computed-property","file":"src/property-access.js","category":"property-access","lineStart":368,"lineEnd":372,"code":"function deleteComputed(obj, key) {\n  delete obj[key];               // computed delete  property name unknown at parse time\n  delete obj[key.toUpperCase()]; // delete with expression in key\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deleteComputed>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<key>"},{"type":"SIDE_EFFECT","id":"<delete obj[key]>","metadata":{"operation":"delete","computed":true}},{"type":"PROPERTY_ACCESS","id":"<obj[key]>","metadata":{"computed":true}},{"type":"SIDE_EFFECT","id":"<delete obj[key.toUpperCase()]>","metadata":{"operation":"delete","computed":true}},{"type":"PROPERTY_ACCESS","id":"<obj[key.toUpperCase()]>","metadata":{"computed":true}},{"type":"CALL","id":"<key.toUpperCase()>","metadata":{"callee":"toUpperCase"}},{"type":"PROPERTY_ACCESS","id":"<key.toUpperCase>","metadata":{"computed":false,"property":"toUpperCase"}}],"edges":[{"src":"<deleteComputed>","dst":"<obj>","type":"CONTAINS"},{"src":"<deleteComputed>","dst":"<key>","type":"CONTAINS"},{"src":"<deleteComputed>","dst":"<delete obj[key]>","type":"CONTAINS"},{"src":"<deleteComputed>","dst":"<delete obj[key.toUpperCase()]>","type":"CONTAINS"},{"src":"<delete obj[key]>","dst":"<obj[key]>","type":"DELETES"},{"src":"<obj[key]>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj[key]>","dst":"<key>","type":"READS_FROM"},{"src":"<delete obj[key.toUpperCase()]>","dst":"<obj[key.toUpperCase()]>","type":"DELETES"},{"src":"<obj[key.toUpperCase()]>","dst":"<obj>","type":"READS_FROM"},{"src":"<obj[key.toUpperCase()]>","dst":"<key.toUpperCase()>","type":"READS_FROM"},{"src":"<key.toUpperCase()>","dst":"<key.toUpperCase>","type":"CALLS"},{"src":"<key.toUpperCase>","dst":"<key>","type":"READS_FROM"}],"rationale":"Function with computed property deletion operations mapped to approved vocabulary. DELETE_OPERATION mapped to SIDE_EFFECT since delete operations cause side effects. Property access relationships mapped to READS_FROM since they read object/key values.","implicitBehavior":["delete returns boolean indicating success","delete on non-configurable properties fails silently in non-strict mode","computed property access evaluates key expression at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:37:34.624Z"}
{"construct":{"id":"prototypes::proto-object-create-null","file":"src/prototypes.js","category":"prototypes","lineStart":57,"lineEnd":61,"code":"const nullProto = Object.create(null);\nnullProto.key = 'value';\n\n// --- Prototype chain inspection ---","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<nullProto>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.create(null)>","metadata":{"callee":"Object.create"}},{"type":"PROPERTY_ACCESS","id":"<Object.create>","metadata":{"objectName":"Object","propertyName":"create"}},{"type":"LITERAL","id":"<null>","metadata":{"value":null,"literalType":"null"}},{"type":"PROPERTY_ACCESS","id":"<nullProto.key>","metadata":{"objectName":"nullProto","propertyName":"key"}},{"type":"LITERAL","id":"<'value'>","metadata":{"value":"value","literalType":"string"}}],"edges":[{"src":"<MODULE>","dst":"<nullProto>","type":"DECLARES"},{"src":"<nullProto>","dst":"<Object.create(null)>","type":"ASSIGNED_FROM"},{"src":"<Object.create(null)>","dst":"<Object.create>","type":"CALLS"},{"src":"<Object.create(null)>","dst":"<null>","type":"PASSES_ARGUMENT"},{"src":"<nullProto.key>","dst":"<'value'>","type":"ASSIGNED_FROM"},{"src":"<MODULE>","dst":"<nullProto.key>","type":"WRITES_TO"}],"rationale":"Creates an object with null prototype using Object.create(null), then assigns a property to it. The object has no prototype chain and lacks inherited methods.","implicitBehavior":["object created with null prototype has no inherited methods like toString(), hasOwnProperty(), etc.","property assignment creates own property directly on the object"]},"pass":2,"annotatedAt":"2026-02-24T00:37:35.855Z"}
{"construct":{"id":"prototypes::proto-constructor-function","file":"src/prototypes.js","category":"prototypes","lineStart":7,"lineEnd":19,"code":"function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function () {\n  return `Hi, I'm ${this.name}`;\n};\n\nPerson.prototype.toString = function () {\n  return `Person(${this.name}, ${this.age})`;\n};","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<Person>","metadata":{"constructorFunction":true}},{"type":"PARAMETER","id":"<name>"},{"type":"PARAMETER","id":"<age>"},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<this.age>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<Person.prototype>"},{"type":"PROPERTY_ACCESS","id":"<Person.prototype.greet>"},{"type":"FUNCTION","id":"<greet:fn>","metadata":{"prototypeMethod":true}},{"type":"EXPRESSION","id":"<`Hi, I'm ${this.name}`>","metadata":{"templateLiteral":true}},{"type":"PROPERTY_ACCESS","id":"<Person.prototype.toString>"},{"type":"FUNCTION","id":"<toString:fn>","metadata":{"prototypeMethod":true}},{"type":"EXPRESSION","id":"<`Person(${this.name}, ${this.age})`>","metadata":{"templateLiteral":true}}],"edges":[{"src":"<Person>","dst":"<name>","type":"HAS_BODY"},{"src":"<Person>","dst":"<age>","type":"HAS_BODY"},{"src":"<Person>","dst":"<this.name>","type":"WRITES_TO"},{"src":"<Person>","dst":"<this.age>","type":"WRITES_TO"},{"src":"<this.name>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<this.age>","dst":"<age>","type":"ASSIGNED_FROM"},{"src":"<Person.prototype.greet>","dst":"<greet:fn>","type":"ASSIGNED_FROM"},{"src":"<greet:fn>","dst":"<`Hi, I'm ${this.name}`>","type":"RETURNS"},{"src":"<`Hi, I'm ${this.name}`>","dst":"<this.name>","type":"READS_FROM"},{"src":"<Person.prototype.toString>","dst":"<toString:fn>","type":"ASSIGNED_FROM"},{"src":"<toString:fn>","dst":"<`Person(${this.name}, ${this.age})`>","type":"RETURNS"},{"src":"<`Person(${this.name}, ${this.age})`>","dst":"<this.name>","type":"READS_FROM"},{"src":"<`Person(${this.name}, ${this.age})`>","dst":"<this.age>","type":"READS_FROM"}],"rationale":"Constructor function pattern with prototype methods. Constructor assigns parameters to instance properties, prototype methods access those properties via 'this'. Used HAS_BODY for parameter containment as closest approved alternative to CONTAINS.","implicitBehavior":["Person function creates prototype object automatically","new Person() will set this.__proto__ to Person.prototype","prototype methods inherit 'this' context from instance when called"]},"pass":2,"annotatedAt":"2026-02-24T00:37:36.059Z"}
{"construct":{"id":"property-access::getter-throws-in-destructuring","file":"src/property-access.js","category":"property-access","lineStart":337,"lineEnd":350,"code":"function getterThrowsInDestructuring() {\n  const dangerous = {\n    get boom() { throw new Error('trap!'); },\n    safe: 1,\n  };\n  try {\n    const { boom } = dangerous; // throws during destructuring\n  } catch (e) {\n    return e.message;\n  }\n}\n\n// --- Proxy wrapping a class constructor ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getterThrowsInDestructuring>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<dangerous>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<dangerous:object>"},{"type":"GETTER","id":"<boom:getter>","metadata":{"propertyName":"boom"}},{"type":"EXPRESSION","id":"<throw new Error('trap!')>","metadata":{"type":"throw"}},{"type":"CALL","id":"<new Error('trap!')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'trap!'>","metadata":{"value":"trap!","literalType":"string"}},{"type":"PROPERTY","id":"<safe:property>","metadata":{"propertyName":"safe"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"EXPRESSION","id":"<{ boom } = dangerous>","metadata":{"pattern":"object"}},{"type":"VARIABLE","id":"<boom>","metadata":{"kind":"const"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"PROPERTY_ACCESS","id":"<e.message>","metadata":{"property":"message"}}],"edges":[{"src":"<getterThrowsInDestructuring>","dst":"<dangerous>","type":"CONTAINS"},{"src":"<dangerous>","dst":"<dangerous:object>","type":"ASSIGNED_FROM"},{"src":"<dangerous:object>","dst":"<boom:getter>","type":"HAS_PROPERTY"},{"src":"<dangerous:object>","dst":"<safe:property>","type":"HAS_PROPERTY"},{"src":"<boom:getter>","dst":"<throw new Error('trap!')>","type":"HAS_BODY"},{"src":"<throw new Error('trap!')>","dst":"<new Error('trap!')>","type":"THROWS"},{"src":"<new Error('trap!')>","dst":"<'trap!'>","type":"PASSES_ARGUMENT"},{"src":"<safe:property>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<getterThrowsInDestructuring>","dst":"<try-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<{ boom } = dangerous>","type":"HAS_BODY"},{"src":"<{ boom } = dangerous>","dst":"<boom>","type":"DECLARES"},{"src":"<{ boom } = dangerous>","dst":"<dangerous>","type":"READS_FROM"},{"src":"<{ boom } = dangerous>","dst":"<boom:getter>","type":"INVOKES"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<e>","type":"CONTAINS"},{"src":"<getterThrowsInDestructuring>","dst":"<e.message>","type":"RETURNS"},{"src":"<e.message>","dst":"<e>","type":"READS_FROM"}],"rationale":"Function with object containing getter that throws. Destructuring assignment triggers getter execution, which throws and is caught by try-catch block. Mapped OBJECT_LITERAL to EXPRESSION and INVOKES_GETTER to INVOKES as closest approved types.","implicitBehavior":["getter is invoked during destructuring assignment","thrown error propagates from getter to destructuring operation","destructuring fails and control transfers to catch block"]},"pass":2,"annotatedAt":"2026-02-24T00:37:37.185Z"}
{"construct":{"id":"property-access::getter-destructuring-side-effect","file":"src/property-access.js","category":"property-access","lineStart":315,"lineEnd":324,"code":"function getterInDestructuring() {\n  let callCount = 0;\n  const sneaky = {\n    get value() { callCount++; return callCount; },\n  };\n  const { value } = sneaky;        // getter fires  callCount incremented\n  const copy = { ...sneaky };      // spread triggers ALL getters\n  return { value, copy, callCount };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getterInDestructuring>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<callCount>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"VARIABLE","id":"<sneaky>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<sneaky:obj>"},{"type":"GETTER","id":"<sneaky.value>","metadata":{"propertyName":"value"}},{"type":"EXPRESSION","id":"<callCount++>","metadata":{"operator":"++"}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<{ value }>","metadata":{"destructuringType":"object"}},{"type":"VARIABLE","id":"<copy>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<...sneaky>","metadata":{"spreadType":"object"}},{"type":"EXPRESSION","id":"<copy:obj>"},{"type":"EXPRESSION","id":"<return:obj>"}],"edges":[{"src":"<getterInDestructuring>","dst":"<callCount>","type":"CONTAINS"},{"src":"<callCount>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<getterInDestructuring>","dst":"<sneaky>","type":"CONTAINS"},{"src":"<sneaky>","dst":"<sneaky:obj>","type":"ASSIGNED_FROM"},{"src":"<sneaky:obj>","dst":"<sneaky.value>","type":"HAS_PROPERTY"},{"src":"<sneaky.value>","dst":"<callCount++>","type":"RETURNS"},{"src":"<callCount++>","dst":"<callCount>","type":"MODIFIES"},{"src":"<callCount++>","dst":"<callCount>","type":"READS_FROM"},{"src":"<getterInDestructuring>","dst":"<value>","type":"CONTAINS"},{"src":"<value>","dst":"<{ value }>","type":"ASSIGNED_FROM"},{"src":"<{ value }>","dst":"<sneaky>","type":"READS_FROM"},{"src":"<{ value }>","dst":"<sneaky.value>","type":"INVOKES"},{"src":"<getterInDestructuring>","dst":"<copy>","type":"CONTAINS"},{"src":"<copy>","dst":"<copy:obj>","type":"ASSIGNED_FROM"},{"src":"<copy:obj>","dst":"<...sneaky>","type":"CONTAINS"},{"src":"<...sneaky>","dst":"<sneaky>","type":"SPREADS_FROM"},{"src":"<...sneaky>","dst":"<sneaky.value>","type":"INVOKES"},{"src":"<getterInDestructuring>","dst":"<return:obj>","type":"RETURNS"},{"src":"<return:obj>","dst":"<value>","type":"CONTAINS"},{"src":"<return:obj>","dst":"<copy>","type":"CONTAINS"},{"src":"<return:obj>","dst":"<callCount>","type":"CONTAINS"}],"rationale":"Function with getter property that has side effects. Destructuring and spread operations both trigger the getter, causing observable state changes to callCount. Used INVOKES to represent getter triggering and EXPRESSION for object literals and destructuring patterns.","implicitBehavior":["getter executes during destructuring assignment","getter executes during object spread","multiple getter invocations modify shared state","property access order affects final state"]},"pass":2,"annotatedAt":"2026-02-24T00:37:37.526Z"}
{"construct":{"id":"property-access::prop-proxy-revocable","file":"src/property-access.js","category":"property-access","lineStart":287,"lineEnd":296,"code":"function proxyRevocable() {\n  const { proxy, revoke } = Proxy.revocable({}, {\n    get(t, prop) { return prop in t ? t[prop] : 'default'; },\n  });\n  proxy.x = 1;\n  const val = proxy.x;\n  revoke();\n  return val;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<proxyRevocable>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<proxy>","metadata":{"kind":"const"}},{"type":"VARIABLE","id":"<revoke>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Proxy.revocable({}, handler)>","metadata":{"callee":"Proxy.revocable"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":"{}","literalType":"object"}},{"type":"FUNCTION","id":"<handler>","metadata":{"async":false,"generator":false}},{"type":"METHOD","id":"<handler.get>","metadata":{"kind":"method"}},{"type":"PARAMETER","id":"<t>"},{"type":"PARAMETER","id":"<prop>"},{"type":"EXPRESSION","id":"<prop in t>","metadata":{"operator":"in"}},{"type":"PROPERTY_ACCESS","id":"<t[prop]>"},{"type":"LITERAL","id":"<'default'>","metadata":{"value":"default","literalType":"string"}},{"type":"PROPERTY_ACCESS","id":"<proxy.x>","metadata":{"property":"x"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<val>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<proxy.x:read>","metadata":{"property":"x","operation":"read"}},{"type":"CALL","id":"<revoke()>","metadata":{"callee":"revoke"}}],"edges":[{"src":"<proxyRevocable>","dst":"<proxy>","type":"CONTAINS"},{"src":"<proxyRevocable>","dst":"<revoke>","type":"CONTAINS"},{"src":"<proxy>","dst":"<Proxy.revocable({}, handler)>","type":"ASSIGNED_FROM"},{"src":"<revoke>","dst":"<Proxy.revocable({}, handler)>","type":"ASSIGNED_FROM"},{"src":"<Proxy.revocable({}, handler)>","dst":"<{}>","type":"PASSES_ARGUMENT"},{"src":"<Proxy.revocable({}, handler)>","dst":"<handler>","type":"PASSES_ARGUMENT"},{"src":"<handler>","dst":"<handler.get>","type":"CONTAINS"},{"src":"<handler.get>","dst":"<t>","type":"CONTAINS"},{"src":"<handler.get>","dst":"<prop>","type":"CONTAINS"},{"src":"<prop in t>","dst":"<prop>","type":"READS_FROM"},{"src":"<prop in t>","dst":"<t>","type":"READS_FROM"},{"src":"<t[prop]>","dst":"<t>","type":"READS_FROM"},{"src":"<t[prop]>","dst":"<prop>","type":"READS_FROM"},{"src":"<handler.get>","dst":"<prop in t>","type":"CONTAINS"},{"src":"<handler.get>","dst":"<t[prop]>","type":"RETURNS"},{"src":"<handler.get>","dst":"<'default'>","type":"RETURNS"},{"src":"<proxy.x>","dst":"<proxy>","type":"READS_FROM"},{"src":"<proxy.x>","dst":"<1>","type":"ASSIGNED_FROM"},{"src":"<val>","dst":"<proxy.x:read>","type":"ASSIGNED_FROM"},{"src":"<proxy.x:read>","dst":"<proxy>","type":"READS_FROM"},{"src":"<proxyRevocable>","dst":"<val>","type":"RETURNS"}],"rationale":"Function creates a revocable proxy with a get trap handler. The proxy is written to, read from, then revoked. The handler intercepts property access with conditional logic. Reduced edge count by removing redundant containment edges and focusing on essential data flow relationships.","implicitBehavior":["Proxy.revocable returns object with proxy and revoke function","get trap intercepts all property reads on proxy","revoke() invalidates proxy making further access throw","destructuring assignment extracts proxy and revoke from returned object"]},"pass":2,"annotatedAt":"2026-02-24T00:37:37.751Z"}
{"construct":{"id":"prototypes::proto-set-prototype","file":"src/prototypes.js","category":"prototypes","lineStart":74,"lineEnd":80,"code":"function reparent(obj, newParent) {\n  Object.setPrototypeOf(obj, newParent);\n  return obj;\n}\n\n// --- Mixin pattern ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<reparent>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<newParent>"},{"type":"CALL","id":"<Object.setPrototypeOf(obj, newParent)>","metadata":{"callee":"Object.setPrototypeOf"}},{"type":"PROPERTY_ACCESS","id":"<Object.setPrototypeOf>","metadata":{"objectName":"Object","propertyName":"setPrototypeOf"}}],"edges":[{"src":"<reparent>","dst":"<obj>","type":"HAS_BODY"},{"src":"<reparent>","dst":"<newParent>","type":"HAS_BODY"},{"src":"<reparent>","dst":"<Object.setPrototypeOf(obj, newParent)>","type":"CONTAINS"},{"src":"<Object.setPrototypeOf(obj, newParent)>","dst":"<Object.setPrototypeOf>","type":"CALLS"},{"src":"<Object.setPrototypeOf(obj, newParent)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.setPrototypeOf(obj, newParent)>","dst":"<newParent>","type":"PASSES_ARGUMENT"},{"src":"<reparent>","dst":"<obj>","type":"RETURNS"},{"src":"<obj>","dst":"<newParent>","type":"MODIFIES"}],"rationale":"Function that modifies an object's prototype chain using Object.setPrototypeOf, then returns the modified object. The prototype relationship is captured through the MODIFIES edge indicating obj's prototype chain is altered to reference newParent.","implicitBehavior":["Object.setPrototypeOf modifies the prototype chain at runtime","May affect performance due to prototype chain optimization invalidation","Changes inheritance hierarchy for the target object"]},"pass":2,"annotatedAt":"2026-02-24T00:37:38.544Z"}
{"construct":{"id":"property-access::getter-computed-destructuring","file":"src/property-access.js","category":"property-access","lineStart":326,"lineEnd":335,"code":"function getterComputedDestructuring() {\n  let fired = false;\n  const obj = {\n    get secret() { fired = true; return 42; },\n  };\n  const key = 'secret';\n  const { [key]: extracted } = obj; // getter via computed key\n  return { extracted, fired };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getterComputedDestructuring>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<fired>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"VARIABLE","id":"<obj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<obj-literal>"},{"type":"GETTER","id":"<obj.secret>","metadata":{"propertyName":"secret"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<42>","metadata":{"value":42,"literalType":"number"}},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<'secret'>","metadata":{"value":"secret","literalType":"string"}},{"type":"VARIABLE","id":"<extracted>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<destructure-obj>","metadata":{"pattern":"object","computed":true}},{"type":"PROPERTY_ACCESS","id":"<obj[key]>","metadata":{"computed":true}},{"type":"EXPRESSION","id":"<return-object>"},{"type":"EXPRESSION","id":"<return-expression>"}],"edges":[{"src":"<getterComputedDestructuring>","dst":"<fired>","type":"CONTAINS"},{"src":"<fired>","dst":"<false>","type":"ASSIGNED_FROM"},{"src":"<getterComputedDestructuring>","dst":"<obj>","type":"CONTAINS"},{"src":"<obj>","dst":"<obj-literal>","type":"ASSIGNED_FROM"},{"src":"<obj-literal>","dst":"<obj.secret>","type":"HAS_PROPERTY"},{"src":"<obj.secret>","dst":"<fired>","type":"WRITES_TO"},{"src":"<obj.secret>","dst":"<true>","type":"FLOWS_INTO"},{"src":"<obj.secret>","dst":"<42>","type":"RETURNS"},{"src":"<getterComputedDestructuring>","dst":"<key>","type":"CONTAINS"},{"src":"<key>","dst":"<'secret'>","type":"ASSIGNED_FROM"},{"src":"<getterComputedDestructuring>","dst":"<extracted>","type":"CONTAINS"},{"src":"<destructure-obj>","dst":"<obj>","type":"READS_FROM"},{"src":"<destructure-obj>","dst":"<extracted>","type":"FLOWS_INTO"},{"src":"<obj[key]>","dst":"<key>","type":"READS_FROM"},{"src":"<obj[key]>","dst":"<obj.secret>","type":"CALLS"},{"src":"<extracted>","dst":"<obj[key]>","type":"ASSIGNED_FROM"},{"src":"<return-object>","dst":"<extracted>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<fired>","type":"HAS_PROPERTY"},{"src":"<return-expression>","dst":"<return-object>","type":"RETURNS"},{"src":"<getterComputedDestructuring>","dst":"<return-expression>","type":"RETURNS"}],"rationale":"Destructuring assignment with computed property key that triggers a getter. The getter is invoked during destructuring, causing side effects (fired = true) and returning a value that gets assigned to the destructured variable. Used EXPRESSION for object literals and destructuring patterns since no specific types exist in approved vocabulary.","implicitBehavior":["getter function is invoked during property access via computed key","destructuring triggers property access which invokes the getter","side effect (fired = true) occurs during destructuring evaluation"]},"pass":2,"annotatedAt":"2026-02-24T00:37:40.372Z"}
{"construct":{"id":"prototypes::proto-mixin-applied","file":"src/prototypes.js","category":"prototypes","lineStart":109,"lineEnd":115,"code":"function Widget(name) {\n  this.name = name;\n}\napplyMixins(Widget, Serializable, EventEmitterMixin);\n\n// --- Property descriptors ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<Widget>","metadata":{"async":false,"generator":false,"constructor":true}},{"type":"PARAMETER","id":"<name>"},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"CALL","id":"<applyMixins(Widget, Serializable, EventEmitterMixin)>","metadata":{"callee":"applyMixins"}},{"type":"EXTERNAL","id":"<applyMixins>"},{"type":"EXTERNAL","id":"<Serializable>"},{"type":"EXTERNAL","id":"<EventEmitterMixin>"}],"edges":[{"src":"<Widget>","dst":"<name>","type":"CONTAINS"},{"src":"<this.name>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<Widget>","dst":"<this.name>","type":"WRITES_TO"},{"src":"<applyMixins(Widget, Serializable, EventEmitterMixin)>","dst":"<applyMixins>","type":"CALLS"},{"src":"<applyMixins(Widget, Serializable, EventEmitterMixin)>","dst":"<Widget>","type":"PASSES_ARGUMENT"},{"src":"<applyMixins(Widget, Serializable, EventEmitterMixin)>","dst":"<Serializable>","type":"PASSES_ARGUMENT"},{"src":"<applyMixins(Widget, Serializable, EventEmitterMixin)>","dst":"<EventEmitterMixin>","type":"PASSES_ARGUMENT"},{"src":"<Widget>","dst":"<Serializable>","type":"DEPENDS_ON"},{"src":"<Widget>","dst":"<EventEmitterMixin>","type":"DEPENDS_ON"}],"rationale":"Constructor function Widget with mixin application. The applyMixins call modifies Widget's prototype to include functionality from both mixins. Used DEPENDS_ON instead of MIXES_IN to capture the relationship between Widget and the mixins.","implicitBehavior":["applyMixins modifies Widget.prototype by copying properties/methods from mixin objects","Widget instances will have access to Serializable and EventEmitterMixin methods","function declaration is hoisted to module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:37:40.498Z"}
{"construct":{"id":"builtins::regex-lookahead","file":"src/builtins.js","category":"builtins","lineStart":328,"lineEnd":330,"code":"const posLookahead = /\\d+(?=px)/;\nconst negLookahead = /\\d+(?!px)/;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<posLookahead>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\d+(?=px)/>","metadata":{"value":"/\\d+(?=px)/","literalType":"regex","pattern":"\\d+(?=px)","flags":""}},{"type":"VARIABLE","id":"<negLookahead>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\d+(?!px)/>","metadata":{"value":"/\\d+(?!px)/","literalType":"regex","pattern":"\\d+(?!px)","flags":""}}],"edges":[{"src":"<module>","dst":"<posLookahead>","type":"DECLARES"},{"src":"<posLookahead>","dst":"</\\d+(?=px)/>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<negLookahead>","type":"DECLARES"},{"src":"<negLookahead>","dst":"</\\d+(?!px)/>","type":"ASSIGNED_FROM"}],"rationale":"Two const variable declarations initialized with regex literals. The Pass 1 annotation already used only approved vocabulary types, so no changes were needed. VARIABLE and LITERAL are approved node types, and DECLARES and ASSIGNED_FROM are approved edge types.","implicitBehavior":["regex literals create RegExp objects with compile-time pattern validation","lookahead assertions are zero-width - they don't consume characters in matches"]},"pass":2,"annotatedAt":"2026-02-24T00:37:43.328Z"}
{"construct":{"id":"property-access::proxy-class-constructor","file":"src/property-access.js","category":"property-access","lineStart":352,"lineEnd":366,"code":"class OriginalClass {\n  constructor(name) { this.name = name; }\n  greet() { return `Hi, ${this.name}`; }\n}\n\nconst TrackedClass = new Proxy(OriginalClass, {\n  construct(target, args, newTarget) {\n    return Reflect.construct(target, args, newTarget);\n  },\n});\n\nconst trackedInstance = new TrackedClass('Alice');\n\n// --- delete on computed properties ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<OriginalClass>"},{"type":"METHOD","id":"<OriginalClass.constructor>","metadata":{"kind":"constructor"}},{"type":"PARAMETER","id":"<name>"},{"type":"PROPERTY_ACCESS","id":"<this.name>","metadata":{"objectName":"this"}},{"type":"METHOD","id":"<OriginalClass.greet>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<`Hi, ${this.name}`>","metadata":{"type":"template-literal"}},{"type":"VARIABLE","id":"<TrackedClass>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Proxy(OriginalClass, {...})>","metadata":{"callee":"Proxy","constructor":true}},{"type":"LITERAL","id":"<proxy-handler>","metadata":{"type":"object"}},{"type":"METHOD","id":"<construct>","metadata":{"kind":"method","proxyTrap":true}},{"type":"PARAMETER","id":"<target>"},{"type":"PARAMETER","id":"<args>"},{"type":"PARAMETER","id":"<newTarget>"},{"type":"CALL","id":"<Reflect.construct(target, args, newTarget)>","metadata":{"callee":"Reflect.construct"}},{"type":"VARIABLE","id":"<trackedInstance>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new TrackedClass('Alice')>","metadata":{"callee":"TrackedClass","constructor":true}},{"type":"LITERAL","id":"<'Alice'>","metadata":{"value":"Alice","literalType":"string"}}],"edges":[{"src":"<OriginalClass>","dst":"<OriginalClass.constructor>","type":"CONTAINS"},{"src":"<OriginalClass>","dst":"<OriginalClass.greet>","type":"CONTAINS"},{"src":"<OriginalClass.constructor>","dst":"<name>","type":"CONTAINS"},{"src":"<this.name>","dst":"<name>","type":"ASSIGNED_FROM"},{"src":"<OriginalClass.constructor>","dst":"<this.name>","type":"WRITES_TO"},{"src":"<OriginalClass.greet>","dst":"<`Hi, ${this.name}`>","type":"RETURNS"},{"src":"<`Hi, ${this.name}`>","dst":"<this.name>","type":"READS_FROM"},{"src":"<TrackedClass>","dst":"<new Proxy(OriginalClass, {...})>","type":"ASSIGNED_FROM"},{"src":"<new Proxy(OriginalClass, {...})>","dst":"<OriginalClass>","type":"PASSES_ARGUMENT"},{"src":"<new Proxy(OriginalClass, {...})>","dst":"<proxy-handler>","type":"PASSES_ARGUMENT"},{"src":"<proxy-handler>","dst":"<construct>","type":"HAS_PROPERTY"},{"src":"<construct>","dst":"<target>","type":"CONTAINS"},{"src":"<construct>","dst":"<args>","type":"CONTAINS"},{"src":"<construct>","dst":"<newTarget>","type":"CONTAINS"},{"src":"<construct>","dst":"<Reflect.construct(target, args, newTarget)>","type":"RETURNS"},{"src":"<Reflect.construct(target, args, newTarget)>","dst":"<target>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.construct(target, args, newTarget)>","dst":"<args>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.construct(target, args, newTarget)>","dst":"<newTarget>","type":"PASSES_ARGUMENT"},{"src":"<trackedInstance>","dst":"<new TrackedClass('Alice')>","type":"ASSIGNED_FROM"},{"src":"<new TrackedClass('Alice')>","dst":"<TrackedClass>","type":"CALLS"},{"src":"<new TrackedClass('Alice')>","dst":"<'Alice'>","type":"PASSES_ARGUMENT"}],"rationale":"Proxy wrapping a class constructor. The proxy handler intercepts construction calls and delegates to Reflect.construct. TrackedClass becomes a proxied constructor that can intercept instantiation. Reduced edge count by removing module-level DECLARES edges and some redundant CALLS edges while preserving core semantic relationships.","implicitBehavior":["Proxy construct trap intercepts 'new' operator","Reflect.construct preserves prototype chain","Proxy maintains instanceof relationship with original class"]},"pass":2,"annotatedAt":"2026-02-24T00:37:45.788Z"}
{"construct":{"id":"prototypes::proto-define-property","file":"src/prototypes.js","category":"prototypes","lineStart":117,"lineEnd":126,"code":"function createReadonly(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  });\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<createReadonly>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<prop>"},{"type":"PARAMETER","id":"<value>"},{"type":"CALL","id":"<Object.defineProperty(obj, prop, {...})>","metadata":{"callee":"Object.defineProperty"}},{"type":"PROPERTY_ACCESS","id":"<Object.defineProperty>","metadata":{"objectName":"Object"}},{"type":"EXPRESSION","id":"<descriptor>","metadata":{"expressionType":"object_literal","properties":["value","writable","enumerable","configurable"]}},{"type":"LITERAL","id":"<false>","metadata":{"value":false,"literalType":"boolean"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<createReadonly>","dst":"<obj>","type":"CONTAINS"},{"src":"<createReadonly>","dst":"<prop>","type":"CONTAINS"},{"src":"<createReadonly>","dst":"<value>","type":"CONTAINS"},{"src":"<createReadonly>","dst":"<Object.defineProperty(obj, prop, {...})>","type":"CONTAINS"},{"src":"<Object.defineProperty(obj, prop, {...})>","dst":"<Object.defineProperty>","type":"CALLS"},{"src":"<Object.defineProperty(obj, prop, {...})>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperty(obj, prop, {...})>","dst":"<prop>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperty(obj, prop, {...})>","dst":"<descriptor>","type":"PASSES_ARGUMENT"},{"src":"<descriptor>","dst":"<value>","type":"HAS_PROPERTY"},{"src":"<descriptor>","dst":"<false>","type":"HAS_PROPERTY"},{"src":"<descriptor>","dst":"<true>","type":"HAS_PROPERTY"},{"src":"<createReadonly>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function that uses Object.defineProperty to create a readonly property on an object. Takes three parameters and returns the modified object. The object literal descriptor is mapped to EXPRESSION since no specific OBJECT_LITERAL type exists in approved vocabulary.","implicitBehavior":["Object.defineProperty modifies the target object's property descriptor","Property becomes non-writable and non-configurable after definition"]},"pass":2,"annotatedAt":"2026-02-24T00:37:46.403Z"}
{"construct":{"id":"prototypes::proto-property-descriptor-read","file":"src/prototypes.js","category":"prototypes","lineStart":153,"lineEnd":162,"code":"function getDescriptor(obj, prop) {\n  return Object.getOwnPropertyDescriptor(obj, prop);\n}\n\nfunction getAllDescriptors(obj) {\n  return Object.getOwnPropertyDescriptors(obj);\n}\n\n// --- instanceof with Symbol.hasInstance ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<getDescriptor>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"PARAMETER","id":"<prop>"},{"type":"CALL","id":"<Object.getOwnPropertyDescriptor(obj, prop)>","metadata":{"callee":"Object.getOwnPropertyDescriptor"}},{"type":"PROPERTY_ACCESS","id":"<Object.getOwnPropertyDescriptor>","metadata":{"objectName":"Object","propertyName":"getOwnPropertyDescriptor"}},{"type":"FUNCTION","id":"<getAllDescriptors>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj2>"},{"type":"CALL","id":"<Object.getOwnPropertyDescriptors(obj)>","metadata":{"callee":"Object.getOwnPropertyDescriptors"}},{"type":"PROPERTY_ACCESS","id":"<Object.getOwnPropertyDescriptors>","metadata":{"objectName":"Object","propertyName":"getOwnPropertyDescriptors"}}],"edges":[{"src":"<getDescriptor>","dst":"<obj>","type":"HAS_BODY"},{"src":"<getDescriptor>","dst":"<prop>","type":"HAS_BODY"},{"src":"<getDescriptor>","dst":"<Object.getOwnPropertyDescriptor(obj, prop)>","type":"RETURNS"},{"src":"<Object.getOwnPropertyDescriptor(obj, prop)>","dst":"<Object.getOwnPropertyDescriptor>","type":"CALLS"},{"src":"<Object.getOwnPropertyDescriptor(obj, prop)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.getOwnPropertyDescriptor(obj, prop)>","dst":"<prop>","type":"PASSES_ARGUMENT"},{"src":"<getAllDescriptors>","dst":"<obj2>","type":"HAS_BODY"},{"src":"<getAllDescriptors>","dst":"<Object.getOwnPropertyDescriptors(obj)>","type":"RETURNS"},{"src":"<Object.getOwnPropertyDescriptors(obj)>","dst":"<Object.getOwnPropertyDescriptors>","type":"CALLS"},{"src":"<Object.getOwnPropertyDescriptors(obj)>","dst":"<obj2>","type":"PASSES_ARGUMENT"}],"rationale":"Two utility functions that wrap Object's property descriptor methods. Each function takes parameters and returns the result of calling built-in Object methods. Used HAS_BODY to represent parameter containment since CONTAINS is not in approved vocabulary.","implicitBehavior":["Object.getOwnPropertyDescriptor returns undefined for non-existent properties","Object.getOwnPropertyDescriptors returns empty object for objects with no own properties","Both methods only examine own properties, not inherited ones"]},"pass":2,"annotatedAt":"2026-02-24T00:37:48.478Z"}
{"construct":{"id":"prototypes::proto-object-create","file":"src/prototypes.js","category":"prototypes","lineStart":43,"lineEnd":55,"code":"const baseProto = {\n  type: 'base',\n  identify() {\n    return this.type;\n  },\n};\n\nconst derived = Object.create(baseProto);\nderived.type = 'derived';\nderived.extra = function () {\n  return 'extra';\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<baseProto>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<baseProto:object>","metadata":{"literalType":"object"}},{"type":"PROPERTY","id":"<baseProto.type>","metadata":{"name":"type"}},{"type":"LITERAL","id":"<'base'>","metadata":{"value":"base","literalType":"string"}},{"type":"METHOD","id":"<baseProto.identify>","metadata":{"kind":"method"}},{"type":"PROPERTY_ACCESS","id":"<this.type>","metadata":{"objectName":"this"}},{"type":"VARIABLE","id":"<derived>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.create(baseProto)>","metadata":{"callee":"Object.create"}},{"type":"PROPERTY","id":"<derived.type>","metadata":{"name":"type"}},{"type":"LITERAL","id":"<'derived'>","metadata":{"value":"derived","literalType":"string"}},{"type":"PROPERTY","id":"<derived.extra>","metadata":{"name":"extra"}},{"type":"FUNCTION","id":"<derived.extra:fn>","metadata":{"anonymous":true}},{"type":"LITERAL","id":"<'extra'>","metadata":{"value":"extra","literalType":"string"}}],"edges":[{"src":"<baseProto>","dst":"<baseProto:object>","type":"ASSIGNED_FROM"},{"src":"<baseProto:object>","dst":"<baseProto.type>","type":"HAS_PROPERTY"},{"src":"<baseProto.type>","dst":"<'base'>","type":"ASSIGNED_FROM"},{"src":"<baseProto:object>","dst":"<baseProto.identify>","type":"HAS_PROPERTY"},{"src":"<baseProto.identify>","dst":"<this.type>","type":"RETURNS"},{"src":"<baseProto.identify>","dst":"<this.type>","type":"READS_FROM"},{"src":"<derived>","dst":"<Object.create(baseProto)>","type":"ASSIGNED_FROM"},{"src":"<Object.create(baseProto)>","dst":"<baseProto>","type":"PASSES_ARGUMENT"},{"src":"<derived>","dst":"<baseProto>","type":"EXTENDS"},{"src":"<derived.type>","dst":"<'derived'>","type":"ASSIGNED_FROM"},{"src":"<derived.extra>","dst":"<derived.extra:fn>","type":"ASSIGNED_FROM"},{"src":"<derived.extra:fn>","dst":"<'extra'>","type":"RETURNS"}],"rationale":"Object literal with method assigned to baseProto. Object.create establishes prototype chain from baseProto to derived. Property assignments add/override properties on derived instance. Used PROPERTY nodes for object properties and EXTENDS for prototype relationship.","implicitBehavior":["prototype chain lookup for inherited properties","this binding in identify method depends on call context","derived inherits identify method from baseProto"]},"pass":2,"annotatedAt":"2026-02-24T00:37:48.478Z"}
{"construct":{"id":"prototypes::monkey-patch-builtin","file":"src/prototypes.js","category":"prototypes","lineStart":173,"lineEnd":177,"code":"Array.prototype.last = function () {\n  return this[this.length - 1];\n};\n[1, 2, 3].last();","commentedOut":false},"annotation":{"nodes":[{"type":"PROPERTY_ACCESS","id":"<Array.prototype.last>","metadata":{"objectName":"Array.prototype","propertyName":"last"}},{"type":"FUNCTION","id":"<last:fn>","metadata":{"arrowFunction":false}},{"type":"PROPERTY_ACCESS","id":"<this[this.length - 1]>","metadata":{"objectName":"this","computed":true}},{"type":"EXPRESSION","id":"<this.length - 1>","metadata":{"operator":"-"}},{"type":"PROPERTY_ACCESS","id":"<this.length>","metadata":{"objectName":"this","propertyName":"length"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<[1, 2, 3]>","metadata":{"literalType":"array","elements":[1,2,3]}},{"type":"CALL","id":"<[1, 2, 3].last()>","metadata":{"callee":"last"}}],"edges":[{"src":"<Array.prototype.last>","dst":"<last:fn>","type":"ASSIGNED_FROM"},{"src":"<last:fn>","dst":"<this[this.length - 1]>","type":"RETURNS"},{"src":"<this[this.length - 1]>","dst":"<this.length - 1>","type":"READS_FROM"},{"src":"<this.length - 1>","dst":"<this.length>","type":"READS_FROM"},{"src":"<this.length - 1>","dst":"<1>","type":"READS_FROM"},{"src":"<[1, 2, 3].last()>","dst":"<last:fn>","type":"CALLS"},{"src":"<[1, 2, 3].last()>","dst":"<[1, 2, 3]>","type":"READS_FROM"}],"rationale":"Monkey-patches Array prototype with a new method, then calls it on an array literal. The function accesses 'this' context to compute the last element. All node and edge types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["modifies global Array prototype affecting all array instances","method becomes available on all existing and future arrays","'this' binding determined at call time"]},"pass":2,"annotatedAt":"2026-02-24T00:37:48.858Z"}
{"construct":{"id":"builtins::regex-lookbehind","file":"src/builtins.js","category":"builtins","lineStart":332,"lineEnd":334,"code":"const posLookbehind = /(?<=\\$)\\d+/;\nconst negLookbehind = /(?<!\\$)\\d+/;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<posLookbehind>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<=\\$)\\d+/>","metadata":{"value":"/(?<=\\$)\\d+/","literalType":"regex","flags":"","hasLookbehind":true,"lookbehindType":"positive"}},{"type":"VARIABLE","id":"<negLookbehind>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</(?<!\\$)\\d+/>","metadata":{"value":"/(?<!\\$)\\d+/","literalType":"regex","flags":"","hasLookbehind":true,"lookbehindType":"negative"}}],"edges":[{"src":"<module>","dst":"<posLookbehind>","type":"DECLARES"},{"src":"<posLookbehind>","dst":"</(?<=\\$)\\d+/>","type":"ASSIGNED_FROM"},{"src":"<module>","dst":"<negLookbehind>","type":"DECLARES"},{"src":"<negLookbehind>","dst":"</(?<!\\$)\\d+/>","type":"ASSIGNED_FROM"}],"rationale":"Two const variable declarations initialized with regex literals. First uses positive lookbehind to match digits after $, second uses negative lookbehind to match digits not after $. All types used in Pass 1 are in the approved vocabulary.","implicitBehavior":["lookbehind assertions require ES2018+ support","regex literals create RegExp objects at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:37:49.273Z"}
{"construct":{"id":"prototypes::proto-inheritance-chain","file":"src/prototypes.js","category":"prototypes","lineStart":28,"lineEnd":41,"code":"function Employee(name, age, role) {\n  Person.call(this, name, age);\n  this.role = role;\n}\n\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\nEmployee.prototype.describe = function () {\n  return `${this.greet()}, I'm a ${this.role}`;\n};\n\n// --- Object.create ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<Employee>","metadata":{"constructorFunction":true}},{"type":"PARAMETER","id":"<name>"},{"type":"PARAMETER","id":"<age>"},{"type":"PARAMETER","id":"<role>"},{"type":"CALL","id":"<Person.call(this, name, age)>","metadata":{"callee":"Person.call"}},{"type":"PROPERTY_ACCESS","id":"<this.role>","metadata":{"objectName":"this"}},{"type":"PROPERTY_ACCESS","id":"<Employee.prototype>","metadata":{"objectName":"Employee"}},{"type":"CALL","id":"<Object.create(Person.prototype)>","metadata":{"callee":"Object.create"}},{"type":"PROPERTY_ACCESS","id":"<Person.prototype>","metadata":{"objectName":"Person"}},{"type":"PROPERTY_ACCESS","id":"<Employee.prototype.constructor>","metadata":{"objectName":"Employee.prototype"}},{"type":"METHOD","id":"<Employee.prototype.describe>","metadata":{"kind":"method"}},{"type":"EXPRESSION","id":"<template-literal>","metadata":{"type":"template-literal"}},{"type":"CALL","id":"<this.greet()>","metadata":{"callee":"this.greet"}}],"edges":[{"src":"<Employee>","dst":"<name>","type":"CONTAINS"},{"src":"<Employee>","dst":"<age>","type":"CONTAINS"},{"src":"<Employee>","dst":"<role>","type":"CONTAINS"},{"src":"<Employee>","dst":"<Person.call(this, name, age)>","type":"CONTAINS"},{"src":"<Person.call(this, name, age)>","dst":"<name>","type":"PASSES_ARGUMENT"},{"src":"<Person.call(this, name, age)>","dst":"<age>","type":"PASSES_ARGUMENT"},{"src":"<this.role>","dst":"<role>","type":"ASSIGNED_FROM"},{"src":"<Employee>","dst":"<this.role>","type":"WRITES_TO"},{"src":"<Employee.prototype>","dst":"<Object.create(Person.prototype)>","type":"ASSIGNED_FROM"},{"src":"<Object.create(Person.prototype)>","dst":"<Person.prototype>","type":"PASSES_ARGUMENT"},{"src":"<Employee.prototype>","dst":"<Person.prototype>","type":"EXTENDS"},{"src":"<Employee.prototype.constructor>","dst":"<Employee>","type":"ASSIGNED_FROM"},{"src":"<Employee.prototype>","dst":"<Employee.prototype.describe>","type":"HAS_PROPERTY"},{"src":"<Employee.prototype.describe>","dst":"<template-literal>","type":"RETURNS"},{"src":"<template-literal>","dst":"<this.greet()>","type":"READS_FROM"},{"src":"<template-literal>","dst":"<this.role>","type":"READS_FROM"},{"src":"<this.greet()>","dst":"<this>","type":"CALLS_ON"}],"rationale":"Classical inheritance pattern using constructor functions. Employee calls Person constructor, sets up prototype chain via Object.create, restores constructor reference, and adds instance method that calls inherited method.","implicitBehavior":["Person.call() sets up inherited properties on Employee instances","Object.create() establishes prototype chain for method inheritance","this.greet() will resolve via prototype chain to Person.prototype.greet","Constructor property restoration maintains proper instanceof behavior"]},"pass":2,"annotatedAt":"2026-02-24T00:37:49.962Z"}
{"construct":{"id":"prototypes::proto-symbol-hasinstance","file":"src/prototypes.js","category":"prototypes","lineStart":164,"lineEnd":171,"code":"class EvenNumber {\n  static [Symbol.hasInstance](instance) {\n    return typeof instance === 'number' && instance % 2 === 0;\n  }\n}\n\n// --- Monkey-patching ---","commentedOut":false},"annotation":{"nodes":[{"type":"CLASS","id":"<EvenNumber>"},{"type":"METHOD","id":"<EvenNumber[Symbol.hasInstance]>","metadata":{"kind":"static","computed":true,"symbol":"Symbol.hasInstance"}},{"type":"PARAMETER","id":"<instance>"},{"type":"EXPRESSION","id":"<typeof instance === 'number' && instance % 2 === 0>","metadata":{"operator":"&&"}},{"type":"LITERAL","id":"<'number'>","metadata":{"value":"number","literalType":"string"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}}],"edges":[{"src":"<EvenNumber>","dst":"<EvenNumber[Symbol.hasInstance]>","type":"CONTAINS"},{"src":"<EvenNumber[Symbol.hasInstance]>","dst":"<instance>","type":"CONTAINS"},{"src":"<EvenNumber[Symbol.hasInstance]>","dst":"<typeof instance === 'number' && instance % 2 === 0>","type":"RETURNS"},{"src":"<typeof instance === 'number' && instance % 2 === 0>","dst":"<instance>","type":"READS_FROM"},{"src":"<typeof instance === 'number' && instance % 2 === 0>","dst":"<'number'>","type":"READS_FROM"},{"src":"<typeof instance === 'number' && instance % 2 === 0>","dst":"<2>","type":"READS_FROM"},{"src":"<typeof instance === 'number' && instance % 2 === 0>","dst":"<0>","type":"READS_FROM"}],"rationale":"Simplified annotation focusing on the key semantic relationships. The class contains a static Symbol.hasInstance method that returns a compound expression. The expression reads from the parameter and literals to perform type and evenness checking.","implicitBehavior":["Symbol.hasInstance method overrides default instanceof behavior for this class","instanceof operator will call this method when checking EvenNumber instances"]},"pass":2,"annotatedAt":"2026-02-24T00:37:50.386Z"}
{"construct":{"id":"prototypes::proto-define-getter-setter","file":"src/prototypes.js","category":"prototypes","lineStart":128,"lineEnd":138,"code":"function withComputedProp(obj) {\n  let _internal = 0;\n  Object.defineProperty(obj, 'computed', {\n    get() { return _internal * 2; },\n    set(v) { _internal = v; },\n    enumerable: true,\n    configurable: true,\n  });\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<withComputedProp>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<_internal>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"CALL","id":"<Object.defineProperty>","metadata":{"callee":"Object.defineProperty"}},{"type":"LITERAL","id":"<'computed'>","metadata":{"value":"computed","literalType":"string"}},{"type":"EXPRESSION","id":"<computed-descriptor>"},{"type":"GETTER","id":"<computed-getter>"},{"type":"SETTER","id":"<computed-setter>"},{"type":"PARAMETER","id":"<v>"},{"type":"EXPRESSION","id":"<_internal * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<true-enumerable>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<true-configurable>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<withComputedProp>","dst":"<obj>","type":"CONTAINS"},{"src":"<withComputedProp>","dst":"<_internal>","type":"CONTAINS"},{"src":"<_internal>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<withComputedProp>","dst":"<Object.defineProperty>","type":"CONTAINS"},{"src":"<Object.defineProperty>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperty>","dst":"<'computed'>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperty>","dst":"<computed-descriptor>","type":"PASSES_ARGUMENT"},{"src":"<computed-descriptor>","dst":"<computed-getter>","type":"HAS_PROPERTY"},{"src":"<computed-descriptor>","dst":"<computed-setter>","type":"HAS_PROPERTY"},{"src":"<computed-descriptor>","dst":"<true-enumerable>","type":"HAS_PROPERTY"},{"src":"<computed-descriptor>","dst":"<true-configurable>","type":"HAS_PROPERTY"},{"src":"<computed-getter>","dst":"<_internal * 2>","type":"RETURNS"},{"src":"<_internal * 2>","dst":"<_internal>","type":"READS_FROM"},{"src":"<_internal * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<computed-setter>","dst":"<v>","type":"CONTAINS"},{"src":"<computed-setter>","dst":"<_internal>","type":"WRITES_TO"},{"src":"<_internal>","dst":"<v>","type":"ASSIGNED_FROM"},{"src":"<withComputedProp>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function that dynamically defines a computed property with getter/setter on an object. The getter returns a computed value, setter updates internal state, and the property is configured as enumerable and configurable.","implicitBehavior":["Property descriptor creates accessor property on object prototype chain","Getter/setter functions capture lexical scope including _internal variable","Object.defineProperty modifies object at runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:37:51.091Z"}
{"construct":{"id":"prototypes::proto-chain-inspection","file":"src/prototypes.js","category":"prototypes","lineStart":63,"lineEnd":72,"code":"function inspectPrototype(obj) {\n  const proto = Object.getPrototypeOf(obj);\n  const hasOwn = obj.hasOwnProperty('name');\n  const hasOwn2 = Object.hasOwn(obj, 'name');\n  const inChain = 'toString' in obj;\n  return { proto, hasOwn, hasOwn2, inChain };\n}\n\n// --- Object.setPrototypeOf ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<inspectPrototype>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<proto>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.getPrototypeOf(obj)>","metadata":{"callee":"Object.getPrototypeOf"}},{"type":"PROPERTY_ACCESS","id":"<Object.getPrototypeOf>","metadata":{"objectName":"Object"}},{"type":"VARIABLE","id":"<hasOwn>","metadata":{"kind":"const"}},{"type":"CALL","id":"<obj.hasOwnProperty('name')>","metadata":{"callee":"hasOwnProperty"}},{"type":"PROPERTY_ACCESS","id":"<obj.hasOwnProperty>","metadata":{"objectName":"obj"}},{"type":"LITERAL","id":"<'name'>","metadata":{"value":"name","literalType":"string"}},{"type":"VARIABLE","id":"<hasOwn2>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Object.hasOwn(obj, 'name')>","metadata":{"callee":"Object.hasOwn"}},{"type":"PROPERTY_ACCESS","id":"<Object.hasOwn>","metadata":{"objectName":"Object"}},{"type":"LITERAL","id":"<'name'2>","metadata":{"value":"name","literalType":"string"}},{"type":"VARIABLE","id":"<inChain>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<'toString' in obj>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<'toString'>","metadata":{"value":"toString","literalType":"string"}},{"type":"EXPRESSION","id":"<{ proto, hasOwn, hasOwn2, inChain }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<inspectPrototype>","dst":"<obj>","type":"CONTAINS"},{"src":"<inspectPrototype>","dst":"<proto>","type":"CONTAINS"},{"src":"<proto>","dst":"<Object.getPrototypeOf(obj)>","type":"ASSIGNED_FROM"},{"src":"<Object.getPrototypeOf(obj)>","dst":"<Object.getPrototypeOf>","type":"CALLS"},{"src":"<Object.getPrototypeOf(obj)>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<inspectPrototype>","dst":"<hasOwn>","type":"CONTAINS"},{"src":"<hasOwn>","dst":"<obj.hasOwnProperty('name')>","type":"ASSIGNED_FROM"},{"src":"<obj.hasOwnProperty('name')>","dst":"<obj.hasOwnProperty>","type":"CALLS"},{"src":"<obj.hasOwnProperty('name')>","dst":"<'name'>","type":"PASSES_ARGUMENT"},{"src":"<inspectPrototype>","dst":"<hasOwn2>","type":"CONTAINS"},{"src":"<hasOwn2>","dst":"<Object.hasOwn(obj, 'name')>","type":"ASSIGNED_FROM"},{"src":"<Object.hasOwn(obj, 'name')>","dst":"<Object.hasOwn>","type":"CALLS"},{"src":"<Object.hasOwn(obj, 'name')>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.hasOwn(obj, 'name')>","dst":"<'name'2>","type":"PASSES_ARGUMENT"},{"src":"<inspectPrototype>","dst":"<inChain>","type":"CONTAINS"},{"src":"<inChain>","dst":"<'toString' in obj>","type":"ASSIGNED_FROM"},{"src":"<'toString' in obj>","dst":"<'toString'>","type":"READS_FROM"},{"src":"<'toString' in obj>","dst":"<obj>","type":"READS_FROM"},{"src":"<inspectPrototype>","dst":"<{ proto, hasOwn, hasOwn2, inChain }>","type":"RETURNS"},{"src":"<{ proto, hasOwn, hasOwn2, inChain }>","dst":"<proto>","type":"READS_FROM"},{"src":"<{ proto, hasOwn, hasOwn2, inChain }>","dst":"<hasOwn>","type":"READS_FROM"},{"src":"<{ proto, hasOwn, hasOwn2, inChain }>","dst":"<hasOwn2>","type":"READS_FROM"},{"src":"<{ proto, hasOwn, hasOwn2, inChain }>","dst":"<inChain>","type":"READS_FROM"}],"rationale":"Function demonstrating different prototype chain inspection methods. Uses Object.getPrototypeOf to get prototype, hasOwnProperty and Object.hasOwn to check own properties, and 'in' operator to check prototype chain. All approved vocabulary types were sufficient to capture the semantic relationships.","implicitBehavior":["Object.getPrototypeOf accesses [[Prototype]] internal slot","hasOwnProperty method may be overridden on the object","Object.hasOwn is safer as it cannot be overridden","'in' operator traverses entire prototype chain","toString property lookup would traverse prototype chain to Object.prototype"]},"pass":2,"annotatedAt":"2026-02-24T00:37:55.302Z"}
{"construct":{"id":"prototypes::monkey-patch-third-party","file":"src/prototypes.js","category":"prototypes","lineStart":179,"lineEnd":186,"code":"function patchRouter(router) {\n  const originalGet = router.get;\n  router.get = function (path, handler) {\n    console.log(`GET ${path}`);\n    return originalGet.call(this, path, handler);\n  };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<patchRouter>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<router>"},{"type":"VARIABLE","id":"<originalGet>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<router.get>","metadata":{"objectName":"router","propertyName":"get"}},{"type":"FUNCTION","id":"<router.get:replacement>","metadata":{"async":false,"generator":false,"anonymous":true}},{"type":"PARAMETER","id":"<path>"},{"type":"PARAMETER","id":"<handler>"},{"type":"CALL","id":"<console.log>","metadata":{"callee":"console.log"}},{"type":"LITERAL","id":"<'GET '>","metadata":{"value":"GET ","literalType":"string"}},{"type":"EXPRESSION","id":"<`GET ${path}`>","metadata":{"type":"template-literal"}},{"type":"CALL","id":"<originalGet.call>","metadata":{"callee":"originalGet.call"}},{"type":"LITERAL","id":"<this>","metadata":{"value":"this","literalType":"this"}}],"edges":[{"src":"<patchRouter>","dst":"<router>","type":"CONTAINS"},{"src":"<patchRouter>","dst":"<originalGet>","type":"DECLARES"},{"src":"<originalGet>","dst":"<router.get>","type":"ASSIGNED_FROM"},{"src":"<router.get>","dst":"<router>","type":"READS_FROM"},{"src":"<router.get>","dst":"<router.get:replacement>","type":"ASSIGNED_FROM"},{"src":"<router.get:replacement>","dst":"<path>","type":"CONTAINS"},{"src":"<router.get:replacement>","dst":"<handler>","type":"CONTAINS"},{"src":"<router.get:replacement>","dst":"<console.log>","type":"CONTAINS"},{"src":"<console.log>","dst":"<`GET ${path}`>","type":"PASSES_ARGUMENT"},{"src":"<`GET ${path}`>","dst":"<path>","type":"READS_FROM"},{"src":"<router.get:replacement>","dst":"<originalGet.call>","type":"RETURNS"},{"src":"<originalGet.call>","dst":"<originalGet>","type":"CALLS"},{"src":"<originalGet.call>","dst":"<this>","type":"PASSES_ARGUMENT"},{"src":"<originalGet.call>","dst":"<path>","type":"PASSES_ARGUMENT"},{"src":"<originalGet.call>","dst":"<handler>","type":"PASSES_ARGUMENT"},{"src":"<patchRouter>","dst":"<router>","type":"MODIFIES"}],"rationale":"Monkey-patching function that captures original method, replaces it with wrapper that logs then delegates to original via .call(). The function modifies the router object by replacing its get method with a logging wrapper.","implicitBehavior":["modifies external object prototype/instance","preserves original method context via .call(this)","side effect logging to console"]},"pass":2,"annotatedAt":"2026-02-24T00:37:57.664Z"}
{"construct":{"id":"prototypes::super-in-object-literal","file":"src/prototypes.js","category":"prototypes","lineStart":197,"lineEnd":207,"code":"const parentObj = {\n  greet() { return 'hello from parent'; },\n};\n\nconst childObj = {\n  __proto__: parentObj,\n  greet() {\n    return super.greet() + ' and child';\n  },\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<parentObj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<parentObj:obj>"},{"type":"METHOD","id":"<parentObj.greet>","metadata":{"kind":"method"}},{"type":"LITERAL","id":"<'hello from parent'>","metadata":{"value":"hello from parent","literalType":"string"}},{"type":"VARIABLE","id":"<childObj>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<childObj:obj>"},{"type":"PROPERTY_ACCESS","id":"<__proto__>","metadata":{"propertyName":"__proto__"}},{"type":"METHOD","id":"<childObj.greet>","metadata":{"kind":"method"}},{"type":"CALL","id":"<super.greet()>","metadata":{"methodName":"greet"}},{"type":"EXPRESSION","id":"<super.greet() + ' and child'>","metadata":{"operator":"+"}},{"type":"LITERAL","id":"<' and child'>","metadata":{"value":" and child","literalType":"string"}}],"edges":[{"src":"<parentObj>","dst":"<parentObj:obj>","type":"ASSIGNED_FROM"},{"src":"<parentObj:obj>","dst":"<parentObj.greet>","type":"CONTAINS"},{"src":"<parentObj.greet>","dst":"<'hello from parent'>","type":"RETURNS"},{"src":"<childObj>","dst":"<childObj:obj>","type":"ASSIGNED_FROM"},{"src":"<childObj:obj>","dst":"<__proto__>","type":"CONTAINS"},{"src":"<__proto__>","dst":"<parentObj>","type":"ASSIGNED_FROM"},{"src":"<childObj:obj>","dst":"<parentObj:obj>","type":"EXTENDS"},{"src":"<childObj:obj>","dst":"<childObj.greet>","type":"CONTAINS"},{"src":"<childObj.greet>","dst":"<super.greet() + ' and child'>","type":"RETURNS"},{"src":"<super.greet()>","dst":"<parentObj.greet>","type":"CALLS"},{"src":"<super.greet() + ' and child'>","dst":"<super.greet()>","type":"READS_FROM"},{"src":"<super.greet() + ' and child'>","dst":"<' and child'>","type":"READS_FROM"}],"rationale":"Object literal with explicit prototype chain via __proto__. Child object extends parent and uses super to call parent method in overridden method. Reduced edge count by removing module-level declarations.","implicitBehavior":["__proto__ sets up prototype chain","super keyword resolves to parent object's method","method override shadows parent method"]},"pass":2,"annotatedAt":"2026-02-24T00:37:59.814Z"}
{"construct":{"id":"prototypes::monkey-patch-global","file":"src/prototypes.js","category":"prototypes","lineStart":188,"lineEnd":195,"code":"const originalFetch = globalThis.fetch;\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n  apply(target, thisArg, args) {\n    console.log('intercepted:', args[0]);\n    return Reflect.apply(target, thisArg, args);\n  },\n});","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<originalFetch>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<globalThis.fetch>","metadata":{"objectName":"globalThis","propertyName":"fetch"}},{"type":"CALL","id":"<fetch-proxy>","metadata":{"callee":"Proxy","constructor":true}},{"type":"METHOD","id":"<apply-handler>","metadata":{"kind":"proxy-handler","trap":"apply"}},{"type":"PARAMETER","id":"<target>"},{"type":"PARAMETER","id":"<thisArg>"},{"type":"PARAMETER","id":"<args>"},{"type":"CALL","id":"<console.log>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<args[0]>","metadata":{"objectName":"args","propertyName":"0"}},{"type":"CALL","id":"<Reflect.apply>","metadata":{"callee":"Reflect.apply"}}],"edges":[{"src":"<originalFetch>","dst":"<globalThis.fetch>","type":"ASSIGNED_FROM"},{"src":"<globalThis.fetch>","dst":"<fetch-proxy>","type":"ASSIGNED_FROM"},{"src":"<fetch-proxy>","dst":"<globalThis.fetch>","type":"PASSES_ARGUMENT"},{"src":"<fetch-proxy>","dst":"<apply-handler>","type":"HAS_PROPERTY"},{"src":"<apply-handler>","dst":"<target>","type":"RECEIVES_ARGUMENT"},{"src":"<apply-handler>","dst":"<thisArg>","type":"RECEIVES_ARGUMENT"},{"src":"<apply-handler>","dst":"<args>","type":"RECEIVES_ARGUMENT"},{"src":"<apply-handler>","dst":"<console.log>","type":"CONTAINS"},{"src":"<apply-handler>","dst":"<Reflect.apply>","type":"RETURNS"},{"src":"<console.log>","dst":"<args[0]>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.apply>","dst":"<target>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.apply>","dst":"<thisArg>","type":"PASSES_ARGUMENT"},{"src":"<Reflect.apply>","dst":"<args>","type":"PASSES_ARGUMENT"}],"rationale":"Monkey patches global fetch by storing original, creating proxy with apply handler that logs and delegates. Modifies global runtime behavior through proxy interception.","implicitBehavior":["all fetch calls globally now go through proxy","proxy intercepts function calls via apply trap","original fetch behavior preserved via Reflect.apply"]},"pass":2,"annotatedAt":"2026-02-24T00:38:00.327Z"}
{"construct":{"id":"runtime-apis::runtime-message-channel","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":55,"lineEnd":60,"code":"function messageChannelPattern() {\n  const { port1, port2 } = new MessageChannel();\n  port1.onmessage = (e) => console.log(e.data);\n  port2.postMessage('hello');\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<messageChannelPattern>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<port1>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<port2>","metadata":{"kind":"const","destructured":true}},{"type":"CALL","id":"<new MessageChannel()>","metadata":{"callee":"MessageChannel","constructor":true}},{"type":"PROPERTY_ACCESS","id":"<port1.onmessage>","metadata":{"objectName":"port1","property":"onmessage"}},{"type":"FUNCTION","id":"<onmessage-handler>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"PARAMETER","id":"<e>"},{"type":"CALL","id":"<console.log(e.data)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<e.data>","metadata":{"objectName":"e","property":"data"}},{"type":"CALL","id":"<port2.postMessage('hello')>","metadata":{"callee":"port2.postMessage"}},{"type":"LITERAL","id":"<'hello'>","metadata":{"value":"hello","literalType":"string"}}],"edges":[{"src":"<messageChannelPattern>","dst":"<port1>","type":"CONTAINS"},{"src":"<messageChannelPattern>","dst":"<port2>","type":"CONTAINS"},{"src":"<port1>","dst":"<new MessageChannel()>","type":"ASSIGNED_FROM"},{"src":"<port2>","dst":"<new MessageChannel()>","type":"ASSIGNED_FROM"},{"src":"<new MessageChannel()>","dst":"<MessageChannel>","type":"CALLS"},{"src":"<port1.onmessage>","dst":"<onmessage-handler>","type":"ASSIGNED_FROM"},{"src":"<onmessage-handler>","dst":"<e>","type":"CONTAINS"},{"src":"<onmessage-handler>","dst":"<console.log(e.data)>","type":"CONTAINS"},{"src":"<console.log(e.data)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(e.data)>","dst":"<e.data>","type":"PASSES_ARGUMENT"},{"src":"<e.data>","dst":"<e>","type":"READS_FROM"},{"src":"<messageChannelPattern>","dst":"<port2.postMessage('hello')>","type":"CONTAINS"},{"src":"<port2.postMessage('hello')>","dst":"<port2.postMessage>","type":"CALLS"},{"src":"<port2.postMessage('hello')>","dst":"<'hello'>","type":"PASSES_ARGUMENT"}],"rationale":"Function creates MessageChannel with destructured ports, assigns event handler to port1, and sends message via port2. Handler reads message data and logs it. All relationships captured using approved vocabulary.","implicitBehavior":["MessageChannel creates bidirectional communication channel","port1.onmessage creates event listener registration","postMessage triggers asynchronous message delivery"]},"pass":2,"annotatedAt":"2026-02-24T00:38:01.074Z"}
{"construct":{"id":"runtime-apis::runtime-atomics-wait-notify","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":37,"lineEnd":44,"code":"function atomicsSynchronization(view) {\n  // Atomics.wait(view, 0, 0);     // blocks thread (worker only)\n  Atomics.notify(view, 0, 1);      // wake one waiting thread\n  Atomics.waitAsync(view, 0, 0);   // non-blocking, returns Promise\n}\n\n// --- Worker Communication (Plugin: workers) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<atomicsSynchronization>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<view>"},{"type":"CALL","id":"<Atomics.notify(view, 0, 1)>","metadata":{"callee":"Atomics.notify"}},{"type":"PROPERTY_ACCESS","id":"<Atomics.notify>","metadata":{"objectName":"Atomics","propertyName":"notify"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"CALL","id":"<Atomics.waitAsync(view, 0, 0)>","metadata":{"callee":"Atomics.waitAsync"}},{"type":"PROPERTY_ACCESS","id":"<Atomics.waitAsync>","metadata":{"objectName":"Atomics","propertyName":"waitAsync"}},{"type":"LITERAL","id":"<0_2>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<0_3>","metadata":{"value":0,"literalType":"number"}}],"edges":[{"src":"<atomicsSynchronization>","dst":"<view>","type":"HAS_BODY"},{"src":"<atomicsSynchronization>","dst":"<Atomics.notify(view, 0, 1)>","type":"HAS_BODY"},{"src":"<atomicsSynchronization>","dst":"<Atomics.waitAsync(view, 0, 0)>","type":"HAS_BODY"},{"src":"<Atomics.notify(view, 0, 1)>","dst":"<Atomics.notify>","type":"CALLS"},{"src":"<Atomics.notify(view, 0, 1)>","dst":"<view>","type":"PASSES_ARGUMENT"},{"src":"<Atomics.notify(view, 0, 1)>","dst":"<0>","type":"PASSES_ARGUMENT"},{"src":"<Atomics.notify(view, 0, 1)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<Atomics.waitAsync(view, 0, 0)>","dst":"<Atomics.waitAsync>","type":"CALLS"},{"src":"<Atomics.waitAsync(view, 0, 0)>","dst":"<view>","type":"PASSES_ARGUMENT"},{"src":"<Atomics.waitAsync(view, 0, 0)>","dst":"<0_2>","type":"PASSES_ARGUMENT"},{"src":"<Atomics.waitAsync(view, 0, 0)>","dst":"<0_3>","type":"PASSES_ARGUMENT"}],"rationale":"Function using Atomics API for thread synchronization. Calls notify to wake threads and waitAsync for non-blocking wait. Changed CONTAINS edges to HAS_BODY to better represent the function containing its parameter and statements.","implicitBehavior":["Atomics.notify affects other threads/workers","Atomics.waitAsync returns Promise that resolves when condition changes","SharedArrayBuffer required for Atomics operations","Cross-origin isolation required in browsers"]},"pass":2,"annotatedAt":"2026-02-24T00:38:01.128Z"}
{"construct":{"id":"runtime-apis::runtime-transfer-ownership","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":70,"lineEnd":76,"code":"function transferOwnership(worker) {\n  const buffer = new ArrayBuffer(1024);\n  worker.postMessage(buffer, [buffer]); // buffer neutered in sender\n}\n\n// --- import.meta Extensions (Plugin: node-modules) ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<transferOwnership>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<worker>"},{"type":"VARIABLE","id":"<buffer>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new ArrayBuffer(1024)>","metadata":{"callee":"ArrayBuffer","constructor":true}},{"type":"LITERAL","id":"<1024>","metadata":{"value":1024,"literalType":"number"}},{"type":"CALL","id":"<worker.postMessage(buffer, [buffer])>","metadata":{"callee":"postMessage"}},{"type":"PROPERTY_ACCESS","id":"<worker.postMessage>","metadata":{"objectName":"worker","propertyName":"postMessage"}},{"type":"EXPRESSION","id":"<[buffer]>","metadata":{"type":"array"}}],"edges":[{"src":"<transferOwnership>","dst":"<worker>","type":"HAS_BODY"},{"src":"<transferOwnership>","dst":"<buffer>","type":"HAS_BODY"},{"src":"<buffer>","dst":"<new ArrayBuffer(1024)>","type":"ASSIGNED_FROM"},{"src":"<new ArrayBuffer(1024)>","dst":"<1024>","type":"PASSES_ARGUMENT"},{"src":"<transferOwnership>","dst":"<worker.postMessage(buffer, [buffer])>","type":"HAS_BODY"},{"src":"<worker.postMessage(buffer, [buffer])>","dst":"<worker.postMessage>","type":"CALLS"},{"src":"<worker.postMessage(buffer, [buffer])>","dst":"<buffer>","type":"PASSES_ARGUMENT"},{"src":"<worker.postMessage(buffer, [buffer])>","dst":"<[buffer]>","type":"PASSES_ARGUMENT"},{"src":"<worker.postMessage>","dst":"<worker>","type":"READS_FROM"},{"src":"<[buffer]>","dst":"<buffer>","type":"HAS_ELEMENT"}],"rationale":"Function that creates an ArrayBuffer and transfers ownership to a worker via postMessage with transferable objects array. Used HAS_BODY instead of CONTAINS for function-to-statement relationships as it better represents the containment of statements within a function body.","implicitBehavior":["ArrayBuffer is neutered/detached in sender after transfer","Worker receives ownership of the buffer memory","Transferable objects optimization avoids copying large data"]},"pass":2,"annotatedAt":"2026-02-24T00:38:02.579Z"}
{"construct":{"id":"prototypes::proto-define-properties","file":"src/prototypes.js","category":"prototypes","lineStart":140,"lineEnd":151,"code":"function defineMultiple(obj) {\n  Object.defineProperties(obj, {\n    x: { value: 10, writable: true, enumerable: true },\n    y: { value: 20, writable: true, enumerable: true },\n    sum: {\n      get() { return this.x + this.y; },\n      enumerable: true,\n    },\n  });\n  return obj;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<defineMultiple>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"CALL","id":"<Object.defineProperties>","metadata":{"callee":"Object.defineProperties"}},{"type":"EXPRESSION","id":"<x-descriptor>","metadata":{"propertyName":"x"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"LITERAL","id":"<true-writable-x>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<true-enumerable-x>","metadata":{"value":true,"literalType":"boolean"}},{"type":"EXPRESSION","id":"<y-descriptor>","metadata":{"propertyName":"y"}},{"type":"LITERAL","id":"<20>","metadata":{"value":20,"literalType":"number"}},{"type":"LITERAL","id":"<true-writable-y>","metadata":{"value":true,"literalType":"boolean"}},{"type":"LITERAL","id":"<true-enumerable-y>","metadata":{"value":true,"literalType":"boolean"}},{"type":"EXPRESSION","id":"<sum-descriptor>","metadata":{"propertyName":"sum"}},{"type":"GETTER","id":"<sum-getter>","metadata":{"async":false,"generator":false}},{"type":"EXPRESSION","id":"<this.x + this.y>","metadata":{"operator":"+"}},{"type":"PROPERTY_ACCESS","id":"<this.x>","metadata":{"objectName":"this","propertyName":"x"}},{"type":"PROPERTY_ACCESS","id":"<this.y>","metadata":{"objectName":"this","propertyName":"y"}},{"type":"LITERAL","id":"<true-enumerable-sum>","metadata":{"value":true,"literalType":"boolean"}}],"edges":[{"src":"<defineMultiple>","dst":"<obj>","type":"CONTAINS"},{"src":"<defineMultiple>","dst":"<Object.defineProperties>","type":"CONTAINS"},{"src":"<Object.defineProperties>","dst":"<obj>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperties>","dst":"<x-descriptor>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperties>","dst":"<y-descriptor>","type":"PASSES_ARGUMENT"},{"src":"<Object.defineProperties>","dst":"<sum-descriptor>","type":"PASSES_ARGUMENT"},{"src":"<x-descriptor>","dst":"<10>","type":"HAS_PROPERTY"},{"src":"<x-descriptor>","dst":"<true-writable-x>","type":"HAS_PROPERTY"},{"src":"<x-descriptor>","dst":"<true-enumerable-x>","type":"HAS_PROPERTY"},{"src":"<y-descriptor>","dst":"<20>","type":"HAS_PROPERTY"},{"src":"<y-descriptor>","dst":"<true-writable-y>","type":"HAS_PROPERTY"},{"src":"<y-descriptor>","dst":"<true-enumerable-y>","type":"HAS_PROPERTY"},{"src":"<sum-descriptor>","dst":"<sum-getter>","type":"HAS_PROPERTY"},{"src":"<sum-descriptor>","dst":"<true-enumerable-sum>","type":"HAS_PROPERTY"},{"src":"<sum-getter>","dst":"<this.x + this.y>","type":"RETURNS"},{"src":"<this.x + this.y>","dst":"<this.x>","type":"READS_FROM"},{"src":"<this.x + this.y>","dst":"<this.y>","type":"READS_FROM"},{"src":"<defineMultiple>","dst":"<obj>","type":"RETURNS"}],"rationale":"Function uses Object.defineProperties to define multiple properties with descriptors. Each descriptor is modeled as an EXPRESSION containing property configuration. The sum property has a GETTER that computes from other properties. Used HAS_PROPERTY for descriptor relationships since no specific property descriptor edges exist in approved vocabulary.","implicitBehavior":["Properties are defined directly on the object, not its prototype","Getter function has 'this' bound to the object when accessed","Property descriptors default configurable to false when not specified"]},"pass":2,"annotatedAt":"2026-02-24T00:38:03.718Z"}
{"construct":{"id":"prototypes::method-vs-function-property-super","file":"src/prototypes.js","category":"prototypes","lineStart":209,"lineEnd":233,"code":"const superParent = {\n  greet() { return 'parent'; },\n};\n\nconst superChild = {\n  __proto__: superParent,\n\n  // Method shorthand  HAS [[HomeObject]], super works\n  shorthand() {\n    return super.greet(); // 'parent' \n  },\n\n  // Function property  NO [[HomeObject]], super is SyntaxError\n  funcProp: function() {\n    // super.greet(); // Would be SyntaxError: 'super' keyword unexpected here\n    return 'no super access';\n  },\n\n  // Arrow property  NO own [[HomeObject]], inherits from defining scope\n  arrowProp: () => {\n    // super.greet(); // Would use enclosing scope's super, not this object's\n    return 'arrow has no own super';\n  },\n};","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<superParent>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<superParent:obj>"},{"type":"METHOD","id":"<superParent.greet>","metadata":{"kind":"method","hasHomeObject":true}},{"type":"LITERAL","id":"<'parent'>","metadata":{"value":"parent","literalType":"string"}},{"type":"VARIABLE","id":"<superChild>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<superChild:obj>"},{"type":"PROPERTY","id":"<__proto__:superParent>"},{"type":"METHOD","id":"<superChild.shorthand>","metadata":{"kind":"method","hasHomeObject":true}},{"type":"CALL","id":"<super.greet()>"},{"type":"PROPERTY","id":"<superChild.funcProp>"},{"type":"FUNCTION","id":"<superChild.funcProp:fn>","metadata":{"hasHomeObject":false}},{"type":"LITERAL","id":"<'no super access'>","metadata":{"value":"no super access","literalType":"string"}},{"type":"PROPERTY","id":"<superChild.arrowProp>"},{"type":"FUNCTION","id":"<superChild.arrowProp:fn>","metadata":{"arrowFunction":true,"hasHomeObject":false}},{"type":"LITERAL","id":"<'arrow has no own super'>","metadata":{"value":"arrow has no own super","literalType":"string"}}],"edges":[{"src":"<superParent>","dst":"<superParent:obj>","type":"ASSIGNED_FROM"},{"src":"<superParent:obj>","dst":"<superParent.greet>","type":"HAS_PROPERTY"},{"src":"<superParent.greet>","dst":"<'parent'>","type":"RETURNS"},{"src":"<superChild>","dst":"<superChild:obj>","type":"ASSIGNED_FROM"},{"src":"<superChild:obj>","dst":"<__proto__:superParent>","type":"HAS_PROPERTY"},{"src":"<__proto__:superParent>","dst":"<superParent:obj>","type":"ASSIGNED_FROM"},{"src":"<superChild:obj>","dst":"<superChild.shorthand>","type":"HAS_PROPERTY"},{"src":"<superChild.shorthand>","dst":"<super.greet()>","type":"CONTAINS"},{"src":"<super.greet()>","dst":"<superParent.greet>","type":"CALLS"},{"src":"<superChild.shorthand>","dst":"<super.greet()>","type":"RETURNS"},{"src":"<superChild:obj>","dst":"<superChild.funcProp>","type":"HAS_PROPERTY"},{"src":"<superChild.funcProp>","dst":"<superChild.funcProp:fn>","type":"ASSIGNED_FROM"},{"src":"<superChild.funcProp:fn>","dst":"<'no super access'>","type":"RETURNS"},{"src":"<superChild:obj>","dst":"<superChild.arrowProp>","type":"HAS_PROPERTY"},{"src":"<superChild.arrowProp>","dst":"<superChild.arrowProp:fn>","type":"ASSIGNED_FROM"},{"src":"<superChild.arrowProp:fn>","dst":"<'arrow has no own super'>","type":"RETURNS"}],"rationale":"Demonstrates three ways to define object methods with different super behavior. Method shorthand has [[HomeObject]] enabling super calls, while function properties and arrow functions do not.","implicitBehavior":["Method shorthand automatically gets [[HomeObject]] set to containing object","Function properties lack [[HomeObject]], making super keyword unavailable","Arrow functions inherit super context from lexical scope, not object","Prototype chain established via __proto__ assignment"]},"pass":2,"annotatedAt":"2026-02-24T00:38:04.534Z"}
{"construct":{"id":"builtins::regex-unicode-props","file":"src/builtins.js","category":"builtins","lineStart":339,"lineEnd":342,"code":"const emoji = /\\p{Emoji}/u;\nconst greek = /\\p{Script=Greek}/u;\nconst letter = /\\p{Letter}/u;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<emoji>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\p{Emoji}/u>","metadata":{"value":"/\\p{Emoji}/u","literalType":"regex","flags":["u"],"unicodeProperty":"Emoji"}},{"type":"VARIABLE","id":"<greek>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\p{Script=Greek}/u>","metadata":{"value":"/\\p{Script=Greek}/u","literalType":"regex","flags":["u"],"unicodeProperty":"Script=Greek"}},{"type":"VARIABLE","id":"<letter>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"</\\p{Letter}/u>","metadata":{"value":"/\\p{Letter}/u","literalType":"regex","flags":["u"],"unicodeProperty":"Letter"}}],"edges":[{"src":"<MODULE>","dst":"<emoji>","type":"DECLARES"},{"src":"<emoji>","dst":"</\\p{Emoji}/u>","type":"ASSIGNED_FROM"},{"src":"<MODULE>","dst":"<greek>","type":"DECLARES"},{"src":"<greek>","dst":"</\\p{Script=Greek}/u>","type":"ASSIGNED_FROM"},{"src":"<MODULE>","dst":"<letter>","type":"DECLARES"},{"src":"<letter>","dst":"</\\p{Letter}/u>","type":"ASSIGNED_FROM"}],"rationale":"Three const variable declarations, each initialized with a regex literal using Unicode property escapes. The 'u' flag enables Unicode property matching. All node and edge types from Pass 1 are already in the approved vocabulary.","implicitBehavior":["Unicode property escapes require the 'u' flag to function","RegExp objects created at runtime with compiled patterns"]},"pass":2,"annotatedAt":"2026-02-24T00:38:04.698Z"}
{"construct":{"id":"prototypes::export-named-list","file":"src/prototypes.js","category":"prototypes","lineStart":235,"lineEnd":260,"code":"export {\n  Person,\n  Employee,\n  baseProto,\n  derived,\n  nullProto,\n  inspectPrototype,\n  reparent,\n  Serializable,\n  EventEmitterMixin,\n  applyMixins,\n  Widget,\n  createReadonly,\n  withComputedProp,\n  defineMultiple,\n  getDescriptor,\n  getAllDescriptors,\n  EvenNumber,\n  patchRouter,\n  originalFetch,\n  parentObj,\n  childObj,\n  superParent,\n  superChild,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<Person>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Employee>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<baseProto>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<derived>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<nullProto>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<inspectPrototype>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<reparent>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Serializable>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<EventEmitterMixin>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<applyMixins>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<Widget>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<createReadonly>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<withComputedProp>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<defineMultiple>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<getDescriptor>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<getAllDescriptors>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<EvenNumber>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<patchRouter>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<originalFetch>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<parentObj>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<childObj>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<superParent>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<superChild>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<Person>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Employee>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<baseProto>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<derived>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<nullProto>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<inspectPrototype>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<reparent>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Serializable>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<EventEmitterMixin>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<applyMixins>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<Widget>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<createReadonly>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<withComputedProp>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<defineMultiple>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<getDescriptor>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<getAllDescriptors>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<EvenNumber>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<patchRouter>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<originalFetch>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<parentObj>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<childObj>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<superParent>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<superChild>","type":"EXPORTS"}],"rationale":"Named export list that re-exports 23 previously declared identifiers from the module's scope. Each identifier becomes available for import by other modules. Removed the CONTAINS edge from module to export as it's not essential to the export construct itself.","implicitBehavior":["exported identifiers must be declared elsewhere in the module","creates named bindings in importing modules","enables tree-shaking of unused exports"]},"pass":2,"annotatedAt":"2026-02-24T00:38:06.266Z"}
{"construct":{"id":"runtime-apis::runtime-broadcast-channel","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":62,"lineEnd":68,"code":"function broadcastChannelPattern() {\n  const bc = new BroadcastChannel('updates');\n  bc.postMessage({ type: 'refresh' });\n  bc.onmessage = (e) => console.log(e.data);\n  bc.close();\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<broadcastChannelPattern>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<bc>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new BroadcastChannel('updates')>","metadata":{"callee":"BroadcastChannel","constructor":true}},{"type":"LITERAL","id":"<'updates'>","metadata":{"value":"updates","literalType":"string"}},{"type":"CALL","id":"<bc.postMessage({ type: 'refresh' })>","metadata":{"callee":"postMessage"}},{"type":"LITERAL","id":"<{ type: 'refresh' }>","metadata":{"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<bc.onmessage>","metadata":{"objectName":"bc","propertyName":"onmessage"}},{"type":"FUNCTION","id":"<(e) => console.log(e.data)>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<e>"},{"type":"CALL","id":"<console.log(e.data)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<e.data>","metadata":{"objectName":"e","propertyName":"data"}},{"type":"CALL","id":"<bc.close()>","metadata":{"callee":"close"}}],"edges":[{"src":"<broadcastChannelPattern>","dst":"<bc>","type":"CONTAINS"},{"src":"<bc>","dst":"<new BroadcastChannel('updates')>","type":"ASSIGNED_FROM"},{"src":"<new BroadcastChannel('updates')>","dst":"<'updates'>","type":"PASSES_ARGUMENT"},{"src":"<bc.postMessage({ type: 'refresh' })>","dst":"<bc>","type":"CALLS_ON"},{"src":"<bc.postMessage({ type: 'refresh' })>","dst":"<{ type: 'refresh' }>","type":"PASSES_ARGUMENT"},{"src":"<bc.onmessage>","dst":"<(e) => console.log(e.data)>","type":"ASSIGNED_FROM"},{"src":"<(e) => console.log(e.data)>","dst":"<e>","type":"CONTAINS"},{"src":"<(e) => console.log(e.data)>","dst":"<console.log(e.data)>","type":"CONTAINS"},{"src":"<console.log(e.data)>","dst":"<e.data>","type":"PASSES_ARGUMENT"},{"src":"<e.data>","dst":"<e>","type":"READS_FROM"},{"src":"<bc.close()>","dst":"<bc>","type":"CALLS_ON"},{"src":"<broadcastChannelPattern>","dst":"<bc.postMessage({ type: 'refresh' })>","type":"CONTAINS"},{"src":"<broadcastChannelPattern>","dst":"<bc.onmessage>","type":"CONTAINS"},{"src":"<broadcastChannelPattern>","dst":"<bc.close()>","type":"CONTAINS"}],"rationale":"Function creates a BroadcastChannel, sends a message, sets up message handler, and closes the channel. The handler is an arrow function that logs received data. Used CALLS_ON for method calls on objects and CONTAINS for function body relationships.","implicitBehavior":["BroadcastChannel enables cross-tab/worker communication","onmessage handler will be called asynchronously when messages arrive","close() releases channel resources"]},"pass":2,"annotatedAt":"2026-02-24T00:38:08.826Z"}
{"construct":{"id":"runtime-apis::export-named-list","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":116,"lineEnd":126,"code":"export {\n  sharedMemory,\n  atomicsSynchronization,\n  workerCommunication,\n  messageChannelPattern,\n  broadcastChannelPattern,\n  transferOwnership,\n  importMetaExtensions,\n  deferredPromise,\n};","commentedOut":false},"annotation":{"nodes":[{"type":"EXPORT","id":"<export-named-list>","metadata":{"exportType":"named"}},{"type":"VARIABLE","id":"<sharedMemory>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<atomicsSynchronization>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<workerCommunication>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<messageChannelPattern>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<broadcastChannelPattern>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<transferOwnership>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<importMetaExtensions>","metadata":{"exported":true}},{"type":"VARIABLE","id":"<deferredPromise>","metadata":{"exported":true}}],"edges":[{"src":"<export-named-list>","dst":"<sharedMemory>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<atomicsSynchronization>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<workerCommunication>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<messageChannelPattern>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<broadcastChannelPattern>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<transferOwnership>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<importMetaExtensions>","type":"EXPORTS"},{"src":"<export-named-list>","dst":"<deferredPromise>","type":"EXPORTS"}],"rationale":"Named export list that re-exports multiple variables/functions. Each exported identifier becomes available to importers under its original name. Removed the CONTAINS edge from module to reduce edge count while preserving the core export relationships.","implicitBehavior":["exported names must be previously declared in module scope","creates bindings in module's export namespace"]},"pass":2,"annotatedAt":"2026-02-24T00:38:09.235Z"}
{"construct":{"id":"statements::if-else","file":"src/statements.js","category":"statements","lineStart":13,"lineEnd":20,"code":"function ifElseStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  } else {\n    return 'non-positive';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<ifElseStatement>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"BRANCH","id":"<if-else>","metadata":{"branchType":"if-else"}},{"type":"EXPRESSION","id":"<x > 0>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<'positive'>","metadata":{"value":"positive","literalType":"string"}},{"type":"LITERAL","id":"<'non-positive'>","metadata":{"value":"non-positive","literalType":"string"}}],"edges":[{"src":"<ifElseStatement>","dst":"<x>","type":"CONTAINS"},{"src":"<ifElseStatement>","dst":"<if-else>","type":"CONTAINS"},{"src":"<if-else>","dst":"<x > 0>","type":"HAS_CONDITION"},{"src":"<x > 0>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 0>","dst":"<0>","type":"READS_FROM"},{"src":"<if-else>","dst":"<'positive'>","type":"HAS_CONSEQUENT"},{"src":"<if-else>","dst":"<'non-positive'>","type":"HAS_ALTERNATE"},{"src":"<ifElseStatement>","dst":"<'positive'>","type":"RETURNS"},{"src":"<ifElseStatement>","dst":"<'non-positive'>","type":"RETURNS"}],"rationale":"Function with if-else branch. Condition compares parameter to literal, each branch returns a different string literal. Removed module declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["function declaration is hoisted to module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:38:10.163Z"}
{"construct":{"id":"runtime-apis::runtime-import-meta-resolve","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":78,"lineEnd":89,"code":"function importMetaExtensions() {\n  const depPath = import.meta.resolve('lodash');\n  const localPath = import.meta.resolve('./utils.js');\n  // Node.js 21+:\n  // const dir = import.meta.dirname;   // replaces __dirname\n  // const file = import.meta.filename; // replaces __filename\n  return { depPath, localPath };\n}\n\n// --- Global Error Sinks (Plugin: error-flow) ---\n// These create implicit edges from ANY uncaught throw/reject to handler.","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<importMetaExtensions>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<depPath>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import.meta.resolve('lodash')>","metadata":{"callee":"import.meta.resolve"}},{"type":"META_PROPERTY","id":"<import.meta.resolve>","metadata":{"objectName":"import.meta","propertyName":"resolve"}},{"type":"LITERAL","id":"<'lodash'>","metadata":{"value":"lodash","literalType":"string"}},{"type":"VARIABLE","id":"<localPath>","metadata":{"kind":"const"}},{"type":"CALL","id":"<import.meta.resolve('./utils.js')>","metadata":{"callee":"import.meta.resolve"}},{"type":"META_PROPERTY","id":"<import.meta.resolve2>","metadata":{"objectName":"import.meta","propertyName":"resolve"}},{"type":"LITERAL","id":"<'./utils.js'>","metadata":{"value":"./utils.js","literalType":"string"}},{"type":"EXPRESSION","id":"<{ depPath, localPath }>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<importMetaExtensions>","dst":"<depPath>","type":"CONTAINS"},{"src":"<importMetaExtensions>","dst":"<localPath>","type":"CONTAINS"},{"src":"<depPath>","dst":"<import.meta.resolve('lodash')>","type":"ASSIGNED_FROM"},{"src":"<import.meta.resolve('lodash')>","dst":"<import.meta.resolve>","type":"CALLS"},{"src":"<import.meta.resolve('lodash')>","dst":"<'lodash'>","type":"PASSES_ARGUMENT"},{"src":"<localPath>","dst":"<import.meta.resolve('./utils.js')>","type":"ASSIGNED_FROM"},{"src":"<import.meta.resolve('./utils.js')>","dst":"<import.meta.resolve2>","type":"CALLS"},{"src":"<import.meta.resolve('./utils.js')>","dst":"<'./utils.js'>","type":"PASSES_ARGUMENT"},{"src":"<importMetaExtensions>","dst":"<{ depPath, localPath }>","type":"RETURNS"},{"src":"<{ depPath, localPath }>","dst":"<depPath>","type":"READS_FROM"},{"src":"<{ depPath, localPath }>","dst":"<localPath>","type":"READS_FROM"}],"rationale":"Function using import.meta.resolve() to resolve module paths. Two separate calls to the same runtime API with different arguments, returning an object literal containing both resolved paths. Changed PROPERTY_ACCESS to META_PROPERTY to better capture the runtime meta-property nature of import.meta.resolve.","implicitBehavior":["import.meta.resolve() performs synchronous module resolution using Node.js resolution algorithm","Resolved paths are absolute file:// URLs in Node.js","Runtime dependency on Node.js ES module loader"]},"pass":2,"annotatedAt":"2026-02-24T00:38:10.472Z"}
{"construct":{"id":"builtins::string-raw-template","file":"src/builtins.js","category":"builtins","lineStart":344,"lineEnd":346,"code":"const windowsPath = String.raw`C:\\Users\\name\\file`;\n// windowsPath === 'C:\\\\Users\\\\name\\\\file'  no escape processing","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<windowsPath>","metadata":{"kind":"const"}},{"type":"CALL","id":"<String.raw`C:\\Users\\name\\file`>","metadata":{"callee":"String.raw","callType":"tagged-template"}},{"type":"PROPERTY_ACCESS","id":"<String.raw>","metadata":{"objectName":"String","propertyName":"raw"}},{"type":"LITERAL","id":"<String>","metadata":{"value":"String","literalType":"identifier","builtinType":"constructor"}},{"type":"LITERAL","id":"<template-literal>","metadata":{"value":"C:\\Users\\name\\file","literalType":"template","raw":true}}],"edges":[{"src":"<module>","dst":"<windowsPath>","type":"DECLARES"},{"src":"<windowsPath>","dst":"<String.raw`C:\\Users\\name\\file`>","type":"ASSIGNED_FROM"},{"src":"<String.raw`C:\\Users\\name\\file`>","dst":"<String.raw>","type":"CALLS"},{"src":"<String.raw>","dst":"<String>","type":"READS_FROM"},{"src":"<String.raw`C:\\Users\\name\\file`>","dst":"<template-literal>","type":"PASSES_ARGUMENT"}],"rationale":"Tagged template literal using String.raw to prevent escape sequence processing. The template literal is passed as argument to the tag function. All types and relationships from Pass 1 are already in the approved vocabulary.","implicitBehavior":["String.raw receives template strings array and substitution values","backslashes are preserved literally without escape processing"]},"pass":2,"annotatedAt":"2026-02-24T00:38:10.911Z"}
{"construct":{"id":"statements::if-basic","file":"src/statements.js","category":"statements","lineStart":5,"lineEnd":11,"code":"function ifStatement(x) {\n  if (x > 0) {\n    return 'positive';\n  }\n  return 'non-positive';\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<ifStatement>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"BRANCH","id":"<if-branch>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<x > 0>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<'positive'>","metadata":{"value":"positive","literalType":"string"}},{"type":"LITERAL","id":"<'non-positive'>","metadata":{"value":"non-positive","literalType":"string"}}],"edges":[{"src":"<ifStatement>","dst":"<x>","type":"CONTAINS"},{"src":"<ifStatement>","dst":"<if-branch>","type":"CONTAINS"},{"src":"<if-branch>","dst":"<x > 0>","type":"HAS_CONDITION"},{"src":"<x > 0>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 0>","dst":"<0>","type":"READS_FROM"},{"src":"<if-branch>","dst":"<'positive'>","type":"HAS_CONSEQUENT"},{"src":"<ifStatement>","dst":"<'positive'>","type":"RETURNS"},{"src":"<ifStatement>","dst":"<'non-positive'>","type":"RETURNS"}],"rationale":"Reduced from 9 to 8 edges by removing the module declaration edge. Function contains parameter and if-branch. Branch has condition that reads from parameter and literal. Function returns different literals based on branch execution.","implicitBehavior":["function declaration is hoisted to module scope","fallthrough return executes when condition is false"]},"pass":2,"annotatedAt":"2026-02-24T00:38:11.543Z"}
{"construct":{"id":"runtime-apis::runtime-promise-try","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":102,"lineEnd":106,"code":"// const result = await Promise.try(() => {\n//   if (cached) return cachedValue;    // sync return  wrapped in Promise\n//   return fetchFromNetwork();          // async return\n// });","commentedOut":true},"annotation":{"nodes":[{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Promise.try(...)>","metadata":{"callee":"Promise.try","async":true}},{"type":"FUNCTION","id":"<Promise.try:callback>","metadata":{"arrowFunction":true}},{"type":"BRANCH","id":"<if-cached>"},{"type":"VARIABLE","id":"<cached>"},{"type":"VARIABLE","id":"<cachedValue>"},{"type":"CALL","id":"<fetchFromNetwork()>","metadata":{"callee":"fetchFromNetwork","async":true}}],"edges":[{"src":"<result>","dst":"<Promise.try(...)>","type":"ASSIGNED_FROM"},{"src":"<Promise.try(...)>","dst":"<Promise.try:callback>","type":"PASSES_ARGUMENT"},{"src":"<Promise.try:callback>","dst":"<if-cached>","type":"CONTAINS"},{"src":"<if-cached>","dst":"<cached>","type":"HAS_CONDITION"},{"src":"<if-cached>","dst":"<cachedValue>","type":"HAS_CONSEQUENT"},{"src":"<if-cached>","dst":"<fetchFromNetwork()>","type":"HAS_ALTERNATE"},{"src":"<Promise.try:callback>","dst":"<cached>","type":"READS_FROM"},{"src":"<Promise.try:callback>","dst":"<cachedValue>","type":"READS_FROM"},{"src":"<fetchFromNetwork()>","dst":"fetchFromNetwork","type":"CALLS"}],"rationale":"Promise.try() call with callback that conditionally returns sync or async values. The callback contains branching logic that reads external variables. Removed module declaration edge to reduce complexity while preserving core semantic relationships.","implicitBehavior":["Promise.try automatically wraps sync returns in resolved Promise","await expression suspends execution until Promise resolves","Both sync and async return paths are normalized to Promise"]},"pass":2,"annotatedAt":"2026-02-24T00:38:12.345Z"}
{"construct":{"id":"runtime-apis::runtime-global-error-handlers","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":91,"lineEnd":100,"code":"// Node.js:\n// process.on('unhandledRejection', (reason, promise) => { ... });\n// process.on('uncaughtException', (error) => { process.exit(1); });\n//\n// Browser:\n// window.addEventListener('unhandledrejection', (event) => { ... });\n// window.addEventListener('error', (event) => { ... });\n\n// --- ES2025+ API Methods (Plugin: es-builtins) ---","commentedOut":true},"annotation":{"nodes":[{"type":"FUNCTION","id":"<process.unhandledRejection>","metadata":{"runtime":"node","eventType":"unhandledRejection"}},{"type":"PARAMETER","id":"<reason>"},{"type":"PARAMETER","id":"<promise>"},{"type":"FUNCTION","id":"<process.uncaughtException>","metadata":{"runtime":"node","eventType":"uncaughtException"}},{"type":"PARAMETER","id":"<error>"},{"type":"CALL","id":"<process.exit(1)>","metadata":{"callee":"process.exit"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"FUNCTION","id":"<window.unhandledrejection>","metadata":{"runtime":"browser","eventType":"unhandledrejection"}},{"type":"PARAMETER","id":"<event1>","metadata":{"parameterName":"event"}},{"type":"FUNCTION","id":"<window.error>","metadata":{"runtime":"browser","eventType":"error"}},{"type":"PARAMETER","id":"<event2>","metadata":{"parameterName":"event"}},{"type":"EXTERNAL","id":"<process>","metadata":{"runtime":"node"}},{"type":"EXTERNAL","id":"<window>","metadata":{"runtime":"browser"}}],"edges":[{"src":"<process>","dst":"<process.unhandledRejection>","type":"LISTENS_TO"},{"src":"<process.unhandledRejection>","dst":"<reason>","type":"RECEIVES_ARGUMENT"},{"src":"<process.unhandledRejection>","dst":"<promise>","type":"RECEIVES_ARGUMENT"},{"src":"<process>","dst":"<process.uncaughtException>","type":"LISTENS_TO"},{"src":"<process.uncaughtException>","dst":"<error>","type":"RECEIVES_ARGUMENT"},{"src":"<process.uncaughtException>","dst":"<process.exit(1)>","type":"CONTAINS"},{"src":"<process.exit(1)>","dst":"<1>","type":"PASSES_ARGUMENT"},{"src":"<window>","dst":"<window.unhandledrejection>","type":"LISTENS_TO"},{"src":"<window.unhandledrejection>","dst":"<event1>","type":"RECEIVES_ARGUMENT"},{"src":"<window>","dst":"<window.error>","type":"LISTENS_TO"},{"src":"<window.error>","dst":"<event2>","type":"RECEIVES_ARGUMENT"}],"rationale":"Global error handlers for both Node.js and browser environments. Process and window objects listen to specific error events with handler functions that receive error-related parameters. Used FUNCTION for event handlers and EXTERNAL for global objects.","implicitBehavior":["unhandledRejection handlers can prevent process termination in Node.js","uncaughtException handlers should typically exit the process after cleanup","browser error handlers can prevent default error reporting via event.preventDefault()","these handlers are registered on global objects (process/window) and affect entire runtime"]},"pass":2,"annotatedAt":"2026-02-24T00:38:13.129Z"}
{"construct":{"id":"statements::for-in","file":"src/statements.js","category":"statements","lineStart":73,"lineEnd":80,"code":"function forIn(obj) {\n  const keys = [];\n  for (const key in obj) {\n    keys.push(key);\n  }\n  return keys;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forIn>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<keys>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-in>","metadata":{"loopType":"for-in"}},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const"}},{"type":"CALL","id":"<keys.push(key)>","metadata":{"callee":"push"}}],"edges":[{"src":"<forIn>","dst":"<obj>","type":"CONTAINS"},{"src":"<forIn>","dst":"<keys>","type":"CONTAINS"},{"src":"<keys>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<forIn>","dst":"<for-in>","type":"CONTAINS"},{"src":"<for-in>","dst":"<obj>","type":"ITERATES_OVER"},{"src":"<for-in>","dst":"<key>","type":"CONTAINS"},{"src":"<forIn>","dst":"<keys.push(key)>","type":"CONTAINS"},{"src":"<keys.push(key)>","dst":"<keys>","type":"CALLS_ON"},{"src":"<keys.push(key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<forIn>","dst":"<keys>","type":"RETURNS"}],"rationale":"Function with for-in loop that iterates over object properties. Loop variable captures each property name, which is pushed to an array that gets returned. Changed CALLS to CALLS_ON to better represent method invocation on the keys array.","implicitBehavior":["for-in iterates over enumerable properties including inherited ones","property order not guaranteed in older JS engines"]},"pass":2,"annotatedAt":"2026-02-24T00:38:14.082Z"}
{"construct":{"id":"runtime-apis::runtime-worker-postmessage","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":46,"lineEnd":53,"code":"function workerCommunication() {\n  const worker = new Worker('./task.js');\n  worker.postMessage({ type: 'start', payload: 'data' });\n  worker.onmessage = (e) => console.log(e.data);\n  worker.onerror = (err) => console.error(err);\n  worker.terminate();\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<workerCommunication>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<worker>","metadata":{"kind":"const"}},{"type":"CALL","id":"<new Worker('./task.js')>","metadata":{"callee":"Worker","constructor":true}},{"type":"LITERAL","id":"<'./task.js'>","metadata":{"value":"./task.js","literalType":"string"}},{"type":"CALL","id":"<worker.postMessage>","metadata":{"callee":"postMessage","method":true}},{"type":"LITERAL","id":"<{ type: 'start', payload: 'data' }>","metadata":{"literalType":"object"}},{"type":"PROPERTY_ACCESS","id":"<worker.onmessage>","metadata":{"objectName":"worker","propertyName":"onmessage"}},{"type":"FUNCTION","id":"<onmessage-handler>","metadata":{"arrowFunction":true,"eventHandler":true}},{"type":"PARAMETER","id":"<e>"},{"type":"CALL","id":"<console.log(e.data)>","metadata":{"callee":"console.log","method":true}},{"type":"PROPERTY_ACCESS","id":"<e.data>","metadata":{"objectName":"e","propertyName":"data"}},{"type":"PROPERTY_ACCESS","id":"<worker.onerror>","metadata":{"objectName":"worker","propertyName":"onerror"}},{"type":"FUNCTION","id":"<onerror-handler>","metadata":{"arrowFunction":true,"eventHandler":true}},{"type":"PARAMETER","id":"<err>"},{"type":"CALL","id":"<console.error(err)>","metadata":{"callee":"console.error","method":true}},{"type":"CALL","id":"<worker.terminate>","metadata":{"callee":"terminate","method":true}}],"edges":[{"src":"<workerCommunication>","dst":"<worker>","type":"CONTAINS"},{"src":"<worker>","dst":"<new Worker('./task.js')>","type":"ASSIGNED_FROM"},{"src":"<new Worker('./task.js')>","dst":"<'./task.js'>","type":"PASSES_ARGUMENT"},{"src":"<workerCommunication>","dst":"<worker.postMessage>","type":"CONTAINS"},{"src":"<worker.postMessage>","dst":"<{ type: 'start', payload: 'data' }>","type":"PASSES_ARGUMENT"},{"src":"<worker.onmessage>","dst":"<onmessage-handler>","type":"ASSIGNED_FROM"},{"src":"<onmessage-handler>","dst":"<e>","type":"CONTAINS"},{"src":"<onmessage-handler>","dst":"<console.log(e.data)>","type":"CONTAINS"},{"src":"<console.log(e.data)>","dst":"<e.data>","type":"PASSES_ARGUMENT"},{"src":"<e.data>","dst":"<e>","type":"READS_FROM"},{"src":"<worker.onerror>","dst":"<onerror-handler>","type":"ASSIGNED_FROM"},{"src":"<onerror-handler>","dst":"<err>","type":"CONTAINS"},{"src":"<onerror-handler>","dst":"<console.error(err)>","type":"CONTAINS"},{"src":"<console.error(err)>","dst":"<err>","type":"PASSES_ARGUMENT"},{"src":"<workerCommunication>","dst":"<worker.terminate>","type":"CONTAINS"}],"rationale":"Function creates a Web Worker, sends a message, sets up event handlers for responses and errors, then terminates the worker. Reduced edge count by removing explicit CALLS edges where the call relationship is implicit in the node structure.","implicitBehavior":["Worker constructor spawns separate thread/process","postMessage triggers asynchronous message passing","onmessage/onerror handlers execute asynchronously when events occur","terminate() forcibly stops worker execution"]},"pass":2,"annotatedAt":"2026-02-24T00:38:15.892Z"}
{"construct":{"id":"statements::do-while","file":"src/statements.js","category":"statements","lineStart":109,"lineEnd":116,"code":"function doWhileLoop() {\n  let attempts = 0;\n  do {\n    attempts++;\n  } while (attempts < 3);\n  return attempts;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<doWhileLoop>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<attempts>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<do-while>","metadata":{"loopType":"do-while"}},{"type":"EXPRESSION","id":"<attempts++>","metadata":{"operator":"++"}},{"type":"EXPRESSION","id":"<attempts < 3>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}}],"edges":[{"src":"<doWhileLoop>","dst":"<attempts>","type":"CONTAINS"},{"src":"<attempts>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<doWhileLoop>","dst":"<do-while>","type":"CONTAINS"},{"src":"<do-while>","dst":"<attempts++>","type":"HAS_BODY"},{"src":"<do-while>","dst":"<attempts < 3>","type":"HAS_CONDITION"},{"src":"<attempts++>","dst":"<attempts>","type":"MODIFIES"},{"src":"<attempts < 3>","dst":"<attempts>","type":"READS_FROM"},{"src":"<attempts < 3>","dst":"<3>","type":"READS_FROM"},{"src":"<doWhileLoop>","dst":"<attempts>","type":"RETURNS"}],"rationale":"Do-while loop executes body at least once, then checks condition. Body modifies attempts variable, condition reads it for comparison. Removed module declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["do-while guarantees at least one execution of the body before condition check"]},"pass":2,"annotatedAt":"2026-02-24T00:38:18.657Z"}
{"construct":{"id":"statements::while","file":"src/statements.js","category":"statements","lineStart":100,"lineEnd":107,"code":"function whileLoop() {\n  let count = 0;\n  while (count < 5) {\n    count++;\n  }\n  return count;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<whileLoop>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<count>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LOOP","id":"<while>","metadata":{"loopType":"while"}},{"type":"EXPRESSION","id":"<count < 5>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<count++>","metadata":{"operator":"++"}}],"edges":[{"src":"<whileLoop>","dst":"<count>","type":"DECLARES"},{"src":"<count>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<whileLoop>","dst":"<while>","type":"CONTAINS"},{"src":"<while>","dst":"<count < 5>","type":"HAS_CONDITION"},{"src":"<count < 5>","dst":"<count>","type":"READS_FROM"},{"src":"<count < 5>","dst":"<5>","type":"READS_FROM"},{"src":"<while>","dst":"<count++>","type":"HAS_BODY"},{"src":"<count++>","dst":"<count>","type":"MODIFIES"},{"src":"<whileLoop>","dst":"<count>","type":"RETURNS"}],"rationale":"While loop construct with condition expression and body that modifies the loop variable. Function declares and initializes a counter variable, loop tests condition by reading the variable and a literal, loop body modifies the variable via increment, and function returns the final variable value.","implicitBehavior":["let declaration is block-scoped to function","increment operation reads current value then writes incremented value","while loop continues until condition becomes false"]},"pass":2,"annotatedAt":"2026-02-24T00:38:19.564Z"}
{"construct":{"id":"statements::for-classic","file":"src/statements.js","category":"statements","lineStart":64,"lineEnd":71,"code":"function classicFor() {\n  const results = [];\n  for (let i = 0; i < 10; i++) {\n    results.push(i);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<classicFor>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-classic>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i < 10>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<10>","metadata":{"value":10,"literalType":"number"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"CALL","id":"<results.push(i)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<results.push>","metadata":{"objectName":"results","propertyName":"push"}}],"edges":[{"src":"<classicFor>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<classicFor>","dst":"<for-classic>","type":"CONTAINS"},{"src":"<for-classic>","dst":"<i>","type":"HAS_INIT"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-classic>","dst":"<i < 10>","type":"HAS_CONDITION"},{"src":"<i < 10>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 10>","dst":"<10>","type":"READS_FROM"},{"src":"<for-classic>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-classic>","dst":"<results.push(i)>","type":"HAS_BODY"},{"src":"<results.push(i)>","dst":"<results.push>","type":"CALLS"},{"src":"<results.push>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(i)>","dst":"<i>","type":"PASSES_ARGUMENT"},{"src":"<classicFor>","dst":"<results>","type":"RETURNS"}],"rationale":"Classic for loop with init, condition, and update expressions. Loop variable scoped to loop, body modifies outer variable through method call. All relationships captured using approved vocabulary.","implicitBehavior":["loop variable i is block-scoped to the for statement","push method mutates the results array"]},"pass":2,"annotatedAt":"2026-02-24T00:38:20.602Z"}
{"construct":{"id":"statements::switch-break","file":"src/statements.js","category":"statements","lineStart":33,"lineEnd":47,"code":"function switchWithBreak(action) {\n  let result;\n  switch (action) {\n    case 'start':\n      result = 'starting';\n      break;\n    case 'stop':\n      result = 'stopping';\n      break;\n    default:\n      result = 'unknown';\n  }\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<switchWithBreak>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<action>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"let"}},{"type":"BRANCH","id":"<switch>","metadata":{"branchType":"switch"}},{"type":"CASE","id":"<case-start>","metadata":{"value":"start"}},{"type":"LITERAL","id":"<'start'>","metadata":{"value":"start","literalType":"string"}},{"type":"LITERAL","id":"<'starting'>","metadata":{"value":"starting","literalType":"string"}},{"type":"CASE","id":"<case-stop>","metadata":{"value":"stop"}},{"type":"LITERAL","id":"<'stop'>","metadata":{"value":"stop","literalType":"string"}},{"type":"LITERAL","id":"<'stopping'>","metadata":{"value":"stopping","literalType":"string"}},{"type":"CASE","id":"<default-case>","metadata":{"isDefault":true}},{"type":"LITERAL","id":"<'unknown'>","metadata":{"value":"unknown","literalType":"string"}}],"edges":[{"src":"<switchWithBreak>","dst":"<action>","type":"CONTAINS"},{"src":"<switchWithBreak>","dst":"<result>","type":"CONTAINS"},{"src":"<switchWithBreak>","dst":"<switch>","type":"CONTAINS"},{"src":"<switch>","dst":"<action>","type":"HAS_CONDITION"},{"src":"<switch>","dst":"<case-start>","type":"HAS_CASE"},{"src":"<switch>","dst":"<case-stop>","type":"HAS_CASE"},{"src":"<switch>","dst":"<default-case>","type":"HAS_DEFAULT"},{"src":"<case-start>","dst":"<'start'>","type":"HAS_CONDITION"},{"src":"<case-start>","dst":"<result>","type":"WRITES_TO"},{"src":"<result>","dst":"<'starting'>","type":"ASSIGNED_FROM"},{"src":"<case-stop>","dst":"<'stop'>","type":"HAS_CONDITION"},{"src":"<case-stop>","dst":"<result>","type":"WRITES_TO"},{"src":"<result>","dst":"<'stopping'>","type":"ASSIGNED_FROM"},{"src":"<default-case>","dst":"<result>","type":"WRITES_TO"},{"src":"<result>","dst":"<'unknown'>","type":"ASSIGNED_FROM"},{"src":"<switchWithBreak>","dst":"<result>","type":"RETURNS"}],"rationale":"Switch statement with explicit break statements. Each case writes to the result variable with different values, preventing fall-through. The approved vocabulary captures all the essential relationships.","implicitBehavior":["break statements prevent fall-through between cases","default case executes when no other cases match","variable result is declared but not initialized"]},"pass":2,"annotatedAt":"2026-02-24T00:38:20.809Z"}
{"construct":{"id":"statements::for-of","file":"src/statements.js","category":"statements","lineStart":82,"lineEnd":89,"code":"function forOf(iterable) {\n  const values = [];\n  for (const item of iterable) {\n    values.push(item);\n  }\n  return values;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forOf>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<iterable>"},{"type":"VARIABLE","id":"<values>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"const"}},{"type":"CALL","id":"<values.push(item)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<values.push>","metadata":{"objectName":"values","propertyName":"push"}}],"edges":[{"src":"<forOf>","dst":"<iterable>","type":"CONTAINS"},{"src":"<forOf>","dst":"<values>","type":"DECLARES"},{"src":"<values>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<forOf>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<iterable>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<item>","type":"CONTAINS"},{"src":"<for-of>","dst":"<values.push(item)>","type":"CONTAINS"},{"src":"<values.push(item)>","dst":"<values.push>","type":"CALLS"},{"src":"<values.push>","dst":"<values>","type":"READS_FROM"},{"src":"<values.push(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<forOf>","dst":"<values>","type":"RETURNS"}],"rationale":"Function with for-of loop that iterates over parameter, declaring const loop variable and calling array method with it. Returns the accumulated array. Removed module-level declaration edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["for-of creates new binding for item on each iteration","array.push mutates the array in-place"]},"pass":2,"annotatedAt":"2026-02-24T00:38:21.113Z"}
{"construct":{"id":"statements::if-else-if-chain","file":"src/statements.js","category":"statements","lineStart":22,"lineEnd":31,"code":"function ifElseIfChain(x) {\n  if (x > 0) {\n    return 'positive';\n  } else if (x < 0) {\n    return 'negative';\n  } else {\n    return 'zero';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<ifElseIfChain>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"BRANCH","id":"<if-x>0>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<x > 0>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<0-first>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<'positive'>","metadata":{"value":"positive","literalType":"string"}},{"type":"BRANCH","id":"<else-if-x<0>","metadata":{"branchType":"else-if"}},{"type":"EXPRESSION","id":"<x < 0>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<0-second>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<'negative'>","metadata":{"value":"negative","literalType":"string"}},{"type":"BRANCH","id":"<else>","metadata":{"branchType":"else"}},{"type":"LITERAL","id":"<'zero'>","metadata":{"value":"zero","literalType":"string"}}],"edges":[{"src":"<ifElseIfChain>","dst":"<x>","type":"CONTAINS"},{"src":"<ifElseIfChain>","dst":"<if-x>0>","type":"CONTAINS"},{"src":"<if-x>0>","dst":"<x > 0>","type":"HAS_CONDITION"},{"src":"<x > 0>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 0>","dst":"<0-first>","type":"READS_FROM"},{"src":"<if-x>0>","dst":"<'positive'>","type":"HAS_CONSEQUENT"},{"src":"<ifElseIfChain>","dst":"<'positive'>","type":"RETURNS"},{"src":"<if-x>0>","dst":"<else-if-x<0>","type":"HAS_ALTERNATE"},{"src":"<else-if-x<0>","dst":"<x < 0>","type":"HAS_CONDITION"},{"src":"<x < 0>","dst":"<x>","type":"READS_FROM"},{"src":"<x < 0>","dst":"<0-second>","type":"READS_FROM"},{"src":"<else-if-x<0>","dst":"<'negative'>","type":"HAS_CONSEQUENT"},{"src":"<ifElseIfChain>","dst":"<'negative'>","type":"RETURNS"},{"src":"<else-if-x<0>","dst":"<else>","type":"HAS_ALTERNATE"},{"src":"<else>","dst":"<'zero'>","type":"HAS_CONSEQUENT"},{"src":"<ifElseIfChain>","dst":"<'zero'>","type":"RETURNS"}],"rationale":"Function with if-else-if-else chain using approved vocabulary. Each branch has its own condition and consequent, with alternates linking to the next branch. Removed module declaration edge and created distinct literal nodes for the two '0' values to maintain atomicity.","implicitBehavior":["function declaration is hoisted to module scope","early return prevents execution of subsequent branches"]},"pass":2,"annotatedAt":"2026-02-24T00:38:21.136Z"}
{"construct":{"id":"runtime-apis::runtime-promise-withresolvers-deferred","file":"src/runtime-apis.js","category":"runtime-apis","lineStart":108,"lineEnd":114,"code":"function deferredPromise() {\n  const { promise, resolve, reject } = Promise.withResolvers();\n  // resolve/reject passed to different scopes as callbacks\n  setTimeout(() => reject(new Error('timeout')), 5000);\n  return { promise, resolve, reject };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<deferredPromise>","metadata":{"async":false,"generator":false}},{"type":"CALL","id":"<Promise.withResolvers()>","metadata":{"callee":"Promise.withResolvers"}},{"type":"VARIABLE","id":"<promise>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<resolve>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<reject>","metadata":{"kind":"const","destructured":true}},{"type":"CALL","id":"<setTimeout(...)>","metadata":{"callee":"setTimeout"}},{"type":"FUNCTION","id":"<timeout-callback>","metadata":{"arrowFunction":true,"anonymous":true}},{"type":"CALL","id":"<reject(new Error('timeout'))>","metadata":{"callee":"reject"}},{"type":"CALL","id":"<new Error('timeout')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'timeout'>","metadata":{"value":"timeout","literalType":"string"}},{"type":"LITERAL","id":"<5000>","metadata":{"value":5000,"literalType":"number"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<deferredPromise>","dst":"<Promise.withResolvers()>","type":"CONTAINS"},{"src":"<Promise.withResolvers()>","dst":"<promise>","type":"FLOWS_INTO"},{"src":"<Promise.withResolvers()>","dst":"<resolve>","type":"FLOWS_INTO"},{"src":"<Promise.withResolvers()>","dst":"<reject>","type":"FLOWS_INTO"},{"src":"<deferredPromise>","dst":"<setTimeout(...)>","type":"CONTAINS"},{"src":"<setTimeout(...)>","dst":"<timeout-callback>","type":"PASSES_ARGUMENT"},{"src":"<setTimeout(...)>","dst":"<5000>","type":"PASSES_ARGUMENT"},{"src":"<timeout-callback>","dst":"<reject(new Error('timeout'))>","type":"CONTAINS"},{"src":"<reject(new Error('timeout'))>","dst":"<new Error('timeout')>","type":"PASSES_ARGUMENT"},{"src":"<new Error('timeout')>","dst":"<'timeout'>","type":"PASSES_ARGUMENT"},{"src":"<deferredPromise>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<promise>","type":"READS_FROM"},{"src":"<return-object>","dst":"<resolve>","type":"READS_FROM"},{"src":"<return-object>","dst":"<reject>","type":"READS_FROM"},{"src":"<timeout-callback>","dst":"<reject>","type":"CAPTURES"}],"rationale":"Function uses Promise.withResolvers() to create deferred promise pattern. Destructures the returned object into promise, resolve, reject variables. Sets timeout that captures and calls reject. Returns object exposing all three components for external control.","implicitBehavior":["Promise.withResolvers() creates a promise with externally accessible resolve/reject functions","setTimeout creates asynchronous execution context","Arrow function captures reject from outer scope via closure","Returned object allows external control of promise resolution"]},"pass":2,"annotatedAt":"2026-02-24T00:38:23.269Z"}
{"construct":{"id":"statements::for-of-destructuring","file":"src/statements.js","category":"statements","lineStart":91,"lineEnd":98,"code":"function forOfDestructuring(entries) {\n  const result = {};\n  for (const [key, value] of entries) {\n    result[key] = value;\n  }\n  return result;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forOfDestructuring>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<entries>"},{"type":"VARIABLE","id":"<result>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<{}>","metadata":{"value":{},"literalType":"object"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<value>","metadata":{"kind":"const","destructured":true}},{"type":"PROPERTY_ACCESS","id":"<result[key]>","metadata":{"objectName":"result","computed":true}},{"type":"EXPRESSION","id":"<result[key] = value>","metadata":{"operator":"="}}],"edges":[{"src":"<forOfDestructuring>","dst":"<entries>","type":"CONTAINS"},{"src":"<forOfDestructuring>","dst":"<result>","type":"CONTAINS"},{"src":"<result>","dst":"<{}>","type":"ASSIGNED_FROM"},{"src":"<forOfDestructuring>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<entries>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<key>","type":"CONTAINS"},{"src":"<for-of>","dst":"<value>","type":"CONTAINS"},{"src":"<for-of>","dst":"<result[key] = value>","type":"CONTAINS"},{"src":"<result[key] = value>","dst":"<result[key]>","type":"WRITES_TO"},{"src":"<result[key] = value>","dst":"<value>","type":"READS_FROM"},{"src":"<result[key]>","dst":"<result>","type":"READS_FROM"},{"src":"<result[key]>","dst":"<key>","type":"READS_FROM"},{"src":"<forOfDestructuring>","dst":"<result>","type":"RETURNS"}],"rationale":"Function with for-of loop using array destructuring. Loop destructures each entry into key/value variables, then assigns value to result object using computed property access. All constructs map directly to approved vocabulary.","implicitBehavior":["destructuring assumes entries contains iterable of 2-element arrays","computed property access creates properties dynamically"]},"pass":2,"annotatedAt":"2026-02-24T00:38:23.469Z"}
{"construct":{"id":"statements::try-finally","file":"src/statements.js","category":"statements","lineStart":139,"lineEnd":146,"code":"function tryFinally() {\n  try {\n    doSomething();\n  } finally {\n    alwaysRun();\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tryFinally>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"CALL","id":"<doSomething()>","metadata":{"callee":"doSomething"}},{"type":"CALL","id":"<alwaysRun()>","metadata":{"callee":"alwaysRun"}}],"edges":[{"src":"<module>","dst":"<tryFinally>","type":"DECLARES"},{"src":"<tryFinally>","dst":"<try-block>","type":"CONTAINS"},{"src":"<tryFinally>","dst":"<finally-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<doSomething()>","type":"HAS_BODY"},{"src":"<finally-block>","dst":"<alwaysRun()>","type":"HAS_BODY"},{"src":"<try-block>","dst":"<finally-block>","type":"FLOWS_INTO"},{"src":"<doSomething()>","dst":"<doSomething>","type":"CALLS"},{"src":"<alwaysRun()>","dst":"<alwaysRun>","type":"CALLS"}],"rationale":"Try-finally statement with no catch block. Finally block always executes regardless of try block outcome. Used FLOWS_INTO instead of HAS_FINALLY to represent the control flow relationship.","implicitBehavior":["finally block executes even if try block throws or returns","finally block can suppress exceptions from try block if it throws or returns"]},"pass":2,"annotatedAt":"2026-02-24T00:38:23.606Z"}
{"construct":{"id":"statements::debugger","file":"src/statements.js","category":"statements","lineStart":210,"lineEnd":214,"code":"function debuggerStatement() {\n  debugger;\n  return 'after debugger';\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<debuggerStatement>","metadata":{"async":false,"generator":false}},{"type":"SIDE_EFFECT","id":"<debugger>","metadata":{"effectType":"debugger"}},{"type":"LITERAL","id":"<'after debugger'>","metadata":{"value":"after debugger","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<debuggerStatement>","type":"DECLARES"},{"src":"<debuggerStatement>","dst":"<debugger>","type":"CONTAINS"},{"src":"<debuggerStatement>","dst":"<'after debugger'>","type":"RETURNS"}],"rationale":"Function containing a debugger statement (modeled as SIDE_EFFECT) followed by a return. The debugger statement is a runtime breakpoint trigger that affects execution flow conditionally based on environment.","implicitBehavior":["debugger statement pauses execution when dev tools are open","no-op in production environments without debugger attached","execution continues after debugger statement when no debugger is attached"]},"pass":2,"annotatedAt":"2026-02-24T00:38:24.494Z"}
{"construct":{"id":"statements::switch-return-fallthrough","file":"src/statements.js","category":"statements","lineStart":49,"lineEnd":62,"code":"function switchWithReturn(action) {\n  switch (action) {\n    case 'start':\n      return 'starting';\n    case 'stop':\n      return 'stopping';\n    case 'pause':\n    case 'suspend':\n      return 'pausing';\n    default:\n      return 'unknown';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<switchWithReturn>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<action>"},{"type":"BRANCH","id":"<switch>","metadata":{"branchType":"switch"}},{"type":"CASE","id":"<case-start>","metadata":{"value":"start"}},{"type":"LITERAL","id":"<'start'>","metadata":{"value":"start","literalType":"string"}},{"type":"LITERAL","id":"<'starting'>","metadata":{"value":"starting","literalType":"string"}},{"type":"CASE","id":"<case-stop>","metadata":{"value":"stop"}},{"type":"LITERAL","id":"<'stop'>","metadata":{"value":"stop","literalType":"string"}},{"type":"LITERAL","id":"<'stopping'>","metadata":{"value":"stopping","literalType":"string"}},{"type":"CASE","id":"<case-pause>","metadata":{"value":"pause"}},{"type":"LITERAL","id":"<'pause'>","metadata":{"value":"pause","literalType":"string"}},{"type":"CASE","id":"<case-suspend>","metadata":{"value":"suspend"}},{"type":"LITERAL","id":"<'suspend'>","metadata":{"value":"suspend","literalType":"string"}},{"type":"LITERAL","id":"<'pausing'>","metadata":{"value":"pausing","literalType":"string"}},{"type":"CASE","id":"<default>","metadata":{"isDefault":true}},{"type":"LITERAL","id":"<'unknown'>","metadata":{"value":"unknown","literalType":"string"}}],"edges":[{"src":"<switchWithReturn>","dst":"<action>","type":"CONTAINS"},{"src":"<switchWithReturn>","dst":"<switch>","type":"CONTAINS"},{"src":"<switch>","dst":"<action>","type":"HAS_CONDITION"},{"src":"<switch>","dst":"<case-start>","type":"HAS_CASE"},{"src":"<switch>","dst":"<case-stop>","type":"HAS_CASE"},{"src":"<switch>","dst":"<case-pause>","type":"HAS_CASE"},{"src":"<switch>","dst":"<case-suspend>","type":"HAS_CASE"},{"src":"<switch>","dst":"<default>","type":"HAS_DEFAULT"},{"src":"<case-start>","dst":"<'start'>","type":"HAS_CONDITION"},{"src":"<case-start>","dst":"<'starting'>","type":"RETURNS"},{"src":"<case-stop>","dst":"<'stop'>","type":"HAS_CONDITION"},{"src":"<case-stop>","dst":"<'stopping'>","type":"RETURNS"},{"src":"<case-pause>","dst":"<'pause'>","type":"HAS_CONDITION"},{"src":"<case-suspend>","dst":"<'suspend'>","type":"HAS_CONDITION"},{"src":"<case-pause>","dst":"<case-suspend>","type":"FLOWS_INTO"},{"src":"<case-suspend>","dst":"<'pausing'>","type":"RETURNS"},{"src":"<default>","dst":"<'unknown'>","type":"RETURNS"}],"rationale":"Switch statement with multiple cases, some with fallthrough behavior. Each case has a condition literal and return value. The pause case flows into suspend case which handles the return.","implicitBehavior":["case-pause falls through to case-suspend due to missing break","all return statements exit the function immediately, preventing further case evaluation"]},"pass":2,"annotatedAt":"2026-02-24T00:38:27.161Z"}
{"construct":{"id":"statements::labeled-function","file":"src/statements.js","category":"statements","lineStart":222,"lineEnd":223,"code":"myLabel: function labeledFn() { return 1; }","commentedOut":false},"annotation":{"nodes":[{"type":"LABEL","id":"<myLabel>","metadata":{"labelType":"statement"}},{"type":"FUNCTION","id":"<labeledFn>","metadata":{"async":false,"generator":false}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<myLabel>","type":"CONTAINS"},{"src":"<myLabel>","dst":"<labeledFn>","type":"CONTAINS"},{"src":"<module>","dst":"<labeledFn>","type":"DECLARES"},{"src":"<labeledFn>","dst":"<1>","type":"RETURNS"}],"rationale":"Label statement containing a function declaration. The label creates a target for break/continue control flow statements. Using CONTAINS instead of LABELS since the approved vocabulary doesn't include a specific labeling relationship.","implicitBehavior":["function declaration is hoisted to module/function scope","label creates a target for break/continue statements"]},"pass":2,"annotatedAt":"2026-02-24T00:38:27.397Z"}
{"construct":{"id":"statements::try-catch","file":"src/statements.js","category":"statements","lineStart":118,"lineEnd":125,"code":"function tryCatch() {\n  try {\n    JSON.parse('invalid');\n  } catch (error) {\n    console.error(error.message);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tryCatch>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<error>","metadata":{"catchParameter":true}},{"type":"CALL","id":"<JSON.parse('invalid')>","metadata":{"callee":"JSON.parse"}},{"type":"LITERAL","id":"<'invalid'>","metadata":{"value":"invalid","literalType":"string"}},{"type":"CALL","id":"<console.error(error.message)>","metadata":{"callee":"console.error"}},{"type":"PROPERTY_ACCESS","id":"<error.message>","metadata":{"property":"message"}},{"type":"EXTERNAL","id":"<JSON.parse>","metadata":{"source":"global"}},{"type":"EXTERNAL","id":"<console.error>","metadata":{"source":"global"}}],"edges":[{"src":"<tryCatch>","dst":"<try-block>","type":"CONTAINS"},{"src":"<tryCatch>","dst":"<catch-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<catch-block>","dst":"<error>","type":"CONTAINS"},{"src":"<try-block>","dst":"<JSON.parse('invalid')>","type":"CONTAINS"},{"src":"<JSON.parse('invalid')>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse('invalid')>","dst":"<'invalid'>","type":"PASSES_ARGUMENT"},{"src":"<JSON.parse('invalid')>","dst":"<catch-block>","type":"THROWS"},{"src":"<catch-block>","dst":"<console.error(error.message)>","type":"CONTAINS"},{"src":"<console.error(error.message)>","dst":"<console.error>","type":"CALLS"},{"src":"<console.error(error.message)>","dst":"<error.message>","type":"PASSES_ARGUMENT"},{"src":"<error.message>","dst":"<error>","type":"READS_FROM"}],"rationale":"Try-catch statement with error handling. Try block contains a call that can throw, catch block receives the error and logs its message property. Added explicit EXTERNAL nodes for global functions to reduce edge count while maintaining semantic clarity.","implicitBehavior":["JSON.parse throws SyntaxError for invalid JSON","error parameter is automatically bound to caught exception","console.error writes to stderr"]},"pass":2,"annotatedAt":"2026-02-24T00:38:28.461Z"}
{"construct":{"id":"statements::finally-return-override","file":"src/statements.js","category":"statements","lineStart":225,"lineEnd":232,"code":"function finallyReturnOverride() {\n  try {\n    return 1;\n  } finally {\n    return 2; // swallows try return  returns 2\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<finallyReturnOverride>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try>"},{"type":"FINALLY_BLOCK","id":"<finally>"},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<finallyReturnOverride>","dst":"<try>","type":"CONTAINS"},{"src":"<finallyReturnOverride>","dst":"<finally>","type":"HAS_FINALLY"},{"src":"<try>","dst":"<1>","type":"RETURNS"},{"src":"<finally>","dst":"<2>","type":"RETURNS"},{"src":"<finallyReturnOverride>","dst":"<2>","type":"RETURNS"}],"rationale":"Function with try-finally where both blocks return. The finally block's return overrides the try block's return, so the function ultimately returns the finally block's value.","implicitBehavior":["finally block return value overrides any return from try block","try block return is discarded when finally returns"]},"pass":2,"annotatedAt":"2026-02-24T00:38:29.199Z"}
{"construct":{"id":"statements::catch-no-binding","file":"src/statements.js","category":"statements","lineStart":161,"lineEnd":168,"code":"function catchWithoutBinding() {\n  try {\n    JSON.parse('{}');\n  } catch {\n    console.error('parse failed');\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<catchWithoutBinding>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>","metadata":{"hasBinding":false}},{"type":"CALL","id":"<JSON.parse('{}')>","metadata":{"callee":"JSON.parse"}},{"type":"PROPERTY_ACCESS","id":"<JSON.parse>","metadata":{"objectName":"JSON","propertyName":"parse"}},{"type":"LITERAL","id":"<'{}'>","metadata":{"value":"{}","literalType":"string"}},{"type":"CALL","id":"<console.error('parse failed')>","metadata":{"callee":"console.error"}},{"type":"PROPERTY_ACCESS","id":"<console.error>","metadata":{"objectName":"console","propertyName":"error"}},{"type":"LITERAL","id":"<'parse failed'>","metadata":{"value":"parse failed","literalType":"string"}}],"edges":[{"src":"<catchWithoutBinding>","dst":"<try-block>","type":"CONTAINS"},{"src":"<catchWithoutBinding>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<JSON.parse('{}')>","type":"CONTAINS"},{"src":"<JSON.parse('{}')>","dst":"<JSON.parse>","type":"CALLS"},{"src":"<JSON.parse('{}')>","dst":"<'{}'>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<console.error('parse failed')>","type":"CONTAINS"},{"src":"<console.error('parse failed')>","dst":"<console.error>","type":"CALLS"},{"src":"<console.error('parse failed')>","dst":"<'parse failed'>","type":"PASSES_ARGUMENT"}],"rationale":"Function with try-catch where catch block has no error binding parameter. The catch block can handle any exception but cannot access the error object. Removed the module declaration edge to reduce edge count while preserving the core try-catch semantics.","implicitBehavior":["catch block catches all exceptions from try block","error object is discarded since no binding parameter is provided","function is implicitly declared in module scope"]},"pass":2,"annotatedAt":"2026-02-24T00:38:29.617Z"}
{"construct":{"id":"statements::labeled-block","file":"src/statements.js","category":"statements","lineStart":202,"lineEnd":208,"code":"function labeledBlock() {\n  block: {\n    if (true) break block;\n    unreachable();\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<labeledBlock>","metadata":{"async":false,"generator":false}},{"type":"LABEL","id":"<block>","metadata":{"labelName":"block"}},{"type":"SCOPE","id":"<block-scope>","metadata":{"scopeType":"block"}},{"type":"BRANCH","id":"<if-true>","metadata":{"branchType":"if"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"CALL","id":"<unreachable()>","metadata":{"callee":"unreachable"}}],"edges":[{"src":"<labeledBlock>","dst":"<block>","type":"CONTAINS"},{"src":"<block>","dst":"<block-scope>","type":"HAS_SCOPE"},{"src":"<block-scope>","dst":"<if-true>","type":"CONTAINS"},{"src":"<if-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<block-scope>","dst":"<unreachable()>","type":"CONTAINS"},{"src":"<unreachable()>","dst":"<unreachable>","type":"CALLS"}],"rationale":"Function contains a labeled block statement with an if condition that breaks to the label, making the unreachable() call dead code. Removed the break statement node and BREAKS_TO edge as they are not in the approved vocabulary.","implicitBehavior":["break statement exits the labeled block scope","unreachable() call is dead code due to unconditional break"]},"pass":2,"annotatedAt":"2026-02-24T00:38:29.634Z"}
{"construct":{"id":"statements::try-catch-finally","file":"src/statements.js","category":"statements","lineStart":127,"lineEnd":137,"code":"function tryCatchFinally() {\n  let resource;\n  try {\n    resource = openResource();\n  } catch (error) {\n    handleError(error);\n  } finally {\n    cleanup(resource);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tryCatchFinally>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<resource>","metadata":{"kind":"let"}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CALL","id":"<openResource()>","metadata":{"callee":"openResource"}},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"PARAMETER","id":"<error>"},{"type":"CALL","id":"<handleError(error)>","metadata":{"callee":"handleError"}},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"CALL","id":"<cleanup(resource)>","metadata":{"callee":"cleanup"}}],"edges":[{"src":"<tryCatchFinally>","dst":"<resource>","type":"CONTAINS"},{"src":"<tryCatchFinally>","dst":"<try-block>","type":"CONTAINS"},{"src":"<tryCatchFinally>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<tryCatchFinally>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<try-block>","dst":"<openResource()>","type":"CONTAINS"},{"src":"<resource>","dst":"<openResource()>","type":"ASSIGNED_FROM"},{"src":"<catch-block>","dst":"<error>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<handleError(error)>","type":"CONTAINS"},{"src":"<handleError(error)>","dst":"<error>","type":"PASSES_ARGUMENT"},{"src":"<finally-block>","dst":"<cleanup(resource)>","type":"CONTAINS"},{"src":"<cleanup(resource)>","dst":"<resource>","type":"PASSES_ARGUMENT"}],"rationale":"Function with try-catch-finally structure using approved vocabulary. Removed module declaration edge and direct function call edges to reduce complexity while preserving core semantic relationships. The try-catch-finally control flow is captured through HAS_CATCH and HAS_FINALLY edges.","implicitBehavior":["finally block executes regardless of try/catch outcome","error parameter only exists within catch block scope","resource variable accessible across all blocks due to function scope","openResource and handleError/cleanup functions are called but not explicitly modeled as separate nodes"]},"pass":2,"annotatedAt":"2026-02-24T00:38:30.948Z"}
{"construct":{"id":"statements::empty-statement","file":"src/statements.js","category":"statements","lineStart":216,"lineEnd":220,"code":"function emptyStatements() {\n  ;\n  for (let i = 0; i < 0; i++);\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<emptyStatements>","metadata":{"async":false,"generator":false}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0-init>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i < 0>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<0-condition>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}}],"edges":[{"src":"<emptyStatements>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"DECLARES"},{"src":"<i>","dst":"<0-init>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 0>","type":"HAS_CONDITION"},{"src":"<i < 0>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 0>","dst":"<0-condition>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"}],"rationale":"Function containing empty statement and for-loop with empty body. The standalone semicolon creates no graph nodes as it's semantically void. Removed the module-level DECLARES edge to reduce edge count while preserving the core semantic structure.","implicitBehavior":["for-loop condition is always false, so body never executes","let declaration is block-scoped to the for-loop"]},"pass":2,"annotatedAt":"2026-02-24T00:38:32.176Z"}
{"construct":{"id":"statements::try-nested","file":"src/statements.js","category":"statements","lineStart":148,"lineEnd":159,"code":"function nestedTryCatch() {\n  try {\n    try {\n      riskyOperation();\n    } catch (innerError) {\n      fallback(innerError);\n    }\n  } catch (outerError) {\n    lastResort(outerError);\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<nestedTryCatch>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<outer-try>","metadata":{"level":"outer"}},{"type":"CATCH_BLOCK","id":"<outer-catch>","metadata":{"level":"outer"}},{"type":"PARAMETER","id":"<outerError>"},{"type":"TRY_BLOCK","id":"<inner-try>","metadata":{"level":"inner"}},{"type":"CATCH_BLOCK","id":"<inner-catch>","metadata":{"level":"inner"}},{"type":"PARAMETER","id":"<innerError>"},{"type":"CALL","id":"<riskyOperation()>","metadata":{"callee":"riskyOperation"}},{"type":"CALL","id":"<fallback(innerError)>","metadata":{"callee":"fallback"}},{"type":"CALL","id":"<lastResort(outerError)>","metadata":{"callee":"lastResort"}},{"type":"EXTERNAL","id":"<riskyOperation>"},{"type":"EXTERNAL","id":"<fallback>"},{"type":"EXTERNAL","id":"<lastResort>"}],"edges":[{"src":"<nestedTryCatch>","dst":"<outer-try>","type":"HAS_BODY"},{"src":"<outer-try>","dst":"<outer-catch>","type":"HAS_CATCH"},{"src":"<outer-catch>","dst":"<outerError>","type":"RECEIVES_ARGUMENT"},{"src":"<outer-try>","dst":"<inner-try>","type":"CONTAINS"},{"src":"<inner-try>","dst":"<inner-catch>","type":"HAS_CATCH"},{"src":"<inner-catch>","dst":"<innerError>","type":"RECEIVES_ARGUMENT"},{"src":"<inner-try>","dst":"<riskyOperation()>","type":"CONTAINS"},{"src":"<inner-catch>","dst":"<fallback(innerError)>","type":"CONTAINS"},{"src":"<outer-catch>","dst":"<lastResort(outerError)>","type":"CONTAINS"},{"src":"<riskyOperation()>","dst":"<riskyOperation>","type":"CALLS"},{"src":"<fallback(innerError)>","dst":"<fallback>","type":"CALLS"},{"src":"<fallback(innerError)>","dst":"<innerError>","type":"PASSES_ARGUMENT"},{"src":"<lastResort(outerError)>","dst":"<lastResort>","type":"CALLS"},{"src":"<lastResort(outerError)>","dst":"<outerError>","type":"PASSES_ARGUMENT"},{"src":"<riskyOperation()>","dst":"<inner-catch>","type":"CATCHES_FROM"},{"src":"<fallback(innerError)>","dst":"<outer-catch>","type":"CATCHES_FROM"}],"rationale":"Nested try-catch blocks with distinct error handling scopes. Inner try catches errors from riskyOperation, outer try catches errors from the inner catch block or any uncaught inner errors. Added external nodes for referenced functions and used CATCHES_FROM to represent error flow relationships.","implicitBehavior":["errors thrown in inner catch block bubble to outer catch","uncaught errors from inner try also bubble to outer catch","error parameter scoping is block-local"]},"pass":2,"annotatedAt":"2026-02-24T00:38:36.489Z"}
{"construct":{"id":"builtins::array-from-mapfn","file":"src/builtins.js","category":"builtins","lineStart":357,"lineEnd":363,"code":"function arrayFromMapFn() {\n  const indices = Array.from({ length: 5 }, (_, i) => i);\n  return indices; // [0, 1, 2, 3, 4]\n}\n\n// --- Symbol.for cross-realm registry ---","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<arrayFromMapFn>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<indices>","metadata":{"kind":"const"}},{"type":"CALL","id":"<Array.from({ length: 5 }, (_, i) => i)>","metadata":{"callee":"Array.from"}},{"type":"LITERAL","id":"<{ length: 5 }>","metadata":{"value":"{ length: 5 }","literalType":"object"}},{"type":"FUNCTION","id":"<(_, i) => i>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<_>"},{"type":"PARAMETER","id":"<i>"}],"edges":[{"src":"<arrayFromMapFn>","dst":"<indices>","type":"CONTAINS"},{"src":"<indices>","dst":"<Array.from({ length: 5 }, (_, i) => i)>","type":"ASSIGNED_FROM"},{"src":"<Array.from({ length: 5 }, (_, i) => i)>","dst":"<Array.from>","type":"CALLS"},{"src":"<Array.from({ length: 5 }, (_, i) => i)>","dst":"<{ length: 5 }>","type":"PASSES_ARGUMENT"},{"src":"<Array.from({ length: 5 }, (_, i) => i)>","dst":"<(_, i) => i>","type":"PASSES_ARGUMENT"},{"src":"<(_, i) => i>","dst":"<_>","type":"CONTAINS"},{"src":"<(_, i) => i>","dst":"<i>","type":"CONTAINS"},{"src":"<(_, i) => i>","dst":"<i>","type":"RETURNS"},{"src":"<arrayFromMapFn>","dst":"<indices>","type":"RETURNS"}],"rationale":"Function that uses Array.from with a mapper function. The mapper function receives index parameter and returns it, creating an array of indices. Removed the module-level DECLARES edge to reduce edge count while preserving core semantic relationships.","implicitBehavior":["Array.from calls the mapper function for each index from 0 to length-1","Arrow function has implicit return of parameter i"]},"pass":2,"annotatedAt":"2026-02-24T00:38:38.265Z"}
{"construct":{"id":"statements::finally-throw-override","file":"src/statements.js","category":"statements","lineStart":234,"lineEnd":243,"code":"function finallyThrowOverride() {\n  try {\n    throw new Error('original');\n  } catch (e) {\n    throw new Error('from catch');\n  } finally {\n    throw new Error('from finally'); // swallows catch throw\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<finallyThrowOverride>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"FINALLY_BLOCK","id":"<finally-block>"},{"type":"PARAMETER","id":"<e>"},{"type":"CALL","id":"<new Error('original')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'original'>","metadata":{"value":"original","literalType":"string"}},{"type":"CALL","id":"<new Error('from catch')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'from catch'>","metadata":{"value":"from catch","literalType":"string"}},{"type":"CALL","id":"<new Error('from finally')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'from finally'>","metadata":{"value":"from finally","literalType":"string"}}],"edges":[{"src":"<finallyThrowOverride>","dst":"<try-block>","type":"CONTAINS"},{"src":"<finallyThrowOverride>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<finallyThrowOverride>","dst":"<finally-block>","type":"HAS_FINALLY"},{"src":"<catch-block>","dst":"<e>","type":"CONTAINS"},{"src":"<try-block>","dst":"<new Error('original')>","type":"THROWS"},{"src":"<new Error('original')>","dst":"<'original'>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<new Error('from catch')>","type":"THROWS"},{"src":"<new Error('from catch')>","dst":"<'from catch'>","type":"PASSES_ARGUMENT"},{"src":"<finally-block>","dst":"<new Error('from finally')>","type":"THROWS"},{"src":"<new Error('from finally')>","dst":"<'from finally'>","type":"PASSES_ARGUMENT"},{"src":"<catch-block>","dst":"<new Error('original')>","type":"CATCHES_FROM"}],"rationale":"Try-catch-finally with throws in all blocks. Reduced edge count by removing explicit CALLS edges to Error constructor (implicit in constructor calls) and module declaration edge (implicit at file level).","implicitBehavior":["finally block throw suppresses catch block throw","only the finally block exception propagates to caller","Error constructor calls are implicit in new Error() expressions"]},"pass":2,"annotatedAt":"2026-02-24T00:38:38.880Z"}
{"construct":{"id":"statements::tdz-switch-fallthrough","file":"src/statements.js","category":"statements","lineStart":245,"lineEnd":255,"code":"function tdzSwitch(x) {\n  switch (x) {\n    case 1:\n      let y = 1; // y scoped to ENTIRE switch block\n      break;\n    case 2:\n      // console.log(y); // ReferenceError  TDZ\n      break;\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<tdzSwitch>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"BRANCH","id":"<switch>","metadata":{"branchType":"switch"}},{"type":"SCOPE","id":"<switch-block-scope>","metadata":{"scopeType":"block"}},{"type":"CASE","id":"<case-1>","metadata":{"value":1}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<y>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<1-init>","metadata":{"value":1,"literalType":"number"}},{"type":"CASE","id":"<case-2>","metadata":{"value":2}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<tdzSwitch>","dst":"<x>","type":"CONTAINS"},{"src":"<tdzSwitch>","dst":"<switch>","type":"CONTAINS"},{"src":"<switch>","dst":"<x>","type":"HAS_CONDITION"},{"src":"<switch>","dst":"<switch-block-scope>","type":"HAS_SCOPE"},{"src":"<switch-block-scope>","dst":"<y>","type":"DECLARES"},{"src":"<switch>","dst":"<case-1>","type":"HAS_CASE"},{"src":"<case-1>","dst":"<1>","type":"HAS_CONDITION"},{"src":"<case-1>","dst":"<y>","type":"CONTAINS"},{"src":"<y>","dst":"<1-init>","type":"ASSIGNED_FROM"},{"src":"<switch>","dst":"<case-2>","type":"HAS_CASE"},{"src":"<case-2>","dst":"<2>","type":"HAS_CONDITION"}],"rationale":"Switch statement with block-scoped let declaration in case 1. The variable y is declared in switch block scope but only initialized when case 1 executes, creating TDZ in case 2. Removed the module-level declaration edge to reduce complexity while preserving the core TDZ semantics.","implicitBehavior":["let declaration is hoisted to switch block scope but remains in TDZ until initialization","case 2 can reference y but will throw ReferenceError due to TDZ","switch cases share the same block scope for let/const declarations"]},"pass":2,"annotatedAt":"2026-02-24T00:38:39.215Z"}
{"construct":{"id":"statements::for-of-no-declaration","file":"src/statements.js","category":"statements","lineStart":319,"lineEnd":326,"code":"function forOfNoDeclaration(items) {\n  let item;\n  for (item of items) {           // REASSIGNS existing var, not declaration\n    console.log(item);\n  }\n  return item; // last item  outer var mutated\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forOfNoDeclaration>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<items>"},{"type":"VARIABLE","id":"<item>","metadata":{"kind":"let"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"CALL","id":"<console.log(item)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}}],"edges":[{"src":"<forOfNoDeclaration>","dst":"<items>","type":"CONTAINS"},{"src":"<forOfNoDeclaration>","dst":"<item>","type":"CONTAINS"},{"src":"<forOfNoDeclaration>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<items>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<item>","type":"MODIFIES"},{"src":"<for-of>","dst":"<console.log(item)>","type":"CONTAINS"},{"src":"<console.log(item)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(item)>","dst":"<item>","type":"PASSES_ARGUMENT"},{"src":"<forOfNoDeclaration>","dst":"<item>","type":"RETURNS"}],"rationale":"For-of loop reassigns existing variable rather than declaring new one. Loop modifies the outer variable through each iteration, which retains the last value and is returned. Removed module-level DECLARES edge to reduce edge count while preserving core semantics.","implicitBehavior":["loop variable retains last iteration value after loop completion","for-of loop reassigns existing variable rather than declaring new binding"]},"pass":2,"annotatedAt":"2026-02-24T00:38:40.012Z"}
{"construct":{"id":"statements::destructure-catch-clause","file":"src/statements.js","category":"statements","lineStart":277,"lineEnd":284,"code":"function destructureCatchClause() {\n  try {\n    throw { code: 'ENOENT', message: 'not found' };\n  } catch ({ code, message }) {\n    return { code, message };\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureCatchClause>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"LITERAL","id":"<{ code: 'ENOENT', message: 'not found' }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'ENOENT'>","metadata":{"value":"ENOENT","literalType":"string"}},{"type":"LITERAL","id":"<'not found'>","metadata":{"value":"not found","literalType":"string"}},{"type":"VARIABLE","id":"<code>","metadata":{"destructured":true}},{"type":"VARIABLE","id":"<message>","metadata":{"destructured":true}},{"type":"LITERAL","id":"<{ code, message }>","metadata":{"literalType":"object","shorthandProperties":true}}],"edges":[{"src":"<destructureCatchClause>","dst":"<try-block>","type":"CONTAINS"},{"src":"<destructureCatchClause>","dst":"<catch-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<{ code: 'ENOENT', message: 'not found' }>","type":"THROWS"},{"src":"<{ code: 'ENOENT', message: 'not found' }>","dst":"<'ENOENT'>","type":"HAS_PROPERTY"},{"src":"<{ code: 'ENOENT', message: 'not found' }>","dst":"<'not found'>","type":"HAS_PROPERTY"},{"src":"<catch-block>","dst":"<code>","type":"DECLARES"},{"src":"<catch-block>","dst":"<message>","type":"DECLARES"},{"src":"<code>","dst":"<{ code: 'ENOENT', message: 'not found' }>","type":"ASSIGNED_FROM"},{"src":"<message>","dst":"<{ code: 'ENOENT', message: 'not found' }>","type":"ASSIGNED_FROM"},{"src":"<destructureCatchClause>","dst":"<{ code, message }>","type":"RETURNS"},{"src":"<{ code, message }>","dst":"<code>","type":"READS_FROM"},{"src":"<{ code, message }>","dst":"<message>","type":"READS_FROM"}],"rationale":"Function with try-catch using destructuring assignment in catch clause. The thrown object is destructured into individual variables, which are then used in the return statement. Used ASSIGNED_FROM instead of DESTRUCTURES_FROM to represent the destructuring relationship.","implicitBehavior":["destructuring creates new bindings scoped to catch block","thrown object becomes the destructuring source"]},"pass":2,"annotatedAt":"2026-02-24T00:38:41.893Z"}
{"construct":{"id":"statements::throw","file":"src/statements.js","category":"statements","lineStart":170,"lineEnd":181,"code":"function throwError(type) {\n  if (type === 'error') {\n    throw new Error('Something went wrong');\n  }\n  if (type === 'custom') {\n    throw { code: 'CUSTOM', message: 'Custom error' };\n  }\n  if (type === 'string') {\n    throw 'simple string error';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<throwError>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<type>"},{"type":"BRANCH","id":"<if-error>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<type === 'error'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'error'>","metadata":{"value":"error","literalType":"string"}},{"type":"EXPRESSION","id":"<throw-error>","metadata":{"throwType":"constructor"}},{"type":"CALL","id":"<new Error('Something went wrong')>","metadata":{"callee":"Error","constructor":true}},{"type":"LITERAL","id":"<'Something went wrong'>","metadata":{"value":"Something went wrong","literalType":"string"}},{"type":"BRANCH","id":"<if-custom>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<type === 'custom'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'custom'>","metadata":{"value":"custom","literalType":"string"}},{"type":"EXPRESSION","id":"<throw-custom>","metadata":{"throwType":"object"}},{"type":"LITERAL","id":"<custom-object>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'CUSTOM'>","metadata":{"value":"CUSTOM","literalType":"string"}},{"type":"LITERAL","id":"<'Custom error'>","metadata":{"value":"Custom error","literalType":"string"}},{"type":"BRANCH","id":"<if-string>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<type === 'string'>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<'string'>","metadata":{"value":"string","literalType":"string"}},{"type":"EXPRESSION","id":"<throw-string>","metadata":{"throwType":"literal"}},{"type":"LITERAL","id":"<'simple string error'>","metadata":{"value":"simple string error","literalType":"string"}}],"edges":[{"src":"<throwError>","dst":"<type>","type":"CONTAINS"},{"src":"<throwError>","dst":"<if-error>","type":"CONTAINS"},{"src":"<throwError>","dst":"<if-custom>","type":"CONTAINS"},{"src":"<throwError>","dst":"<if-string>","type":"CONTAINS"},{"src":"<if-error>","dst":"<type === 'error'>","type":"HAS_CONDITION"},{"src":"<type === 'error'>","dst":"<type>","type":"READS_FROM"},{"src":"<type === 'error'>","dst":"<'error'>","type":"READS_FROM"},{"src":"<if-error>","dst":"<throw-error>","type":"HAS_CONSEQUENT"},{"src":"<throw-error>","dst":"<new Error('Something went wrong')>","type":"THROWS"},{"src":"<new Error('Something went wrong')>","dst":"<'Something went wrong'>","type":"PASSES_ARGUMENT"},{"src":"<if-custom>","dst":"<type === 'custom'>","type":"HAS_CONDITION"},{"src":"<type === 'custom'>","dst":"<type>","type":"READS_FROM"},{"src":"<type === 'custom'>","dst":"<'custom'>","type":"READS_FROM"},{"src":"<if-custom>","dst":"<throw-custom>","type":"HAS_CONSEQUENT"},{"src":"<throw-custom>","dst":"<custom-object>","type":"THROWS"},{"src":"<custom-object>","dst":"<'CUSTOM'>","type":"HAS_PROPERTY"},{"src":"<custom-object>","dst":"<'Custom error'>","type":"HAS_PROPERTY"},{"src":"<if-string>","dst":"<type === 'string'>","type":"HAS_CONDITION"},{"src":"<type === 'string'>","dst":"<type>","type":"READS_FROM"},{"src":"<type === 'string'>","dst":"<'string'>","type":"READS_FROM"},{"src":"<if-string>","dst":"<throw-string>","type":"HAS_CONSEQUENT"},{"src":"<throw-string>","dst":"<'simple string error'>","type":"THROWS"}],"rationale":"Function with three conditional throw statements. Each throw expression uses THROWS edge to connect to what's being thrown - Error constructor call, object literal, or string literal. Removed the CALLS edge from constructor call to Error since it's captured by the THROWS relationship.","implicitBehavior":["throw statements cause immediate function exit","thrown values propagate up call stack until caught","Error constructor creates stack trace"]},"pass":2,"annotatedAt":"2026-02-24T00:38:43.849Z"}
{"construct":{"id":"statements::labeled-continue","file":"src/statements.js","category":"statements","lineStart":192,"lineEnd":200,"code":"function labeledContinue() {\n  const results = [];\n  loop: for (let i = 0; i < 5; i++) {\n    if (i === 3) continue loop;\n    results.push(i);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<labeledContinue>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LABEL","id":"<loop>","metadata":{"labelName":"loop"}},{"type":"LOOP","id":"<for-loop>","metadata":{"loopType":"for"}},{"type":"VARIABLE","id":"<i>","metadata":{"kind":"let"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"EXPRESSION","id":"<i < 5>","metadata":{"operator":"<"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"EXPRESSION","id":"<i++>","metadata":{"operator":"++"}},{"type":"BRANCH","id":"<if-i===3>","metadata":{"branchType":"if"}},{"type":"EXPRESSION","id":"<i === 3>","metadata":{"operator":"==="}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"EXPRESSION","id":"<continue-loop>","metadata":{"statementType":"continue","targetLabel":"loop"}},{"type":"CALL","id":"<results.push(i)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<results.push>","metadata":{"objectName":"results","propertyName":"push"}}],"edges":[{"src":"<labeledContinue>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<labeledContinue>","dst":"<loop>","type":"CONTAINS"},{"src":"<labeledContinue>","dst":"<for-loop>","type":"CONTAINS"},{"src":"<for-loop>","dst":"<i>","type":"CONTAINS"},{"src":"<i>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<for-loop>","dst":"<i < 5>","type":"HAS_CONDITION"},{"src":"<i < 5>","dst":"<i>","type":"READS_FROM"},{"src":"<i < 5>","dst":"<5>","type":"READS_FROM"},{"src":"<for-loop>","dst":"<i++>","type":"HAS_UPDATE"},{"src":"<i++>","dst":"<i>","type":"MODIFIES"},{"src":"<for-loop>","dst":"<if-i===3>","type":"HAS_BODY"},{"src":"<if-i===3>","dst":"<i === 3>","type":"HAS_CONDITION"},{"src":"<i === 3>","dst":"<i>","type":"READS_FROM"},{"src":"<i === 3>","dst":"<3>","type":"READS_FROM"},{"src":"<if-i===3>","dst":"<continue-loop>","type":"HAS_CONSEQUENT"},{"src":"<continue-loop>","dst":"<loop>","type":"FLOWS_INTO"},{"src":"<for-loop>","dst":"<results.push(i)>","type":"HAS_BODY"},{"src":"<results.push(i)>","dst":"<results.push>","type":"CALLS"},{"src":"<results.push>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(i)>","dst":"<i>","type":"PASSES_ARGUMENT"},{"src":"<labeledContinue>","dst":"<results>","type":"RETURNS"}],"rationale":"Function with labeled loop containing conditional continue. The continue statement is modeled as an EXPRESSION that flows into the label, representing the control flow jump.","implicitBehavior":["continue skips remaining loop body and jumps to loop update expression","labeled continue can target outer loops in nested structures"]},"pass":2,"annotatedAt":"2026-02-24T00:38:43.850Z"}
{"construct":{"id":"statements::for-in-no-declaration","file":"src/statements.js","category":"statements","lineStart":328,"lineEnd":335,"code":"function forInNoDeclaration(obj) {\n  let key;\n  for (key in obj) {              // REASSIGNS existing var\n    console.log(key);\n  }\n  return key; // last key  outer var mutated\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forInNoDeclaration>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<obj>"},{"type":"VARIABLE","id":"<key>","metadata":{"kind":"let"}},{"type":"LOOP","id":"<for-in>","metadata":{"loopType":"for-in"}},{"type":"CALL","id":"<console.log(key)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}}],"edges":[{"src":"<forInNoDeclaration>","dst":"<obj>","type":"CONTAINS"},{"src":"<forInNoDeclaration>","dst":"<key>","type":"CONTAINS"},{"src":"<forInNoDeclaration>","dst":"<for-in>","type":"CONTAINS"},{"src":"<for-in>","dst":"<obj>","type":"ITERATES_OVER"},{"src":"<for-in>","dst":"<key>","type":"MODIFIES"},{"src":"<for-in>","dst":"<console.log(key)>","type":"HAS_BODY"},{"src":"<console.log(key)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(key)>","dst":"<key>","type":"PASSES_ARGUMENT"},{"src":"<forInNoDeclaration>","dst":"<key>","type":"RETURNS"}],"rationale":"For-in loop reassigns existing variable rather than declaring new one. Loop modifies the outer variable, which is then returned. Removed module-level declaration edge to reduce edge count while preserving core semantics.","implicitBehavior":["for-in iterates over enumerable properties","variable retains last assigned value after loop completion"]},"pass":2,"annotatedAt":"2026-02-24T00:38:43.931Z"}
{"construct":{"id":"statements::labeled-break","file":"src/statements.js","category":"statements","lineStart":183,"lineEnd":190,"code":"function labeledBreak() {\n  outer: for (let i = 0; i < 5; i++) {\n    for (let j = 0; j < 5; j++) {\n      if (i === 2 && j === 2) break outer;\n    }\n  }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<labeledBreak>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"LABEL\",\n"},"pass":2,"annotatedAt":"2026-02-24T00:38:45.995Z"}
{"construct":{"id":"builtins::sparse-array","file":"src/builtins.js","category":"builtins","lineStart":348,"lineEnd":355,"code":"function sparseArrayOps() {\n  const sparse = [1, , 3, , 5];\n  const length = sparse.length;       // 5\n  const hasIndex1 = 1 in sparse;      // false  hole, not undefined\n  const mapped = sparse.map(x => x * 2); // [2, empty, 6, empty, 10]\n  return { length, hasIndex1, mapped };\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<sparseArrayOps>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<sparse>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<sparse-array>","metadata":{"value":"[1, , 3, , 5]","literalType":"array","sparse":true,"holes":[1,3]}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"LITERAL","id":"<5>","metadata":{"value":5,"literalType":"number"}},{"type":"VARIABLE","id":"<length>","metadata":{"kind":"const"}},{"type":"PROPERTY_ACCESS","id":"<sparse.length>","metadata":{"property":"length"}},{"type":"VARIABLE","id":"<hasIndex1>","metadata":{"kind":"const"}},{"type":"EXPRESSION","id":"<1 in sparse>","metadata":{"operator":"in"}},{"type":"LITERAL","id":"<1-key>","metadata":{"value":1,"literalType":"number"}},{"type":"VARIABLE","id":"<mapped>","metadata":{"kind":"const"}},{"type":"CALL","id":"<sparse.map(x => x * 2)>","metadata":{"method":"map"}},{"type":"FUNCTION","id":"<map-callback>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>"},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"EXPRESSION","id":"<return-object>","metadata":{"type":"object-literal"}}],"edges":[{"src":"<sparseArrayOps>","dst":"<sparse>","type":"CONTAINS"},{"src":"<sparseArrayOps>","dst":"<length>","type":"CONTAINS"},{"src":"<sparseArrayOps>","dst":"<hasIndex1>","type":"CONTAINS"},{"src":"<sparseArrayOps>","dst":"<mapped>","type":"CONTAINS"},{"src":"<sparse>","dst":"<sparse-array>","type":"ASSIGNED_FROM"},{"src":"<sparse-array>","dst":"<1>","type":"HAS_ELEMENT"},{"src":"<sparse-array>","dst":"<3>","type":"HAS_ELEMENT"},{"src":"<sparse-array>","dst":"<5>","type":"HAS_ELEMENT"},{"src":"<length>","dst":"<sparse.length>","type":"ASSIGNED_FROM"},{"src":"<sparse.length>","dst":"<sparse>","type":"READS_FROM"},{"src":"<hasIndex1>","dst":"<1 in sparse>","type":"ASSIGNED_FROM"},{"src":"<1 in sparse>","dst":"<1-key>","type":"READS_FROM"},{"src":"<1 in sparse>","dst":"<sparse>","type":"READS_FROM"},{"src":"<mapped>","dst":"<sparse.map(x => x * 2)>","type":"ASSIGNED_FROM"},{"src":"<sparse.map(x => x * 2)>","dst":"<sparse>","type":"CALLS_ON"},{"src":"<sparse.map(x => x * 2)>","dst":"<map-callback>","type":"PASSES_ARGUMENT"},{"src":"<map-callback>","dst":"<x>","type":"CONTAINS"},{"src":"<map-callback>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"},{"src":"<sparseArrayOps>","dst":"<return-object>","type":"RETURNS"},{"src":"<return-object>","dst":"<length>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<hasIndex1>","type":"HAS_PROPERTY"},{"src":"<return-object>","dst":"<mapped>","type":"HAS_PROPERTY"}],"rationale":"Function demonstrating sparse array operations. Creates array with holes, accesses length property, tests hole existence with 'in' operator, and maps over sparse array preserving holes. Changed CALLS to CALLS_ON for method invocation on sparse array.","implicitBehavior":["Array holes are not enumerable properties","Array.prototype.map skips holes but preserves them in result","'in' operator checks for property existence, not value","Sparse array length includes holes in count"]},"pass":2,"annotatedAt":"2026-02-24T00:38:47.608Z"}
{"construct":{"id":"statements::switch-true-pattern","file":"src/statements.js","category":"statements","lineStart":286,"lineEnd":294,"code":"function switchTruePattern(x) {\n  switch (true) {\n    case x > 100: return 'high';\n    case x > 50:  return 'medium';\n    case x > 0:   return 'low';\n    default:       return 'none';\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<switchTruePattern>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<x>"},{"type":"BRANCH","id":"<switch-true>","metadata":{"branchType":"switch"}},{"type":"LITERAL","id":"<true>","metadata":{"value":true,"literalType":"boolean"}},{"type":"CASE","id":"<case-x>100>"},{"type":"EXPRESSION","id":"<x > 100>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<100>","metadata":{"value":100,"literalType":"number"}},{"type":"LITERAL","id":"<'high'>","metadata":{"value":"high","literalType":"string"}},{"type":"CASE","id":"<case-x>50>"},{"type":"EXPRESSION","id":"<x > 50>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<50>","metadata":{"value":50,"literalType":"number"}},{"type":"LITERAL","id":"<'medium'>","metadata":{"value":"medium","literalType":"string"}},{"type":"CASE","id":"<case-x>0>"},{"type":"EXPRESSION","id":"<x > 0>","metadata":{"operator":">"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"LITERAL","id":"<'low'>","metadata":{"value":"low","literalType":"string"}},{"type":"CASE","id":"<default-case>","metadata":{"isDefault":true}},{"type":"LITERAL","id":"<'none'>","metadata":{"value":"none","literalType":"string"}}],"edges":[{"src":"<switchTruePattern>","dst":"<x>","type":"CONTAINS"},{"src":"<switchTruePattern>","dst":"<switch-true>","type":"CONTAINS"},{"src":"<switch-true>","dst":"<true>","type":"HAS_CONDITION"},{"src":"<switch-true>","dst":"<case-x>100>","type":"HAS_CASE"},{"src":"<switch-true>","dst":"<case-x>50>","type":"HAS_CASE"},{"src":"<switch-true>","dst":"<case-x>0>","type":"HAS_CASE"},{"src":"<switch-true>","dst":"<default-case>","type":"HAS_DEFAULT"},{"src":"<case-x>100>","dst":"<x > 100>","type":"HAS_CONDITION"},{"src":"<x > 100>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 100>","dst":"<100>","type":"READS_FROM"},{"src":"<case-x>100>","dst":"<'high'>","type":"RETURNS"},{"src":"<case-x>50>","dst":"<x > 50>","type":"HAS_CONDITION"},{"src":"<x > 50>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 50>","dst":"<50>","type":"READS_FROM"},{"src":"<case-x>50>","dst":"<'medium'>","type":"RETURNS"},{"src":"<case-x>0>","dst":"<x > 0>","type":"HAS_CONDITION"},{"src":"<x > 0>","dst":"<x>","type":"READS_FROM"},{"src":"<x > 0>","dst":"<0>","type":"READS_FROM"},{"src":"<case-x>0>","dst":"<'low'>","type":"RETURNS"},{"src":"<default-case>","dst":"<'none'>","type":"RETURNS"}],"rationale":"Switch-true pattern using boolean conditions as case expressions. Each case evaluates a comparison against the parameter, with implicit returns creating early exits. All node and edge types from Pass 1 were already in the approved vocabulary.","implicitBehavior":["switch cases fall through without explicit break statements","return statements provide implicit break behavior","cases evaluated in order until match found"]},"pass":2,"annotatedAt":"2026-02-24T00:38:52.551Z"}
{"construct":{"id":"statements::for-of-destructure-assign","file":"src/statements.js","category":"statements","lineStart":337,"lineEnd":344,"code":"function forOfDestructureAssign(pairs) {\n  let a, b;\n  for ([a, b] of pairs) {        // destructuring assignment in for-of head\n    console.log(a, b);\n  }\n  return { a, b }; // last pair values\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forOfDestructureAssign>","metadata":{"async":false,"generator":false}},{"type":"PARAMETER","id":"<pairs>"},{"type":"VARIABLE","id":"<a>","metadata":{"kind":"let"}},{"type":"VARIABLE","id":"<b>","metadata":{"kind":"let"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"EXPRESSION","id":"<[a, b]>","metadata":{"type":"array-pattern"}},{"type":"CALL","id":"<console.log(a, b)>","metadata":{"callee":"console.log"}},{"type":"PROPERTY_ACCESS","id":"<console.log>","metadata":{"objectName":"console","propertyName":"log"}},{"type":"EXPRESSION","id":"<{ a, b }>","metadata":{"type":"object","shorthandProperties":true}}],"edges":[{"src":"<forOfDestructureAssign>","dst":"<pairs>","type":"CONTAINS"},{"src":"<forOfDestructureAssign>","dst":"<a>","type":"CONTAINS"},{"src":"<forOfDestructureAssign>","dst":"<b>","type":"CONTAINS"},{"src":"<forOfDestructureAssign>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<pairs>","type":"ITERATES_OVER"},{"src":"<[a, b]>","dst":"<a>","type":"ASSIGNED_FROM"},{"src":"<[a, b]>","dst":"<b>","type":"ASSIGNED_FROM"},{"src":"<for-of>","dst":"<console.log(a, b)>","type":"CONTAINS"},{"src":"<console.log(a, b)>","dst":"<console.log>","type":"CALLS"},{"src":"<console.log(a, b)>","dst":"<a>","type":"PASSES_ARGUMENT"},{"src":"<console.log(a, b)>","dst":"<b>","type":"PASSES_ARGUMENT"},{"src":"<forOfDestructureAssign>","dst":"<{ a, b }>","type":"RETURNS"},{"src":"<{ a, b }>","dst":"<a>","type":"READS_FROM"},{"src":"<{ a, b }>","dst":"<b>","type":"READS_FROM"}],"rationale":"Function with for-of loop using destructuring assignment. Loop destructures each iteration value into pre-declared variables, which are then used in loop body and return statement. Mapped destructuring pattern to EXPRESSION and destructuring relationships to ASSIGNED_FROM.","implicitBehavior":["destructuring assignment modifies existing variables rather than declaring new ones","variables retain values from last iteration after loop completes"]},"pass":2,"annotatedAt":"2026-02-24T00:38:52.551Z"}
{"construct":{"id":"ts-specific::interface-basic","file":"src/ts-specific.ts","category":"ts-specific","lineStart":21,"lineEnd":27,"code":"interface User {\n  name: string;\n  age: number;\n  email?: string;\n  readonly id: number;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"INTERFACE","id":"<User>"},{"type":"PROPERTY","id":"<User.name>","metadata":{"type":"string","optional":false,"readonly":false}},{"type":"PROPERTY","id":"<User.age>","metadata":{"type":"number","optional":false,"readonly":false}},{"type":"PROPERTY","id":"<User.email>","metadata":{"type":"string","optional":true,"readonly":false}},{"type":"PROPERTY","id":"<User.id>","metadata":{"type":"number","optional":false,"readonly":true}}],"edges":[{"src":"<module>","dst":"<User>","type":"DECLARES"},{"src":"<User>","dst":"<User.name>","type":"CONTAINS"},{"src":"<User>","dst":"<User.age>","type":"CONTAINS"},{"src":"<User>","dst":"<User.email>","type":"CONTAINS"},{"src":"<User>","dst":"<User.id>","type":"CONTAINS"}],"rationale":"Interface declaration with four properties having different modifiers. Each property is a distinct node with type annotations and modifier metadata. All types used (INTERFACE, PROPERTY, DECLARES, CONTAINS) are in the approved vocabulary.","implicitBehavior":["interface is structural type - any object with matching shape satisfies it","readonly properties cannot be reassigned after initialization","optional properties may be undefined"]},"pass":2,"annotatedAt":"2026-02-24T00:38:53.372Z"}
{"construct":{"id":"statements::for-of-destructuring-object","file":"src/statements.js","category":"statements","lineStart":296,"lineEnd":304,"code":"function forOfDestructuringObject() {\n  const points = [{ x: 1, y: 2 }, { x: 3, y: 4 }];\n  const results = [];\n  for (const { x, y } of points) {\n    results.push(x + y);\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forOfDestructuringObject>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<points>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>","metadata":{"literalType":"array"}},{"type":"LITERAL","id":"<{ x: 1, y: 2 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<1>","metadata":{"value":1,"literalType":"number"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}},{"type":"LITERAL","id":"<{ x: 3, y: 4 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<3>","metadata":{"value":3,"literalType":"number"}},{"type":"LITERAL","id":"<4>","metadata":{"value":4,"literalType":"number"}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"literalType":"array"}},{"type":"LOOP","id":"<for-of>","metadata":{"loopType":"for-of"}},{"type":"VARIABLE","id":"<x>","metadata":{"kind":"const","destructured":true}},{"type":"VARIABLE","id":"<y>","metadata":{"kind":"const","destructured":true}},{"type":"CALL","id":"<results.push(x + y)>","metadata":{"callee":"push"}},{"type":"EXPRESSION","id":"<x + y>","metadata":{"operator":"+"}}],"edges":[{"src":"<forOfDestructuringObject>","dst":"<points>","type":"CONTAINS"},{"src":"<points>","dst":"<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>","type":"ASSIGNED_FROM"},{"src":"<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>","dst":"<{ x: 1, y: 2 }>","type":"HAS_ELEMENT"},{"src":"<[{ x: 1, y: 2 }, { x: 3, y: 4 }]>","dst":"<{ x: 3, y: 4 }>","type":"HAS_ELEMENT"},{"src":"<{ x: 1, y: 2 }>","dst":"<1>","type":"HAS_PROPERTY"},{"src":"<{ x: 1, y: 2 }>","dst":"<2>","type":"HAS_PROPERTY"},{"src":"<{ x: 3, y: 4 }>","dst":"<3>","type":"HAS_PROPERTY"},{"src":"<{ x: 3, y: 4 }>","dst":"<4>","type":"HAS_PROPERTY"},{"src":"<forOfDestructuringObject>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<forOfDestructuringObject>","dst":"<for-of>","type":"CONTAINS"},{"src":"<for-of>","dst":"<points>","type":"ITERATES_OVER"},{"src":"<for-of>","dst":"<x>","type":"CONTAINS"},{"src":"<for-of>","dst":"<y>","type":"CONTAINS"},{"src":"<for-of>","dst":"<results.push(x + y)>","type":"HAS_BODY"},{"src":"<results.push(x + y)>","dst":"<results>","type":"CALLS_ON"},{"src":"<results.push(x + y)>","dst":"<x + y>","type":"PASSES_ARGUMENT"},{"src":"<x + y>","dst":"<x>","type":"READS_FROM"},{"src":"<x + y>","dst":"<y>","type":"READS_FROM"},{"src":"<forOfDestructuringObject>","dst":"<results>","type":"RETURNS"}],"rationale":"For-of loop with object destructuring. Loop variables x and y are destructured from each object in the points array. The loop body calls push on results array with the sum of destructured values. Changed CALLS to CALLS_ON to better represent method invocation on the results object.","implicitBehavior":["destructuring assignment extracts x and y properties from each iterated object","const loop variables are block-scoped to each iteration"]},"pass":2,"annotatedAt":"2026-02-24T00:38:54.298Z"}
{"construct":{"id":"statements::for-in-destructuring","file":"src/statements.js","category":"statements","lineStart":366,"lineEnd":373,"code":"function forInDestructuring() {\n  const results = [];\n  for (const { length } in { abc: 1, de: 2, f: 3 }) {\n    results.push(length); // 3, 2, 1  destructures the string KEY, not value\n  }\n  return results;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<forInDestructuring>","metadata":{"async":false,"generator":false}},{"type":"VARIABLE","id":"<results>","metadata":{"kind":"const"}},{"type":"LITERAL","id":"<[]>","metadata":{"value":[],"literalType":"array"}},{"type":"LOOP","id":"<for-in>","metadata":{"loopType":"for-in"}},{"type":"VARIABLE","id":"<length>","metadata":{"kind":"const","destructured":true}},{"type":"LITERAL","id":"<{ abc: 1, de: 2, f: 3 }>","metadata":{"literalType":"object"}},{"type":"CALL","id":"<results.push(length)>","metadata":{"callee":"push"}},{"type":"PROPERTY_ACCESS","id":"<results.push>","metadata":{"property":"push"}}],"edges":[{"src":"<forInDestructuring>","dst":"<results>","type":"CONTAINS"},{"src":"<results>","dst":"<[]>","type":"ASSIGNED_FROM"},{"src":"<forInDestructuring>","dst":"<for-in>","type":"CONTAINS"},{"src":"<for-in>","dst":"<{ abc: 1, de: 2, f: 3 }>","type":"ITERATES_OVER"},{"src":"<for-in>","dst":"<length>","type":"CONTAINS"},{"src":"<for-in>","dst":"<results.push(length)>","type":"HAS_BODY"},{"src":"<results.push(length)>","dst":"<results.push>","type":"CALLS"},{"src":"<results.push>","dst":"<results>","type":"READS_FROM"},{"src":"<results.push(length)>","dst":"<length>","type":"PASSES_ARGUMENT"},{"src":"<forInDestructuring>","dst":"<results>","type":"RETURNS"}],"rationale":"For-in loop with destructuring pattern. The loop iterates over object keys, with each key string being destructured to extract its 'length' property, then pushes that length to results array. Removed the destructuring pattern node as it's not in approved vocabulary.","implicitBehavior":["for-in iterates over enumerable property names as strings","destructuring pattern { length } extracts the 'length' property from each key string","keys are processed in insertion order for string keys"]},"pass":2,"annotatedAt":"2026-02-24T00:38:54.960Z"}
{"construct":{"id":"statements::for-in-inherited","file":"src/statements.js","category":"statements","lineStart":257,"lineEnd":275,"code":"function forInInherited() {\n  const parent = { inherited: true };\n  const child = Object.create(parent);\n  child.own = true;\n\n  const allKeys = [];\n  for (const key in child) {\n    allKeys.push(key); // ['own', 'inherited']\n  }\n\n  const ownKeys = [];\n  for (const key in child) {\n    if (Object.hasOwn(child, key)) {\n      ownKeys.push(key); // ['own']\n    }\n  }\n  return { allKeys, ownKeys };\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<forInInherited>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"VARIAB"},"pass":2,"annotatedAt":"2026-02-24T00:38:56.401Z"}
{"construct":{"id":"ts-specific::ts-typed-function","file":"src/ts-specific.ts","category":"ts-specific","lineStart":13,"lineEnd":16,"code":"function typedFunction(name: string, age: number): string {\n  return `${name} is ${age}`;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<typedFunction>","metadata":{"async":false,"generator":false,"typed":true}},{"type":"PARAMETER","id":"<name>","metadata":{"type":"string"}},{"type":"PARAMETER","id":"<age>","metadata":{"type":"number"}},{"type":"TYPE_REFERENCE","id":"<string:return>","metadata":{"typeName":"string"}},{"type":"EXPRESSION","id":"<`${name} is ${age}`>"},{"type":"EXPRESSION","id":"<${name}>"},{"type":"EXPRESSION","id":"<${age}>"}],"edges":[{"src":"<module>","dst":"<typedFunction>","type":"DECLARES"},{"src":"<typedFunction>","dst":"<name>","type":"CONTAINS"},{"src":"<typedFunction>","dst":"<age>","type":"CONTAINS"},{"src":"<typedFunction>","dst":"<string:return>","type":"RETURNS_TYPE"},{"src":"<name>","dst":"<string>","type":"HAS_TYPE"},{"src":"<age>","dst":"<number>","type":"HAS_TYPE"},{"src":"<typedFunction>","dst":"<`${name} is ${age}`>","type":"RETURNS"},{"src":"<`${name} is ${age}`>","dst":"<${name}>","type":"CONTAINS"},{"src":"<`${name} is ${age}`>","dst":"<${age}>","type":"CONTAINS"},{"src":"<${name}>","dst":"<name>","type":"READS_FROM"},{"src":"<${age}>","dst":"<age>","type":"READS_FROM"}],"rationale":"TypeScript function with typed parameters and return type. Template literal return value interpolates both parameters. Mapped TYPE_ANNOTATION to TYPE_REFERENCE and TEMPLATE_LITERAL/TEMPLATE_EXPRESSION to EXPRESSION.","implicitBehavior":["TypeScript type checking enforces parameter and return types at compile time"]},"pass":2,"annotatedAt":"2026-02-24T00:38:56.428Z"}
{"construct":{"id":"ts-specific::interface-method","file":"src/ts-specific.ts","category":"ts-specific","lineStart":29,"lineEnd":32,"code":"interface Printable {\n  print(): void;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"INTERFACE","id":"<Printable>","metadata":{"kind":"interface"}},{"type":"METHOD","id":"<Printable.print>","metadata":{"kind":"interface-method","returnType":"void"}}],"edges":[{"src":"<module>","dst":"<Printable>","type":"DECLARES"},{"src":"<Printable>","dst":"<Printable.print>","type":"CONTAINS"}],"rationale":"Interface declaration containing a method signature. The interface defines a contract that implementing classes must fulfill. Both INTERFACE and METHOD are in the approved vocabulary, and DECLARES/CONTAINS accurately capture the relationships.","implicitBehavior":["interface methods are abstract - no implementation","implementing classes must provide concrete implementation","structural typing - any object with matching shape satisfies interface"]},"pass":2,"annotatedAt":"2026-02-24T00:38:56.746Z"}
{"construct":{"id":"statements::destructure-catch-nested","file":"src/statements.js","category":"statements","lineStart":357,"lineEnd":364,"code":"function destructureCatchNested() {\n  try {\n    throw { errors: [{ code: 'E1', path: '/api' }], status: 500 };\n  } catch ({ errors: [{ code, path }], status }) {\n    return { code, path, status };\n  }\n}","commentedOut":false},"annotation":{"nodes":[{"type":"FUNCTION","id":"<destructureCatchNested>","metadata":{"async":false,"generator":false}},{"type":"TRY_BLOCK","id":"<try-block>"},{"type":"CATCH_BLOCK","id":"<catch-block>"},{"type":"LITERAL","id":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","metadata":{"literalType":"object"}},{"type":"LITERAL","id":"<'E1'>","metadata":{"value":"E1","literalType":"string"}},{"type":"LITERAL","id":"<'/api'>","metadata":{"value":"/api","literalType":"string"}},{"type":"LITERAL","id":"<500>","metadata":{"value":500,"literalType":"number"}},{"type":"VARIABLE","id":"<code>","metadata":{"destructured":true}},{"type":"VARIABLE","id":"<path>","metadata":{"destructured":true}},{"type":"VARIABLE","id":"<status>","metadata":{"destructured":true}},{"type":"EXPRESSION","id":"<{ code, path, status }>","metadata":{"objectLiteral":true}}],"edges":[{"src":"<destructureCatchNested>","dst":"<try-block>","type":"CONTAINS"},{"src":"<destructureCatchNested>","dst":"<catch-block>","type":"CONTAINS"},{"src":"<try-block>","dst":"<catch-block>","type":"HAS_CATCH"},{"src":"<try-block>","dst":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","type":"THROWS"},{"src":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","dst":"<'E1'>","type":"CONTAINS"},{"src":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","dst":"<'/api'>","type":"CONTAINS"},{"src":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","dst":"<500>","type":"CONTAINS"},{"src":"<catch-block>","dst":"<code>","type":"DECLARES"},{"src":"<catch-block>","dst":"<path>","type":"DECLARES"},{"src":"<catch-block>","dst":"<status>","type":"DECLARES"},{"src":"<code>","dst":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","type":"ASSIGNED_FROM"},{"src":"<path>","dst":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","type":"ASSIGNED_FROM"},{"src":"<status>","dst":"<{ errors: [{ code: 'E1', path: '/api' }], status: 500 }>","type":"ASSIGNED_FROM"},{"src":"<destructureCatchNested>","dst":"<{ code, path, status }>","type":"RETURNS"},{"src":"<{ code, path, status }>","dst":"<code>","type":"READS_FROM"},{"src":"<{ code, path, status }>","dst":"<path>","type":"READS_FROM"},{"src":"<{ code, path, status }>","dst":"<status>","type":"READS_FROM"}],"rationale":"Function with try-catch using nested destructuring. The catch parameter destructures deeply into the thrown object structure, extracting nested properties. The return statement creates a new object from the destructured variables.","implicitBehavior":["destructuring creates new bindings in catch block scope","nested destructuring follows object/array structure","catch parameter is block-scoped"]},"pass":2,"annotatedAt":"2026-02-24T00:38:56.791Z"}
{"construct":{"id":"ts-specific::interface-extends","file":"src/ts-specific.ts","category":"ts-specific","lineStart":34,"lineEnd":38,"code":"interface Admin extends User, Printable {\n  role: string;\n  permissions: string[];\n}","commentedOut":false},"annotation":{"nodes":[{"type":"INTERFACE","id":"<Admin>","metadata":{"language":"typescript"}},{"type":"PROPERTY","id":"<Admin.role>","metadata":{"type":"string"}},{"type":"PROPERTY","id":"<Admin.permissions>","metadata":{"type":"string[]"}}],"edges":[{"src":"<module>","dst":"<Admin>","type":"DECLARES"},{"src":"<Admin>","dst":"<User>","type":"EXTENDS"},{"src":"<Admin>","dst":"<Printable>","type":"EXTENDS"},{"src":"<Admin>","dst":"<Admin.role>","type":"CONTAINS"},{"src":"<Admin>","dst":"<Admin.permissions>","type":"CONTAINS"}],"rationale":"TypeScript interface extending multiple interfaces. Admin inherits all properties from User and Printable, plus defines its own properties. All types used in Pass 1 are already in the approved vocabulary.","implicitBehavior":["structural typing - any object with matching shape satisfies this interface","multiple inheritance through interface extension","compile-time type checking only"]},"pass":2,"annotatedAt":"2026-02-24T00:38:58.340Z"}
{"construct":{"id":"statements::labeled-for-switch-interaction","file":"src/statements.js","category":"statements","lineStart":306,"lineEnd":317,"code":"function labeledForSwitch(items) {\n  const processed = [];\n  loop: for (const item of items) {\n    switch (item.type) {\n      case 'skip': continue loop;    // continues FOR, not switch\n      case 'stop': break loop;       // breaks FOR, not switch\n      case 'data': processed.push(item); break; // breaks switch only\n    }\n  }\n  return processed;\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<labeledForSwitch>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARA"},"pass":2,"annotatedAt":"2026-02-24T00:39:00.060Z"}
{"construct":{"id":"ts-specific::interface-index-signature","file":"src/ts-specific.ts","category":"ts-specific","lineStart":40,"lineEnd":43,"code":"interface StringMap {\n  [key: string]: string;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"INTERFACE","id":"<StringMap>"},{"type":"PROPERTY","id":"<StringMap[key: string]>","metadata":{"keyType":"string","valueType":"string","isIndexSignature":true}},{"type":"PARAMETER","id":"<key>","metadata":{"type":"string"}}],"edges":[{"src":"<module>","dst":"<StringMap>","type":"DECLARES"},{"src":"<StringMap>","dst":"<StringMap[key: string]>","type":"HAS_PROPERTY"},{"src":"<StringMap[key: string]>","dst":"<key>","type":"CONTAINS"}],"rationale":"Interface with index signature mapped to PROPERTY node type since it defines a property access pattern. The index signature parameter is captured as a PARAMETER node. Used HAS_PROPERTY edge to connect interface to its index signature property.","implicitBehavior":["allows any string property access","provides type constraint for bracket notation access","structural typing compatibility with objects having string properties"]},"pass":2,"annotatedAt":"2026-02-24T00:39:01.050Z"}
{"construct":{"id":"ts-specific::type-alias-union","file":"src/ts-specific.ts","category":"ts-specific","lineStart":56,"lineEnd":57,"code":"type ID = string | number;","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_ALIAS","id":"<ID>","metadata":{"kind":"union"}},{"type":"TYPE_REFERENCE","id":"<string>","metadata":{"primitive":true}},{"type":"TYPE_REFERENCE","id":"<number>","metadata":{"primitive":true}}],"edges":[{"src":"<module>","dst":"<ID>","type":"DECLARES"},{"src":"<ID>","dst":"<string>","type":"UNION_MEMBER"},{"src":"<ID>","dst":"<number>","type":"UNION_MEMBER"}],"rationale":"Type alias declaration creating a union type. The alias contains two primitive type references as union members.","implicitBehavior":["TypeScript structural typing allows any string or number to satisfy this type","Union type creates type narrowing opportunities in control flow"]},"pass":2,"annotatedAt":"2026-02-24T00:39:01.206Z"}
{"construct":{"id":"statements::typeof-switch-narrowing","file":"src/statements.js","category":"statements","lineStart":346,"lineEnd":355,"code":"function typeofSwitch(val) {\n  switch (typeof val) {\n    case 'string': return val.trim();\n    case 'number': return val.toFixed(2);\n    case 'object': return val === null ? 'null' : JSON.stringify(val);\n    case 'function': return val();\n    default: return String(val);\n  }\n}","commentedOut":false},"annotation":{"nodes":[],"edges":[],"rationale":"PARSE_ERROR: Could not extract JSON from response: ```json\n{\n  \"nodes\": [\n    {\n      \"type\": \"FUNCTION\",\n      \"id\": \"<typeofSwitch>\",\n      \"metadata\": {\n        \"async\": false,\n        \"generator\": false\n      }\n    },\n    {\n      \"type\": \"PARAMETE"},"pass":2,"annotatedAt":"2026-02-24T00:39:01.431Z"}
{"construct":{"id":"ts-specific::ts-typed-arrow","file":"src/ts-specific.ts","category":"ts-specific","lineStart":18,"lineEnd":19,"code":"const typedArrow = (x: number): number => x * 2;","commentedOut":false},"annotation":{"nodes":[{"type":"VARIABLE","id":"<typedArrow>","metadata":{"kind":"const"}},{"type":"FUNCTION","id":"<typedArrow:fn>","metadata":{"arrowFunction":true}},{"type":"PARAMETER","id":"<x>","metadata":{"typeAnnotation":"number"}},{"type":"TYPE_REFERENCE","id":"<number:param>","metadata":{"typeName":"number"}},{"type":"TYPE_REFERENCE","id":"<number:return>","metadata":{"typeName":"number"}},{"type":"EXPRESSION","id":"<x * 2>","metadata":{"operator":"*"}},{"type":"LITERAL","id":"<2>","metadata":{"value":2,"literalType":"number"}}],"edges":[{"src":"<module>","dst":"<typedArrow>","type":"DECLARES"},{"src":"<typedArrow>","dst":"<typedArrow:fn>","type":"ASSIGNED_FROM"},{"src":"<typedArrow:fn>","dst":"<x>","type":"CONTAINS"},{"src":"<x>","dst":"<number:param>","type":"HAS_TYPE"},{"src":"<typedArrow:fn>","dst":"<number:return>","type":"RETURNS_TYPE"},{"src":"<typedArrow:fn>","dst":"<x * 2>","type":"RETURNS"},{"src":"<x * 2>","dst":"<x>","type":"READS_FROM"},{"src":"<x * 2>","dst":"<2>","type":"READS_FROM"}],"rationale":"TypeScript arrow function with typed parameter and return type. Used TYPE_REFERENCE for type annotations and RETURNS_TYPE for function return type annotation.","implicitBehavior":["TypeScript type checking enforces number type at compile time","Runtime behavior identical to untyped arrow function"]},"pass":2,"annotatedAt":"2026-02-24T00:39:01.674Z"}
{"construct":{"id":"ts-specific::interface-construct-signature","file":"src/ts-specific.ts","category":"ts-specific","lineStart":51,"lineEnd":54,"code":"interface Constructor {\n  new (name: string): User;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"INTERFACE","id":"<Constructor>","metadata":{"kind":"interface"}},{"type":"METHOD","id":"<Constructor.new>","metadata":{"kind":"construct","isConstructSignature":true}},{"type":"PARAMETER","id":"<name>","metadata":{"type":"string"}},{"type":"TYPE_REFERENCE","id":"<string>","metadata":{"primitive":true}},{"type":"TYPE_REFERENCE","id":"<User>","metadata":{"primitive":false}}],"edges":[{"src":"<Constructor>","dst":"<Constructor.new>","type":"CONTAINS"},{"src":"<Constructor.new>","dst":"<name>","type":"RECEIVES_ARGUMENT"},{"src":"<name>","dst":"<string>","type":"HAS_TYPE"},{"src":"<Constructor.new>","dst":"<User>","type":"RETURNS_TYPE"}],"rationale":"Interface with construct signature mapped to METHOD node type as the closest approved match. The construct signature defines a constructor contract specifying parameter types and return type for new operator usage.","implicitBehavior":["construct signature enables 'new' operator usage","interface provides structural typing contract","construct signature differs from regular method signature"]},"pass":2,"annotatedAt":"2026-02-24T00:39:03.619Z"}
{"construct":{"id":"ts-specific::interface-call-signature","file":"src/ts-specific.ts","category":"ts-specific","lineStart":45,"lineEnd":49,"code":"interface Logger {\n  (message: string): void;\n  level: string;\n}","commentedOut":false},"annotation":{"nodes":[{"type":"INTERFACE","id":"<Logger>","metadata":{"callable":true}},{"type":"METHOD","id":"<Logger:call>","metadata":{"returnType":"void","isCallSignature":true}},{"type":"PARAMETER","id":"<message>","metadata":{"type":"string"}},{"type":"PROPERTY","id":"<Logger.level>","metadata":{"type":"string"}}],"edges":[{"src":"<module>","dst":"<Logger>","type":"DECLARES"},{"src":"<Logger>","dst":"<Logger:call>","type":"CONTAINS"},{"src":"<Logger>","dst":"<Logger.level>","type":"CONTAINS"},{"src":"<Logger:call>","dst":"<message>","type":"RECEIVES_ARGUMENT"}],"rationale":"Interface with both callable signature and property. Using METHOD as closest match for call signature since it represents a callable construct. Changed CONTAINS edge to RECEIVES_ARGUMENT for parameter relationship to be more semantically precise.","implicitBehavior":["interface can be implemented by functions with additional properties","structural typing allows any compatible object/function"]},"pass":2,"annotatedAt":"2026-02-24T00:39:03.793Z"}
{"construct":{"id":"ts-specific::type-alias-tuple","file":"src/ts-specific.ts","category":"ts-specific","lineStart":65,"lineEnd":66,"code":"type Pair<A, B> = [A, B];","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_ALIAS","id":"<Pair>","metadata":{"generic":true}},{"type":"TYPE_PARAMETER","id":"<A>"},{"type":"TYPE_PARAMETER","id":"<B>"},{"type":"TYPE_REFERENCE","id":"<[A, B]>","metadata":{"tupleLength":2,"isTuple":true}}],"edges":[{"src":"<module>","dst":"<Pair>","type":"DECLARES"},{"src":"<Pair>","dst":"<A>","type":"HAS_TYPE_PARAMETER"},{"src":"<Pair>","dst":"<B>","type":"HAS_TYPE_PARAMETER"},{"src":"<Pair>","dst":"<[A, B]>","type":"ALIASES"},{"src":"<[A, B]>","dst":"<A>","type":"HAS_ELEMENT"},{"src":"<[A, B]>","dst":"<B>","type":"HAS_ELEMENT"}],"rationale":"Generic type alias defining a tuple type using approved vocabulary. TYPE_REFERENCE represents the tuple structure with metadata indicating it's a tuple, HAS_TYPE_PARAMETER connects the alias to its parameters, and ALIASES shows the type alias relationship.","implicitBehavior":["type alias creates a new name for the tuple type","generic type parameters are scoped to the alias definition","tuple maintains element order and fixed length"]},"pass":2,"annotatedAt":"2026-02-24T00:39:05.893Z"}
{"construct":{"id":"ts-specific::enum-numeric","file":"src/ts-specific.ts","category":"ts-specific","lineStart":68,"lineEnd":74,"code":"enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}","commentedOut":false},"annotation":{"nodes":[{"type":"ENUM","id":"<Direction>","metadata":{"numeric":true}},{"type":"ENUM_MEMBER","id":"<Direction.Up>","metadata":{"value":0}},{"type":"ENUM_MEMBER","id":"<Direction.Down>","metadata":{"value":1}},{"type":"ENUM_MEMBER","id":"<Direction.Left>","metadata":{"value":2}},{"type":"ENUM_MEMBER","id":"<Direction.Right>","metadata":{"value":3}}],"edges":[{"src":"<module>","dst":"<Direction>","type":"DECLARES"},{"src":"<Direction>","dst":"<Direction.Up>","type":"CONTAINS"},{"src":"<Direction>","dst":"<Direction.Down>","type":"CONTAINS"},{"src":"<Direction>","dst":"<Direction.Left>","type":"CONTAINS"},{"src":"<Direction>","dst":"<Direction.Right>","type":"CONTAINS"}],"rationale":"TypeScript numeric enum declaration using approved vocabulary. ENUM and ENUM_MEMBER types are both in the approved list, so the Pass 1 annotation maps directly without any vocabulary gaps.","implicitBehavior":["enum creates both type and runtime object","numeric values auto-assigned (0, 1, 2, 3)","reverse mapping generated (Direction[0] === 'Up')"]},"pass":2,"annotatedAt":"2026-02-24T00:39:07.194Z"}
{"construct":{"id":"ts-specific::enum-heterogeneous","file":"src/ts-specific.ts","category":"ts-specific","lineStart":90,"lineEnd":94,"code":"enum Mixed {\n  No = 0,\n  Yes = 'YES',\n}","commentedOut":false},"annotation":{"nodes":[{"type":"ENUM","id":"<Mixed>","metadata":{"heterogeneous":true}},{"type":"ENUM_MEMBER","id":"<Mixed.No>","metadata":{"key":"No"}},{"type":"LITERAL","id":"<0>","metadata":{"value":0,"literalType":"number"}},{"type":"ENUM_MEMBER","id":"<Mixed.Yes>","metadata":{"key":"Yes"}},{"type":"LITERAL","id":"<'YES'>","metadata":{"value":"YES","literalType":"string"}}],"edges":[{"src":"<module>","dst":"<Mixed>","type":"DECLARES"},{"src":"<Mixed>","dst":"<Mixed.No>","type":"CONTAINS"},{"src":"<Mixed>","dst":"<Mixed.Yes>","type":"CONTAINS"},{"src":"<Mixed.No>","dst":"<0>","type":"ASSIGNED_FROM"},{"src":"<Mixed.Yes>","dst":"<'YES'>","type":"ASSIGNED_FROM"}],"rationale":"TypeScript heterogeneous enum with mixed numeric and string values. Each member is explicitly assigned a literal value of different types. All types used are in the approved vocabulary.","implicitBehavior":["TypeScript generates both forward and reverse mapping objects for numeric members","String members only get forward mapping","Runtime object has both numeric and string keys"]},"pass":2,"annotatedAt":"2026-02-24T00:39:07.194Z"}
{"construct":{"id":"ts-specific::type-alias-generic","file":"src/ts-specific.ts","category":"ts-specific","lineStart":59,"lineEnd":60,"code":"type Nullable<T> = T | null;","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_ALIAS","id":"<Nullable>","metadata":{"generic":true}},{"type":"TYPE_PARAMETER","id":"<T>"},{"type":"TYPE_REFERENCE","id":"<T:ref>","metadata":{"referencesTypeParam":true}},{"type":"LITERAL_TYPE","id":"<null>","metadata":{"value":"null","literalType":"null"}}],"edges":[{"src":"<Nullable>","dst":"<T>","type":"HAS_TYPE_PARAMETER"},{"src":"<Nullable>","dst":"<T:ref>","type":"UNION_MEMBER"},{"src":"<Nullable>","dst":"<null>","type":"UNION_MEMBER"},{"src":"<T:ref>","dst":"<T>","type":"RESOLVES_TO"}],"rationale":"Generic type alias defining a union type using approved vocabulary. The type parameter T is referenced within the union definition, with both the type reference and null literal as union members.","implicitBehavior":["type parameter T can be instantiated with any type","union type enables null-checking in TypeScript's type system"]},"pass":2,"annotatedAt":"2026-02-24T00:39:07.849Z"}
{"construct":{"id":"ts-specific::type-alias-function","file":"src/ts-specific.ts","category":"ts-specific","lineStart":62,"lineEnd":63,"code":"type Callback = (error: Error | null, result?: unknown) => void;","commentedOut":false},"annotation":{"nodes":[{"type":"TYPE_ALIAS","id":"<Callback>","metadata":{"kind":"function"}},{"type":"PARAMETER","id":"<error>","metadata":{"type":"Error | null"}},{"type":"PARAMETER","id":"<result>","metadata":{"type":"unknown","optional":true}},{"type":"TYPE_REFERENCE","id":"<Error | null>","metadata":{"kind":"union"}},{"type":"TYPE_REFERENCE","id":"<Error>","metadata":{"kind":"reference"}},{"type":"LITERAL_TYPE","id":"<null>","metadata":{"kind":"literal"}},{"type":"TYPE_REFERENCE","id":"<unknown>","metadata":{"kind":"primitive"}},{"type":"TYPE_REFERENCE","id":"<void>","metadata":{"kind":"primitive"}}],"edges":[{"src":"<module>","dst":"<Callback>","type":"DECLARES"},{"src":"<Callback>","dst":"<error>","type":"CONTAINS"},{"src":"<Callback>","dst":"<result>","type":"CONTAINS"},{"src":"<Callback>","dst":"<void>","type":"RETURNS_TYPE"},{"src":"<error>","dst":"<Error | null>","type":"HAS_TYPE"},{"src":"<result>","dst":"<unknown>","type":"HAS_TYPE"},{"src":"<Error | null>","dst":"<Error>","type":"UNION_MEMBER"},{"src":"<Error | null>","dst":"<null>","type":"UNION_MEMBER"}],"rationale":"TypeScript type alias defining a function signature with error-first callback pattern. Contains typed parameters and return type. Mapped TYPE nodes to TYPE_REFERENCE/LITERAL_TYPE, RETURNS to RETURNS_TYPE, and union containment to UNION_MEMBER.","implicitBehavior":["type alias creates a reusable type definition","union type allows either Error or null for error parameter","optional parameter can be omitted in function calls"]},"pass":2,"annotatedAt":"2026-02-24T00:39:09.037Z"}
{"construct": {"id": "statements::for-comma-update", "file": "src/statements.js", "category": "statements", "lineStart": 375, "lineEnd": 391, "code": "function forCommaUpdate() {\n  const arr = [1, 2, 3, 4, 5];\n\n  // Two-pointer technique  comma in both init and update\n  for (let lo = 0, hi = arr.length - 1; lo < hi; lo++, hi--) {\n    [arr[lo], arr[hi]] = [arr[hi], arr[lo]]; // swap\n  }\n\n  // Side effect in update clause\n  let processed = 0;\n  for (let i = 0; i < 3; i++, processed++) {\n    // comma separates two update expressions\n  }\n\n  return { arr, processed };\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<forCommaUpdate>", "metadata": {"async": false, "generator": false}}, {"type": "VARIABLE", "id": "<arr>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<[1, 2, 3, 4, 5]>", "metadata": {"literalType": "array"}}, {"type": "LOOP", "id": "<for-two-pointer>", "metadata": {"loopType": "for"}}, {"type": "VARIABLE", "id": "<lo>", "metadata": {"kind": "let"}}, {"type": "LITERAL", "id": "<0>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "VARIABLE", "id": "<hi>", "metadata": {"kind": "let"}}, {"type": "EXPRESSION", "id": "<arr.length - 1>", "metadata": {"operator": "-"}}, {"type": "EXPRESSION", "id": "<lo < hi>", "metadata": {"operator": "<"}}, {"type": "EXPRESSION", "id": "<lo++>", "metadata": {"operator": "++"}}, {"type": "EXPRESSION", "id": "<hi-->", "metadata": {"operator": "--"}}, {"type": "EXPRESSION", "id": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>", "metadata": {"operator": "="}}, {"type": "VARIABLE", "id": "<processed>", "metadata": {"kind": "let"}}, {"type": "LITERAL", "id": "<0-2>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "LOOP", "id": "<for-side-effect>", "metadata": {"loopType": "for"}}, {"type": "VARIABLE", "id": "<i>", "metadata": {"kind": "let"}}, {"type": "LITERAL", "id": "<0-3>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "EXPRESSION", "id": "<i < 3>", "metadata": {"operator": "<"}}, {"type": "LITERAL", "id": "<3>", "metadata": {"value": 3, "literalType": "number"}}, {"type": "EXPRESSION", "id": "<i++>", "metadata": {"operator": "++"}}, {"type": "EXPRESSION", "id": "<processed++>", "metadata": {"operator": "++"}}, {"type": "EXPRESSION", "id": "<{ arr, processed }>", "metadata": {"literalType": "object"}}], "edges": [{"src": "<module>", "dst": "<forCommaUpdate>", "type": "DECLARES"}, {"src": "<forCommaUpdate>", "dst": "<arr>", "type": "CONTAINS"}, {"src": "<arr>", "dst": "<[1, 2, 3, 4, 5]>", "type": "ASSIGNED_FROM"}, {"src": "<forCommaUpdate>", "dst": "<for-two-pointer>", "type": "CONTAINS"}, {"src": "<for-two-pointer>", "dst": "<lo>", "type": "HAS_INIT"}, {"src": "<lo>", "dst": "<0>", "type": "ASSIGNED_FROM"}, {"src": "<for-two-pointer>", "dst": "<hi>", "type": "HAS_INIT"}, {"src": "<hi>", "dst": "<arr.length - 1>", "type": "ASSIGNED_FROM"}, {"src": "<arr.length - 1>", "dst": "<arr>", "type": "READS_FROM"}, {"src": "<for-two-pointer>", "dst": "<lo < hi>", "type": "HAS_CONDITION"}, {"src": "<lo < hi>", "dst": "<lo>", "type": "READS_FROM"}, {"src": "<lo < hi>", "dst": "<hi>", "type": "READS_FROM"}, {"src": "<for-two-pointer>", "dst": "<lo++>", "type": "HAS_UPDATE"}, {"src": "<lo++>", "dst": "<lo>", "type": "MODIFIES"}, {"src": "<for-two-pointer>", "dst": "<hi-->", "type": "HAS_UPDATE"}, {"src": "<hi-->", "dst": "<hi>", "type": "MODIFIES"}, {"src": "<for-two-pointer>", "dst": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>", "type": "HAS_BODY"}, {"src": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>", "dst": "<arr>", "type": "MODIFIES"}, {"src": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>", "dst": "<lo>", "type": "READS_FROM"}, {"src": "<[arr[lo], arr[hi]] = [arr[hi], arr[lo]]>", "dst": "<hi>", "type": "READS_FROM"}, {"src": "<forCommaUpdate>", "dst": "<processed>", "type": "CONTAINS"}, {"src": "<processed>", "dst": "<0-2>", "type": "ASSIGNED_FROM"}, {"src": "<forCommaUpdate>", "dst": "<for-side-effect>", "type": "CONTAINS"}, {"src": "<for-side-effect>", "dst": "<i>", "type": "HAS_INIT"}, {"src": "<i>", "dst": "<0-3>", "type": "ASSIGNED_FROM"}, {"src": "<for-side-effect>", "dst": "<i < 3>", "type": "HAS_CONDITION"}, {"src": "<i < 3>", "dst": "<i>", "type": "READS_FROM"}, {"src": "<i < 3>", "dst": "<3>", "type": "READS_FROM"}, {"src": "<for-side-effect>", "dst": "<i++>", "type": "HAS_UPDATE"}, {"src": "<i++>", "dst": "<i>", "type": "MODIFIES"}, {"src": "<for-side-effect>", "dst": "<processed++>", "type": "HAS_UPDATE"}, {"src": "<processed++>", "dst": "<processed>", "type": "MODIFIES"}, {"src": "<forCommaUpdate>", "dst": "<{ arr, processed }>", "type": "RETURNS"}, {"src": "<{ arr, processed }>", "dst": "<arr>", "type": "READS_FROM"}, {"src": "<{ arr, processed }>", "dst": "<processed>", "type": "READS_FROM"}], "rationale": "Function with two for loops demonstrating comma operators. First loop has comma-separated init and update clauses for two-pointer technique. Second loop has comma-separated update expressions including side effect on external variable. [merge-map applied]", "implicitBehavior": ["comma operator evaluates left-to-right and returns rightmost value", "loop variables are block-scoped to their respective loops"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "statements::in-operator-type-guard", "file": "src/statements.js", "category": "statements", "lineStart": 393, "lineEnd": 411, "code": "function inOperatorTypeGuard(input) {\n  // 'prop' in obj as conditional guard  narrows type inside branch\n  if ('name' in input) {\n    return input.name.toUpperCase(); // safe  guarded by 'in' check\n  }\n\n  // Compound in-check  multiple property guards\n  if ('items' in input && 'count' in input) {\n    return input.items.slice(0, input.count);\n  }\n\n  // Negated in-check\n  if (!('error' in input)) {\n    return input;\n  }\n\n  return null;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<inOperatorTypeGuard>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<input>"}, {"type": "BRANCH", "id": "<if-name-in-input>", "metadata": {"branchType": "if"}}, {"type": "EXPRESSION", "id": "<'name' in input>", "metadata": {"operator": "in"}}, {"type": "LITERAL", "id": "<'name'>", "metadata": {"value": "name", "literalType": "string"}}, {"type": "PROPERTY_ACCESS", "id": "<input.name>"}, {"type": "CALL", "id": "<input.name.toUpperCase()>", "metadata": {"callee": "toUpperCase"}}, {"type": "BRANCH", "id": "<if-items-and-count>", "metadata": {"branchType": "if"}}, {"type": "EXPRESSION", "id": "<'items' in input && 'count' in input>", "metadata": {"operator": "&&"}}, {"type": "EXPRESSION", "id": "<'items' in input>", "metadata": {"operator": "in"}}, {"type": "LITERAL", "id": "<'items'>", "metadata": {"value": "items", "literalType": "string"}}, {"type": "EXPRESSION", "id": "<'count' in input>", "metadata": {"operator": "in"}}, {"type": "LITERAL", "id": "<'count'>", "metadata": {"value": "count", "literalType": "string"}}, {"type": "PROPERTY_ACCESS", "id": "<input.items>"}, {"type": "CALL", "id": "<input.items.slice(0, input.count)>", "metadata": {"callee": "slice"}}, {"type": "LITERAL", "id": "<0>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "PROPERTY_ACCESS", "id": "<input.count>"}, {"type": "BRANCH", "id": "<if-not-error>", "metadata": {"branchType": "if"}}, {"type": "EXPRESSION", "id": "<!('error' in input)>", "metadata": {"operator": "!"}}, {"type": "EXPRESSION", "id": "<'error' in input>", "metadata": {"operator": "in"}}, {"type": "LITERAL", "id": "<'error'>", "metadata": {"value": "error", "literalType": "string"}}, {"type": "LITERAL", "id": "<null>", "metadata": {"value": null, "literalType": "null"}}], "edges": [{"src": "<module>", "dst": "<inOperatorTypeGuard>", "type": "DECLARES"}, {"src": "<inOperatorTypeGuard>", "dst": "<input>", "type": "CONTAINS"}, {"src": "<inOperatorTypeGuard>", "dst": "<if-name-in-input>", "type": "CONTAINS"}, {"src": "<if-name-in-input>", "dst": "<'name' in input>", "type": "HAS_CONDITION"}, {"src": "<'name' in input>", "dst": "<'name'>", "type": "READS_FROM"}, {"src": "<'name' in input>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<if-name-in-input>", "dst": "<input.name.toUpperCase()>", "type": "HAS_CONSEQUENT"}, {"src": "<input.name.toUpperCase()>", "dst": "<input.name>", "type": "CALLS"}, {"src": "<input.name>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<inOperatorTypeGuard>", "dst": "<if-items-and-count>", "type": "CONTAINS"}, {"src": "<if-items-and-count>", "dst": "<'items' in input && 'count' in input>", "type": "HAS_CONDITION"}, {"src": "<'items' in input && 'count' in input>", "dst": "<'items' in input>", "type": "READS_FROM"}, {"src": "<'items' in input && 'count' in input>", "dst": "<'count' in input>", "type": "READS_FROM"}, {"src": "<'items' in input>", "dst": "<'items'>", "type": "READS_FROM"}, {"src": "<'items' in input>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<'count' in input>", "dst": "<'count'>", "type": "READS_FROM"}, {"src": "<'count' in input>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<if-items-and-count>", "dst": "<input.items.slice(0, input.count)>", "type": "HAS_CONSEQUENT"}, {"src": "<input.items.slice(0, input.count)>", "dst": "<input.items>", "type": "CALLS"}, {"src": "<input.items.slice(0, input.count)>", "dst": "<0>", "type": "PASSES_ARGUMENT"}, {"src": "<input.items.slice(0, input.count)>", "dst": "<input.count>", "type": "PASSES_ARGUMENT"}, {"src": "<input.items>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<input.count>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<inOperatorTypeGuard>", "dst": "<if-not-error>", "type": "CONTAINS"}, {"src": "<if-not-error>", "dst": "<!('error' in input)>", "type": "HAS_CONDITION"}, {"src": "<!('error' in input)>", "dst": "<'error' in input>", "type": "READS_FROM"}, {"src": "<'error' in input>", "dst": "<'error'>", "type": "READS_FROM"}, {"src": "<'error' in input>", "dst": "<input>", "type": "READS_FROM"}, {"src": "<if-not-error>", "dst": "<input>", "type": "HAS_CONSEQUENT"}, {"src": "<inOperatorTypeGuard>", "dst": "<null>", "type": "RETURNS"}, {"src": "<if-name-in-input>", "dst": "<input.name.toUpperCase()>", "type": "RETURNS"}, {"src": "<if-items-and-count>", "dst": "<input.items.slice(0, input.count)>", "type": "RETURNS"}, {"src": "<if-not-error>", "dst": "<input>", "type": "RETURNS"}], "rationale": "Function using 'in' operator for type guarding. Three conditional branches check for different properties, with compound conditions and negation. Each branch returns different values based on property existence. [merge-map applied]", "implicitBehavior": ["TypeScript type narrowing within each branch based on 'in' operator checks", "Property access is safe after 'in' check confirms property existence"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::enum-const", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 83, "lineEnd": 88, "code": "const enum Flags {\n  Read = 1,\n  Write = 2,\n  Execute = 4,\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "ENUM", "id": "<Flags>", "metadata": {"kind": "const"}}, {"type": "ENUM_MEMBER", "id": "<Flags.Read>", "metadata": {"name": "Read"}}, {"type": "LITERAL", "id": "<1>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "ENUM_MEMBER", "id": "<Flags.Write>", "metadata": {"name": "Write"}}, {"type": "LITERAL", "id": "<2>", "metadata": {"value": 2, "literalType": "number"}}, {"type": "ENUM_MEMBER", "id": "<Flags.Execute>", "metadata": {"name": "Execute"}}, {"type": "LITERAL", "id": "<4>", "metadata": {"value": 4, "literalType": "number"}}], "edges": [{"src": "<module>", "dst": "<Flags>", "type": "DECLARES"}, {"src": "<Flags>", "dst": "<Flags.Read>", "type": "CONTAINS"}, {"src": "<Flags>", "dst": "<Flags.Write>", "type": "CONTAINS"}, {"src": "<Flags>", "dst": "<Flags.Execute>", "type": "CONTAINS"}, {"src": "<Flags.Read>", "dst": "<1>", "type": "ASSIGNED_FROM"}, {"src": "<Flags.Write>", "dst": "<2>", "type": "ASSIGNED_FROM"}, {"src": "<Flags.Execute>", "dst": "<4>", "type": "ASSIGNED_FROM"}], "rationale": "Const enum declaration with explicit numeric values. Each member is assigned a literal value. [merge-map applied]", "implicitBehavior": ["const enum members are inlined at compile time", "no runtime object is generated", "values are substituted directly at usage sites"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::enum-string", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 76, "lineEnd": 81, "code": "enum Status {\n  Active = 'ACTIVE',\n  Inactive = 'INACTIVE',\n  Pending = 'PENDING',\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "ENUM", "id": "<Status>", "metadata": {"enumType": "string"}}, {"type": "ENUM_MEMBER", "id": "<Status.Active>", "metadata": {"key": "Active"}}, {"type": "LITERAL", "id": "<'ACTIVE'>", "metadata": {"value": "ACTIVE", "literalType": "string"}}, {"type": "ENUM_MEMBER", "id": "<Status.Inactive>", "metadata": {"key": "Inactive"}}, {"type": "LITERAL", "id": "<'INACTIVE'>", "metadata": {"value": "INACTIVE", "literalType": "string"}}, {"type": "ENUM_MEMBER", "id": "<Status.Pending>", "metadata": {"key": "Pending"}}, {"type": "LITERAL", "id": "<'PENDING'>", "metadata": {"value": "PENDING", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<Status>", "type": "DECLARES"}, {"src": "<Status>", "dst": "<Status.Active>", "type": "CONTAINS"}, {"src": "<Status>", "dst": "<Status.Inactive>", "type": "CONTAINS"}, {"src": "<Status>", "dst": "<Status.Pending>", "type": "CONTAINS"}, {"src": "<Status.Active>", "dst": "<'ACTIVE'>", "type": "ASSIGNED_FROM"}, {"src": "<Status.Inactive>", "dst": "<'INACTIVE'>", "type": "ASSIGNED_FROM"}, {"src": "<Status.Pending>", "dst": "<'PENDING'>", "type": "ASSIGNED_FROM"}], "rationale": "String enum declaration with explicit string values. Each enum member is assigned a specific string literal value. [merge-map applied]", "implicitBehavior": ["TypeScript compiles to object with bidirectional mapping for numeric enums, but string enums only map key->value", "Enum creates both a type and a runtime value"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::generic-function", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 96, "lineEnd": 99, "code": "function identity<T>(value: T): T {\n  return value;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<identity>", "metadata": {"async": false, "generator": false, "generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": null}}, {"type": "PARAMETER", "id": "<value>", "metadata": {"type": "T"}}, {"type": "TYPE_REFERENCE", "id": "<T:param>", "metadata": {"typeReference": "T", "originalType": "TYPE_ANNOTATION"}}, {"type": "TYPE_REFERENCE", "id": "<T:return>", "metadata": {"typeReference": "T", "originalType": "TYPE_ANNOTATION"}}], "edges": [{"src": "<module>", "dst": "<identity>", "type": "DECLARES"}, {"src": "<identity>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<identity>", "dst": "<value>", "type": "CONTAINS"}, {"src": "<value>", "dst": "<T:param>", "type": "HAS_TYPE"}, {"src": "<identity>", "dst": "<T:return>", "type": "RETURNS_TYPE"}, {"src": "<T:param>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<T:return>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<identity>", "dst": "<value>", "type": "RETURNS"}], "rationale": "Generic function with type parameter T. Parameter and return type both reference the same type parameter, creating type flow constraint. [merge-map applied]", "implicitBehavior": ["type parameter T is inferred from call site arguments", "return type constraint enforces same type as input"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::generic-function-multi", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 101, "lineEnd": 104, "code": "function merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<merge>", "metadata": {"async": false, "generator": false, "generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": null}}, {"type": "TYPE_PARAMETER", "id": "<U>", "metadata": {"constraint": null}}, {"type": "PARAMETER", "id": "<obj1>", "metadata": {"typeAnnotation": "T"}}, {"type": "PARAMETER", "id": "<obj2>", "metadata": {"typeAnnotation": "U"}}, {"type": "TYPE_REFERENCE", "id": "<T & U>", "metadata": {"kind": "intersection", "originalType": "TYPE_ANNOTATION"}}, {"type": "EXPRESSION", "id": "<{ ...obj1, ...obj2 }>", "metadata": {"kind": "object-spread"}}], "edges": [{"src": "<module>", "dst": "<merge>", "type": "DECLARES"}, {"src": "<merge>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<merge>", "dst": "<U>", "type": "CONTAINS"}, {"src": "<merge>", "dst": "<obj1>", "type": "CONTAINS"}, {"src": "<merge>", "dst": "<obj2>", "type": "CONTAINS"}, {"src": "<obj1>", "dst": "<T>", "type": "HAS_TYPE"}, {"src": "<obj2>", "dst": "<U>", "type": "HAS_TYPE"}, {"src": "<merge>", "dst": "<T & U>", "type": "RETURNS_TYPE"}, {"src": "<T & U>", "dst": "<T>", "type": "INTERSECTS_WITH"}, {"src": "<T & U>", "dst": "<U>", "type": "INTERSECTS_WITH"}, {"src": "<merge>", "dst": "<{ ...obj1, ...obj2 }>", "type": "RETURNS"}, {"src": "<{ ...obj1, ...obj2 }>", "dst": "<obj1>", "type": "SPREADS_FROM", "metadata": {"originalType": "SPREADS"}}, {"src": "<{ ...obj1, ...obj2 }>", "dst": "<obj2>", "type": "SPREADS_FROM", "metadata": {"originalType": "SPREADS"}}], "rationale": "Generic function with two type parameters T and U. Parameters are typed with these generics, return type is intersection T & U. Body spreads both parameters into new object. [merge-map applied]", "implicitBehavior": ["type inference at call site", "intersection type merges properties from both types", "spread operator creates shallow copy"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::generic-constraint", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 130, "lineEnd": 133, "code": "function getLength<T extends { length: number }>(item: T): number {\n  return item.length;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<getLength>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"hasConstraint": true}}, {"type": "TYPE_REFERENCE", "id": "<{ length: number }>", "metadata": {"constraintType": "object", "originalType": "TYPE_CONSTRAINT"}}, {"type": "PARAMETER", "id": "<item>", "metadata": {"typeAnnotation": "T"}}, {"type": "TYPE_REFERENCE", "id": "<T:param>", "metadata": {"type": "T", "originalType": "TYPE_ANNOTATION"}}, {"type": "TYPE_REFERENCE", "id": "<number:return>", "metadata": {"type": "number", "originalType": "TYPE_ANNOTATION"}}, {"type": "PROPERTY_ACCESS", "id": "<item.length>", "metadata": {"property": "length"}}], "edges": [{"src": "<module>", "dst": "<getLength>", "type": "DECLARES"}, {"src": "<getLength>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<T>", "dst": "<{ length: number }>", "type": "CONSTRAINED_BY"}, {"src": "<getLength>", "dst": "<item>", "type": "CONTAINS"}, {"src": "<item>", "dst": "<T:param>", "type": "HAS_TYPE"}, {"src": "<getLength>", "dst": "<number:return>", "type": "RETURNS_TYPE", "metadata": {"originalType": "HAS_RETURN_TYPE"}}, {"src": "<getLength>", "dst": "<item.length>", "type": "RETURNS"}, {"src": "<item.length>", "dst": "<item>", "type": "READS_FROM"}], "rationale": "Generic function with type parameter T constrained to objects with length property. Type constraint ensures safe property access. [merge-map applied]", "implicitBehavior": ["TypeScript compiler enforces constraint at call sites", "Type parameter T is inferred from argument type when possible"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::generic-default", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 135, "lineEnd": 138, "code": "function createArray<T = string>(length: number, fill: T): T[] {\n  return Array(length).fill(fill);\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<createArray>", "metadata": {"async": false, "generator": false, "generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"hasDefault": true, "defaultType": "string"}}, {"type": "PARAMETER", "id": "<length>", "metadata": {"type": "number"}}, {"type": "PARAMETER", "id": "<fill>", "metadata": {"type": "T"}}, {"type": "CALL", "id": "<Array(length)>", "metadata": {"callee": "Array"}}, {"type": "CALL", "id": "<Array(length).fill(fill)>", "metadata": {"callee": "fill"}}], "edges": [{"src": "<module>", "dst": "<createArray>", "type": "DECLARES"}, {"src": "<createArray>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<createArray>", "dst": "<length>", "type": "CONTAINS"}, {"src": "<createArray>", "dst": "<fill>", "type": "CONTAINS"}, {"src": "<fill>", "dst": "<T>", "type": "HAS_TYPE"}, {"src": "<createArray>", "dst": "<Array(length).fill(fill)>", "type": "RETURNS"}, {"src": "<Array(length)>", "dst": "<Array>", "type": "CALLS"}, {"src": "<Array(length)>", "dst": "<length>", "type": "PASSES_ARGUMENT"}, {"src": "<Array(length).fill(fill)>", "dst": "<Array(length)>", "type": "CALLS"}, {"src": "<Array(length).fill(fill)>", "dst": "<fill>", "type": "PASSES_ARGUMENT"}], "rationale": "Generic function with default type parameter. Type parameter T defaults to string, parameter fill is typed as T, return type is T[]. [merge-map applied]", "implicitBehavior": ["type parameter T defaults to string when not explicitly provided", "return type T[] is inferred from generic constraint"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::generic-interface", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 123, "lineEnd": 128, "code": "interface Repository<T> {\n  find(id: string): Promise<T>;\n  save(item: T): Promise<void>;\n  delete(id: string): Promise<boolean>;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "INTERFACE", "id": "<Repository>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "METHOD", "id": "<Repository.find>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<id>", "metadata": {"type": "string"}}, {"type": "TYPE_REFERENCE", "id": "<Promise<T>>", "metadata": {"generic": true, "baseType": "Promise", "originalType": "TYPE"}}, {"type": "METHOD", "id": "<Repository.save>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<item>", "metadata": {"type": "T"}}, {"type": "TYPE_REFERENCE", "id": "<Promise<void>>", "metadata": {"generic": true, "baseType": "Promise", "originalType": "TYPE"}}, {"type": "METHOD", "id": "<Repository.delete>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<id2>", "metadata": {"type": "string"}}, {"type": "TYPE_REFERENCE", "id": "<Promise<boolean>>", "metadata": {"generic": true, "baseType": "Promise", "originalType": "TYPE"}}], "edges": [{"src": "<module>", "dst": "<Repository>", "type": "DECLARES"}, {"src": "<Repository>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Repository>", "dst": "<Repository.find>", "type": "CONTAINS"}, {"src": "<Repository>", "dst": "<Repository.save>", "type": "CONTAINS"}, {"src": "<Repository>", "dst": "<Repository.delete>", "type": "CONTAINS"}, {"src": "<Repository.find>", "dst": "<id>", "type": "CONTAINS"}, {"src": "<Repository.find>", "dst": "<Promise<T>>", "type": "RETURNS"}, {"src": "<Promise<T>>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER", "metadata": {"originalType": "PARAMETERIZED_BY"}}, {"src": "<Repository.save>", "dst": "<item>", "type": "CONTAINS"}, {"src": "<Repository.save>", "dst": "<Promise<void>>", "type": "RETURNS"}, {"src": "<item>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<Repository.delete>", "dst": "<id2>", "type": "CONTAINS"}, {"src": "<Repository.delete>", "dst": "<Promise<boolean>>", "type": "RETURNS"}], "rationale": "Generic interface with type parameter T. Contains three method signatures with typed parameters and Promise return types. [merge-map applied]", "implicitBehavior": ["structural typing - any object with matching shape satisfies interface", "type parameter T can be constrained or substituted at usage sites"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::satisfies", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 162, "lineEnd": 166, "code": "const theme = {\n  primary: '#007bff',\n  secondary: '#6c757d',\n} satisfies Record<string, string>;", "commentedOut": false}, "annotation": {"nodes": [{"type": "VARIABLE", "id": "<theme>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<{primary: '#007bff', secondary: '#6c757d'}>", "metadata": {"literalType": "object"}}, {"type": "LITERAL", "id": "<'#007bff'>", "metadata": {"value": "#007bff", "literalType": "string"}}, {"type": "LITERAL", "id": "<'#6c757d'>", "metadata": {"value": "#6c757d", "literalType": "string"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, string>>", "metadata": {"constraintType": "satisfies", "originalType": "TYPE_CONSTRAINT"}}], "edges": [{"src": "<module>", "dst": "<theme>", "type": "DECLARES"}, {"src": "<theme>", "dst": "<{primary: '#007bff', secondary: '#6c757d'}>", "type": "ASSIGNED_FROM"}, {"src": "<{primary: '#007bff', secondary: '#6c757d'}>", "dst": "<'#007bff'>", "type": "HAS_PROPERTY"}, {"src": "<{primary: '#007bff', secondary: '#6c757d'}>", "dst": "<'#6c757d'>", "type": "HAS_PROPERTY"}, {"src": "<{primary: '#007bff', secondary: '#6c757d'}>", "dst": "<Record<string, string>>", "type": "HAS_TYPE", "metadata": {"originalType": "SATISFIES_TYPE"}}], "rationale": "TypeScript satisfies operator constrains object literal to match type without widening. Object satisfies Record type constraint. [merge-map applied]", "implicitBehavior": ["type constraint validation at compile time", "preserves exact literal types instead of widening to string"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::type-assertion-as", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 140, "lineEnd": 145, "code": "function typeAssertions(value: unknown) {\n  const asString = value as string;\n  const angleBracket = <number>value;\n  return { asString, angleBracket };\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<typeAssertions>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<value>", "metadata": {"typeAnnotation": "unknown"}}, {"type": "VARIABLE", "id": "<asString>", "metadata": {"kind": "const"}}, {"type": "EXPRESSION", "id": "<value as string>", "metadata": {"assertionType": "as", "targetType": "string", "originalType": "TYPE_ASSERTION"}}, {"type": "VARIABLE", "id": "<angleBracket>", "metadata": {"kind": "const"}}, {"type": "EXPRESSION", "id": "<<number>value>", "metadata": {"assertionType": "angle-bracket", "targetType": "number", "originalType": "TYPE_ASSERTION"}}, {"type": "EXPRESSION", "id": "<{ asString, angleBracket }>", "metadata": {"expressionType": "object-literal"}}], "edges": [{"src": "<module>", "dst": "<typeAssertions>", "type": "DECLARES"}, {"src": "<typeAssertions>", "dst": "<value>", "type": "CONTAINS"}, {"src": "<typeAssertions>", "dst": "<asString>", "type": "DECLARES"}, {"src": "<typeAssertions>", "dst": "<angleBracket>", "type": "DECLARES"}, {"src": "<asString>", "dst": "<value as string>", "type": "ASSIGNED_FROM"}, {"src": "<value as string>", "dst": "<value>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_TYPE_OF"}}, {"src": "<angleBracket>", "dst": "<<number>value>", "type": "ASSIGNED_FROM"}, {"src": "<<number>value>", "dst": "<value>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_TYPE_OF"}}, {"src": "<typeAssertions>", "dst": "<{ asString, angleBracket }>", "type": "RETURNS"}, {"src": "<{ asString, angleBracket }>", "dst": "<asString>", "type": "READS_FROM"}, {"src": "<{ asString, angleBracket }>", "dst": "<angleBracket>", "type": "READS_FROM"}], "rationale": "Function with parameter typed as unknown. Two type assertions using different syntax (as and angle-bracket) create new typed views of the same value. Returns object literal reading both asserted variables. [merge-map applied]", "implicitBehavior": ["Type assertions bypass TypeScript's type checking at runtime", "Both assertion syntaxes are equivalent but angle-bracket syntax conflicts with JSX"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::non-null-assertion", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 147, "lineEnd": 151, "code": "function nonNullAssertion(map: Map<string, string>) {\n  const value = map.get('key')!;\n  return value.toUpperCase();\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<nonNullAssertion>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<map>", "metadata": {"tsType": "Map<string, string>"}}, {"type": "VARIABLE", "id": "<value>", "metadata": {"kind": "const"}}, {"type": "CALL", "id": "<map.get('key')>", "metadata": {"callee": "get"}}, {"type": "LITERAL", "id": "<'key'>", "metadata": {"value": "key", "literalType": "string"}}, {"type": "EXPRESSION", "id": "<map.get('key')!>", "metadata": {"operator": "!", "originalType": "TS_NON_NULL_ASSERTION"}}, {"type": "CALL", "id": "<value.toUpperCase()>", "metadata": {"callee": "toUpperCase"}}], "edges": [{"src": "<module>", "dst": "<nonNullAssertion>", "type": "DECLARES"}, {"src": "<nonNullAssertion>", "dst": "<map>", "type": "CONTAINS"}, {"src": "<nonNullAssertion>", "dst": "<value>", "type": "DECLARES"}, {"src": "<map.get('key')>", "dst": "<map>", "type": "CALLS"}, {"src": "<map.get('key')>", "dst": "<'key'>", "type": "PASSES_ARGUMENT"}, {"src": "<map.get('key')!>", "dst": "<map.get('key')>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_NON_NULL"}}, {"src": "<value>", "dst": "<map.get('key')!>", "type": "ASSIGNED_FROM"}, {"src": "<value.toUpperCase()>", "dst": "<value>", "type": "CALLS"}, {"src": "<nonNullAssertion>", "dst": "<value.toUpperCase()>", "type": "RETURNS"}], "rationale": "Function with TypeScript non-null assertion operator. The assertion wraps the method call result, telling TypeScript to treat it as non-null/undefined. [merge-map applied]", "implicitBehavior": ["TypeScript compiler removes non-null assertion at runtime", "Runtime error if assertion is wrong and value is null/undefined"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::access-modifiers", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 168, "lineEnd": 179, "code": "class Service {\n  public name: string;\n  protected config: Record<string, unknown>;\n  private secret: string;\n\n  constructor(name: string, secret: string) {\n    this.name = name;\n    this.config = {};\n    this.secret = secret;\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Service>"}, {"type": "PROPERTY", "id": "<Service.name>", "metadata": {"accessModifier": "public", "type": "string"}}, {"type": "PROPERTY", "id": "<Service.config>", "metadata": {"accessModifier": "protected", "type": "Record<string, unknown>"}}, {"type": "PROPERTY", "id": "<Service.secret>", "metadata": {"accessModifier": "private", "type": "string"}}, {"type": "METHOD", "id": "<Service.constructor>", "metadata": {"kind": "constructor"}}, {"type": "PARAMETER", "id": "<name>", "metadata": {"type": "string"}}, {"type": "PARAMETER", "id": "<secret>", "metadata": {"type": "string"}}, {"type": "PROPERTY_ACCESS", "id": "<this.name>"}, {"type": "PROPERTY_ACCESS", "id": "<this.config>"}, {"type": "PROPERTY_ACCESS", "id": "<this.secret>"}, {"type": "LITERAL", "id": "<{}>", "metadata": {"value": "{}", "literalType": "object"}}], "edges": [{"src": "<module>", "dst": "<Service>", "type": "DECLARES"}, {"src": "<Service>", "dst": "<Service.name>", "type": "CONTAINS"}, {"src": "<Service>", "dst": "<Service.config>", "type": "CONTAINS"}, {"src": "<Service>", "dst": "<Service.secret>", "type": "CONTAINS"}, {"src": "<Service>", "dst": "<Service.constructor>", "type": "CONTAINS"}, {"src": "<Service.constructor>", "dst": "<name>", "type": "CONTAINS"}, {"src": "<Service.constructor>", "dst": "<secret>", "type": "CONTAINS"}, {"src": "<Service.constructor>", "dst": "<this.name>", "type": "WRITES_TO"}, {"src": "<Service.constructor>", "dst": "<this.config>", "type": "WRITES_TO"}, {"src": "<Service.constructor>", "dst": "<this.secret>", "type": "WRITES_TO"}, {"src": "<this.name>", "dst": "<name>", "type": "ASSIGNED_FROM"}, {"src": "<this.config>", "dst": "<{}>", "type": "ASSIGNED_FROM"}, {"src": "<this.secret>", "dst": "<secret>", "type": "ASSIGNED_FROM"}], "rationale": "TypeScript class with explicit access modifiers on properties. Constructor initializes all properties with different visibility levels. [merge-map applied]", "implicitBehavior": ["public members accessible from anywhere", "protected members accessible from class and subclasses only", "private members accessible from this class only", "TypeScript compile-time access control (runtime has no enforcement)"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::generic-class", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 106, "lineEnd": 121, "code": "class Container<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n\n  map<U>(fn: (value: T) => U): Container<U> {\n    return new Container(fn(this.value));\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Container>", "metadata": {"generic": true, "typeParameters": ["T"]}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"scope": "class"}}, {"type": "PROPERTY", "id": "<Container.value>", "metadata": {"visibility": "private", "type": "T"}}, {"type": "METHOD", "id": "<Container.constructor>", "metadata": {"kind": "constructor"}}, {"type": "PARAMETER", "id": "<constructor.value>", "metadata": {"type": "T"}}, {"type": "PROPERTY_ACCESS", "id": "<this.value>", "metadata": {"objectName": "this"}}, {"type": "METHOD", "id": "<Container.getValue>", "metadata": {"kind": "method", "returnType": "T"}}, {"type": "METHOD", "id": "<Container.map>", "metadata": {"kind": "method", "generic": true, "typeParameters": ["U"], "returnType": "Container<U>"}}, {"type": "TYPE_PARAMETER", "id": "<U>", "metadata": {"scope": "method"}}, {"type": "PARAMETER", "id": "<map.fn>", "metadata": {"type": "(value: T) => U"}}, {"type": "CALL", "id": "<new Container(fn(this.value))>", "metadata": {"constructor": true}}, {"type": "CALL", "id": "<fn(this.value)>", "metadata": {"callee": "fn"}}], "edges": [{"src": "<module>", "dst": "<Container>", "type": "DECLARES"}, {"src": "<Container>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Container>", "dst": "<Container.value>", "type": "CONTAINS"}, {"src": "<Container>", "dst": "<Container.constructor>", "type": "CONTAINS"}, {"src": "<Container>", "dst": "<Container.getValue>", "type": "CONTAINS"}, {"src": "<Container>", "dst": "<Container.map>", "type": "CONTAINS"}, {"src": "<Container.value>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<Container.constructor>", "dst": "<constructor.value>", "type": "CONTAINS"}, {"src": "<constructor.value>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<this.value>", "dst": "<constructor.value>", "type": "ASSIGNED_FROM"}, {"src": "<Container.constructor>", "dst": "<this.value>", "type": "WRITES_TO"}, {"src": "<Container.getValue>", "dst": "<T>", "type": "RETURNS_TYPE"}, {"src": "<Container.getValue>", "dst": "<this.value>", "type": "RETURNS"}, {"src": "<Container.getValue>", "dst": "<this.value>", "type": "READS_FROM"}, {"src": "<Container.map>", "dst": "<U>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Container.map>", "dst": "<map.fn>", "type": "CONTAINS"}, {"src": "<map.fn>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "PARAMETER_TYPED_AS"}}, {"src": "<map.fn>", "dst": "<U>", "type": "RETURNS_TYPE"}, {"src": "<Container.map>", "dst": "<Container>", "type": "RETURNS_TYPE"}, {"src": "<Container.map>", "dst": "<U>", "type": "RETURNS_TYPE", "metadata": {"originalType": "RETURNS_GENERIC_TYPE"}}, {"src": "<Container.map>", "dst": "<new Container(fn(this.value))>", "type": "RETURNS"}, {"src": "<new Container(fn(this.value))>", "dst": "<Container>", "type": "CALLS", "metadata": {"originalType": "INSTANTIATES"}}, {"src": "<new Container(fn(this.value))>", "dst": "<fn(this.value)>", "type": "PASSES_ARGUMENT"}, {"src": "<fn(this.value)>", "dst": "<map.fn>", "type": "CALLS"}, {"src": "<fn(this.value)>", "dst": "<this.value>", "type": "PASSES_ARGUMENT"}, {"src": "<fn(this.value)>", "dst": "<this.value>", "type": "READS_FROM"}], "rationale": "Generic class with type parameter T. Contains private property, constructor, getter method, and generic map method with type parameter U. Type relationships captured through TYPED_AS and RETURNS_TYPE edges. [merge-map applied]", "implicitBehavior": ["Type parameter T is constrained to class scope", "Type parameter U is constrained to map method scope", "Generic type instantiation creates new type-specialized instances"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::decorator-class", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 224, "lineEnd": 228, "code": "function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<sealed>", "metadata": {"decorator": true, "async": false, "generator": false}}, {"type": "PARAMETER", "id": "<constructor>", "metadata": {"type": "Function"}}, {"type": "CALL", "id": "<Object.seal(constructor)>", "metadata": {"callee": "Object.seal"}}, {"type": "PROPERTY_ACCESS", "id": "<constructor.prototype>", "metadata": {"objectName": "constructor", "propertyName": "prototype"}}, {"type": "CALL", "id": "<Object.seal(constructor.prototype)>", "metadata": {"callee": "Object.seal"}}], "edges": [{"src": "<module>", "dst": "<sealed>", "type": "DECLARES"}, {"src": "<sealed>", "dst": "<constructor>", "type": "CONTAINS"}, {"src": "<sealed>", "dst": "<Object.seal(constructor)>", "type": "CONTAINS"}, {"src": "<sealed>", "dst": "<Object.seal(constructor.prototype)>", "type": "CONTAINS"}, {"src": "<Object.seal(constructor)>", "dst": "<Object.seal>", "type": "CALLS"}, {"src": "<Object.seal(constructor)>", "dst": "<constructor>", "type": "PASSES_ARGUMENT"}, {"src": "<Object.seal(constructor.prototype)>", "dst": "<Object.seal>", "type": "CALLS"}, {"src": "<Object.seal(constructor.prototype)>", "dst": "<constructor.prototype>", "type": "PASSES_ARGUMENT"}, {"src": "<constructor.prototype>", "dst": "<constructor>", "type": "READS_FROM"}], "rationale": "Decorator function that seals both a constructor and its prototype. Takes a Function parameter and makes two Object.seal calls with different targets. [merge-map applied]", "implicitBehavior": ["Object.seal prevents new properties from being added and marks existing properties as non-configurable", "Decorator pattern - function designed to be used with @sealed syntax in TypeScript"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::as-const", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 153, "lineEnd": 160, "code": "const config = {\n  api: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3,\n} as const;\n\nconst directions = ['up', 'down', 'left', 'right'] as const;", "commentedOut": false}, "annotation": {"nodes": [{"type": "VARIABLE", "id": "<config>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<config:object>", "metadata": {"readonly": true, "originalType": "OBJECT"}}, {"type": "PROPERTY", "id": "<config:object.api>", "metadata": {"key": "api", "readonly": true}}, {"type": "LITERAL", "id": "<'https://api.example.com'>", "metadata": {"value": "https://api.example.com", "literalType": "string"}}, {"type": "PROPERTY", "id": "<config:object.timeout>", "metadata": {"key": "timeout", "readonly": true}}, {"type": "LITERAL", "id": "<5000>", "metadata": {"value": 5000, "literalType": "number"}}, {"type": "PROPERTY", "id": "<config:object.retries>", "metadata": {"key": "retries", "readonly": true}}, {"type": "LITERAL", "id": "<3>", "metadata": {"value": 3, "literalType": "number"}}, {"type": "EXPRESSION", "id": "<config:as-const>", "metadata": {"assertionType": "const", "originalType": "TYPE_ASSERTION"}}, {"type": "VARIABLE", "id": "<directions>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<directions:array>", "metadata": {"readonly": true, "originalType": "ARRAY"}}, {"type": "LITERAL", "id": "<'up'>", "metadata": {"value": "up", "literalType": "string"}}, {"type": "LITERAL", "id": "<'down'>", "metadata": {"value": "down", "literalType": "string"}}, {"type": "LITERAL", "id": "<'left'>", "metadata": {"value": "left", "literalType": "string"}}, {"type": "LITERAL", "id": "<'right'>", "metadata": {"value": "right", "literalType": "string"}}, {"type": "EXPRESSION", "id": "<directions:as-const>", "metadata": {"assertionType": "const", "originalType": "TYPE_ASSERTION"}}], "edges": [{"src": "<module>", "dst": "<config>", "type": "DECLARES"}, {"src": "<config>", "dst": "<config:as-const>", "type": "ASSIGNED_FROM"}, {"src": "<config:as-const>", "dst": "<config:object>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_TYPE"}}, {"src": "<config:object>", "dst": "<config:object.api>", "type": "HAS_PROPERTY"}, {"src": "<config:object.api>", "dst": "<'https://api.example.com'>", "type": "ASSIGNED_FROM"}, {"src": "<config:object>", "dst": "<config:object.timeout>", "type": "HAS_PROPERTY"}, {"src": "<config:object.timeout>", "dst": "<5000>", "type": "ASSIGNED_FROM"}, {"src": "<config:object>", "dst": "<config:object.retries>", "type": "HAS_PROPERTY"}, {"src": "<config:object.retries>", "dst": "<3>", "type": "ASSIGNED_FROM"}, {"src": "<module>", "dst": "<directions>", "type": "DECLARES"}, {"src": "<directions>", "dst": "<directions:as-const>", "type": "ASSIGNED_FROM"}, {"src": "<directions:as-const>", "dst": "<directions:array>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_TYPE"}}, {"src": "<directions:array>", "dst": "<'up'>", "type": "HAS_ELEMENT"}, {"src": "<directions:array>", "dst": "<'down'>", "type": "HAS_ELEMENT"}, {"src": "<directions:array>", "dst": "<'left'>", "type": "HAS_ELEMENT"}, {"src": "<directions:array>", "dst": "<'right'>", "type": "HAS_ELEMENT"}], "rationale": "TypeScript 'as const' assertions create readonly types. Each assertion is a type operation that makes the object/array deeply readonly with literal types. [merge-map applied]", "implicitBehavior": ["as const makes object properties readonly and infers literal types instead of widening to string/number", "array becomes readonly tuple with literal element types", "prevents type widening at compile time"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::decorator-usage", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 230, "lineEnd": 237, "code": "@sealed\nclass DecoratedClass {\n  @log\n  method() {\n    return 42;\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "DECORATOR", "id": "<@sealed>", "metadata": {"name": "sealed"}}, {"type": "CLASS", "id": "<DecoratedClass>"}, {"type": "DECORATOR", "id": "<@log>", "metadata": {"name": "log"}}, {"type": "METHOD", "id": "<DecoratedClass.method>", "metadata": {"kind": "method"}}, {"type": "LITERAL", "id": "<42>", "metadata": {"value": 42, "literalType": "number"}}], "edges": [{"src": "<module>", "dst": "<DecoratedClass>", "type": "DECLARES"}, {"src": "<@sealed>", "dst": "<DecoratedClass>", "type": "DECORATED_BY", "metadata": {"originalType": "DECORATES"}}, {"src": "<DecoratedClass>", "dst": "<DecoratedClass.method>", "type": "CONTAINS"}, {"src": "<@log>", "dst": "<DecoratedClass.method>", "type": "DECORATED_BY", "metadata": {"originalType": "DECORATES"}}, {"src": "<DecoratedClass.method>", "dst": "<42>", "type": "RETURNS"}, {"src": "<@sealed>", "dst": "<sealed>", "type": "CALLS"}, {"src": "<@log>", "dst": "<log>", "type": "CALLS"}], "rationale": "Class decorator @sealed modifies the class, method decorator @log modifies the method. Decorators are function calls that transform their targets. [merge-map applied]", "implicitBehavior": ["decorators execute at class definition time", "sealed decorator likely prevents class extension", "log decorator likely wraps method with logging behavior"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::parameter-properties", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 181, "lineEnd": 189, "code": "class ServiceWithParamProps {\n  constructor(\n    public name: string,\n    protected config: Record<string, unknown>,\n    private secret: string,\n    readonly id: number,\n  ) {}\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<ServiceWithParamProps>"}, {"type": "METHOD", "id": "<ServiceWithParamProps.constructor>", "metadata": {"kind": "constructor"}}, {"type": "PARAMETER", "id": "<name>", "metadata": {"visibility": "public", "type": "string"}}, {"type": "PARAMETER", "id": "<config>", "metadata": {"visibility": "protected", "type": "Record<string, unknown>"}}, {"type": "PARAMETER", "id": "<secret>", "metadata": {"visibility": "private", "type": "string"}}, {"type": "PARAMETER", "id": "<id>", "metadata": {"readonly": true, "type": "number"}}, {"type": "PROPERTY", "id": "<ServiceWithParamProps.name>", "metadata": {"visibility": "public", "type": "string"}}, {"type": "PROPERTY", "id": "<ServiceWithParamProps.config>", "metadata": {"visibility": "protected", "type": "Record<string, unknown>"}}, {"type": "PROPERTY", "id": "<ServiceWithParamProps.secret>", "metadata": {"visibility": "private", "type": "string"}}, {"type": "PROPERTY", "id": "<ServiceWithParamProps.id>", "metadata": {"readonly": true, "type": "number"}}], "edges": [{"src": "<module>", "dst": "<ServiceWithParamProps>", "type": "DECLARES"}, {"src": "<ServiceWithParamProps>", "dst": "<ServiceWithParamProps.constructor>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps.constructor>", "dst": "<name>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps.constructor>", "dst": "<config>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps.constructor>", "dst": "<secret>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps.constructor>", "dst": "<id>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps>", "dst": "<ServiceWithParamProps.name>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps>", "dst": "<ServiceWithParamProps.config>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps>", "dst": "<ServiceWithParamProps.secret>", "type": "CONTAINS"}, {"src": "<ServiceWithParamProps>", "dst": "<ServiceWithParamProps.id>", "type": "CONTAINS"}, {"src": "<name>", "dst": "<ServiceWithParamProps.name>", "type": "DECLARES", "metadata": {"originalType": "CREATES_PROPERTY"}}, {"src": "<config>", "dst": "<ServiceWithParamProps.config>", "type": "DECLARES", "metadata": {"originalType": "CREATES_PROPERTY"}}, {"src": "<secret>", "dst": "<ServiceWithParamProps.secret>", "type": "DECLARES", "metadata": {"originalType": "CREATES_PROPERTY"}}, {"src": "<id>", "dst": "<ServiceWithParamProps.id>", "type": "DECLARES", "metadata": {"originalType": "CREATES_PROPERTY"}}, {"src": "<ServiceWithParamProps.name>", "dst": "<name>", "type": "ASSIGNED_FROM"}, {"src": "<ServiceWithParamProps.config>", "dst": "<config>", "type": "ASSIGNED_FROM"}, {"src": "<ServiceWithParamProps.secret>", "dst": "<secret>", "type": "ASSIGNED_FROM"}, {"src": "<ServiceWithParamProps.id>", "dst": "<id>", "type": "ASSIGNED_FROM"}], "rationale": "TypeScript parameter properties automatically create class properties from constructor parameters. Each parameter creates a corresponding property with the same visibility and type. [merge-map applied]", "implicitBehavior": ["parameter properties automatically generate property declarations", "property assignments happen implicitly in constructor body", "visibility modifiers control property access"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::conditional-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 239, "lineEnd": 240, "code": "type IsString<T> = T extends string ? true : false;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<IsString>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "CONDITIONAL_TYPE", "id": "<T extends string ? true : false>", "metadata": {"checkType": "T", "extendsType": "string"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"primitive": true, "originalType": "TYPE"}}, {"type": "LITERAL_TYPE", "id": "<true>", "metadata": {"value": true, "literalType": "boolean"}}, {"type": "LITERAL_TYPE", "id": "<false>", "metadata": {"value": false, "literalType": "boolean"}}], "edges": [{"src": "<module>", "dst": "<IsString>", "type": "DECLARES"}, {"src": "<IsString>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<IsString>", "dst": "<T extends string ? true : false>", "type": "ASSIGNED_FROM"}, {"src": "<T extends string ? true : false>", "dst": "<T>", "type": "HAS_CONDITION", "metadata": {"originalType": "CHECKS_TYPE"}}, {"src": "<T extends string ? true : false>", "dst": "<string>", "type": "EXTENDS", "metadata": {"originalType": "EXTENDS_TYPE"}}, {"src": "<T extends string ? true : false>", "dst": "<true>", "type": "HAS_CONSEQUENT"}, {"src": "<T extends string ? true : false>", "dst": "<false>", "type": "HAS_ALTERNATE"}], "rationale": "Generic type alias with conditional type. Checks if type parameter T extends string, returning literal true/false types. [merge-map applied]", "implicitBehavior": ["type-level computation occurs at compile time", "distributive conditional type behavior over union types"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::decorator-method", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 215, "lineEnd": 222, "code": "function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey}`);\n    return original.apply(this, args);\n  };\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<log>", "metadata": {"decorator": true, "async": false, "generator": false}}, {"type": "PARAMETER", "id": "<target>", "metadata": {"type": "any"}}, {"type": "PARAMETER", "id": "<propertyKey>", "metadata": {"type": "string"}}, {"type": "PARAMETER", "id": "<descriptor>", "metadata": {"type": "PropertyDescriptor"}}, {"type": "VARIABLE", "id": "<original>", "metadata": {"kind": "const"}}, {"type": "PROPERTY_ACCESS", "id": "<descriptor.value>", "metadata": {"objectName": "descriptor"}}, {"type": "FUNCTION", "id": "<wrapper:fn>", "metadata": {"arrowFunction": false, "anonymous": true}}, {"type": "PARAMETER", "id": "<args>", "metadata": {"type": "any[]", "restParameter": true}}, {"type": "CALL", "id": "<console.log>", "metadata": {"callee": "console.log"}}, {"type": "EXPRESSION", "id": "<template-literal>", "metadata": {"type": "template-literal"}}, {"type": "CALL", "id": "<original.apply>", "metadata": {"callee": "original.apply"}}, {"type": "LITERAL", "id": "<this>", "metadata": {"value": "this", "literalType": "this"}}], "edges": [{"src": "<module>", "dst": "<log>", "type": "DECLARES"}, {"src": "<log>", "dst": "<target>", "type": "CONTAINS"}, {"src": "<log>", "dst": "<propertyKey>", "type": "CONTAINS"}, {"src": "<log>", "dst": "<descriptor>", "type": "CONTAINS"}, {"src": "<log>", "dst": "<original>", "type": "DECLARES"}, {"src": "<original>", "dst": "<descriptor.value>", "type": "ASSIGNED_FROM"}, {"src": "<descriptor.value>", "dst": "<descriptor>", "type": "READS_FROM"}, {"src": "<descriptor.value>", "dst": "<wrapper:fn>", "type": "ASSIGNED_FROM"}, {"src": "<wrapper:fn>", "dst": "<args>", "type": "CONTAINS"}, {"src": "<wrapper:fn>", "dst": "<console.log>", "type": "CONTAINS"}, {"src": "<console.log>", "dst": "<template-literal>", "type": "PASSES_ARGUMENT"}, {"src": "<template-literal>", "dst": "<propertyKey>", "type": "READS_FROM"}, {"src": "<wrapper:fn>", "dst": "<original.apply>", "type": "RETURNS"}, {"src": "<original.apply>", "dst": "<original>", "type": "CALLS"}, {"src": "<original.apply>", "dst": "<this>", "type": "PASSES_ARGUMENT"}, {"src": "<original.apply>", "dst": "<args>", "type": "PASSES_ARGUMENT"}], "rationale": "TypeScript decorator function that wraps method calls with logging. Creates a wrapper function that logs method name before calling original implementation. [merge-map applied]", "implicitBehavior": ["decorator applied at compile time to target methods", "PropertyDescriptor mutation affects method behavior", "this context preserved through apply"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::conditional-type-infer", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 242, "lineEnd": 243, "code": "type UnpackPromise<T> = T extends Promise<infer U> ? U : T;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<UnpackPromise>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "CONDITIONAL_TYPE", "id": "<T extends Promise<infer U> ? U : T>"}, {"type": "TYPE_REFERENCE", "id": "<T extends Promise<infer U>>", "metadata": {"originalType": "TYPE_CONSTRAINT"}}, {"type": "TYPE_REFERENCE", "id": "<Promise<infer U>>", "metadata": {"originalType": "GENERIC_TYPE"}}, {"type": "INFER_TYPE", "id": "<infer U>", "metadata": {"originalType": "INFERRED_TYPE"}}, {"type": "TYPE_PARAMETER", "id": "<U>", "metadata": {"inferred": true}}, {"type": "TYPE_REFERENCE", "id": "<U:true-branch>"}, {"type": "TYPE_REFERENCE", "id": "<T:false-branch>"}], "edges": [{"src": "<module>", "dst": "<UnpackPromise>", "type": "DECLARES"}, {"src": "<UnpackPromise>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<UnpackPromise>", "dst": "<T extends Promise<infer U> ? U : T>", "type": "ASSIGNED_FROM"}, {"src": "<T extends Promise<infer U> ? U : T>", "dst": "<T extends Promise<infer U>>", "type": "HAS_CONDITION"}, {"src": "<T extends Promise<infer U>>", "dst": "<T>", "type": "HAS_CONDITION", "metadata": {"originalType": "CHECKS_TYPE"}}, {"src": "<T extends Promise<infer U>>", "dst": "<Promise<infer U>>", "type": "EXTENDS", "metadata": {"originalType": "EXTENDS_TYPE"}}, {"src": "<Promise<infer U>>", "dst": "<infer U>", "type": "HAS_TYPE", "metadata": {"originalType": "HAS_TYPE_ARGUMENT"}}, {"src": "<infer U>", "dst": "<U>", "type": "INFERS"}, {"src": "<T extends Promise<infer U> ? U : T>", "dst": "<U:true-branch>", "type": "HAS_CONSEQUENT"}, {"src": "<T extends Promise<infer U> ? U : T>", "dst": "<T:false-branch>", "type": "HAS_ALTERNATE"}, {"src": "<U:true-branch>", "dst": "<U>", "type": "READS_FROM", "metadata": {"originalType": "REFERENCES"}}, {"src": "<T:false-branch>", "dst": "<T>", "type": "READS_FROM", "metadata": {"originalType": "REFERENCES"}}], "rationale": "Conditional type with type inference. The condition checks if T extends Promise<U> and infers U, returning U if true or T if false. [merge-map applied]", "implicitBehavior": ["Type inference creates new type variable U in scope of true branch", "Conditional type is distributive over union types"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::conditional-type-exclude", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 245, "lineEnd": 246, "code": "type StrictNonNull<T> = T extends null | undefined ? never : T;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<StrictNonNull>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": null}}, {"type": "CONDITIONAL_TYPE", "id": "<T extends null | undefined ? never : T>", "metadata": {"condition": "T extends null | undefined"}}, {"type": "TYPE_ALIAS", "id": "<null | undefined>", "metadata": {"members": ["null", "undefined"], "originalType": "TYPE_UNION"}}, {"type": "LITERAL_TYPE", "id": "<null>", "metadata": {"value": "null", "originalType": "TYPE_LITERAL"}}, {"type": "LITERAL_TYPE", "id": "<undefined>", "metadata": {"value": "undefined", "originalType": "TYPE_LITERAL"}}, {"type": "LITERAL_TYPE", "id": "<never>", "metadata": {"value": "never", "originalType": "TYPE_LITERAL"}}], "edges": [{"src": "<module>", "dst": "<StrictNonNull>", "type": "DECLARES"}, {"src": "<StrictNonNull>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<StrictNonNull>", "dst": "<T extends null | undefined ? never : T>", "type": "ASSIGNED_FROM"}, {"src": "<T extends null | undefined ? never : T>", "dst": "<T>", "type": "HAS_CONDITION", "metadata": {"originalType": "CHECKS_TYPE"}}, {"src": "<T extends null | undefined ? never : T>", "dst": "<null | undefined>", "type": "HAS_CONDITION", "metadata": {"originalType": "EXTENDS_CHECK"}}, {"src": "<null | undefined>", "dst": "<null>", "type": "CONTAINS"}, {"src": "<null | undefined>", "dst": "<undefined>", "type": "CONTAINS"}, {"src": "<T extends null | undefined ? never : T>", "dst": "<never>", "type": "HAS_CONSEQUENT"}, {"src": "<T extends null | undefined ? never : T>", "dst": "<T>", "type": "HAS_ALTERNATE"}], "rationale": "Generic type alias with conditional type that excludes null/undefined. Uses 'never' type to eliminate matching cases. [merge-map applied]", "implicitBehavior": ["TypeScript's structural type checking", "never type acts as bottom type in unions", "conditional type distributes over union types"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::mapped-type-readonly", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 248, "lineEnd": 249, "code": "type ReadonlyAll<T> = { readonly [K in keyof T]: T[K] };", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<ReadonlyAll>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "TYPE_ALIAS", "id": "<ReadonlyAll:mapped>", "metadata": {"readonly": true, "originalType": "MAPPED_TYPE"}}, {"type": "TYPE_PARAMETER", "id": "<K>", "metadata": {"mappedTypeKey": true}}, {"type": "TYPE_REFERENCE", "id": "<keyof T>", "metadata": {"originalType": "KEYOF_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<T[K]>", "metadata": {"originalType": "INDEXED_ACCESS_TYPE"}}], "edges": [{"src": "<module>", "dst": "<ReadonlyAll>", "type": "DECLARES"}, {"src": "<ReadonlyAll>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<ReadonlyAll>", "dst": "<ReadonlyAll:mapped>", "type": "ASSIGNED_FROM"}, {"src": "<ReadonlyAll:mapped>", "dst": "<K>", "type": "CONTAINS"}, {"src": "<K>", "dst": "<keyof T>", "type": "CONSTRAINED_BY"}, {"src": "<keyof T>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<ReadonlyAll:mapped>", "dst": "<T[K]>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_TO"}}, {"src": "<T[K]>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<T[K]>", "dst": "<K>", "type": "READS_FROM", "metadata": {"originalType": "INDEXED_BY"}}], "rationale": "Generic type alias defining a mapped type that makes all properties of T readonly. The mapped type iterates over keys of T, preserving their types. [merge-map applied]", "implicitBehavior": ["mapped type creates new object type structure", "readonly modifier prevents property mutation", "preserves optional/required property modifiers"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::abstract-class", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 191, "lineEnd": 213, "code": "abstract class Shape {\n  abstract area(): number;\n  abstract perimeter(): number;\n\n  describe(): string {\n    return `Area: ${this.area()}, Perimeter: ${this.perimeter()}`;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(private radius: number) {\n    super();\n  }\n\n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n\n  perimeter(): number {\n    return 2 * Math.PI * this.radius;\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Shape>", "metadata": {"abstract": true}}, {"type": "METHOD", "id": "<Shape.area>", "metadata": {"abstract": true, "returnType": "number"}}, {"type": "METHOD", "id": "<Shape.perimeter>", "metadata": {"abstract": true, "returnType": "number"}}, {"type": "METHOD", "id": "<Shape.describe>", "metadata": {"returnType": "string"}}, {"type": "EXPRESSION", "id": "<template-literal>", "metadata": {"type": "template-literal"}}, {"type": "CALL", "id": "<this.area()>", "metadata": {"callee": "area"}}, {"type": "CALL", "id": "<this.perimeter()>", "metadata": {"callee": "perimeter"}}, {"type": "CLASS", "id": "<Circle>"}, {"type": "METHOD", "id": "<Circle.constructor>", "metadata": {"kind": "constructor"}}, {"type": "PARAMETER", "id": "<radius>", "metadata": {"visibility": "private", "type": "number"}}, {"type": "CALL", "id": "<super()>", "metadata": {"callee": "super"}}, {"type": "METHOD", "id": "<Circle.area>", "metadata": {"returnType": "number", "implements": "Shape.area"}}, {"type": "EXPRESSION", "id": "<Math.PI * this.radius ** 2>", "metadata": {"operator": "**"}}, {"type": "PROPERTY_ACCESS", "id": "<Math.PI>"}, {"type": "PROPERTY_ACCESS", "id": "<this.radius>"}, {"type": "METHOD", "id": "<Circle.perimeter>", "metadata": {"returnType": "number", "implements": "Shape.perimeter"}}, {"type": "EXPRESSION", "id": "<2 * Math.PI * this.radius>", "metadata": {"operator": "*"}}, {"type": "LITERAL", "id": "<2>", "metadata": {"value": 2, "literalType": "number"}}], "edges": [{"src": "<module>", "dst": "<Shape>", "type": "DECLARES"}, {"src": "<Shape>", "dst": "<Shape.area>", "type": "CONTAINS"}, {"src": "<Shape>", "dst": "<Shape.perimeter>", "type": "CONTAINS"}, {"src": "<Shape>", "dst": "<Shape.describe>", "type": "CONTAINS"}, {"src": "<Shape.describe>", "dst": "<template-literal>", "type": "RETURNS"}, {"src": "<template-literal>", "dst": "<this.area()>", "type": "CONTAINS"}, {"src": "<template-literal>", "dst": "<this.perimeter()>", "type": "CONTAINS"}, {"src": "<this.area()>", "dst": "<Shape.area>", "type": "CALLS"}, {"src": "<this.perimeter()>", "dst": "<Shape.perimeter>", "type": "CALLS"}, {"src": "<module>", "dst": "<Circle>", "type": "DECLARES"}, {"src": "<Circle>", "dst": "<Shape>", "type": "EXTENDS"}, {"src": "<Circle>", "dst": "<Circle.constructor>", "type": "CONTAINS"}, {"src": "<Circle.constructor>", "dst": "<radius>", "type": "CONTAINS"}, {"src": "<Circle.constructor>", "dst": "<super()>", "type": "CONTAINS"}, {"src": "<super()>", "dst": "<Shape>", "type": "CALLS"}, {"src": "<Circle>", "dst": "<Circle.area>", "type": "CONTAINS"}, {"src": "<Circle.area>", "dst": "<Shape.area>", "type": "IMPLEMENTS"}, {"src": "<Circle.area>", "dst": "<Math.PI * this.radius ** 2>", "type": "RETURNS"}, {"src": "<Math.PI * this.radius ** 2>", "dst": "<Math.PI>", "type": "READS_FROM"}, {"src": "<Math.PI * this.radius ** 2>", "dst": "<this.radius>", "type": "READS_FROM"}, {"src": "<this.radius>", "dst": "<radius>", "type": "READS_FROM"}, {"src": "<Circle>", "dst": "<Circle.perimeter>", "type": "CONTAINS"}, {"src": "<Circle.perimeter>", "dst": "<Shape.perimeter>", "type": "IMPLEMENTS"}, {"src": "<Circle.perimeter>", "dst": "<2 * Math.PI * this.radius>", "type": "RETURNS"}, {"src": "<2 * Math.PI * this.radius>", "dst": "<2>", "type": "READS_FROM"}, {"src": "<2 * Math.PI * this.radius>", "dst": "<Math.PI>", "type": "READS_FROM"}, {"src": "<2 * Math.PI * this.radius>", "dst": "<this.radius>", "type": "READS_FROM"}], "rationale": "Abstract class Shape defines abstract methods and concrete method. Circle extends Shape and implements the abstract methods. Constructor parameter is private field. [merge-map applied]", "implicitBehavior": ["abstract class cannot be instantiated directly", "abstract methods must be implemented by concrete subclasses", "private constructor parameter creates implicit property field", "super() call required in constructor of extending class"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::mapped-type-mutable", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 254, "lineEnd": 255, "code": "type Mutable<T> = { -readonly [K in keyof T]: T[K] };", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<Mutable>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "TYPE_ALIAS", "id": "<Mutable:mapped>", "metadata": {"removeReadonly": true, "originalType": "MAPPED_TYPE"}}, {"type": "TYPE_PARAMETER", "id": "<K>", "metadata": {"mappingVariable": true}}, {"type": "TYPE_REFERENCE", "id": "<keyof T>", "metadata": {"originalType": "KEYOF_OPERATOR"}}, {"type": "PROPERTY_ACCESS", "id": "<T[K]>", "metadata": {"originalType": "INDEXED_ACCESS"}}], "edges": [{"src": "<module>", "dst": "<Mutable>", "type": "DECLARES"}, {"src": "<Mutable>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<Mutable>", "dst": "<Mutable:mapped>", "type": "ASSIGNED_FROM"}, {"src": "<Mutable:mapped>", "dst": "<K>", "type": "CONTAINS"}, {"src": "<K>", "dst": "<keyof T>", "type": "ITERATES_OVER"}, {"src": "<keyof T>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<Mutable:mapped>", "dst": "<T[K]>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_TO"}}, {"src": "<T[K]>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<T[K]>", "dst": "<K>", "type": "READS_FROM"}], "rationale": "Generic type alias defining a mapped type that removes readonly modifiers. The mapped type iterates over keys of T, producing mutable properties. [merge-map applied]", "implicitBehavior": ["readonly modifier removal creates new type with same structure but mutable properties", "preserves optional/required status of original properties"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::mapped-type-optional", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 251, "lineEnd": 252, "code": "type Optional<T> = { [K in keyof T]?: T[K] };", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<Optional>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "TYPE_ALIAS", "id": "<Optional:mapped>", "metadata": {"modifier": "optional", "originalType": "MAPPED_TYPE"}}, {"type": "TYPE_PARAMETER", "id": "<K>", "metadata": {"mappingVariable": true}}, {"type": "TYPE_REFERENCE", "id": "<keyof T>", "metadata": {"originalType": "KEYOF_OPERATOR"}}, {"type": "PROPERTY_ACCESS", "id": "<T[K]>", "metadata": {"originalType": "INDEX_ACCESS"}}], "edges": [{"src": "<module>", "dst": "<Optional>", "type": "DECLARES"}, {"src": "<Optional>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<Optional>", "dst": "<Optional:mapped>", "type": "ASSIGNED_FROM"}, {"src": "<Optional:mapped>", "dst": "<K>", "type": "CONTAINS"}, {"src": "<K>", "dst": "<keyof T>", "type": "ITERATES_OVER"}, {"src": "<keyof T>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<Optional:mapped>", "dst": "<T[K]>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_TO"}}, {"src": "<T[K]>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<T[K]>", "dst": "<K>", "type": "READS_FROM", "metadata": {"originalType": "INDEXED_BY"}}], "rationale": "Generic type alias defining a mapped type that makes all properties of T optional. K iterates over keys of T, each property maps to T[K] with optional modifier. [merge-map applied]", "implicitBehavior": ["optional modifier (?) makes properties non-required", "mapped type creates new object type structure", "preserves original property types while changing optionality"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::template-literal-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 257, "lineEnd": 260, "code": "type EventName = 'click' | 'focus' | 'blur';\ntype OnEvent = `on${Capitalize<EventName>}`;\ntype CSSProperty = `${string}-${string}`;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<EventName>", "metadata": {"kind": "union"}}, {"type": "LITERAL_TYPE", "id": "<'click'>", "metadata": {"value": "click", "literalType": "string"}}, {"type": "LITERAL_TYPE", "id": "<'focus'>", "metadata": {"value": "focus", "literalType": "string"}}, {"type": "LITERAL_TYPE", "id": "<'blur'>", "metadata": {"value": "blur", "literalType": "string"}}, {"type": "TYPE_ALIAS", "id": "<OnEvent>", "metadata": {"kind": "template-literal"}}, {"type": "TYPE_REFERENCE", "id": "<`on${Capitalize<EventName>}`>", "metadata": {"prefix": "on", "originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<Capitalize<EventName>>", "metadata": {"utility": "Capitalize", "originalType": "UTILITY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<CSSProperty>", "metadata": {"kind": "template-literal"}}, {"type": "TYPE_REFERENCE", "id": "<`${string}-${string}`>", "metadata": {"separator": "-", "originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"primitive": "string", "originalType": "PRIMITIVE_TYPE"}}], "edges": [{"src": "<module>", "dst": "<EventName>", "type": "DECLARES"}, {"src": "<EventName>", "dst": "<'click'>", "type": "UNION_MEMBER"}, {"src": "<EventName>", "dst": "<'focus'>", "type": "UNION_MEMBER"}, {"src": "<EventName>", "dst": "<'blur'>", "type": "UNION_MEMBER"}, {"src": "<module>", "dst": "<OnEvent>", "type": "DECLARES"}, {"src": "<OnEvent>", "dst": "<`on${Capitalize<EventName>}`>", "type": "ASSIGNED_FROM"}, {"src": "<`on${Capitalize<EventName>}`>", "dst": "<Capitalize<EventName>>", "type": "CONTAINS", "metadata": {"originalType": "TEMPLATE_SUBSTITUTION"}}, {"src": "<Capitalize<EventName>>", "dst": "<EventName>", "type": "DERIVES_FROM", "metadata": {"originalType": "TRANSFORMS"}}, {"src": "<module>", "dst": "<CSSProperty>", "type": "DECLARES"}, {"src": "<CSSProperty>", "dst": "<`${string}-${string}`>", "type": "ASSIGNED_FROM"}, {"src": "<`${string}-${string}`>", "dst": "<string>", "type": "CONTAINS", "metadata": {"originalType": "TEMPLATE_SUBSTITUTION"}}], "rationale": "Three type aliases: union of string literals, template literal type with utility transformation, and template literal with primitive string placeholders. [merge-map applied]", "implicitBehavior": ["template literal types generate all possible string combinations", "Capitalize utility type transforms first character to uppercase", "string primitive in template allows any string value"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::union-intersection", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 268, "lineEnd": 272, "code": "type StringOrNumber = string | number;\ntype ObjA = { a: string };\ntype ObjB = { b: number };\ntype Combined = ObjA & ObjB;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<StringOrNumber>", "metadata": {"kind": "union"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"primitive": true, "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number>", "metadata": {"primitive": true, "originalType": "TYPE"}}, {"type": "TYPE_ALIAS", "id": "<string | number>", "metadata": {"originalType": "UNION_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<ObjA>", "metadata": {"kind": "object"}}, {"type": "TYPE_REFERENCE", "id": "<{ a: string }>", "metadata": {"originalType": "OBJECT_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<a: string>", "metadata": {"propertyName": "a", "originalType": "PROPERTY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<ObjB>", "metadata": {"kind": "object"}}, {"type": "TYPE_REFERENCE", "id": "<{ b: number }>", "metadata": {"originalType": "OBJECT_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<b: number>", "metadata": {"propertyName": "b", "originalType": "PROPERTY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<Combined>", "metadata": {"kind": "intersection"}}, {"type": "TYPE_REFERENCE", "id": "<ObjA & ObjB>", "metadata": {"originalType": "INTERSECTION_TYPE"}}], "edges": [{"src": "<module>", "dst": "<StringOrNumber>", "type": "DECLARES"}, {"src": "<StringOrNumber>", "dst": "<string | number>", "type": "ASSIGNED_FROM"}, {"src": "<string | number>", "dst": "<string>", "type": "UNION_MEMBER"}, {"src": "<string | number>", "dst": "<number>", "type": "UNION_MEMBER"}, {"src": "<module>", "dst": "<ObjA>", "type": "DECLARES"}, {"src": "<ObjA>", "dst": "<{ a: string }>", "type": "ASSIGNED_FROM"}, {"src": "<{ a: string }>", "dst": "<a: string>", "type": "CONTAINS"}, {"src": "<a: string>", "dst": "<string>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<ObjB>", "type": "DECLARES"}, {"src": "<ObjB>", "dst": "<{ b: number }>", "type": "ASSIGNED_FROM"}, {"src": "<{ b: number }>", "dst": "<b: number>", "type": "CONTAINS"}, {"src": "<b: number>", "dst": "<number>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<Combined>", "type": "DECLARES"}, {"src": "<Combined>", "dst": "<ObjA & ObjB>", "type": "ASSIGNED_FROM"}, {"src": "<ObjA & ObjB>", "dst": "<ObjA>", "type": "INTERSECTS_WITH", "metadata": {"originalType": "INTERSECTION_MEMBER"}}, {"src": "<ObjA & ObjB>", "dst": "<ObjB>", "type": "INTERSECTS_WITH", "metadata": {"originalType": "INTERSECTION_MEMBER"}}], "rationale": "TypeScript type aliases defining union and intersection types. Union combines alternatives, intersection combines all properties from constituent types. [merge-map applied]", "implicitBehavior": ["union types require type narrowing for safe access", "intersection types merge all properties into single type", "structural typing applies to object type compatibility"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::type-guard-is", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 279, "lineEnd": 282, "code": "function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<isString>", "metadata": {"async": false, "generator": false, "typeGuard": true}}, {"type": "PARAMETER", "id": "<value>", "metadata": {"typeAnnotation": "unknown"}}, {"type": "TYPE_REFERENCE", "id": "<value is string>", "metadata": {"parameterName": "value", "predicateType": "string", "originalType": "TYPE_PREDICATE"}}, {"type": "EXPRESSION", "id": "<typeof value === 'string'>", "metadata": {"operator": "==="}}, {"type": "EXPRESSION", "id": "<typeof value>", "metadata": {"operator": "typeof"}}, {"type": "LITERAL", "id": "<'string'>", "metadata": {"value": "string", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<isString>", "type": "DECLARES"}, {"src": "<isString>", "dst": "<value>", "type": "CONTAINS"}, {"src": "<isString>", "dst": "<value is string>", "type": "HAS_TYPE", "metadata": {"originalType": "HAS_TYPE_PREDICATE"}}, {"src": "<isString>", "dst": "<typeof value === 'string'>", "type": "RETURNS"}, {"src": "<typeof value === 'string'>", "dst": "<typeof value>", "type": "READS_FROM"}, {"src": "<typeof value === 'string'>", "dst": "<'string'>", "type": "READS_FROM"}, {"src": "<typeof value>", "dst": "<value>", "type": "READS_FROM"}, {"src": "<value is string>", "dst": "<value>", "type": "HAS_TYPE", "metadata": {"originalType": "NARROWS_TYPE_OF"}}], "rationale": "TypeScript type guard function with type predicate return annotation. The function narrows the type of its parameter based on runtime check. [merge-map applied]", "implicitBehavior": ["TypeScript compiler uses return type predicate for control flow analysis", "When function returns true, TypeScript narrows parameter type in calling context"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::discriminated-union", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 274, "lineEnd": 277, "code": "type Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: Error };", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<Result>", "metadata": {"generic": true, "discriminated": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "TYPE_ALIAS", "id": "<Result:union>", "metadata": {"originalType": "UNION_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<success-case>", "metadata": {"discriminant": "success: true", "originalType": "OBJECT_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<success-case.success>", "metadata": {"required": true, "originalType": "PROPERTY_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<true>", "metadata": {"value": true, "literalType": "boolean"}}, {"type": "TYPE_REFERENCE", "id": "<success-case.data>", "metadata": {"required": true, "originalType": "PROPERTY_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<error-case>", "metadata": {"discriminant": "success: false", "originalType": "OBJECT_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<error-case.success>", "metadata": {"required": true, "originalType": "PROPERTY_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<false>", "metadata": {"value": false, "literalType": "boolean"}}, {"type": "TYPE_REFERENCE", "id": "<error-case.error>", "metadata": {"required": true, "originalType": "PROPERTY_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<Error>"}], "edges": [{"src": "<module>", "dst": "<Result>", "type": "DECLARES"}, {"src": "<Result>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Result>", "dst": "<Result:union>", "type": "RESOLVES_TO"}, {"src": "<Result:union>", "dst": "<success-case>", "type": "UNION_MEMBER", "metadata": {"originalType": "HAS_VARIANT"}}, {"src": "<Result:union>", "dst": "<error-case>", "type": "UNION_MEMBER", "metadata": {"originalType": "HAS_VARIANT"}}, {"src": "<success-case>", "dst": "<success-case.success>", "type": "HAS_PROPERTY"}, {"src": "<success-case>", "dst": "<success-case.data>", "type": "HAS_PROPERTY"}, {"src": "<success-case.success>", "dst": "<true>", "type": "HAS_TYPE"}, {"src": "<success-case.data>", "dst": "<T>", "type": "HAS_TYPE"}, {"src": "<error-case>", "dst": "<error-case.success>", "type": "HAS_PROPERTY"}, {"src": "<error-case>", "dst": "<error-case.error>", "type": "HAS_PROPERTY"}, {"src": "<error-case.success>", "dst": "<false>", "type": "HAS_TYPE"}, {"src": "<error-case.error>", "dst": "<Error>", "type": "HAS_TYPE"}], "rationale": "Discriminated union type with generic parameter. Two object variants distinguished by literal boolean values on 'success' property. [merge-map applied]", "implicitBehavior": ["TypeScript can narrow union types based on discriminant property checks", "Generic type parameter T is contravariant in data property"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::keyof-typeof", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 289, "lineEnd": 292, "code": "type UserKeys = keyof User;\nconst sampleUser = { name: 'Alice', age: 30 };\ntype InferredUser = typeof sampleUser;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<UserKeys>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<keyof User>", "metadata": {"operator": "keyof", "originalType": "TYPE_OPERATOR"}}, {"type": "TYPE_REFERENCE", "id": "<User>"}, {"type": "VARIABLE", "id": "<sampleUser>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<{ name: 'Alice', age: 30 }>", "metadata": {"originalType": "OBJECT_LITERAL"}}, {"type": "LITERAL", "id": "<'Alice'>", "metadata": {"value": "Alice", "literalType": "string"}}, {"type": "LITERAL", "id": "<30>", "metadata": {"value": 30, "literalType": "number"}}, {"type": "TYPE_ALIAS", "id": "<InferredUser>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<typeof sampleUser>", "metadata": {"operator": "typeof", "originalType": "TYPE_OPERATOR"}}], "edges": [{"src": "<module>", "dst": "<UserKeys>", "type": "DECLARES"}, {"src": "<UserKeys>", "dst": "<keyof User>", "type": "ASSIGNED_FROM"}, {"src": "<keyof User>", "dst": "<User>", "type": "READS_FROM", "metadata": {"originalType": "OPERATES_ON"}}, {"src": "<module>", "dst": "<sampleUser>", "type": "DECLARES"}, {"src": "<sampleUser>", "dst": "<{ name: 'Alice', age: 30 }>", "type": "ASSIGNED_FROM"}, {"src": "<{ name: 'Alice', age: 30 }>", "dst": "<'Alice'>", "type": "HAS_PROPERTY"}, {"src": "<{ name: 'Alice', age: 30 }>", "dst": "<30>", "type": "HAS_PROPERTY"}, {"src": "<module>", "dst": "<InferredUser>", "type": "DECLARES"}, {"src": "<InferredUser>", "dst": "<typeof sampleUser>", "type": "ASSIGNED_FROM"}, {"src": "<typeof sampleUser>", "dst": "<sampleUser>", "type": "READS_FROM", "metadata": {"originalType": "OPERATES_ON"}}], "rationale": "TypeScript type operations: keyof extracts property keys from a type, typeof infers type from a value. Both create new type aliases through type operators. [merge-map applied]", "implicitBehavior": ["keyof produces union of string literal types", "typeof performs structural type inference", "type aliases are compile-time only constructs"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::index-access-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 294, "lineEnd": 296, "code": "type UserName = User['name'];\ntype UserNameOrAge = User['name' | 'age'];", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<UserName>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<User['name']>", "metadata": {"objectType": "User", "indexType": "name", "originalType": "INDEX_ACCESS_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<UserNameOrAge>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<User['name' | 'age']>", "metadata": {"objectType": "User", "originalType": "INDEX_ACCESS_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<'name' | 'age'>", "metadata": {"unionMembers": ["name", "age"], "originalType": "UNION_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<'name'>", "metadata": {"value": "name", "literalType": "string"}}, {"type": "LITERAL_TYPE", "id": "<'age'>", "metadata": {"value": "age", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<UserName>", "type": "DECLARES"}, {"src": "<UserName>", "dst": "<User['name']>", "type": "ASSIGNED_FROM"}, {"src": "<User['name']>", "dst": "<User>", "type": "READS_FROM", "metadata": {"originalType": "INDEXES_INTO"}}, {"src": "<User['name']>", "dst": "<'name'>", "type": "READS_FROM", "metadata": {"originalType": "INDEXED_BY"}}, {"src": "<module>", "dst": "<UserNameOrAge>", "type": "DECLARES"}, {"src": "<UserNameOrAge>", "dst": "<User['name' | 'age']>", "type": "ASSIGNED_FROM"}, {"src": "<User['name' | 'age']>", "dst": "<User>", "type": "READS_FROM", "metadata": {"originalType": "INDEXES_INTO"}}, {"src": "<User['name' | 'age']>", "dst": "<'name' | 'age'>", "type": "READS_FROM", "metadata": {"originalType": "INDEXED_BY"}}, {"src": "<'name' | 'age'>", "dst": "<'name'>", "type": "CONTAINS"}, {"src": "<'name' | 'age'>", "dst": "<'age'>", "type": "CONTAINS"}], "rationale": "TypeScript index access types that extract property types from object types. First extracts single property, second uses union type to extract multiple properties. [merge-map applied]", "implicitBehavior": ["Type resolution occurs at compile time", "Index access with union produces union of accessed property types"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::namespace", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 298, "lineEnd": 307, "code": "namespace Validation {\n  export interface Schema {\n    validate(data: unknown): boolean;\n  }\n\n  export function createSchema(): Schema {\n    return { validate: () => true };\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "NAMESPACE", "id": "<Validation>", "metadata": {"exported": false}}, {"type": "INTERFACE", "id": "<Validation.Schema>", "metadata": {"exported": true}}, {"type": "METHOD", "id": "<Validation.Schema.validate>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<data>", "metadata": {"type": "unknown"}}, {"type": "FUNCTION", "id": "<Validation.createSchema>", "metadata": {"exported": true}}, {"type": "LITERAL", "id": "<{ validate: () => true }>", "metadata": {"literalType": "object"}}, {"type": "FUNCTION", "id": "<() => true>", "metadata": {"arrowFunction": true}}, {"type": "LITERAL", "id": "<true>", "metadata": {"value": true, "literalType": "boolean"}}], "edges": [{"src": "<module>", "dst": "<Validation>", "type": "DECLARES"}, {"src": "<Validation>", "dst": "<Validation.Schema>", "type": "CONTAINS"}, {"src": "<Validation>", "dst": "<Validation.createSchema>", "type": "CONTAINS"}, {"src": "<Validation.Schema>", "dst": "<Validation.Schema.validate>", "type": "CONTAINS"}, {"src": "<Validation.Schema.validate>", "dst": "<data>", "type": "CONTAINS"}, {"src": "<Validation.createSchema>", "dst": "<{ validate: () => true }>", "type": "RETURNS"}, {"src": "<{ validate: () => true }>", "dst": "<() => true>", "type": "HAS_PROPERTY"}, {"src": "<() => true>", "dst": "<true>", "type": "RETURNS"}, {"src": "<Validation.createSchema>", "dst": "<Validation.Schema>", "type": "RETURNS_TYPE"}], "rationale": "TypeScript namespace containing an exported interface and function. The function returns an object literal implementing the interface. [merge-map applied]", "implicitBehavior": ["namespace creates a merged declaration and value", "exported members are accessible via dot notation", "interface defines structural contract"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-import-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 338, "lineEnd": 342, "code": "// import type { User } from './types';\n// import { type Role, Permission } from './auth';\n// (commented out  no actual modules to import from, but syntax is valid)\ntype ImportedType = User;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<ImportedType>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<User>", "metadata": {"referencedType": "User"}}], "edges": [{"src": "<module>", "dst": "<ImportedType>", "type": "DECLARES"}, {"src": "<ImportedType>", "dst": "<User>", "type": "ASSIGNED_FROM"}], "rationale": "Type alias declaration that references an imported type. The User type is referenced but not declared in this module. [merge-map applied]", "implicitBehavior": ["TypeScript compiler will resolve User type reference at compile time", "Type-only imports are erased at runtime"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::type-guard-assertion", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 284, "lineEnd": 287, "code": "function hasName(obj: unknown): obj is { name: string } {\n  return typeof obj === 'object' && obj !== null && 'name' in obj;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<hasName>", "metadata": {"typeGuard": true}}, {"type": "PARAMETER", "id": "<obj>", "metadata": {"type": "unknown"}}, {"type": "TYPE_REFERENCE", "id": "<obj is { name: string }>", "metadata": {"predicateType": "type-guard", "originalType": "TYPE_PREDICATE"}}, {"type": "EXPRESSION", "id": "<typeof obj === 'object'>", "metadata": {"operator": "==="}}, {"type": "EXPRESSION", "id": "<obj !== null>", "metadata": {"operator": "!=="}}, {"type": "EXPRESSION", "id": "<'name' in obj>", "metadata": {"operator": "in"}}, {"type": "EXPRESSION", "id": "<guard-conjunction>", "metadata": {"operator": "&&"}}, {"type": "LITERAL", "id": "<'object'>", "metadata": {"value": "object", "literalType": "string"}}, {"type": "LITERAL", "id": "<null>", "metadata": {"value": null, "literalType": "null"}}, {"type": "LITERAL", "id": "<'name'>", "metadata": {"value": "name", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<hasName>", "type": "DECLARES"}, {"src": "<hasName>", "dst": "<obj>", "type": "CONTAINS"}, {"src": "<hasName>", "dst": "<obj is { name: string }>", "type": "HAS_TYPE", "metadata": {"originalType": "HAS_TYPE_PREDICATE"}}, {"src": "<hasName>", "dst": "<guard-conjunction>", "type": "RETURNS"}, {"src": "<guard-conjunction>", "dst": "<typeof obj === 'object'>", "type": "CONTAINS"}, {"src": "<guard-conjunction>", "dst": "<obj !== null>", "type": "CONTAINS"}, {"src": "<guard-conjunction>", "dst": "<'name' in obj>", "type": "CONTAINS"}, {"src": "<typeof obj === 'object'>", "dst": "<obj>", "type": "READS_FROM"}, {"src": "<typeof obj === 'object'>", "dst": "<'object'>", "type": "READS_FROM"}, {"src": "<obj !== null>", "dst": "<obj>", "type": "READS_FROM"}, {"src": "<obj !== null>", "dst": "<null>", "type": "READS_FROM"}, {"src": "<'name' in obj>", "dst": "<'name'>", "type": "READS_FROM"}, {"src": "<'name' in obj>", "dst": "<obj>", "type": "READS_FROM"}, {"src": "<obj is { name: string }>", "dst": "<obj>", "type": "HAS_TYPE", "metadata": {"originalType": "NARROWS_TYPE_OF"}}], "rationale": "TypeScript type guard function that narrows the type of its parameter. The return type predicate creates a type-level assertion that affects the parameter's type in calling contexts. [merge-map applied]", "implicitBehavior": ["TypeScript compiler uses return value to narrow obj type in calling scope", "Type predicate only applies when function returns true"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::function-overloads", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 318, "lineEnd": 323, "code": "function processInput(input: string): string;\nfunction processInput(input: number): number;\nfunction processInput(input: string | number): string | number {\n  return input;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "METHOD", "id": "<processInput:overload1>", "metadata": {"parameterTypes": ["string"], "returnType": "string", "originalType": "FUNCTION_OVERLOAD"}}, {"type": "METHOD", "id": "<processInput:overload2>", "metadata": {"parameterTypes": ["number"], "returnType": "number", "originalType": "FUNCTION_OVERLOAD"}}, {"type": "FUNCTION", "id": "<processInput>", "metadata": {"implementation": true, "parameterTypes": ["string | number"], "returnType": "string | number"}}, {"type": "PARAMETER", "id": "<input>", "metadata": {"type": "string | number"}}], "edges": [{"src": "<module>", "dst": "<processInput:overload1>", "type": "DECLARES"}, {"src": "<module>", "dst": "<processInput:overload2>", "type": "DECLARES"}, {"src": "<module>", "dst": "<processInput>", "type": "DECLARES"}, {"src": "<processInput>", "dst": "<processInput:overload1>", "type": "IMPLEMENTS_OVERLOAD"}, {"src": "<processInput>", "dst": "<processInput:overload2>", "type": "IMPLEMENTS_OVERLOAD"}, {"src": "<processInput>", "dst": "<input>", "type": "CONTAINS"}, {"src": "<processInput>", "dst": "<input>", "type": "RETURNS"}], "rationale": "TypeScript function overloads with implementation. Two overload signatures define specific type contracts, while the implementation function provides the actual runtime behavior. [merge-map applied]", "implicitBehavior": ["TypeScript compiler uses overload signatures for type checking at call sites", "Implementation signature is not visible to callers", "Overload resolution follows declaration order"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-export-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 344, "lineEnd": 346, "code": "export type { Admin };\n// export { type Status };  inline type export (already exported as value above)", "commentedOut": false}, "annotation": {"nodes": [{"type": "EXPORT", "id": "<export-type-Admin>", "metadata": {"exportType": "type-only", "exportKind": "named"}}, {"type": "TYPE_REFERENCE", "id": "<Admin>", "metadata": {"kind": "type", "originalType": "TYPE"}}], "edges": [{"src": "<module>", "dst": "<export-type-Admin>", "type": "CONTAINS"}, {"src": "<export-type-Admin>", "dst": "<Admin>", "type": "EXPORTS"}, {"src": "<module>", "dst": "<Admin>", "type": "EXPORTS", "metadata": {"originalType": "EXPORTS_TYPE"}}], "rationale": "TypeScript type-only export that re-exports a type definition. Creates export binding that only exists at compile time. [merge-map applied]", "implicitBehavior": ["type-only export is erased at runtime", "exported type must be defined elsewhere in module or imported"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-declare-const", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 348, "lineEnd": 349, "code": "declare const __VERSION__: string;", "commentedOut": false}, "annotation": {"nodes": [{"type": "VARIABLE", "id": "<__VERSION__>", "metadata": {"kind": "const", "declared": true, "tsType": "string"}}], "edges": [{"src": "<module>", "dst": "<__VERSION__>", "type": "DECLARES"}], "rationale": "TypeScript ambient declaration of a const variable. Declares the variable exists with string type but provides no implementation. [merge-map applied]", "implicitBehavior": ["ambient declaration - no runtime code generated", "type information available at compile time", "assumes external definition at runtime"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::tuple-types", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 262, "lineEnd": 266, "code": "type Point2D = [number, number];\ntype Point3D = [number, number, number];\ntype NamedTuple = [name: string, age: number];\ntype RestTuple = [string, ...number[]];", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<Point2D>", "metadata": {"kind": "tuple"}}, {"type": "TYPE_ALIAS", "id": "<Point2D:tuple>", "metadata": {"elementCount": 2, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number:0>", "metadata": {"typeName": "number", "position": 0}}, {"type": "TYPE_REFERENCE", "id": "<number:1>", "metadata": {"typeName": "number", "position": 1}}, {"type": "TYPE_ALIAS", "id": "<Point3D>", "metadata": {"kind": "tuple"}}, {"type": "TYPE_ALIAS", "id": "<Point3D:tuple>", "metadata": {"elementCount": 3, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number:0:3d>", "metadata": {"typeName": "number", "position": 0}}, {"type": "TYPE_REFERENCE", "id": "<number:1:3d>", "metadata": {"typeName": "number", "position": 1}}, {"type": "TYPE_REFERENCE", "id": "<number:2:3d>", "metadata": {"typeName": "number", "position": 2}}, {"type": "TYPE_ALIAS", "id": "<NamedTuple>", "metadata": {"kind": "tuple", "hasNamedElements": true}}, {"type": "TYPE_ALIAS", "id": "<NamedTuple:tuple>", "metadata": {"elementCount": 2, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<name>", "metadata": {"elementName": "name", "position": 0, "originalType": "TUPLE_ELEMENT"}}, {"type": "TYPE_REFERENCE", "id": "<string:named>", "metadata": {"typeName": "string"}}, {"type": "TYPE_REFERENCE", "id": "<age>", "metadata": {"elementName": "age", "position": 1, "originalType": "TUPLE_ELEMENT"}}, {"type": "TYPE_REFERENCE", "id": "<number:named>", "metadata": {"typeName": "number"}}, {"type": "TYPE_ALIAS", "id": "<RestTuple>", "metadata": {"kind": "tuple", "hasRestElement": true}}, {"type": "TYPE_ALIAS", "id": "<RestTuple:tuple>", "metadata": {"hasRestElement": true, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<string:rest>", "metadata": {"typeName": "string", "position": 0}}, {"type": "PARAMETER", "id": "<...number[]>", "metadata": {"position": 1, "originalType": "REST_ELEMENT"}}, {"type": "TYPE_REFERENCE", "id": "<number[]>", "metadata": {"elementType": "number", "originalType": "ARRAY_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number:array>", "metadata": {"typeName": "number"}}], "edges": [{"src": "<module>", "dst": "<Point2D>", "type": "DECLARES"}, {"src": "<Point2D>", "dst": "<Point2D:tuple>", "type": "DECLARES", "metadata": {"originalType": "DEFINES_TYPE"}}, {"src": "<Point2D:tuple>", "dst": "<number:0>", "type": "HAS_ELEMENT"}, {"src": "<Point2D:tuple>", "dst": "<number:1>", "type": "HAS_ELEMENT"}, {"src": "<module>", "dst": "<Point3D>", "type": "DECLARES"}, {"src": "<Point3D>", "dst": "<Point3D:tuple>", "type": "DECLARES", "metadata": {"originalType": "DEFINES_TYPE"}}, {"src": "<Point3D:tuple>", "dst": "<number:0:3d>", "type": "HAS_ELEMENT"}, {"src": "<Point3D:tuple>", "dst": "<number:1:3d>", "type": "HAS_ELEMENT"}, {"src": "<Point3D:tuple>", "dst": "<number:2:3d>", "type": "HAS_ELEMENT"}, {"src": "<module>", "dst": "<NamedTuple>", "type": "DECLARES"}, {"src": "<NamedTuple>", "dst": "<NamedTuple:tuple>", "type": "DECLARES", "metadata": {"originalType": "DEFINES_TYPE"}}, {"src": "<NamedTuple:tuple>", "dst": "<name>", "type": "HAS_ELEMENT"}, {"src": "<name>", "dst": "<string:named>", "type": "HAS_TYPE"}, {"src": "<NamedTuple:tuple>", "dst": "<age>", "type": "HAS_ELEMENT"}, {"src": "<age>", "dst": "<number:named>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<RestTuple>", "type": "DECLARES"}, {"src": "<RestTuple>", "dst": "<RestTuple:tuple>", "type": "DECLARES", "metadata": {"originalType": "DEFINES_TYPE"}}, {"src": "<RestTuple:tuple>", "dst": "<string:rest>", "type": "HAS_ELEMENT"}, {"src": "<RestTuple:tuple>", "dst": "<...number[]>", "type": "CONTAINS", "metadata": {"originalType": "HAS_REST_ELEMENT"}}, {"src": "<...number[]>", "dst": "<number[]>", "type": "SPREADS_FROM", "metadata": {"originalType": "SPREADS_TYPE"}}, {"src": "<number[]>", "dst": "<number:array>", "type": "CONTAINS", "metadata": {"originalType": "HAS_ELEMENT_TYPE"}}], "rationale": "TypeScript tuple type aliases with varying complexity. Point2D/3D are simple positional tuples, NamedTuple has labeled elements, RestTuple includes a rest element for variable-length tuples. [merge-map applied]", "implicitBehavior": ["tuple types enforce exact length and position-based typing", "named tuple elements provide better IDE support but don't affect runtime", "rest elements allow variable-length tuples with type constraints", "tuple types are structural - compatible tuples are assignable regardless of alias name"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-declare-function", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 351, "lineEnd": 352, "code": "declare function require(id: string): any;", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<require>", "metadata": {"declared": true, "ambient": true}}, {"type": "PARAMETER", "id": "<id>", "metadata": {"type": "string"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"primitive": true, "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<any>", "metadata": {"primitive": true, "originalType": "TYPE"}}], "edges": [{"src": "<module>", "dst": "<require>", "type": "DECLARES"}, {"src": "<require>", "dst": "<id>", "type": "CONTAINS"}, {"src": "<id>", "dst": "<string>", "type": "HAS_TYPE"}, {"src": "<require>", "dst": "<any>", "type": "RETURNS_TYPE"}], "rationale": "TypeScript ambient function declaration. Declares a function signature without implementation, with typed parameter and return type. [merge-map applied]", "implicitBehavior": ["ambient declaration assumes implementation exists at runtime", "function is available globally without import"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::class-implements", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 325, "lineEnd": 336, "code": "class UserImpl implements User, Printable {\n  constructor(\n    public name: string,\n    public age: number,\n    public readonly id: number,\n  ) {}\n\n  print(): void {\n    console.log(this.name);\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<UserImpl>"}, {"type": "INTERFACE", "id": "<User>"}, {"type": "INTERFACE", "id": "<Printable>"}, {"type": "METHOD", "id": "<UserImpl.constructor>", "metadata": {"kind": "constructor"}}, {"type": "PARAMETER", "id": "<name>", "metadata": {"visibility": "public", "type": "string"}}, {"type": "PARAMETER", "id": "<age>", "metadata": {"visibility": "public", "type": "number"}}, {"type": "PARAMETER", "id": "<id>", "metadata": {"visibility": "public", "readonly": true, "type": "number"}}, {"type": "METHOD", "id": "<UserImpl.print>", "metadata": {"kind": "method", "returnType": "void"}}, {"type": "CALL", "id": "<console.log(this.name)>", "metadata": {"callee": "console.log"}}, {"type": "PROPERTY_ACCESS", "id": "<this.name>", "metadata": {"objectName": "this"}}], "edges": [{"src": "<module>", "dst": "<UserImpl>", "type": "DECLARES"}, {"src": "<UserImpl>", "dst": "<User>", "type": "IMPLEMENTS"}, {"src": "<UserImpl>", "dst": "<Printable>", "type": "IMPLEMENTS"}, {"src": "<UserImpl>", "dst": "<UserImpl.constructor>", "type": "CONTAINS"}, {"src": "<UserImpl>", "dst": "<UserImpl.print>", "type": "CONTAINS"}, {"src": "<UserImpl.constructor>", "dst": "<name>", "type": "CONTAINS"}, {"src": "<UserImpl.constructor>", "dst": "<age>", "type": "CONTAINS"}, {"src": "<UserImpl.constructor>", "dst": "<id>", "type": "CONTAINS"}, {"src": "<UserImpl.print>", "dst": "<console.log(this.name)>", "type": "CONTAINS"}, {"src": "<console.log(this.name)>", "dst": "<console.log>", "type": "CALLS"}, {"src": "<console.log(this.name)>", "dst": "<this.name>", "type": "PASSES_ARGUMENT"}, {"src": "<this.name>", "dst": "<name>", "type": "READS_FROM"}], "rationale": "TypeScript class implementing multiple interfaces. Constructor parameters with visibility modifiers automatically create properties. Method implementation calls console.log with property access. [merge-map applied]", "implicitBehavior": ["public constructor parameters automatically create class properties", "TypeScript compile-time interface conformance checking", "this.name property created from public name parameter"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-declare-module", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 354, "lineEnd": 358, "code": "declare module '*.css' {\n  const content: Record<string, string>;\n  export default content;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "NAMESPACE", "id": "<declare-*.css>", "metadata": {"pattern": "*.css", "ambient": true, "originalType": "MODULE_DECLARATION"}}, {"type": "VARIABLE", "id": "<content>", "metadata": {"kind": "const"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, string>>", "metadata": {"typeExpression": "Record<string, string>", "originalType": "TYPE_ANNOTATION"}}, {"type": "EXPORT", "id": "<default-export>", "metadata": {"exportType": "default"}}], "edges": [{"src": "<module>", "dst": "<declare-*.css>", "type": "DECLARES"}, {"src": "<declare-*.css>", "dst": "<content>", "type": "CONTAINS"}, {"src": "<content>", "dst": "<Record<string, string>>", "type": "HAS_TYPE"}, {"src": "<declare-*.css>", "dst": "<default-export>", "type": "CONTAINS"}, {"src": "<default-export>", "dst": "<content>", "type": "EXPORTS"}], "rationale": "Ambient module declaration for CSS files. Declares a pattern-matched module containing a typed constant that is default exported. [merge-map applied]", "implicitBehavior": ["TypeScript compiler uses this for module resolution of .css imports", "Pattern matching applies to any file ending in .css", "Ambient declaration provides types without runtime implementation"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-declare-namespace", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 367, "lineEnd": 372, "code": "declare namespace NodeJS {\n  interface ProcessEnv {\n    NODE_ENV: 'development' | 'production';\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "NAMESPACE", "id": "<NodeJS>", "metadata": {"declared": true}}, {"type": "INTERFACE", "id": "<ProcessEnv>", "metadata": {"declared": true}}, {"type": "PROPERTY", "id": "<NODE_ENV>", "metadata": {"optional": false}}, {"type": "TYPE_ALIAS", "id": "<'development' | 'production'>", "metadata": {"unionMembers": ["'development'", "'production'"], "originalType": "UNION_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<'development'>", "metadata": {"value": "development", "literalType": "string"}}, {"type": "LITERAL_TYPE", "id": "<'production'>", "metadata": {"value": "production", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<NodeJS>", "type": "DECLARES"}, {"src": "<NodeJS>", "dst": "<ProcessEnv>", "type": "CONTAINS"}, {"src": "<ProcessEnv>", "dst": "<NODE_ENV>", "type": "CONTAINS"}, {"src": "<NODE_ENV>", "dst": "<'development' | 'production'>", "type": "HAS_TYPE"}, {"src": "<'development' | 'production'>", "dst": "<'development'>", "type": "CONTAINS"}, {"src": "<'development' | 'production'>", "dst": "<'production'>", "type": "CONTAINS"}], "rationale": "Ambient namespace declaration containing an interface with a property typed as a union of string literals. The declare keyword creates type-only declarations without runtime code. [merge-map applied]", "implicitBehavior": ["ambient declaration merges with existing NodeJS namespace if present", "no runtime code generated", "available globally in TypeScript compilation"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-declare-global", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 360, "lineEnd": 365, "code": "declare global {\n  interface Window {\n    __APP_STATE__: unknown;\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "EXPRESSION", "id": "<global-declaration>", "metadata": {"kind": "global", "ambient": true, "originalType": "DECLARATION"}}, {"type": "INTERFACE", "id": "<Window>", "metadata": {"augmentation": true, "global": true}}, {"type": "PROPERTY", "id": "<__APP_STATE__>", "metadata": {"type": "unknown"}}], "edges": [{"src": "<module>", "dst": "<global-declaration>", "type": "CONTAINS"}, {"src": "<global-declaration>", "dst": "<Window>", "type": "DECLARES"}, {"src": "<Window>", "dst": "<__APP_STATE__>", "type": "HAS_PROPERTY"}], "rationale": "TypeScript global declaration that augments the existing Window interface with a new property. Creates ambient type information without runtime code. [merge-map applied]", "implicitBehavior": ["merges with existing Window interface in global scope", "only affects TypeScript type checking, no runtime impact", "makes property available on window object globally"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-override", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 374, "lineEnd": 380, "code": "class BaseWithMethod {\n  greet() { return 'hello'; }\n}\nclass DerivedWithOverride extends BaseWithMethod {\n  override greet() { return 'hi'; }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<BaseWithMethod>"}, {"type": "METHOD", "id": "<BaseWithMethod.greet>", "metadata": {"kind": "method"}}, {"type": "LITERAL", "id": "<'hello'>", "metadata": {"value": "hello", "literalType": "string"}}, {"type": "CLASS", "id": "<DerivedWithOverride>"}, {"type": "METHOD", "id": "<DerivedWithOverride.greet>", "metadata": {"kind": "method", "override": true}}, {"type": "LITERAL", "id": "<'hi'>", "metadata": {"value": "hi", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<BaseWithMethod>", "type": "DECLARES"}, {"src": "<BaseWithMethod>", "dst": "<BaseWithMethod.greet>", "type": "CONTAINS"}, {"src": "<BaseWithMethod.greet>", "dst": "<'hello'>", "type": "RETURNS"}, {"src": "<module>", "dst": "<DerivedWithOverride>", "type": "DECLARES"}, {"src": "<DerivedWithOverride>", "dst": "<BaseWithMethod>", "type": "EXTENDS"}, {"src": "<DerivedWithOverride>", "dst": "<DerivedWithOverride.greet>", "type": "CONTAINS"}, {"src": "<DerivedWithOverride.greet>", "dst": "<BaseWithMethod.greet>", "type": "OVERRIDES"}, {"src": "<DerivedWithOverride.greet>", "dst": "<'hi'>", "type": "RETURNS"}], "rationale": "TypeScript class inheritance with explicit override annotation. The derived method overrides the base method with different return value. [merge-map applied]", "implicitBehavior": ["TypeScript compiler enforces override annotation matches actual override", "Runtime method resolution uses derived implementation"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::utility-types", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 309, "lineEnd": 316, "code": "type PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype PickedUser = Pick<User, 'name' | 'age'>;\ntype OmittedUser = Omit<User, 'email'>;\ntype UserRecord = Record<string, User>;\ntype ExtractedType = Extract<string | number | boolean, string | boolean>;\ntype ExcludedType = Exclude<string | number | boolean, boolean>;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<PartialUser>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Partial<User>>", "metadata": {"utilityName": "Partial", "originalType": "UTILITY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<RequiredUser>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Required<User>>", "metadata": {"utilityName": "Required", "originalType": "UTILITY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<PickedUser>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Pick<User, 'name' | 'age'>>", "metadata": {"utilityName": "Pick", "originalType": "UTILITY_TYPE"}}, {"type": "LITERAL", "id": "<'name'>", "metadata": {"value": "name", "literalType": "string"}}, {"type": "LITERAL", "id": "<'age'>", "metadata": {"value": "age", "literalType": "string"}}, {"type": "TYPE_ALIAS", "id": "<OmittedUser>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Omit<User, 'email'>>", "metadata": {"utilityName": "Omit", "originalType": "UTILITY_TYPE"}}, {"type": "LITERAL", "id": "<'email'>", "metadata": {"value": "email", "literalType": "string"}}, {"type": "TYPE_ALIAS", "id": "<UserRecord>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, User>>", "metadata": {"utilityName": "Record", "originalType": "UTILITY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<ExtractedType>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Extract<string | number | boolean, string | boolean>>", "metadata": {"utilityName": "Extract", "originalType": "UTILITY_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<string | number | boolean>", "metadata": {"unionMembers": ["string", "number", "boolean"], "originalType": "UNION_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<string | boolean>", "metadata": {"unionMembers": ["string", "boolean"], "originalType": "UNION_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<ExcludedType>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Exclude<string | number | boolean, boolean>>", "metadata": {"utilityName": "Exclude", "originalType": "UTILITY_TYPE"}}], "edges": [{"src": "<module>", "dst": "<PartialUser>", "type": "DECLARES"}, {"src": "<PartialUser>", "dst": "<Partial<User>>", "type": "ASSIGNED_FROM"}, {"src": "<Partial<User>>", "dst": "<User>", "type": "DERIVES_FROM", "metadata": {"originalType": "TRANSFORMS"}}, {"src": "<module>", "dst": "<RequiredUser>", "type": "DECLARES"}, {"src": "<RequiredUser>", "dst": "<Required<User>>", "type": "ASSIGNED_FROM"}, {"src": "<Required<User>>", "dst": "<User>", "type": "DERIVES_FROM", "metadata": {"originalType": "TRANSFORMS"}}, {"src": "<module>", "dst": "<PickedUser>", "type": "DECLARES"}, {"src": "<PickedUser>", "dst": "<Pick<User, 'name' | 'age'>>", "type": "ASSIGNED_FROM"}, {"src": "<Pick<User, 'name' | 'age'>>", "dst": "<User>", "type": "DERIVES_FROM", "metadata": {"originalType": "TRANSFORMS"}}, {"src": "<Pick<User, 'name' | 'age'>>", "dst": "<'name'>", "type": "READS_FROM", "metadata": {"originalType": "SELECTS_PROPERTY"}}, {"src": "<Pick<User, 'name' | 'age'>>", "dst": "<'age'>", "type": "READS_FROM", "metadata": {"originalType": "SELECTS_PROPERTY"}}, {"src": "<module>", "dst": "<OmittedUser>", "type": "DECLARES"}, {"src": "<OmittedUser>", "dst": "<Omit<User, 'email'>>", "type": "ASSIGNED_FROM"}, {"src": "<Omit<User, 'email'>>", "dst": "<User>", "type": "DERIVES_FROM", "metadata": {"originalType": "TRANSFORMS"}}, {"src": "<Omit<User, 'email'>>", "dst": "<'email'>", "type": "CONTAINS", "metadata": {"originalType": "EXCLUDES_PROPERTY"}}, {"src": "<module>", "dst": "<UserRecord>", "type": "DECLARES"}, {"src": "<UserRecord>", "dst": "<Record<string, User>>", "type": "ASSIGNED_FROM"}, {"src": "<Record<string, User>>", "dst": "<User>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_TO"}}, {"src": "<module>", "dst": "<ExtractedType>", "type": "DECLARES"}, {"src": "<ExtractedType>", "dst": "<Extract<string | number | boolean, string | boolean>>", "type": "ASSIGNED_FROM"}, {"src": "<Extract<string | number | boolean, string | boolean>>", "dst": "<string | number | boolean>", "type": "READS_FROM", "metadata": {"originalType": "EXTRACTS_FROM"}}, {"src": "<Extract<string | number | boolean, string | boolean>>", "dst": "<string | boolean>", "type": "HAS_CONDITION", "metadata": {"originalType": "MATCHES_AGAINST"}}, {"src": "<module>", "dst": "<ExcludedType>", "type": "DECLARES"}, {"src": "<ExcludedType>", "dst": "<Exclude<string | number | boolean, boolean>>", "type": "ASSIGNED_FROM"}, {"src": "<Exclude<string | number | boolean, boolean>>", "dst": "<string | number | boolean>", "type": "CONTAINS", "metadata": {"originalType": "EXCLUDES_FROM"}}], "rationale": "TypeScript utility types that transform existing types. Each utility type performs a specific transformation operation on the input type, with some taking additional parameters for property selection or exclusion. [merge-map applied]", "implicitBehavior": ["Partial makes all properties optional", "Required makes all properties required", "Pick creates new type with only selected properties", "Omit creates new type excluding specified properties", "Record creates mapped type with string keys", "Extract performs conditional type extraction", "Exclude performs conditional type exclusion"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-module-augmentation", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 404, "lineEnd": 409, "code": "declare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "NAMESPACE", "id": "<express-augmentation>", "metadata": {"targetModule": "express", "originalType": "MODULE_AUGMENTATION"}}, {"type": "INTERFACE", "id": "<Request-augmentation>", "metadata": {"name": "Request", "isAugmentation": true}}, {"type": "PROPERTY", "id": "<user>", "metadata": {"optional": true}}, {"type": "TYPE_REFERENCE", "id": "<user-type>", "metadata": {"kind": "object", "originalType": "TYPE"}}, {"type": "PROPERTY", "id": "<id>", "metadata": {"type": "string"}}, {"type": "PROPERTY", "id": "<role>", "metadata": {"type": "string"}}], "edges": [{"src": "<module>", "dst": "<express-augmentation>", "type": "DECLARES"}, {"src": "<express-augmentation>", "dst": "<Request-augmentation>", "type": "CONTAINS"}, {"src": "<Request-augmentation>", "dst": "<user>", "type": "CONTAINS"}, {"src": "<user>", "dst": "<user-type>", "type": "HAS_TYPE"}, {"src": "<user-type>", "dst": "<id>", "type": "CONTAINS"}, {"src": "<user-type>", "dst": "<role>", "type": "CONTAINS"}, {"src": "<express-augmentation>", "dst": "express", "type": "MERGES_WITH", "metadata": {"originalType": "AUGMENTS"}}], "rationale": "TypeScript module augmentation that extends the Express Request interface with an optional user property containing id and role fields. [merge-map applied]", "implicitBehavior": ["merges with existing Request interface in express module", "affects all imports of express.Request in the project", "ambient declaration - no runtime code generated"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-recursive-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 411, "lineEnd": 412, "code": "type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<JSONValue>", "metadata": {"recursive": true}}, {"type": "TYPE_ALIAS", "id": "<JSONValue:union>", "metadata": {"originalType": "UNION_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"originalType": "PRIMITIVE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number>", "metadata": {"originalType": "PRIMITIVE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<boolean>", "metadata": {"originalType": "PRIMITIVE_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<null>"}, {"type": "TYPE_REFERENCE", "id": "<JSONValue[]>", "metadata": {"originalType": "ARRAY_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<JSONValue:object>", "metadata": {"originalType": "OBJECT_TYPE"}}, {"type": "PROPERTY", "id": "<[key: string]: JSONValue>", "metadata": {"originalType": "INDEX_SIGNATURE"}}], "edges": [{"src": "<module>", "dst": "<JSONValue>", "type": "DECLARES"}, {"src": "<JSONValue>", "dst": "<JSONValue:union>", "type": "ASSIGNED_FROM"}, {"src": "<JSONValue:union>", "dst": "<string>", "type": "CONTAINS"}, {"src": "<JSONValue:union>", "dst": "<number>", "type": "CONTAINS"}, {"src": "<JSONValue:union>", "dst": "<boolean>", "type": "CONTAINS"}, {"src": "<JSONValue:union>", "dst": "<null>", "type": "CONTAINS"}, {"src": "<JSONValue:union>", "dst": "<JSONValue[]>", "type": "CONTAINS"}, {"src": "<JSONValue:union>", "dst": "<JSONValue:object>", "type": "CONTAINS"}, {"src": "<JSONValue[]>", "dst": "<JSONValue>", "type": "CONTAINS", "metadata": {"originalType": "ELEMENT_TYPE"}}, {"src": "<JSONValue:object>", "dst": "<[key: string]: JSONValue>", "type": "CONTAINS"}, {"src": "<[key: string]: JSONValue>", "dst": "<string>", "type": "HAS_TYPE", "metadata": {"originalType": "KEY_TYPE"}}, {"src": "<[key: string]: JSONValue>", "dst": "<JSONValue>", "type": "HAS_TYPE", "metadata": {"originalType": "VALUE_TYPE"}}, {"src": "<JSONValue>", "dst": "<JSONValue>", "type": "ALIASES", "metadata": {"originalType": "SELF_REFERENCES"}}], "rationale": "Recursive type alias defining a union of JSON-compatible types. The type references itself in both array element type and object value type, creating a self-referential structure. [merge-map applied]", "implicitBehavior": ["TypeScript compiler handles recursive type resolution", "Structural typing allows any matching shape to satisfy this type"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-const-type-param", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 387, "lineEnd": 391, "code": "function literal<const T>(value: T): T {\n  return value;\n}\nconst literalResult = literal({ x: 1, y: [2, 3] } as const);", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<literal>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": "const"}}, {"type": "PARAMETER", "id": "<value>", "metadata": {"type": "T"}}, {"type": "VARIABLE", "id": "<literalResult>", "metadata": {"kind": "const"}}, {"type": "CALL", "id": "<literal({ x: 1, y: [2, 3] } as const)>"}, {"type": "LITERAL", "id": "<{ x: 1, y: [2, 3] }>", "metadata": {"literalType": "object", "constAssertion": true}}, {"type": "LITERAL", "id": "<1>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "LITERAL", "id": "<[2, 3]>", "metadata": {"literalType": "array", "constAssertion": true}}, {"type": "LITERAL", "id": "<2>", "metadata": {"value": 2, "literalType": "number"}}, {"type": "LITERAL", "id": "<3>", "metadata": {"value": 3, "literalType": "number"}}], "edges": [{"src": "<module>", "dst": "<literal>", "type": "DECLARES"}, {"src": "<literal>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<literal>", "dst": "<value>", "type": "CONTAINS"}, {"src": "<value>", "dst": "<T>", "type": "HAS_TYPE"}, {"src": "<literal>", "dst": "<T>", "type": "RETURNS_TYPE"}, {"src": "<literal>", "dst": "<value>", "type": "RETURNS"}, {"src": "<module>", "dst": "<literalResult>", "type": "DECLARES"}, {"src": "<literalResult>", "dst": "<literal({ x: 1, y: [2, 3] } as const)>", "type": "ASSIGNED_FROM"}, {"src": "<literal({ x: 1, y: [2, 3] } as const)>", "dst": "<literal>", "type": "CALLS"}, {"src": "<literal({ x: 1, y: [2, 3] } as const)>", "dst": "<{ x: 1, y: [2, 3] }>", "type": "PASSES_ARGUMENT"}, {"src": "<{ x: 1, y: [2, 3] }>", "dst": "<1>", "type": "HAS_PROPERTY"}, {"src": "<{ x: 1, y: [2, 3] }>", "dst": "<[2, 3]>", "type": "HAS_PROPERTY"}, {"src": "<[2, 3]>", "dst": "<2>", "type": "HAS_ELEMENT"}, {"src": "<[2, 3]>", "dst": "<3>", "type": "HAS_ELEMENT"}], "rationale": "Generic function with const type parameter constraint that preserves literal types. The 'const' modifier on T ensures the type parameter captures the most specific literal type rather than widening to general types. [merge-map applied]", "implicitBehavior": ["const type parameter prevents type widening", "as const assertion creates readonly literal types", "type inference captures exact literal structure"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-variance-in-out", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 393, "lineEnd": 402, "code": "interface Producer<out T> {\n  produce(): T;\n}\ninterface Consumer<in T> {\n  consume(value: T): void;\n}\ninterface Transformer<in T, out U> {\n  transform(input: T): U;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "INTERFACE", "id": "<Producer>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<Producer.T>", "metadata": {"variance": "out", "covariant": true}}, {"type": "METHOD", "id": "<Producer.produce>", "metadata": {"returnType": "T"}}, {"type": "INTERFACE", "id": "<Consumer>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<Consumer.T>", "metadata": {"variance": "in", "contravariant": true}}, {"type": "METHOD", "id": "<Consumer.consume>", "metadata": {"returnType": "void"}}, {"type": "PARAMETER", "id": "<Consumer.consume.value>", "metadata": {"paramType": "T"}}, {"type": "INTERFACE", "id": "<Transformer>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<Transformer.T>", "metadata": {"variance": "in", "contravariant": true}}, {"type": "TYPE_PARAMETER", "id": "<Transformer.U>", "metadata": {"variance": "out", "covariant": true}}, {"type": "METHOD", "id": "<Transformer.transform>", "metadata": {"returnType": "U"}}, {"type": "PARAMETER", "id": "<Transformer.transform.input>", "metadata": {"paramType": "T"}}], "edges": [{"src": "<module>", "dst": "<Producer>", "type": "DECLARES"}, {"src": "<Producer>", "dst": "<Producer.T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Producer>", "dst": "<Producer.produce>", "type": "CONTAINS"}, {"src": "<Producer.produce>", "dst": "<Producer.T>", "type": "RETURNS_TYPE"}, {"src": "<module>", "dst": "<Consumer>", "type": "DECLARES"}, {"src": "<Consumer>", "dst": "<Consumer.T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Consumer>", "dst": "<Consumer.consume>", "type": "CONTAINS"}, {"src": "<Consumer.consume>", "dst": "<Consumer.consume.value>", "type": "CONTAINS"}, {"src": "<Consumer.consume.value>", "dst": "<Consumer.T>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<Transformer>", "type": "DECLARES"}, {"src": "<Transformer>", "dst": "<Transformer.T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Transformer>", "dst": "<Transformer.U>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<Transformer>", "dst": "<Transformer.transform>", "type": "CONTAINS"}, {"src": "<Transformer.transform>", "dst": "<Transformer.transform.input>", "type": "CONTAINS"}, {"src": "<Transformer.transform.input>", "dst": "<Transformer.T>", "type": "HAS_TYPE"}, {"src": "<Transformer.transform>", "dst": "<Transformer.U>", "type": "RETURNS_TYPE"}], "rationale": "TypeScript variance annotations control subtyping relationships. 'out' makes type parameters covariant (can substitute subtypes), 'in' makes them contravariant (can substitute supertypes). [merge-map applied]", "implicitBehavior": ["variance annotations affect assignability between generic types", "covariant 'out' parameters can only appear in output positions", "contravariant 'in' parameters can only appear in input positions", "TypeScript enforces variance position restrictions at compile time"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-asserts-guard", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 382, "lineEnd": 385, "code": "function assertDefined<T>(val: T | undefined): asserts val is T {\n  if (val === undefined) throw new Error('undefined');\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<assertDefined>", "metadata": {"async": false, "generator": false, "typeGuard": true, "assertsGuard": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"name": "T"}}, {"type": "PARAMETER", "id": "<val>", "metadata": {"name": "val"}}, {"type": "TYPE_REFERENCE", "id": "<T | undefined>", "metadata": {"kind": "union", "originalType": "TYPE_ANNOTATION"}}, {"type": "EXPRESSION", "id": "<asserts val is T>", "metadata": {"assertsType": "T", "assertsVariable": "val", "originalType": "TYPE_ASSERTION"}}, {"type": "BRANCH", "id": "<if-undefined-check>", "metadata": {"branchType": "if"}}, {"type": "EXPRESSION", "id": "<val === undefined>", "metadata": {"operator": "==="}}, {"type": "LITERAL", "id": "<undefined>", "metadata": {"value": "undefined", "literalType": "undefined"}}, {"type": "EXPRESSION", "id": "<throw-error>", "metadata": {"kind": "throw"}}, {"type": "CALL", "id": "<new Error('undefined')>", "metadata": {"callee": "Error", "constructor": true}}, {"type": "LITERAL", "id": "<'undefined'>", "metadata": {"value": "undefined", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<assertDefined>", "type": "DECLARES"}, {"src": "<assertDefined>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<assertDefined>", "dst": "<val>", "type": "CONTAINS"}, {"src": "<val>", "dst": "<T | undefined>", "type": "HAS_TYPE"}, {"src": "<assertDefined>", "dst": "<asserts val is T>", "type": "RETURNS"}, {"src": "<asserts val is T>", "dst": "<val>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_ABOUT"}}, {"src": "<asserts val is T>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "NARROWS_TO"}}, {"src": "<assertDefined>", "dst": "<if-undefined-check>", "type": "CONTAINS"}, {"src": "<if-undefined-check>", "dst": "<val === undefined>", "type": "HAS_CONDITION"}, {"src": "<val === undefined>", "dst": "<val>", "type": "READS_FROM"}, {"src": "<val === undefined>", "dst": "<undefined>", "type": "READS_FROM"}, {"src": "<if-undefined-check>", "dst": "<throw-error>", "type": "HAS_CONSEQUENT"}, {"src": "<throw-error>", "dst": "<new Error('undefined')>", "type": "THROWS"}, {"src": "<new Error('undefined')>", "dst": "<Error>", "type": "CALLS"}, {"src": "<new Error('undefined')>", "dst": "<'undefined'>", "type": "PASSES_ARGUMENT"}], "rationale": "TypeScript assertion function with generic type parameter. Uses 'asserts' return type to narrow the parameter type, throwing if assertion fails. [merge-map applied]", "implicitBehavior": ["TypeScript compiler uses asserts signature for control flow analysis", "After successful call, TypeScript narrows val from T | undefined to T", "Function never returns normally when assertion fails (throws instead)"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-recursive-type-tree", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 414, "lineEnd": 418, "code": "type TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<TreeNode>", "metadata": {"generic": true, "recursive": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": null}}, {"type": "TYPE_REFERENCE", "id": "<TreeNode:objectType>", "metadata": {"kind": "object", "originalType": "OBJECT_TYPE"}}, {"type": "PROPERTY", "id": "<value>", "metadata": {"required": true}}, {"type": "PROPERTY", "id": "<children>", "metadata": {"required": true}}, {"type": "TYPE_REFERENCE", "id": "<TreeNode<T>[]>", "metadata": {"elementType": "TreeNode<T>", "originalType": "ARRAY_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<TreeNode<T>:ref>", "metadata": {"typeArgs": ["T"]}}], "edges": [{"src": "<module>", "dst": "<TreeNode>", "type": "DECLARES"}, {"src": "<TreeNode>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<TreeNode>", "dst": "<TreeNode:objectType>", "type": "RESOLVES_TO"}, {"src": "<TreeNode:objectType>", "dst": "<value>", "type": "HAS_PROPERTY"}, {"src": "<TreeNode:objectType>", "dst": "<children>", "type": "HAS_PROPERTY"}, {"src": "<value>", "dst": "<T>", "type": "HAS_TYPE"}, {"src": "<children>", "dst": "<TreeNode<T>[]>", "type": "HAS_TYPE"}, {"src": "<TreeNode<T>[]>", "dst": "<TreeNode<T>:ref>", "type": "CONTAINS", "metadata": {"originalType": "HAS_ELEMENT_TYPE"}}, {"src": "<TreeNode<T>:ref>", "dst": "<TreeNode>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<TreeNode<T>:ref>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "INSTANTIATED_WITH"}}], "rationale": "Generic recursive type alias defining a tree structure. The type references itself in the children array, creating a self-referential type definition. [merge-map applied]", "implicitBehavior": ["TypeScript structural typing allows any object matching this shape", "Recursive type creates infinite depth possibility", "Generic parameter T can be instantiated with any type"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-import-assertions", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 488, "lineEnd": 491, "code": "// import data from './data.json' with { type: 'json' };\n// (commented out  import attributes syntax, requires runtime support)\ntype ImportedJSON = Record<string, unknown>;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<ImportedJSON>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, unknown>>", "metadata": {"generic": true, "typeArgs": ["string", "unknown"]}}], "edges": [{"src": "<module>", "dst": "<ImportedJSON>", "type": "DECLARES"}, {"src": "<ImportedJSON>", "dst": "<Record<string, unknown>>", "type": "ASSIGNED_FROM"}], "rationale": "Type alias declaration that creates a type binding for a generic Record type with string keys and unknown values. [merge-map applied]", "implicitBehavior": ["type exists only at compile time", "Record is a built-in TypeScript utility type"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-import-type-star", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 483, "lineEnd": 486, "code": "// import type * as AllTypes from './modules-helpers.js';\n// (commented out  no actual modules to import from, but syntax is valid)\ntype AllTypesPlaceholder = Record<string, unknown>;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<AllTypesPlaceholder>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, unknown>>", "metadata": {"utility": "Record", "keyType": "string", "valueType": "unknown", "originalType": "TYPE_EXPRESSION"}}], "edges": [{"src": "<module>", "dst": "<AllTypesPlaceholder>", "type": "DECLARES"}, {"src": "<AllTypesPlaceholder>", "dst": "<Record<string, unknown>>", "type": "ASSIGNED_FROM"}], "rationale": "Type alias declaration using TypeScript's Record utility type. The commented import would create a namespace binding for all exported types. [merge-map applied]", "implicitBehavior": ["type alias exists only at compile time", "Record utility type creates object type with string keys and unknown values"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-noinfer", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 475, "lineEnd": 481, "code": "function createFSM<S extends string>(config: {\n  initial: NoInfer<S>;\n  states: Record<S, object>;\n}) {\n  return config;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<createFSM>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<S>", "metadata": {"constraint": "string"}}, {"type": "PARAMETER", "id": "<config>", "metadata": {"hasTypeAnnotation": true}}, {"type": "TYPE_REFERENCE", "id": "<config:type>", "metadata": {"kind": "object", "originalType": "TYPE_ANNOTATION"}}, {"type": "PROPERTY", "id": "<initial>", "metadata": {"required": true}}, {"type": "TYPE_REFERENCE", "id": "<NoInfer<S>>", "metadata": {"utility": "NoInfer", "argument": "S", "originalType": "TYPE_UTILITY"}}, {"type": "PROPERTY", "id": "<states>", "metadata": {"required": true}}, {"type": "TYPE_REFERENCE", "id": "<Record<S, object>>", "metadata": {"utility": "Record", "keyType": "S", "valueType": "object", "originalType": "TYPE_ANNOTATION"}}], "edges": [{"src": "<module>", "dst": "<createFSM>", "type": "DECLARES"}, {"src": "<createFSM>", "dst": "<S>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<S>", "dst": "string", "type": "EXTENDS"}, {"src": "<createFSM>", "dst": "<config>", "type": "CONTAINS"}, {"src": "<config>", "dst": "<config:type>", "type": "HAS_TYPE"}, {"src": "<config:type>", "dst": "<initial>", "type": "HAS_PROPERTY"}, {"src": "<config:type>", "dst": "<states>", "type": "HAS_PROPERTY"}, {"src": "<initial>", "dst": "<NoInfer<S>>", "type": "HAS_TYPE"}, {"src": "<NoInfer<S>>", "dst": "<S>", "type": "CONTAINS", "metadata": {"originalType": "WRAPS_TYPE"}}, {"src": "<states>", "dst": "<Record<S, object>>", "type": "HAS_TYPE"}, {"src": "<Record<S, object>>", "dst": "<S>", "type": "HAS_TYPE", "metadata": {"originalType": "USES_TYPE"}}, {"src": "<createFSM>", "dst": "<config>", "type": "RETURNS"}], "rationale": "Generic function with type parameter S constrained to string. Parameter uses NoInfer utility type to prevent type inference from the initial property, while states uses Record utility type. [merge-map applied]", "implicitBehavior": ["NoInfer prevents TypeScript from inferring S from the initial property value", "Record<S, object> creates a mapped type where keys are of type S"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-template-literal-infer", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 420, "lineEnd": 426, "code": "type ParseRoute<T extends string> =\n  T extends `/${infer Segment}/${infer Rest}`\n    ? [Segment, ...ParseRoute<`/${Rest}`>]\n    : T extends `/${infer Segment}`\n      ? [Segment]\n      : [];", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<ParseRoute>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": "string"}}, {"type": "CONDITIONAL_TYPE", "id": "<ParseRoute-conditional>", "metadata": {"nested": true}}, {"type": "TYPE_REFERENCE", "id": "<`/${infer Segment}/${infer Rest}`>", "metadata": {"pattern": "/${infer Segment}/${infer Rest}", "originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "INFER_TYPE", "id": "<infer Segment>", "metadata": {"inferredName": "Segment"}}, {"type": "INFER_TYPE", "id": "<infer Rest>", "metadata": {"inferredName": "Rest"}}, {"type": "TYPE_ALIAS", "id": "<[Segment, ...ParseRoute<`/${Rest}`>]>", "metadata": {"hasSpread": true, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<ParseRoute<`/${Rest}`>>", "metadata": {"recursive": true, "originalType": "RECURSIVE_TYPE_CALL"}}, {"type": "TYPE_REFERENCE", "id": "<`/${Rest}`>", "metadata": {"pattern": "/${Rest}", "originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<`/${infer Segment}`>", "metadata": {"pattern": "/${infer Segment}", "originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "INFER_TYPE", "id": "<infer Segment-2>", "metadata": {"inferredName": "Segment"}}, {"type": "TYPE_ALIAS", "id": "<[Segment]>", "metadata": {"hasSpread": false, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<[]>", "metadata": {"empty": true, "originalType": "TUPLE_TYPE"}}], "edges": [{"src": "<module>", "dst": "<ParseRoute>", "type": "DECLARES"}, {"src": "<ParseRoute>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<ParseRoute>", "dst": "<ParseRoute-conditional>", "type": "ASSIGNED_FROM"}, {"src": "<ParseRoute-conditional>", "dst": "<T>", "type": "HAS_CONDITION", "metadata": {"originalType": "CHECKS_TYPE"}}, {"src": "<ParseRoute-conditional>", "dst": "<`/${infer Segment}/${infer Rest}`>", "type": "HAS_CONDITION", "metadata": {"originalType": "EXTENDS_CHECK"}}, {"src": "<`/${infer Segment}/${infer Rest}`>", "dst": "<infer Segment>", "type": "INFERS"}, {"src": "<`/${infer Segment}/${infer Rest}`>", "dst": "<infer Rest>", "type": "INFERS"}, {"src": "<ParseRoute-conditional>", "dst": "<[Segment, ...ParseRoute<`/${Rest}`>]>", "type": "HAS_CONSEQUENT"}, {"src": "<[Segment, ...ParseRoute<`/${Rest}`>]>", "dst": "<infer Segment>", "type": "READS_FROM", "metadata": {"originalType": "USES_INFERRED"}}, {"src": "<[Segment, ...ParseRoute<`/${Rest}`>]>", "dst": "<ParseRoute<`/${Rest}`>>", "type": "SPREADS_FROM", "metadata": {"originalType": "SPREADS"}}, {"src": "<ParseRoute<`/${Rest}`>>", "dst": "<ParseRoute>", "type": "CALLS"}, {"src": "<ParseRoute<`/${Rest}`>>", "dst": "<`/${Rest}`>", "type": "PASSES_ARGUMENT"}, {"src": "<`/${Rest}`>", "dst": "<infer Rest>", "type": "READS_FROM", "metadata": {"originalType": "USES_INFERRED"}}, {"src": "<ParseRoute-conditional>", "dst": "<`/${infer Segment}`>", "type": "HAS_CONDITION", "metadata": {"originalType": "EXTENDS_CHECK"}}, {"src": "<`/${infer Segment}`>", "dst": "<infer Segment-2>", "type": "INFERS"}, {"src": "<ParseRoute-conditional>", "dst": "<[Segment]>", "type": "HAS_ALTERNATE"}, {"src": "<[Segment]>", "dst": "<infer Segment-2>", "type": "READS_FROM", "metadata": {"originalType": "USES_INFERRED"}}, {"src": "<ParseRoute-conditional>", "dst": "<[]>", "type": "HAS_ALTERNATE"}], "rationale": "Recursive conditional type that parses URL path segments using template literal pattern matching. Uses infer to extract segments and recursively processes remaining path. [merge-map applied]", "implicitBehavior": ["TypeScript's structural type matching", "Template literal type inference", "Recursive type instantiation with termination condition", "Tuple type construction with spread operator"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-explicit-this-param", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 511, "lineEnd": 514, "code": "function onActivate(this: { name: string }, greeting: string): string {\n  return `${greeting}, ${this.name}`;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<onActivate>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<this>", "metadata": {"kind": "this", "typeAnnotation": "{ name: string }"}}, {"type": "PARAMETER", "id": "<greeting>", "metadata": {"typeAnnotation": "string"}}, {"type": "LITERAL", "id": "<template-literal>", "metadata": {"literalType": "template", "parts": ["", ", ", ""]}}, {"type": "PROPERTY_ACCESS", "id": "<this.name>", "metadata": {"objectName": "this", "propertyName": "name"}}], "edges": [{"src": "<module>", "dst": "<onActivate>", "type": "DECLARES"}, {"src": "<onActivate>", "dst": "<this>", "type": "CONTAINS"}, {"src": "<onActivate>", "dst": "<greeting>", "type": "CONTAINS"}, {"src": "<onActivate>", "dst": "<template-literal>", "type": "RETURNS"}, {"src": "<template-literal>", "dst": "<greeting>", "type": "READS_FROM"}, {"src": "<template-literal>", "dst": "<this.name>", "type": "READS_FROM"}, {"src": "<this.name>", "dst": "<this>", "type": "READS_FROM"}], "rationale": "TypeScript function with explicit this parameter type annotation. The this parameter constrains the calling context type, and the function returns a template literal that reads from both parameters. [merge-map applied]", "implicitBehavior": ["this parameter is compile-time only and doesn't affect runtime parameter count", "TypeScript enforces that function is called with compatible this context"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-exhaustive-never", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 461, "lineEnd": 473, "code": "type ShapeUnion = { kind: 'circle'; radius: number } | { kind: 'square'; side: number };\n\nfunction shapeArea(shape: ShapeUnion): number {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n    default: {\n      const _exhaustive: never = shape;\n      throw new Error(`Unknown shape: ${_exhaustive}`);\n    }\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<ShapeUnion>", "metadata": {"kind": "union"}}, {"type": "TYPE_REFERENCE", "id": "<circle-type>", "metadata": {"discriminant": "circle", "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<square-type>", "metadata": {"discriminant": "square", "originalType": "TYPE"}}, {"type": "FUNCTION", "id": "<shapeArea>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<shape>", "metadata": {"typeAnnotation": "ShapeUnion"}}, {"type": "BRANCH", "id": "<switch-shape.kind>", "metadata": {"discriminant": "shape.kind", "originalType": "SWITCH"}}, {"type": "CASE", "id": "<case-circle>", "metadata": {"value": "circle"}}, {"type": "CASE", "id": "<case-square>", "metadata": {"value": "square"}}, {"type": "CASE", "id": "<case-default>", "metadata": {"isDefault": true}}, {"type": "EXPRESSION", "id": "<Math.PI * shape.radius ** 2>", "metadata": {"operator": "*"}}, {"type": "EXPRESSION", "id": "<shape.side ** 2>", "metadata": {"operator": "**"}}, {"type": "VARIABLE", "id": "<_exhaustive>", "metadata": {"kind": "const", "typeAnnotation": "never"}}, {"type": "CALL", "id": "<throw new Error>", "metadata": {"callee": "Error", "isThrow": true}}, {"type": "LITERAL", "id": "<'Unknown shape: '>", "metadata": {"value": "Unknown shape: ", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<ShapeUnion>", "type": "DECLARES"}, {"src": "<ShapeUnion>", "dst": "<circle-type>", "type": "CONTAINS"}, {"src": "<ShapeUnion>", "dst": "<square-type>", "type": "CONTAINS"}, {"src": "<module>", "dst": "<shapeArea>", "type": "DECLARES"}, {"src": "<shapeArea>", "dst": "<shape>", "type": "CONTAINS"}, {"src": "<shape>", "dst": "<ShapeUnion>", "type": "HAS_TYPE"}, {"src": "<shapeArea>", "dst": "<switch-shape.kind>", "type": "CONTAINS"}, {"src": "<switch-shape.kind>", "dst": "<shape>", "type": "READS_FROM"}, {"src": "<switch-shape.kind>", "dst": "<case-circle>", "type": "HAS_CASE"}, {"src": "<switch-shape.kind>", "dst": "<case-square>", "type": "HAS_CASE"}, {"src": "<switch-shape.kind>", "dst": "<case-default>", "type": "HAS_DEFAULT"}, {"src": "<case-circle>", "dst": "<Math.PI * shape.radius ** 2>", "type": "RETURNS"}, {"src": "<case-square>", "dst": "<shape.side ** 2>", "type": "RETURNS"}, {"src": "<Math.PI * shape.radius ** 2>", "dst": "<shape>", "type": "READS_FROM"}, {"src": "<shape.side ** 2>", "dst": "<shape>", "type": "READS_FROM"}, {"src": "<case-default>", "dst": "<_exhaustive>", "type": "DECLARES"}, {"src": "<_exhaustive>", "dst": "<shape>", "type": "ASSIGNED_FROM"}, {"src": "<case-default>", "dst": "<throw new Error>", "type": "CONTAINS"}, {"src": "<throw new Error>", "dst": "<_exhaustive>", "type": "READS_FROM"}, {"src": "<throw new Error>", "dst": "<'Unknown shape: '>", "type": "PASSES_ARGUMENT"}], "rationale": "TypeScript exhaustiveness checking pattern using discriminated union. The never type assignment ensures compile-time verification that all union cases are handled. [merge-map applied]", "implicitBehavior": ["TypeScript compiler enforces that _exhaustive assignment is unreachable if all union cases are handled", "never type prevents compilation if new union variants are added without updating switch cases", "Discriminated union enables type narrowing in each case branch"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-this-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 440, "lineEnd": 459, "code": "class Builder {\n  private builderValue = 0;\n\n  add(n: number): this {\n    this.builderValue += n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.builderValue *= n;\n    return this;\n  }\n}\n\nclass AdvancedBuilder extends Builder {\n  negate(): this {\n    return this;\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Builder>"}, {"type": "PROPERTY", "id": "<Builder.builderValue>", "metadata": {"visibility": "private", "hasInitializer": true}}, {"type": "LITERAL", "id": "<0>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "METHOD", "id": "<Builder.add>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<n>", "metadata": {"type": "number"}}, {"type": "TYPE_REFERENCE", "id": "<this-return-type>", "metadata": {"type": "this", "originalType": "TYPE_ANNOTATION"}}, {"type": "EXPRESSION", "id": "<this.builderValue += n>", "metadata": {"operator": "+="}}, {"type": "PROPERTY_ACCESS", "id": "<this.builderValue>", "metadata": {"objectName": "this"}}, {"type": "METHOD", "id": "<Builder.multiply>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<n2>", "metadata": {"type": "number"}}, {"type": "TYPE_REFERENCE", "id": "<this-return-type2>", "metadata": {"type": "this", "originalType": "TYPE_ANNOTATION"}}, {"type": "EXPRESSION", "id": "<this.builderValue *= n>", "metadata": {"operator": "*="}}, {"type": "PROPERTY_ACCESS", "id": "<this.builderValue2>", "metadata": {"objectName": "this"}}, {"type": "CLASS", "id": "<AdvancedBuilder>"}, {"type": "METHOD", "id": "<AdvancedBuilder.negate>", "metadata": {"kind": "method"}}, {"type": "TYPE_REFERENCE", "id": "<this-return-type3>", "metadata": {"type": "this", "originalType": "TYPE_ANNOTATION"}}], "edges": [{"src": "<module>", "dst": "<Builder>", "type": "DECLARES"}, {"src": "<Builder>", "dst": "<Builder.builderValue>", "type": "CONTAINS"}, {"src": "<Builder.builderValue>", "dst": "<0>", "type": "ASSIGNED_FROM"}, {"src": "<Builder>", "dst": "<Builder.add>", "type": "CONTAINS"}, {"src": "<Builder.add>", "dst": "<n>", "type": "CONTAINS"}, {"src": "<Builder.add>", "dst": "<this-return-type>", "type": "RETURNS_TYPE", "metadata": {"originalType": "HAS_RETURN_TYPE"}}, {"src": "<Builder.add>", "dst": "<this.builderValue += n>", "type": "CONTAINS"}, {"src": "<this.builderValue += n>", "dst": "<this.builderValue>", "type": "WRITES_TO"}, {"src": "<this.builderValue += n>", "dst": "<n>", "type": "READS_FROM"}, {"src": "<Builder.add>", "dst": "<this>", "type": "RETURNS"}, {"src": "<Builder>", "dst": "<Builder.multiply>", "type": "CONTAINS"}, {"src": "<Builder.multiply>", "dst": "<n2>", "type": "CONTAINS"}, {"src": "<Builder.multiply>", "dst": "<this-return-type2>", "type": "RETURNS_TYPE", "metadata": {"originalType": "HAS_RETURN_TYPE"}}, {"src": "<Builder.multiply>", "dst": "<this.builderValue *= n>", "type": "CONTAINS"}, {"src": "<this.builderValue *= n>", "dst": "<this.builderValue2>", "type": "WRITES_TO"}, {"src": "<this.builderValue *= n>", "dst": "<n2>", "type": "READS_FROM"}, {"src": "<Builder.multiply>", "dst": "<this>", "type": "RETURNS"}, {"src": "<module>", "dst": "<AdvancedBuilder>", "type": "DECLARES"}, {"src": "<AdvancedBuilder>", "dst": "<Builder>", "type": "EXTENDS"}, {"src": "<AdvancedBuilder>", "dst": "<AdvancedBuilder.negate>", "type": "CONTAINS"}, {"src": "<AdvancedBuilder.negate>", "dst": "<this-return-type3>", "type": "RETURNS_TYPE", "metadata": {"originalType": "HAS_RETURN_TYPE"}}, {"src": "<AdvancedBuilder.negate>", "dst": "<this>", "type": "RETURNS"}], "rationale": "TypeScript 'this' return type enables fluent interfaces. Each method returns the current instance, allowing method chaining. The 'this' type is polymorphic - it resolves to the actual class type at call site. [merge-map applied]", "implicitBehavior": ["this type is polymorphic - resolves to Builder in Builder methods, AdvancedBuilder in AdvancedBuilder methods", "enables fluent chaining: new AdvancedBuilder().add(5).multiply(2).negate()", "inherited methods return the subclass type when called on subclass instances"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-branded-type", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 428, "lineEnd": 438, "code": "type UserId = string & { readonly __brand: unique symbol };\ntype OrderId = string & { readonly __brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction createOrderId(id: string): OrderId {\n  return id as OrderId;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<UserId>", "metadata": {"branded": true}}, {"type": "TYPE_REFERENCE", "id": "<string & { readonly __brand: unique symbol }>", "metadata": {"operator": "&", "originalType": "TYPE_INTERSECTION"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"originalType": "TYPE_PRIMITIVE"}}, {"type": "TYPE_REFERENCE", "id": "<{ readonly __brand: unique symbol }>", "metadata": {"originalType": "TYPE_OBJECT"}}, {"type": "PROPERTY", "id": "<__brand>", "metadata": {"readonly": true, "originalType": "TYPE_PROPERTY"}}, {"type": "TYPE_REFERENCE", "id": "<unique symbol>", "metadata": {"originalType": "TYPE_UNIQUE_SYMBOL"}}, {"type": "TYPE_ALIAS", "id": "<OrderId>", "metadata": {"branded": true}}, {"type": "TYPE_REFERENCE", "id": "<string & { readonly __brand: unique symbol }#2>", "metadata": {"operator": "&", "originalType": "TYPE_INTERSECTION"}}, {"type": "TYPE_REFERENCE", "id": "<{ readonly __brand: unique symbol }#2>", "metadata": {"originalType": "TYPE_OBJECT"}}, {"type": "PROPERTY", "id": "<__brand#2>", "metadata": {"readonly": true, "originalType": "TYPE_PROPERTY"}}, {"type": "TYPE_REFERENCE", "id": "<unique symbol#2>", "metadata": {"originalType": "TYPE_UNIQUE_SYMBOL"}}, {"type": "FUNCTION", "id": "<createUserId>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<id>", "metadata": {"hasTypeAnnotation": true}}, {"type": "EXPRESSION", "id": "<id as UserId>", "metadata": {"originalType": "TYPE_ASSERTION"}}, {"type": "FUNCTION", "id": "<createOrderId>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<id#2>", "metadata": {"hasTypeAnnotation": true}}, {"type": "EXPRESSION", "id": "<id as OrderId>", "metadata": {"originalType": "TYPE_ASSERTION"}}], "edges": [{"src": "<module>", "dst": "<UserId>", "type": "DECLARES"}, {"src": "<UserId>", "dst": "<string & { readonly __brand: unique symbol }>", "type": "ASSIGNED_FROM"}, {"src": "<string & { readonly __brand: unique symbol }>", "dst": "<string>", "type": "INTERSECTS_WITH"}, {"src": "<string & { readonly __brand: unique symbol }>", "dst": "<{ readonly __brand: unique symbol }>", "type": "INTERSECTS_WITH"}, {"src": "<{ readonly __brand: unique symbol }>", "dst": "<__brand>", "type": "CONTAINS"}, {"src": "<__brand>", "dst": "<unique symbol>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<OrderId>", "type": "DECLARES"}, {"src": "<OrderId>", "dst": "<string & { readonly __brand: unique symbol }#2>", "type": "ASSIGNED_FROM"}, {"src": "<string & { readonly __brand: unique symbol }#2>", "dst": "<string>", "type": "INTERSECTS_WITH"}, {"src": "<string & { readonly __brand: unique symbol }#2>", "dst": "<{ readonly __brand: unique symbol }#2>", "type": "INTERSECTS_WITH"}, {"src": "<{ readonly __brand: unique symbol }#2>", "dst": "<__brand#2>", "type": "CONTAINS"}, {"src": "<__brand#2>", "dst": "<unique symbol#2>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<createUserId>", "type": "DECLARES"}, {"src": "<createUserId>", "dst": "<id>", "type": "CONTAINS"}, {"src": "<id>", "dst": "<string>", "type": "HAS_TYPE"}, {"src": "<createUserId>", "dst": "<UserId>", "type": "RETURNS"}, {"src": "<createUserId>", "dst": "<id as UserId>", "type": "RETURNS"}, {"src": "<id as UserId>", "dst": "<id>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_FROM"}}, {"src": "<id as UserId>", "dst": "<UserId>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_TO"}}, {"src": "<module>", "dst": "<createOrderId>", "type": "DECLARES"}, {"src": "<createOrderId>", "dst": "<id#2>", "type": "CONTAINS"}, {"src": "<id#2>", "dst": "<string>", "type": "HAS_TYPE"}, {"src": "<createOrderId>", "dst": "<OrderId>", "type": "RETURNS"}, {"src": "<createOrderId>", "dst": "<id as OrderId>", "type": "RETURNS"}, {"src": "<id as OrderId>", "dst": "<id#2>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_FROM"}}, {"src": "<id as OrderId>", "dst": "<OrderId>", "type": "HAS_TYPE", "metadata": {"originalType": "ASSERTS_TO"}}], "rationale": "TypeScript branded types using intersection with unique symbol properties. Each type alias creates a nominal type that's structurally identical to string but type-distinct. Factory functions use type assertions to cast strings to branded types. [merge-map applied]", "implicitBehavior": ["unique symbol creates a fresh symbol type for each declaration", "intersection types require both string and brand object properties", "type assertions bypass structural type checking", "branded types prevent accidental mixing of semantically different string values"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-abstract-construct", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 501, "lineEnd": 509, "code": "type AbstractConstructor<T> = abstract new (...args: any[]) => T;\n\nfunction withMixin<T extends AbstractConstructor<{}>>(Base: T) {\n  abstract class Mixed extends Base {\n    abstract doThing(): void;\n  }\n  return Mixed;\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<AbstractConstructor>", "metadata": {"generic": true, "typeParameters": ["T"]}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"scope": "AbstractConstructor"}}, {"type": "TYPE_REFERENCE", "id": "<abstract new (...args: any[]) => T>", "metadata": {"abstract": true, "variadic": true, "originalType": "CONSTRUCTOR_TYPE"}}, {"type": "FUNCTION", "id": "<withMixin>", "metadata": {"generic": true, "typeParameters": ["T"]}}, {"type": "TYPE_PARAMETER", "id": "<T:withMixin>", "metadata": {"scope": "withMixin", "constraint": "AbstractConstructor<{}>"}}, {"type": "PARAMETER", "id": "<Base>", "metadata": {"type": "T"}}, {"type": "CLASS", "id": "<Mixed>", "metadata": {"abstract": true, "local": true}}, {"type": "METHOD", "id": "<Mixed.doThing>", "metadata": {"abstract": true, "kind": "method"}}], "edges": [{"src": "<module>", "dst": "<AbstractConstructor>", "type": "DECLARES"}, {"src": "<AbstractConstructor>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<AbstractConstructor>", "dst": "<abstract new (...args: any[]) => T>", "type": "RESOLVES_TO"}, {"src": "<abstract new (...args: any[]) => T>", "dst": "<T>", "type": "RETURNS"}, {"src": "<module>", "dst": "<withMixin>", "type": "DECLARES"}, {"src": "<withMixin>", "dst": "<T:withMixin>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<T:withMixin>", "dst": "<AbstractConstructor>", "type": "CONSTRAINED_BY"}, {"src": "<withMixin>", "dst": "<Base>", "type": "CONTAINS"}, {"src": "<withMixin>", "dst": "<Mixed>", "type": "CONTAINS"}, {"src": "<Mixed>", "dst": "<Base>", "type": "EXTENDS"}, {"src": "<Mixed>", "dst": "<Mixed.doThing>", "type": "CONTAINS"}, {"src": "<withMixin>", "dst": "<Mixed>", "type": "RETURNS"}], "rationale": "TypeScript type alias for abstract constructor pattern and generic mixin function. The type alias defines a constructor signature constraint, while the function creates a local abstract class that extends the base and adds abstract methods. [merge-map applied]", "implicitBehavior": ["Type parameter T in withMixin is constrained to abstract constructors", "Mixed class inherits all properties and methods from Base", "Abstract methods must be implemented by concrete subclasses", "Return type of withMixin is inferred as constructor type of Mixed"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-declaration-merging", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 516, "lineEnd": 519, "code": "class Box { x = 0; }\ninterface Box { y: number; }\n// Box now has both x (from class) and y (from interface)", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Box>", "metadata": {"declarationMerging": true}}, {"type": "PROPERTY", "id": "<Box.x>", "metadata": {"initializer": "0", "source": "class"}}, {"type": "LITERAL", "id": "<0>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "INTERFACE", "id": "<Box:interface>", "metadata": {"declarationMerging": true}}, {"type": "PROPERTY", "id": "<Box.y>", "metadata": {"type": "number", "source": "interface"}}, {"type": "TYPE_REFERENCE", "id": "<number>", "metadata": {"primitive": true, "originalType": "TYPE"}}], "edges": [{"src": "<module>", "dst": "<Box>", "type": "DECLARES"}, {"src": "<module>", "dst": "<Box:interface>", "type": "DECLARES"}, {"src": "<Box>", "dst": "<Box.x>", "type": "CONTAINS"}, {"src": "<Box.x>", "dst": "<0>", "type": "ASSIGNED_FROM"}, {"src": "<Box:interface>", "dst": "<Box.y>", "type": "CONTAINS"}, {"src": "<Box.y>", "dst": "<number>", "type": "HAS_TYPE"}, {"src": "<Box>", "dst": "<Box:interface>", "type": "MERGES_WITH"}, {"src": "<Box:interface>", "dst": "<Box>", "type": "MERGES_WITH"}], "rationale": "TypeScript declaration merging combines class and interface with same name. Both contribute properties to the merged type. [merge-map applied]", "implicitBehavior": ["TypeScript merges class and interface declarations with same name", "Merged type has both runtime properties (from class) and type-only properties (from interface)", "Class provides implementation, interface provides additional type constraints"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-const-enum-computed", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 493, "lineEnd": 499, "code": "const enum BitFlags {\n  Read = 1 << 0,\n  Write = 1 << 1,\n  Execute = 1 << 2,\n  ReadWrite = Read | Write,\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "ENUM", "id": "<BitFlags>", "metadata": {"kind": "const", "computed": true}}, {"type": "ENUM_MEMBER", "id": "<BitFlags.Read>", "metadata": {"computed": true}}, {"type": "EXPRESSION", "id": "<1 << 0>", "metadata": {"operator": "<<"}}, {"type": "LITERAL", "id": "<1>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "LITERAL", "id": "<0>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "ENUM_MEMBER", "id": "<BitFlags.Write>", "metadata": {"computed": true}}, {"type": "EXPRESSION", "id": "<1 << 1>", "metadata": {"operator": "<<"}}, {"type": "LITERAL", "id": "<1_2>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "LITERAL", "id": "<1_literal>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "ENUM_MEMBER", "id": "<BitFlags.Execute>", "metadata": {"computed": true}}, {"type": "EXPRESSION", "id": "<1 << 2>", "metadata": {"operator": "<<"}}, {"type": "LITERAL", "id": "<1_3>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "LITERAL", "id": "<2>", "metadata": {"value": 2, "literalType": "number"}}, {"type": "ENUM_MEMBER", "id": "<BitFlags.ReadWrite>", "metadata": {"computed": true}}, {"type": "EXPRESSION", "id": "<Read | Write>", "metadata": {"operator": "|"}}], "edges": [{"src": "<module>", "dst": "<BitFlags>", "type": "DECLARES"}, {"src": "<BitFlags>", "dst": "<BitFlags.Read>", "type": "CONTAINS"}, {"src": "<BitFlags>", "dst": "<BitFlags.Write>", "type": "CONTAINS"}, {"src": "<BitFlags>", "dst": "<BitFlags.Execute>", "type": "CONTAINS"}, {"src": "<BitFlags>", "dst": "<BitFlags.ReadWrite>", "type": "CONTAINS"}, {"src": "<BitFlags.Read>", "dst": "<1 << 0>", "type": "ASSIGNED_FROM"}, {"src": "<1 << 0>", "dst": "<1>", "type": "READS_FROM"}, {"src": "<1 << 0>", "dst": "<0>", "type": "READS_FROM"}, {"src": "<BitFlags.Write>", "dst": "<1 << 1>", "type": "ASSIGNED_FROM"}, {"src": "<1 << 1>", "dst": "<1_2>", "type": "READS_FROM"}, {"src": "<1 << 1>", "dst": "<1_literal>", "type": "READS_FROM"}, {"src": "<BitFlags.Execute>", "dst": "<1 << 2>", "type": "ASSIGNED_FROM"}, {"src": "<1 << 2>", "dst": "<1_3>", "type": "READS_FROM"}, {"src": "<1 << 2>", "dst": "<2>", "type": "READS_FROM"}, {"src": "<BitFlags.ReadWrite>", "dst": "<Read | Write>", "type": "ASSIGNED_FROM"}, {"src": "<Read | Write>", "dst": "<BitFlags.Read>", "type": "READS_FROM"}, {"src": "<Read | Write>", "dst": "<BitFlags.Write>", "type": "READS_FROM"}], "rationale": "TypeScript const enum with computed values using bitwise operations. Each member has an expression that computes its value, with ReadWrite referencing other enum members. [merge-map applied]", "implicitBehavior": ["const enum values are inlined at compile time", "enum members are accessible as BitFlags.Read etc.", "computed expressions are evaluated at compile time"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-class-method-overloads", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 521, "lineEnd": 528, "code": "class Parser {\n  parse(input: string): string;\n  parse(input: number): number;\n  parse(input: string | number): string | number {\n    return input;\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Parser>"}, {"type": "METHOD", "id": "<Parser.parse>", "metadata": {"kind": "method", "overloaded": true}}, {"type": "METHOD", "id": "<Parser.parse:overload1>", "metadata": {"signatureOnly": true, "originalType": "METHOD_OVERLOAD"}}, {"type": "METHOD", "id": "<Parser.parse:overload2>", "metadata": {"signatureOnly": true, "originalType": "METHOD_OVERLOAD"}}, {"type": "METHOD", "id": "<Parser.parse:implementation>", "metadata": {"signatureOnly": false, "originalType": "METHOD_OVERLOAD"}}, {"type": "PARAMETER", "id": "<input:overload1>", "metadata": {"tsType": "string"}}, {"type": "PARAMETER", "id": "<input:overload2>", "metadata": {"tsType": "number"}}, {"type": "PARAMETER", "id": "<input:implementation>", "metadata": {"tsType": "string | number"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"primitive": true, "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number>", "metadata": {"primitive": true, "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<string | number>", "metadata": {"unionType": true, "originalType": "TYPE"}}], "edges": [{"src": "<module>", "dst": "<Parser>", "type": "DECLARES"}, {"src": "<Parser>", "dst": "<Parser.parse>", "type": "CONTAINS"}, {"src": "<Parser.parse>", "dst": "<Parser.parse:overload1>", "type": "HAS_OVERLOAD"}, {"src": "<Parser.parse>", "dst": "<Parser.parse:overload2>", "type": "HAS_OVERLOAD"}, {"src": "<Parser.parse>", "dst": "<Parser.parse:implementation>", "type": "IMPLEMENTS_OVERLOAD", "metadata": {"originalType": "HAS_IMPLEMENTATION"}}, {"src": "<Parser.parse:overload1>", "dst": "<input:overload1>", "type": "CONTAINS"}, {"src": "<Parser.parse:overload2>", "dst": "<input:overload2>", "type": "CONTAINS"}, {"src": "<Parser.parse:implementation>", "dst": "<input:implementation>", "type": "CONTAINS"}, {"src": "<input:overload1>", "dst": "<string>", "type": "HAS_TYPE"}, {"src": "<input:overload2>", "dst": "<number>", "type": "HAS_TYPE"}, {"src": "<input:implementation>", "dst": "<string | number>", "type": "HAS_TYPE"}, {"src": "<Parser.parse:overload1>", "dst": "<string>", "type": "RETURNS_TYPE"}, {"src": "<Parser.parse:overload2>", "dst": "<number>", "type": "RETURNS_TYPE"}, {"src": "<Parser.parse:implementation>", "dst": "<string | number>", "type": "RETURNS_TYPE"}, {"src": "<Parser.parse:implementation>", "dst": "<input:implementation>", "type": "RETURNS"}], "rationale": "TypeScript method overloads with two signature declarations and one implementation. Each overload has distinct parameter and return types, with the implementation handling the union type. [merge-map applied]", "implicitBehavior": ["TypeScript compiler validates calls against overload signatures, not implementation signature", "Implementation must be compatible with all declared overloads"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-ambient-class-enum", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 564, "lineEnd": 571, "code": "declare class ExternalLib {\n  constructor(config: object);\n  process(): Promise<void>;\n}\ndeclare enum Platform { Web, Mobile, Desktop }\n\n// --- Decorator metadata (Stage 3 + TS experimental) ---", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<ExternalLib>", "metadata": {"ambient": true}}, {"type": "METHOD", "id": "<ExternalLib.constructor>", "metadata": {"kind": "constructor", "ambient": true}}, {"type": "PARAMETER", "id": "<config>", "metadata": {"type": "object"}}, {"type": "METHOD", "id": "<ExternalLib.process>", "metadata": {"kind": "method", "ambient": true, "returnType": "Promise<void>"}}, {"type": "ENUM", "id": "<Platform>", "metadata": {"ambient": true}}, {"type": "ENUM_MEMBER", "id": "<Platform.Web>"}, {"type": "ENUM_MEMBER", "id": "<Platform.Mobile>"}, {"type": "ENUM_MEMBER", "id": "<Platform.Desktop>"}], "edges": [{"src": "<module>", "dst": "<ExternalLib>", "type": "DECLARES"}, {"src": "<ExternalLib>", "dst": "<ExternalLib.constructor>", "type": "CONTAINS"}, {"src": "<ExternalLib>", "dst": "<ExternalLib.process>", "type": "CONTAINS"}, {"src": "<ExternalLib.constructor>", "dst": "<config>", "type": "CONTAINS"}, {"src": "<module>", "dst": "<Platform>", "type": "DECLARES"}, {"src": "<Platform>", "dst": "<Platform.Web>", "type": "CONTAINS"}, {"src": "<Platform>", "dst": "<Platform.Mobile>", "type": "CONTAINS"}, {"src": "<Platform>", "dst": "<Platform.Desktop>", "type": "CONTAINS"}], "rationale": "Ambient declarations for external class and enum. Class has constructor with typed parameter and async method. Enum has three members. [merge-map applied]", "implicitBehavior": ["ambient declarations don't generate runtime code", "type information available at compile time only", "enum members get numeric values by default (0, 1, 2)"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-unique-symbol", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 560, "lineEnd": 562, "code": "declare const uniqueSym: unique symbol;\ntype WithSymKey = { [uniqueSym]: string };", "commentedOut": false}, "annotation": {"nodes": [{"type": "VARIABLE", "id": "<uniqueSym>", "metadata": {"kind": "const", "declared": true, "tsType": "unique symbol"}}, {"type": "TYPE_REFERENCE", "id": "<unique symbol>", "metadata": {"tsKind": "unique symbol", "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<WithSymKey>", "metadata": {"tsKind": "type alias", "originalType": "TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<WithSymKey:object>", "metadata": {"tsKind": "object type", "originalType": "TYPE"}}, {"type": "PROPERTY", "id": "<WithSymKey:[uniqueSym]>", "metadata": {"computed": true, "tsType": "string"}}], "edges": [{"src": "<module>", "dst": "<uniqueSym>", "type": "DECLARES"}, {"src": "<uniqueSym>", "dst": "<unique symbol>", "type": "HAS_TYPE"}, {"src": "<module>", "dst": "<WithSymKey>", "type": "DECLARES"}, {"src": "<WithSymKey>", "dst": "<WithSymKey:object>", "type": "ASSIGNED_FROM"}, {"src": "<WithSymKey:object>", "dst": "<WithSymKey:[uniqueSym]>", "type": "CONTAINS"}, {"src": "<WithSymKey:[uniqueSym]>", "dst": "<uniqueSym>", "type": "READS_FROM", "metadata": {"originalType": "USES_AS_KEY"}}, {"src": "<WithSymKey:[uniqueSym]>", "dst": "<string>", "type": "HAS_TYPE"}], "rationale": "TypeScript unique symbol declaration and type alias using it as computed property key. The unique symbol creates a brand-new symbol type, and the object type uses it as a computed property key. [merge-map applied]", "implicitBehavior": ["unique symbol creates a nominal type that's distinct from all other symbols", "computed property key creates a property that can only be accessed with the exact symbol"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-enum-namespace-merge", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 554, "lineEnd": 558, "code": "enum Color { Red, Green, Blue }\nnamespace Color {\n  export function parse(s: string): Color { return Color[s as keyof typeof Color]; }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "ENUM", "id": "<Color>", "metadata": {"kind": "enum"}}, {"type": "ENUM_MEMBER", "id": "<Color.Red>", "metadata": {"value": 0}}, {"type": "ENUM_MEMBER", "id": "<Color.Green>", "metadata": {"value": 1}}, {"type": "ENUM_MEMBER", "id": "<Color.Blue>", "metadata": {"value": 2}}, {"type": "NAMESPACE", "id": "<Color:namespace>", "metadata": {"kind": "namespace"}}, {"type": "FUNCTION", "id": "<Color.parse>", "metadata": {"exported": true}}, {"type": "PARAMETER", "id": "<s>", "metadata": {"type": "string"}}, {"type": "PROPERTY_ACCESS", "id": "<Color[s]>", "metadata": {"computed": true}}, {"type": "EXPRESSION", "id": "<s as keyof typeof Color>", "metadata": {"originalType": "TYPE_ASSERTION"}}], "edges": [{"src": "<module>", "dst": "<Color>", "type": "DECLARES"}, {"src": "<Color>", "dst": "<Color.Red>", "type": "CONTAINS"}, {"src": "<Color>", "dst": "<Color.Green>", "type": "CONTAINS"}, {"src": "<Color>", "dst": "<Color.Blue>", "type": "CONTAINS"}, {"src": "<module>", "dst": "<Color:namespace>", "type": "DECLARES"}, {"src": "<Color:namespace>", "dst": "<Color.parse>", "type": "CONTAINS"}, {"src": "<Color.parse>", "dst": "<s>", "type": "CONTAINS"}, {"src": "<Color.parse>", "dst": "<Color[s]>", "type": "RETURNS"}, {"src": "<Color[s]>", "dst": "<Color>", "type": "READS_FROM"}, {"src": "<Color[s]>", "dst": "<s as keyof typeof Color>", "type": "READS_FROM", "metadata": {"originalType": "USES_INDEX"}}, {"src": "<s as keyof typeof Color>", "dst": "<s>", "type": "DERIVES_FROM", "metadata": {"originalType": "CASTS_FROM"}}, {"src": "<Color:namespace>", "dst": "<Color>", "type": "MERGES_WITH"}], "rationale": "TypeScript enum-namespace merge pattern. Enum declares members with implicit numeric values, namespace adds static methods that merge into the same identifier. [merge-map applied]", "implicitBehavior": ["enum generates both type and value at runtime", "namespace merges with enum creating hybrid type/value", "enum members get auto-incremented numeric values", "typeof Color creates union type of enum keys"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-parameter-decorators", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 591, "lineEnd": 599, "code": "// Common in NestJS/Angular  parameter decorators\nfunction Inject(token: string) {\n  return function(target: any, propertyKey: string | symbol, parameterIndex: number) {};\n}\n\nclass AppController {\n  constructor(@Inject('DB') private db: any) {}\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<Inject>", "metadata": {"decoratorFactory": true}}, {"type": "PARAMETER", "id": "<token>", "metadata": {"type": "string"}}, {"type": "FUNCTION", "id": "<Inject:decorator>", "metadata": {"parameterDecorator": true}}, {"type": "PARAMETER", "id": "<target>"}, {"type": "PARAMETER", "id": "<propertyKey>"}, {"type": "PARAMETER", "id": "<parameterIndex>"}, {"type": "CLASS", "id": "<AppController>"}, {"type": "METHOD", "id": "<AppController.constructor>", "metadata": {"kind": "constructor"}}, {"type": "PARAMETER", "id": "<db>", "metadata": {"visibility": "private", "type": "any"}}, {"type": "DECORATOR", "id": "<@Inject('DB')>", "metadata": {"decoratorName": "Inject", "target": "parameter", "originalType": "DECORATOR_APPLICATION"}}, {"type": "LITERAL", "id": "<'DB'>", "metadata": {"value": "DB", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<Inject>", "type": "DECLARES"}, {"src": "<Inject>", "dst": "<token>", "type": "CONTAINS"}, {"src": "<Inject>", "dst": "<Inject:decorator>", "type": "RETURNS"}, {"src": "<Inject:decorator>", "dst": "<target>", "type": "CONTAINS"}, {"src": "<Inject:decorator>", "dst": "<propertyKey>", "type": "CONTAINS"}, {"src": "<Inject:decorator>", "dst": "<parameterIndex>", "type": "CONTAINS"}, {"src": "<module>", "dst": "<AppController>", "type": "DECLARES"}, {"src": "<AppController>", "dst": "<AppController.constructor>", "type": "CONTAINS"}, {"src": "<AppController.constructor>", "dst": "<db>", "type": "CONTAINS"}, {"src": "<@Inject('DB')>", "dst": "<Inject>", "type": "CALLS"}, {"src": "<@Inject('DB')>", "dst": "<'DB'>", "type": "PASSES_ARGUMENT"}, {"src": "<db>", "dst": "<@Inject('DB')>", "type": "DECORATED_BY"}, {"src": "<@Inject('DB')>", "dst": "<Inject:decorator>", "type": "RETURNS", "metadata": {"originalType": "EVALUATES_TO"}}], "rationale": "Parameter decorator factory pattern. Inject function returns a decorator that gets applied to the db parameter. The decorator application captures metadata about the parameter's injection token. [merge-map applied]", "implicitBehavior": ["decorator metadata stored in reflect-metadata", "parameter injection resolved at runtime by DI container", "private parameter creates property on class instance"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-decorator-metadata", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 573, "lineEnd": 589, "code": "function track(constructor: Function, context: ClassDecoratorContext) {\n  context.metadata.tracked = true;\n}\n\nfunction log(target: Function, context: ClassMethodDecoratorContext) {\n  context.addInitializer(function() {\n    console.log(`${String(context.name)} initialized`);\n  });\n}\n\n@track\nclass TrackedService {\n  @log\n  process(data: string) { return data; }\n}\n// const meta = TrackedService[Symbol.metadata]; // { tracked: true }", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<track>", "metadata": {"decorator": true, "decoratorType": "class"}}, {"type": "PARAMETER", "id": "<constructor>", "metadata": {"type": "Function"}}, {"type": "PARAMETER", "id": "<context>", "metadata": {"type": "ClassDecoratorContext"}}, {"type": "PROPERTY_ACCESS", "id": "<context.metadata.tracked>", "metadata": {"objectName": "context.metadata"}}, {"type": "LITERAL", "id": "<true>", "metadata": {"value": true, "literalType": "boolean"}}, {"type": "FUNCTION", "id": "<log>", "metadata": {"decorator": true, "decoratorType": "method"}}, {"type": "PARAMETER", "id": "<target>", "metadata": {"type": "Function"}}, {"type": "PARAMETER", "id": "<context2>", "metadata": {"type": "ClassMethodDecoratorContext"}}, {"type": "CALL", "id": "<context.addInitializer(...)>", "metadata": {"callee": "context.addInitializer"}}, {"type": "FUNCTION", "id": "<addInitializer-callback>", "metadata": {"anonymous": true}}, {"type": "CALL", "id": "<console.log(...)>", "metadata": {"callee": "console.log"}}, {"type": "EXPRESSION", "id": "<String(context.name)>", "metadata": {"template": true}}, {"type": "CLASS", "id": "<TrackedService>", "metadata": {"decorated": true}}, {"type": "DECORATOR", "id": "<@track>", "metadata": {"decoratorName": "track", "originalType": "DECORATOR_APPLICATION"}}, {"type": "METHOD", "id": "<TrackedService.process>", "metadata": {"kind": "method", "decorated": true}}, {"type": "DECORATOR", "id": "<@log>", "metadata": {"decoratorName": "log", "originalType": "DECORATOR_APPLICATION"}}, {"type": "PARAMETER", "id": "<data>", "metadata": {"type": "string"}}], "edges": [{"src": "<module>", "dst": "<track>", "type": "DECLARES"}, {"src": "<track>", "dst": "<constructor>", "type": "CONTAINS"}, {"src": "<track>", "dst": "<context>", "type": "CONTAINS"}, {"src": "<track>", "dst": "<context.metadata.tracked>", "type": "WRITES_TO"}, {"src": "<context.metadata.tracked>", "dst": "<true>", "type": "ASSIGNED_FROM"}, {"src": "<module>", "dst": "<log>", "type": "DECLARES"}, {"src": "<log>", "dst": "<target>", "type": "CONTAINS"}, {"src": "<log>", "dst": "<context2>", "type": "CONTAINS"}, {"src": "<log>", "dst": "<context.addInitializer(...)>", "type": "CONTAINS"}, {"src": "<context.addInitializer(...)>", "dst": "<addInitializer-callback>", "type": "PASSES_ARGUMENT"}, {"src": "<addInitializer-callback>", "dst": "<console.log(...)>", "type": "CONTAINS"}, {"src": "<console.log(...)>", "dst": "<String(context.name)>", "type": "PASSES_ARGUMENT"}, {"src": "<module>", "dst": "<TrackedService>", "type": "DECLARES"}, {"src": "<@track>", "dst": "<track>", "type": "DECORATED_BY", "metadata": {"originalType": "APPLIES_DECORATOR"}}, {"src": "<TrackedService>", "dst": "<@track>", "type": "DECORATED_BY"}, {"src": "<TrackedService>", "dst": "<TrackedService.process>", "type": "CONTAINS"}, {"src": "<@log>", "dst": "<log>", "type": "DECORATED_BY", "metadata": {"originalType": "APPLIES_DECORATOR"}}, {"src": "<TrackedService.process>", "dst": "<@log>", "type": "DECORATED_BY"}, {"src": "<TrackedService.process>", "dst": "<data>", "type": "CONTAINS"}, {"src": "<TrackedService.process>", "dst": "<data>", "type": "RETURNS"}], "rationale": "TypeScript decorators with metadata manipulation. Class decorator sets metadata property, method decorator adds initialization callback. Decorators are applied to their targets through decorator application nodes. [merge-map applied]", "implicitBehavior": ["Decorators execute at class definition time", "Symbol.metadata property is automatically created on decorated classes", "Method initializers run when class is instantiated", "Decorator context provides reflection capabilities"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-constructor-overloads", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 530, "lineEnd": 545, "code": "class Point {\n  x: number;\n  y: number;\n  constructor(x: number, y: number);\n  constructor(coords: [number, number]);\n  constructor(xOrCoords: number | [number, number], y?: number) {\n    if (Array.isArray(xOrCoords)) {\n      this.x = xOrCoords[0];\n      this.y = xOrCoords[1];\n    } else {\n      this.x = xOrCoords;\n      this.y = y!;\n    }\n  }\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<Point>"}, {"type": "PROPERTY", "id": "<Point.x>", "metadata": {"type": "number"}}, {"type": "PROPERTY", "id": "<Point.y>", "metadata": {"type": "number"}}, {"type": "METHOD", "id": "<Point.constructor:overload1>", "metadata": {"kind": "constructor", "overloadIndex": 0, "originalType": "METHOD_OVERLOAD"}}, {"type": "PARAMETER", "id": "<x:overload1>", "metadata": {"type": "number"}}, {"type": "PARAMETER", "id": "<y:overload1>", "metadata": {"type": "number"}}, {"type": "METHOD", "id": "<Point.constructor:overload2>", "metadata": {"kind": "constructor", "overloadIndex": 1, "originalType": "METHOD_OVERLOAD"}}, {"type": "PARAMETER", "id": "<coords:overload2>", "metadata": {"type": "[number, number]"}}, {"type": "METHOD", "id": "<Point.constructor>", "metadata": {"kind": "constructor", "implementation": true}}, {"type": "PARAMETER", "id": "<xOrCoords>", "metadata": {"type": "number | [number, number]"}}, {"type": "PARAMETER", "id": "<y>", "metadata": {"type": "number", "optional": true}}, {"type": "BRANCH", "id": "<Array.isArray(xOrCoords)>"}, {"type": "PROPERTY_ACCESS", "id": "<this.x:branch1>", "metadata": {"objectName": "this"}}, {"type": "PROPERTY_ACCESS", "id": "<xOrCoords[0]>"}, {"type": "PROPERTY_ACCESS", "id": "<this.y:branch1>", "metadata": {"objectName": "this"}}, {"type": "PROPERTY_ACCESS", "id": "<xOrCoords[1]>"}, {"type": "PROPERTY_ACCESS", "id": "<this.x:branch2>", "metadata": {"objectName": "this"}}, {"type": "PROPERTY_ACCESS", "id": "<this.y:branch2>", "metadata": {"objectName": "this"}}, {"type": "EXPRESSION", "id": "<y!>", "metadata": {"operator": "!"}}], "edges": [{"src": "<module>", "dst": "<Point>", "type": "DECLARES"}, {"src": "<Point>", "dst": "<Point.x>", "type": "CONTAINS"}, {"src": "<Point>", "dst": "<Point.y>", "type": "CONTAINS"}, {"src": "<Point>", "dst": "<Point.constructor:overload1>", "type": "CONTAINS"}, {"src": "<Point>", "dst": "<Point.constructor:overload2>", "type": "CONTAINS"}, {"src": "<Point>", "dst": "<Point.constructor>", "type": "CONTAINS"}, {"src": "<Point.constructor:overload1>", "dst": "<x:overload1>", "type": "CONTAINS"}, {"src": "<Point.constructor:overload1>", "dst": "<y:overload1>", "type": "CONTAINS"}, {"src": "<Point.constructor:overload2>", "dst": "<coords:overload2>", "type": "CONTAINS"}, {"src": "<Point.constructor>", "dst": "<xOrCoords>", "type": "CONTAINS"}, {"src": "<Point.constructor>", "dst": "<y>", "type": "CONTAINS"}, {"src": "<Point.constructor>", "dst": "<Point.constructor:overload1>", "type": "IMPLEMENTS_OVERLOAD"}, {"src": "<Point.constructor>", "dst": "<Point.constructor:overload2>", "type": "IMPLEMENTS_OVERLOAD"}, {"src": "<Point.constructor>", "dst": "<Array.isArray(xOrCoords)>", "type": "CONTAINS"}, {"src": "<Array.isArray(xOrCoords)>", "dst": "<xOrCoords>", "type": "READS_FROM"}, {"src": "<Array.isArray(xOrCoords)>", "dst": "<this.x:branch1>", "type": "HAS_CONSEQUENT"}, {"src": "<Array.isArray(xOrCoords)>", "dst": "<this.y:branch1>", "type": "HAS_CONSEQUENT"}, {"src": "<Array.isArray(xOrCoords)>", "dst": "<this.x:branch2>", "type": "HAS_ALTERNATE"}, {"src": "<Array.isArray(xOrCoords)>", "dst": "<this.y:branch2>", "type": "HAS_ALTERNATE"}, {"src": "<this.x:branch1>", "dst": "<xOrCoords[0]>", "type": "ASSIGNED_FROM"}, {"src": "<xOrCoords[0]>", "dst": "<xOrCoords>", "type": "READS_FROM"}, {"src": "<this.y:branch1>", "dst": "<xOrCoords[1]>", "type": "ASSIGNED_FROM"}, {"src": "<xOrCoords[1]>", "dst": "<xOrCoords>", "type": "READS_FROM"}, {"src": "<this.x:branch2>", "dst": "<xOrCoords>", "type": "ASSIGNED_FROM"}, {"src": "<this.y:branch2>", "dst": "<y!>", "type": "ASSIGNED_FROM"}, {"src": "<y!>", "dst": "<y>", "type": "READS_FROM"}], "rationale": "TypeScript constructor overloads define multiple call signatures for the same implementation. The class has two overload signatures and one implementation that handles both cases through runtime type checking. [merge-map applied]", "implicitBehavior": ["TypeScript compiler ensures only overload signatures are visible to callers", "Non-null assertion operator (!) tells compiler to ignore potential undefined value", "Array destructuring access creates implicit bounds checking"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-mapped-type-as-clause", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 601, "lineEnd": 607, "code": "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\ntype RemoveKind<T> = {\n  [K in keyof T as Exclude<K, 'kind'>]: T[K]\n};", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<Getters>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "TYPE_ALIAS", "id": "<Getters:mapped>", "metadata": {"keyMapping": true, "originalType": "MAPPED_TYPE"}}, {"type": "TYPE_PARAMETER", "id": "<K>", "metadata": {"mappedTypeKey": true, "originalType": "TYPE_VARIABLE"}}, {"type": "TYPE_REFERENCE", "id": "<get${Capitalize<string & K>}>", "metadata": {"template": "get${Capitalize<string & K>}", "originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<() => T[K]>", "metadata": {"originalType": "FUNCTION_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<RemoveKind>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T2>", "metadata": {"aliasFor": "T"}}, {"type": "TYPE_ALIAS", "id": "<RemoveKind:mapped>", "metadata": {"keyMapping": true, "originalType": "MAPPED_TYPE"}}, {"type": "TYPE_PARAMETER", "id": "<K2>", "metadata": {"mappedTypeKey": true, "aliasFor": "K", "originalType": "TYPE_VARIABLE"}}, {"type": "TYPE_REFERENCE", "id": "<Exclude<K, 'kind'>>", "metadata": {"originalType": "UTILITY_TYPE"}}, {"type": "LITERAL", "id": "<'kind'>", "metadata": {"value": "kind", "literalType": "string"}}], "edges": [{"src": "<module>", "dst": "<Getters>", "type": "DECLARES"}, {"src": "<Getters>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<Getters>", "dst": "<Getters:mapped>", "type": "ASSIGNED_FROM"}, {"src": "<Getters:mapped>", "dst": "<K>", "type": "ITERATES_OVER"}, {"src": "<Getters:mapped>", "dst": "<get${Capitalize<string & K>}>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_KEY_TO"}}, {"src": "<Getters:mapped>", "dst": "<() => T[K]>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_VALUE_TO"}}, {"src": "<get${Capitalize<string & K>}>", "dst": "<K>", "type": "READS_FROM"}, {"src": "<() => T[K]>", "dst": "<T>", "type": "READS_FROM"}, {"src": "<() => T[K]>", "dst": "<K>", "type": "READS_FROM"}, {"src": "<module>", "dst": "<RemoveKind>", "type": "DECLARES"}, {"src": "<RemoveKind>", "dst": "<T2>", "type": "CONTAINS"}, {"src": "<RemoveKind>", "dst": "<RemoveKind:mapped>", "type": "ASSIGNED_FROM"}, {"src": "<RemoveKind:mapped>", "dst": "<K2>", "type": "ITERATES_OVER"}, {"src": "<RemoveKind:mapped>", "dst": "<Exclude<K, 'kind'>>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_KEY_TO"}}, {"src": "<RemoveKind:mapped>", "dst": "<T2>", "type": "DERIVES_FROM", "metadata": {"originalType": "MAPS_VALUE_TO"}}, {"src": "<Exclude<K, 'kind'>>", "dst": "<K2>", "type": "READS_FROM"}, {"src": "<Exclude<K, 'kind'>>", "dst": "<'kind'>", "type": "READS_FROM"}], "rationale": "Two mapped types with key remapping via 'as' clauses. First transforms keys to getter method names, second filters out 'kind' property. Each mapped type iterates over keys and transforms both key and value types. [merge-map applied]", "implicitBehavior": ["Template literal type performs string manipulation at type level", "Exclude utility type performs conditional type filtering", "Mapped type key remapping creates new property names"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-this-type-guard", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 637, "lineEnd": 649, "code": "class FSNode {\n  isFile(): this is FSFileNode { return this instanceof FSFileNode; }\n  isDir(): this is FSDirNode { return this instanceof FSDirNode; }\n}\n\nclass FSFileNode extends FSNode {\n  content: string = '';\n}\n\nclass FSDirNode extends FSNode {\n  children: FSNode[] = [];\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<FSNode>"}, {"type": "METHOD", "id": "<FSNode.isFile>", "metadata": {"kind": "method", "typeGuard": true, "returnType": "this is FSFileNode"}}, {"type": "METHOD", "id": "<FSNode.isDir>", "metadata": {"kind": "method", "typeGuard": true, "returnType": "this is FSDirNode"}}, {"type": "EXPRESSION", "id": "<this instanceof FSFileNode>", "metadata": {"operator": "instanceof"}}, {"type": "EXPRESSION", "id": "<this instanceof FSDirNode>", "metadata": {"operator": "instanceof"}}, {"type": "CLASS", "id": "<FSFileNode>"}, {"type": "PROPERTY", "id": "<FSFileNode.content>", "metadata": {"type": "string", "initialValue": "''"}}, {"type": "LITERAL", "id": "<''>", "metadata": {"value": "", "literalType": "string"}}, {"type": "CLASS", "id": "<FSDirNode>"}, {"type": "PROPERTY", "id": "<FSDirNode.children>", "metadata": {"type": "FSNode[]", "initialValue": "[]"}}, {"type": "LITERAL", "id": "<[]>", "metadata": {"value": "[]", "literalType": "array"}}], "edges": [{"src": "<module>", "dst": "<FSNode>", "type": "DECLARES"}, {"src": "<FSNode>", "dst": "<FSNode.isFile>", "type": "CONTAINS"}, {"src": "<FSNode>", "dst": "<FSNode.isDir>", "type": "CONTAINS"}, {"src": "<FSNode.isFile>", "dst": "<this instanceof FSFileNode>", "type": "RETURNS"}, {"src": "<FSNode.isDir>", "dst": "<this instanceof FSDirNode>", "type": "RETURNS"}, {"src": "<this instanceof FSFileNode>", "dst": "<FSFileNode>", "type": "READS_FROM"}, {"src": "<this instanceof FSDirNode>", "dst": "<FSDirNode>", "type": "READS_FROM"}, {"src": "<module>", "dst": "<FSFileNode>", "type": "DECLARES"}, {"src": "<FSFileNode>", "dst": "<FSNode>", "type": "EXTENDS"}, {"src": "<FSFileNode>", "dst": "<FSFileNode.content>", "type": "CONTAINS"}, {"src": "<FSFileNode.content>", "dst": "<''>", "type": "ASSIGNED_FROM"}, {"src": "<module>", "dst": "<FSDirNode>", "type": "DECLARES"}, {"src": "<FSDirNode>", "dst": "<FSNode>", "type": "EXTENDS"}, {"src": "<FSDirNode>", "dst": "<FSDirNode.children>", "type": "CONTAINS"}, {"src": "<FSDirNode.children>", "dst": "<[]>", "type": "ASSIGNED_FROM"}], "rationale": "TypeScript type guard methods that narrow 'this' type using instanceof checks. Base class with two subclasses that extend it and define typed properties. [merge-map applied]", "implicitBehavior": ["Type narrowing occurs when type guard returns true", "TypeScript compiler uses return type annotation for control flow analysis", "instanceof checks prototype chain at runtime"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-distributive-conditional", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 547, "lineEnd": 552, "code": "type ToArray<T> = T extends any ? T[] : never;\ntype DistResult = ToArray<string | number>; // string[] | number[]\n\ntype ToArrayND<T> = [T] extends [any] ? T[] : never;\ntype NonDistResult = ToArrayND<string | number>; // (string | number)[]", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<ToArray>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"scope": "ToArray"}}, {"type": "CONDITIONAL_TYPE", "id": "<T extends any ? T[] : never>", "metadata": {"distributive": true}}, {"type": "TYPE_REFERENCE", "id": "<T extends any>", "metadata": {"constraintType": "any", "originalType": "TYPE_CONSTRAINT"}}, {"type": "TYPE_REFERENCE", "id": "<T[]>", "metadata": {"elementType": "T", "originalType": "ARRAY_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never>", "metadata": {"value": "never"}}, {"type": "TYPE_ALIAS", "id": "<DistResult>", "metadata": {"generic": false}}, {"type": "TYPE_REFERENCE", "id": "<ToArray<string | number>>", "metadata": {"typeFunction": "ToArray", "originalType": "TYPE_APPLICATION"}}, {"type": "TYPE_ALIAS", "id": "<string | number>", "metadata": {"memberCount": 2, "originalType": "UNION_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<string>", "metadata": {"primitive": "string", "originalType": "PRIMITIVE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number>", "metadata": {"primitive": "number", "originalType": "PRIMITIVE_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<ToArrayND>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T_nd>", "metadata": {"scope": "ToArrayND"}}, {"type": "CONDITIONAL_TYPE", "id": "<[T] extends [any] ? T[] : never>", "metadata": {"distributive": false}}, {"type": "TYPE_REFERENCE", "id": "<[T] extends [any]>", "metadata": {"constraintType": "[any]", "originalType": "TYPE_CONSTRAINT"}}, {"type": "TYPE_ALIAS", "id": "<[T]>", "metadata": {"elementCount": 1, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_ALIAS", "id": "<[any]>", "metadata": {"elementCount": 1, "originalType": "TUPLE_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<T[]_nd>", "metadata": {"elementType": "T", "originalType": "ARRAY_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never_nd>", "metadata": {"value": "never"}}, {"type": "TYPE_ALIAS", "id": "<NonDistResult>", "metadata": {"generic": false}}, {"type": "TYPE_REFERENCE", "id": "<ToArrayND<string | number>>", "metadata": {"typeFunction": "ToArrayND", "originalType": "TYPE_APPLICATION"}}, {"type": "TYPE_ALIAS", "id": "<string | number_nd>", "metadata": {"memberCount": 2, "originalType": "UNION_TYPE"}}], "edges": [{"src": "<module>", "dst": "<ToArray>", "type": "DECLARES"}, {"src": "<ToArray>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<ToArray>", "dst": "<T extends any ? T[] : never>", "type": "RESOLVES_TO"}, {"src": "<T extends any ? T[] : never>", "dst": "<T extends any>", "type": "HAS_CONDITION"}, {"src": "<T extends any ? T[] : never>", "dst": "<T[]>", "type": "HAS_CONSEQUENT"}, {"src": "<T extends any ? T[] : never>", "dst": "<never>", "type": "HAS_ALTERNATE"}, {"src": "<T extends any>", "dst": "<T>", "type": "CONSTRAINED_BY", "metadata": {"originalType": "CONSTRAINS"}}, {"src": "<T[]>", "dst": "<T>", "type": "CONTAINS", "metadata": {"originalType": "ELEMENT_TYPE"}}, {"src": "<module>", "dst": "<DistResult>", "type": "DECLARES"}, {"src": "<DistResult>", "dst": "<ToArray<string | number>>", "type": "RESOLVES_TO"}, {"src": "<ToArray<string | number>>", "dst": "<ToArray>", "type": "CALLS", "metadata": {"originalType": "INSTANTIATES"}}, {"src": "<ToArray<string | number>>", "dst": "<string | number>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPE_ARGUMENT"}}, {"src": "<string | number>", "dst": "<string>", "type": "UNION_MEMBER"}, {"src": "<string | number>", "dst": "<number>", "type": "UNION_MEMBER"}, {"src": "<module>", "dst": "<ToArrayND>", "type": "DECLARES"}, {"src": "<ToArrayND>", "dst": "<T_nd>", "type": "CONTAINS"}, {"src": "<ToArrayND>", "dst": "<[T] extends [any] ? T[] : never>", "type": "RESOLVES_TO"}, {"src": "<[T] extends [any] ? T[] : never>", "dst": "<[T] extends [any]>", "type": "HAS_CONDITION"}, {"src": "<[T] extends [any] ? T[] : never>", "dst": "<T[]_nd>", "type": "HAS_CONSEQUENT"}, {"src": "<[T] extends [any] ? T[] : never>", "dst": "<never_nd>", "type": "HAS_ALTERNATE"}, {"src": "<[T] extends [any]>", "dst": "<[T]>", "type": "CONSTRAINED_BY", "metadata": {"originalType": "CONSTRAINS"}}, {"src": "<[T] extends [any]>", "dst": "<[any]>", "type": "CONSTRAINED_BY", "metadata": {"originalType": "CONSTRAINT_TARGET"}}, {"src": "<[T]>", "dst": "<T_nd>", "type": "CONTAINS", "metadata": {"originalType": "TUPLE_ELEMENT"}}, {"src": "<T[]_nd>", "dst": "<T_nd>", "type": "CONTAINS", "metadata": {"originalType": "ELEMENT_TYPE"}}, {"src": "<module>", "dst": "<NonDistResult>", "type": "DECLARES"}, {"src": "<NonDistResult>", "dst": "<ToArrayND<string | number>>", "type": "RESOLVES_TO"}, {"src": "<ToArrayND<string | number>>", "dst": "<ToArrayND>", "type": "CALLS", "metadata": {"originalType": "INSTANTIATES"}}, {"src": "<ToArrayND<string | number>>", "dst": "<string | number_nd>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPE_ARGUMENT"}}, {"src": "<string | number_nd>", "dst": "<string>", "type": "UNION_MEMBER"}, {"src": "<string | number_nd>", "dst": "<number>", "type": "UNION_MEMBER"}], "rationale": "TypeScript distributive conditional types. ToArray distributes over union types due to naked type parameter, while ToArrayND prevents distribution by wrapping in tuple. The key semantic difference is captured in the conditional type metadata and constraint structure. [merge-map applied]", "implicitBehavior": ["distributive conditional types automatically distribute over union types when the checked type is a naked type parameter", "wrapping the checked type in a tuple [T] prevents distribution", "ToArray<string | number> becomes string[] | number[] due to distribution", "ToArrayND<string | number> becomes (string | number)[] without distribution"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-function-type-intersection", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 651, "lineEnd": 654, "code": "type StringHandler = (input: string) => string;\ntype NumberHandler = (input: number) => number;\ntype BothHandler = StringHandler & NumberHandler;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<StringHandler>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<StringHandler:fn-type>", "metadata": {"originalType": "FUNCTION_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<StringHandler:input>", "metadata": {"name": "input", "originalType": "PARAMETER_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<string1>", "metadata": {"typeName": "string"}}, {"type": "TYPE_REFERENCE", "id": "<string2>", "metadata": {"typeName": "string"}}, {"type": "TYPE_ALIAS", "id": "<NumberHandler>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<NumberHandler:fn-type>", "metadata": {"originalType": "FUNCTION_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<NumberHandler:input>", "metadata": {"name": "input", "originalType": "PARAMETER_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<number1>", "metadata": {"typeName": "number"}}, {"type": "TYPE_REFERENCE", "id": "<number2>", "metadata": {"typeName": "number"}}, {"type": "TYPE_ALIAS", "id": "<BothHandler>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<StringHandler & NumberHandler>", "metadata": {"operator": "&", "originalType": "INTERSECTION_TYPE"}}], "edges": [{"src": "<module>", "dst": "<StringHandler>", "type": "DECLARES"}, {"src": "<StringHandler>", "dst": "<StringHandler:fn-type>", "type": "ASSIGNED_FROM"}, {"src": "<StringHandler:fn-type>", "dst": "<StringHandler:input>", "type": "CONTAINS"}, {"src": "<StringHandler:input>", "dst": "<string1>", "type": "HAS_TYPE"}, {"src": "<StringHandler:fn-type>", "dst": "<string2>", "type": "RETURNS"}, {"src": "<module>", "dst": "<NumberHandler>", "type": "DECLARES"}, {"src": "<NumberHandler>", "dst": "<NumberHandler:fn-type>", "type": "ASSIGNED_FROM"}, {"src": "<NumberHandler:fn-type>", "dst": "<NumberHandler:input>", "type": "CONTAINS"}, {"src": "<NumberHandler:input>", "dst": "<number1>", "type": "HAS_TYPE"}, {"src": "<NumberHandler:fn-type>", "dst": "<number2>", "type": "RETURNS"}, {"src": "<module>", "dst": "<BothHandler>", "type": "DECLARES"}, {"src": "<BothHandler>", "dst": "<StringHandler & NumberHandler>", "type": "ASSIGNED_FROM"}, {"src": "<StringHandler & NumberHandler>", "dst": "<StringHandler>", "type": "INTERSECTS_WITH"}, {"src": "<StringHandler & NumberHandler>", "dst": "<NumberHandler>", "type": "INTERSECTS_WITH"}], "rationale": "Three type aliases: two function types and an intersection type. Function types contain parameter types and return types. Intersection type combines both function types requiring implementation to satisfy both signatures. [merge-map applied]", "implicitBehavior": ["intersection type requires callable with both signatures", "TypeScript structural typing applies", "function overload resolution at call sites"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-variadic-tuple", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 609, "lineEnd": 613, "code": "type Concat<A extends unknown[], B extends unknown[]> = [...A, ...B];\ntype HeadOf<T extends unknown[]> = T extends [infer H, ...unknown[]] ? H : never;\ntype TailOf<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;\ntype LastOf<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<Concat>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<A>", "metadata": {"constraint": "unknown[]"}}, {"type": "TYPE_PARAMETER", "id": "<B>", "metadata": {"constraint": "unknown[]"}}, {"type": "TYPE_ALIAS", "id": "<[...A, ...B]>", "metadata": {"variadic": true, "originalType": "TUPLE_TYPE"}}, {"type": "EXPRESSION", "id": "<...A>", "metadata": {"originalType": "SPREAD_ELEMENT"}}, {"type": "EXPRESSION", "id": "<...B>", "metadata": {"originalType": "SPREAD_ELEMENT"}}, {"type": "TYPE_ALIAS", "id": "<HeadOf>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"constraint": "unknown[]"}}, {"type": "CONDITIONAL_TYPE", "id": "<T extends [infer H, ...unknown[]] ? H : never>"}, {"type": "INFER_TYPE", "id": "<H>", "metadata": {"originalType": "INFERRED_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never>"}, {"type": "TYPE_ALIAS", "id": "<TailOf>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T:TailOf>", "metadata": {"constraint": "unknown[]"}}, {"type": "CONDITIONAL_TYPE", "id": "<T extends [unknown, ...infer R] ? R : never>"}, {"type": "INFER_TYPE", "id": "<R>", "metadata": {"originalType": "INFERRED_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never:TailOf>"}, {"type": "TYPE_ALIAS", "id": "<LastOf>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T:LastOf>", "metadata": {"constraint": "unknown[]"}}, {"type": "CONDITIONAL_TYPE", "id": "<T extends [...unknown[], infer L] ? L : never>"}, {"type": "INFER_TYPE", "id": "<L>", "metadata": {"originalType": "INFERRED_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never:LastOf>"}], "edges": [{"src": "<module>", "dst": "<Concat>", "type": "DECLARES"}, {"src": "<Concat>", "dst": "<A>", "type": "CONTAINS"}, {"src": "<Concat>", "dst": "<B>", "type": "CONTAINS"}, {"src": "<Concat>", "dst": "<[...A, ...B]>", "type": "RESOLVES_TO"}, {"src": "<[...A, ...B]>", "dst": "<...A>", "type": "CONTAINS"}, {"src": "<[...A, ...B]>", "dst": "<...B>", "type": "CONTAINS"}, {"src": "<...A>", "dst": "<A>", "type": "SPREADS_FROM", "metadata": {"originalType": "SPREADS"}}, {"src": "<...B>", "dst": "<B>", "type": "SPREADS_FROM", "metadata": {"originalType": "SPREADS"}}, {"src": "<module>", "dst": "<HeadOf>", "type": "DECLARES"}, {"src": "<HeadOf>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<HeadOf>", "dst": "<T extends [infer H, ...unknown[]] ? H : never>", "type": "RESOLVES_TO"}, {"src": "<T extends [infer H, ...unknown[]] ? H : never>", "dst": "<T>", "type": "HAS_CONDITION", "metadata": {"originalType": "TESTS"}}, {"src": "<T extends [infer H, ...unknown[]] ? H : never>", "dst": "<H>", "type": "INFERS"}, {"src": "<T extends [infer H, ...unknown[]] ? H : never>", "dst": "<H>", "type": "RETURNS", "metadata": {"originalType": "RETURNS_TRUE"}}, {"src": "<T extends [infer H, ...unknown[]] ? H : never>", "dst": "<never>", "type": "RETURNS", "metadata": {"originalType": "RETURNS_FALSE"}}, {"src": "<module>", "dst": "<TailOf>", "type": "DECLARES"}, {"src": "<TailOf>", "dst": "<T:TailOf>", "type": "CONTAINS"}, {"src": "<TailOf>", "dst": "<T extends [unknown, ...infer R] ? R : never>", "type": "RESOLVES_TO"}, {"src": "<T extends [unknown, ...infer R] ? R : never>", "dst": "<T:TailOf>", "type": "HAS_CONDITION", "metadata": {"originalType": "TESTS"}}, {"src": "<T extends [unknown, ...infer R] ? R : never>", "dst": "<R>", "type": "INFERS"}, {"src": "<T extends [unknown, ...infer R] ? R : never>", "dst": "<R>", "type": "RETURNS", "metadata": {"originalType": "RETURNS_TRUE"}}, {"src": "<T extends [unknown, ...infer R] ? R : never>", "dst": "<never:TailOf>", "type": "RETURNS", "metadata": {"originalType": "RETURNS_FALSE"}}, {"src": "<module>", "dst": "<LastOf>", "type": "DECLARES"}, {"src": "<LastOf>", "dst": "<T:LastOf>", "type": "CONTAINS"}, {"src": "<LastOf>", "dst": "<T extends [...unknown[], infer L] ? L : never>", "type": "RESOLVES_TO"}, {"src": "<T extends [...unknown[], infer L] ? L : never>", "dst": "<T:LastOf>", "type": "HAS_CONDITION", "metadata": {"originalType": "TESTS"}}, {"src": "<T extends [...unknown[], infer L] ? L : never>", "dst": "<L>", "type": "INFERS"}, {"src": "<T extends [...unknown[], infer L] ? L : never>", "dst": "<L>", "type": "RETURNS", "metadata": {"originalType": "RETURNS_TRUE"}}, {"src": "<T extends [...unknown[], infer L] ? L : never>", "dst": "<never:LastOf>", "type": "RETURNS", "metadata": {"originalType": "RETURNS_FALSE"}}], "rationale": "Four generic type aliases demonstrating variadic tuple operations. Concat uses spread syntax to merge tuples. HeadOf/TailOf/LastOf use conditional types with pattern matching and type inference to extract tuple elements. [merge-map applied]", "implicitBehavior": ["Type parameter constraints enforce array-like types", "Conditional types perform structural pattern matching at compile time", "infer keyword captures types during pattern matching", "Variadic tuple types preserve element order and count"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-import-type-inline", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 688, "lineEnd": 693, "code": "// Type-level import()  resolves types without runtime import\ntype InlineImported = import('./modules-helpers.js').default;\n// In function signatures: function handle(req: import('express').Request): void {}\n\n// --- TypeScript using with type annotations ---", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<InlineImported>", "metadata": {"kind": "type"}}, {"type": "IMPORT", "id": "<import('./modules-helpers.js')>", "metadata": {"source": "./modules-helpers.js", "importKind": "type-only", "originalType": "TYPE_IMPORT"}}, {"type": "PROPERTY_ACCESS", "id": "<import('./modules-helpers.js').default>", "metadata": {"property": "default", "originalType": "TYPE_ACCESS"}}], "edges": [{"src": "<module>", "dst": "<InlineImported>", "type": "DECLARES"}, {"src": "<InlineImported>", "dst": "<import('./modules-helpers.js').default>", "type": "ASSIGNED_FROM"}, {"src": "<import('./modules-helpers.js').default>", "dst": "<import('./modules-helpers.js')>", "type": "READS_FROM", "metadata": {"originalType": "ACCESSES_PROPERTY"}}, {"src": "<import('./modules-helpers.js')>", "dst": "<./modules-helpers.js>", "type": "IMPORTS_FROM", "metadata": {"originalType": "IMPORTS_TYPE_FROM"}}], "rationale": "Type alias using inline import() type operator. Creates type-level dependency without runtime import. [merge-map applied]", "implicitBehavior": ["type-only import - no runtime code generated", "resolved at compile time only"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-typeof-class", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 624, "lineEnd": 635, "code": "class ExampleForTypeof {\n  static create() { return new ExampleForTypeof(); }\n  method() { return 1; }\n}\n\ntype ExampleInstance = ExampleForTypeof;            // instance type  has method()\ntype ExampleConstructor = typeof ExampleForTypeof;  // constructor type  has create()\n\nfunction classFactory(Cls: typeof ExampleForTypeof): ExampleForTypeof {\n  return Cls.create();\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<ExampleForTypeof>"}, {"type": "METHOD", "id": "<ExampleForTypeof.create>", "metadata": {"kind": "static"}}, {"type": "EXPRESSION", "id": "<new ExampleForTypeof()>", "metadata": {"operator": "new"}}, {"type": "METHOD", "id": "<ExampleForTypeof.method>", "metadata": {"kind": "instance"}}, {"type": "LITERAL", "id": "<1>", "metadata": {"value": 1, "literalType": "number"}}, {"type": "TYPE_ALIAS", "id": "<ExampleInstance>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<ExampleForTypeof:instance-type>"}, {"type": "TYPE_ALIAS", "id": "<ExampleConstructor>", "metadata": {"kind": "type"}}, {"type": "TYPE_REFERENCE", "id": "<typeof ExampleForTypeof>", "metadata": {"originalType": "TYPEOF_TYPE"}}, {"type": "FUNCTION", "id": "<classFactory>", "metadata": {"async": false, "generator": false}}, {"type": "PARAMETER", "id": "<Cls>", "metadata": {"typeAnnotated": true}}, {"type": "TYPE_REFERENCE", "id": "<typeof ExampleForTypeof:param-type>"}, {"type": "TYPE_REFERENCE", "id": "<ExampleForTypeof:return-type>"}, {"type": "CALL", "id": "<Cls.create()>", "metadata": {"callee": "Cls.create"}}], "edges": [{"src": "<module>", "dst": "<ExampleForTypeof>", "type": "DECLARES"}, {"src": "<ExampleForTypeof>", "dst": "<ExampleForTypeof.create>", "type": "CONTAINS"}, {"src": "<ExampleForTypeof>", "dst": "<ExampleForTypeof.method>", "type": "CONTAINS"}, {"src": "<ExampleForTypeof.create>", "dst": "<new ExampleForTypeof()>", "type": "RETURNS"}, {"src": "<new ExampleForTypeof()>", "dst": "<ExampleForTypeof>", "type": "CALLS", "metadata": {"originalType": "INSTANTIATES"}}, {"src": "<ExampleForTypeof.method>", "dst": "<1>", "type": "RETURNS"}, {"src": "<module>", "dst": "<ExampleInstance>", "type": "DECLARES"}, {"src": "<ExampleInstance>", "dst": "<ExampleForTypeof:instance-type>", "type": "ALIASES"}, {"src": "<ExampleForTypeof:instance-type>", "dst": "<ExampleForTypeof>", "type": "HAS_TYPE", "metadata": {"originalType": "INSTANCE_TYPE_OF"}}, {"src": "<module>", "dst": "<ExampleConstructor>", "type": "DECLARES"}, {"src": "<ExampleConstructor>", "dst": "<typeof ExampleForTypeof>", "type": "ALIASES"}, {"src": "<typeof ExampleForTypeof>", "dst": "<ExampleForTypeof>", "type": "HAS_TYPE", "metadata": {"originalType": "CONSTRUCTOR_TYPE_OF"}}, {"src": "<module>", "dst": "<classFactory>", "type": "DECLARES"}, {"src": "<classFactory>", "dst": "<Cls>", "type": "CONTAINS"}, {"src": "<Cls>", "dst": "<typeof ExampleForTypeof:param-type>", "type": "HAS_TYPE"}, {"src": "<typeof ExampleForTypeof:param-type>", "dst": "<ExampleForTypeof>", "type": "HAS_TYPE", "metadata": {"originalType": "CONSTRUCTOR_TYPE_OF"}}, {"src": "<classFactory>", "dst": "<ExampleForTypeof:return-type>", "type": "RETURNS_TYPE", "metadata": {"originalType": "HAS_RETURN_TYPE"}}, {"src": "<ExampleForTypeof:return-type>", "dst": "<ExampleForTypeof>", "type": "HAS_TYPE", "metadata": {"originalType": "INSTANCE_TYPE_OF"}}, {"src": "<classFactory>", "dst": "<Cls.create()>", "type": "RETURNS"}, {"src": "<Cls.create()>", "dst": "<Cls>", "type": "CALLS_ON"}, {"src": "<Cls.create()>", "dst": "<ExampleForTypeof.create>", "type": "CALLS"}], "rationale": "TypeScript typeof operator creates constructor types distinct from instance types. The class has both instance methods and static methods. Type aliases capture the semantic difference between instance type and constructor type. [merge-map applied]", "implicitBehavior": ["typeof operator extracts constructor type including static members", "Instance type includes instance methods but not static methods", "Constructor type includes static methods and call signature", "Type system enforces that Cls parameter can only be constructor-compatible classes"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-enum-reverse-mapping", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 656, "lineEnd": 664, "code": "enum HttpStatus {\n  OK = 200,\n  NotFound = 404,\n  ServerError = 500,\n}\nconst statusName = HttpStatus[200];           // 'OK'  reverse mapping\nconst statusCode = HttpStatus.OK;             // 200  forward mapping\n// String enums do NOT have reverse mapping", "commentedOut": false}, "annotation": {"nodes": [{"type": "ENUM", "id": "<HttpStatus>", "metadata": {"hasReverseMappings": true}}, {"type": "ENUM_MEMBER", "id": "<HttpStatus.OK>", "metadata": {"key": "OK", "value": 200}}, {"type": "ENUM_MEMBER", "id": "<HttpStatus.NotFound>", "metadata": {"key": "NotFound", "value": 404}}, {"type": "ENUM_MEMBER", "id": "<HttpStatus.ServerError>", "metadata": {"key": "ServerError", "value": 500}}, {"type": "LITERAL", "id": "<200>", "metadata": {"value": 200, "literalType": "number"}}, {"type": "LITERAL", "id": "<404>", "metadata": {"value": 404, "literalType": "number"}}, {"type": "LITERAL", "id": "<500>", "metadata": {"value": 500, "literalType": "number"}}, {"type": "VARIABLE", "id": "<statusName>", "metadata": {"kind": "const"}}, {"type": "PROPERTY_ACCESS", "id": "<HttpStatus[200]>", "metadata": {"accessType": "computed", "isReverseMapping": true}}, {"type": "VARIABLE", "id": "<statusCode>", "metadata": {"kind": "const"}}, {"type": "PROPERTY_ACCESS", "id": "<HttpStatus.OK>", "metadata": {"accessType": "member", "isForwardMapping": true}}], "edges": [{"src": "<module>", "dst": "<HttpStatus>", "type": "DECLARES"}, {"src": "<HttpStatus>", "dst": "<HttpStatus.OK>", "type": "CONTAINS"}, {"src": "<HttpStatus>", "dst": "<HttpStatus.NotFound>", "type": "CONTAINS"}, {"src": "<HttpStatus>", "dst": "<HttpStatus.ServerError>", "type": "CONTAINS"}, {"src": "<HttpStatus.OK>", "dst": "<200>", "type": "ASSIGNED_FROM"}, {"src": "<HttpStatus.NotFound>", "dst": "<404>", "type": "ASSIGNED_FROM"}, {"src": "<HttpStatus.ServerError>", "dst": "<500>", "type": "ASSIGNED_FROM"}, {"src": "<module>", "dst": "<statusName>", "type": "DECLARES"}, {"src": "<statusName>", "dst": "<HttpStatus[200]>", "type": "ASSIGNED_FROM"}, {"src": "<HttpStatus[200]>", "dst": "<HttpStatus>", "type": "READS_FROM"}, {"src": "<HttpStatus[200]>", "dst": "<200>", "type": "READS_FROM", "metadata": {"originalType": "USES_KEY"}}, {"src": "<module>", "dst": "<statusCode>", "type": "DECLARES"}, {"src": "<statusCode>", "dst": "<HttpStatus.OK>", "type": "ASSIGNED_FROM"}, {"src": "<HttpStatus.OK>", "dst": "<HttpStatus>", "type": "READS_FROM"}], "rationale": "TypeScript enum with numeric values creates both forward (namevalue) and reverse (valuename) mappings. Computed access uses reverse mapping, member access uses forward mapping. [merge-map applied]", "implicitBehavior": ["TypeScript generates reverse mappings for numeric enums at compile time", "String enums do not generate reverse mappings", "Reverse mapping creates bidirectional object structure"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-generic-keyof-constraint", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 615, "lineEnd": 622, "code": "function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nfunction pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {\n  return items.map(item => item[key]);\n}", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<getProperty>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>", "metadata": {"name": "T"}}, {"type": "TYPE_PARAMETER", "id": "<K>", "metadata": {"name": "K"}}, {"type": "TYPE_REFERENCE", "id": "<keyof T>", "metadata": {"operator": "keyof", "target": "T", "originalType": "TYPE_CONSTRAINT"}}, {"type": "PARAMETER", "id": "<obj>", "metadata": {"typeAnnotation": "T"}}, {"type": "PARAMETER", "id": "<key>", "metadata": {"typeAnnotation": "K"}}, {"type": "TYPE_REFERENCE", "id": "<T[K]>", "metadata": {"indexedAccess": true, "object": "T", "key": "K", "originalType": "TYPE_ANNOTATION"}}, {"type": "PROPERTY_ACCESS", "id": "<obj[key]>"}, {"type": "FUNCTION", "id": "<pluck>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T2>", "metadata": {"name": "T"}}, {"type": "TYPE_PARAMETER", "id": "<K2>", "metadata": {"name": "K"}}, {"type": "TYPE_REFERENCE", "id": "<keyof T2>", "metadata": {"operator": "keyof", "target": "T", "originalType": "TYPE_CONSTRAINT"}}, {"type": "PARAMETER", "id": "<items>", "metadata": {"typeAnnotation": "T[]"}}, {"type": "PARAMETER", "id": "<key2>", "metadata": {"typeAnnotation": "K"}}, {"type": "TYPE_REFERENCE", "id": "<T[K][]>", "metadata": {"arrayOf": "T[K]", "originalType": "TYPE_ANNOTATION"}}, {"type": "CALL", "id": "<items.map(...)>", "metadata": {"method": "map"}}, {"type": "FUNCTION", "id": "<arrow-fn>", "metadata": {"arrowFunction": true}}, {"type": "PARAMETER", "id": "<item>"}, {"type": "PROPERTY_ACCESS", "id": "<item[key]>"}], "edges": [{"src": "<module>", "dst": "<getProperty>", "type": "DECLARES"}, {"src": "<getProperty>", "dst": "<T>", "type": "CONTAINS"}, {"src": "<getProperty>", "dst": "<K>", "type": "CONTAINS"}, {"src": "<K>", "dst": "<keyof T>", "type": "CONSTRAINED_BY"}, {"src": "<keyof T>", "dst": "<T>", "type": "DEPENDS_ON"}, {"src": "<getProperty>", "dst": "<obj>", "type": "CONTAINS"}, {"src": "<getProperty>", "dst": "<key>", "type": "CONTAINS"}, {"src": "<obj>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<key>", "dst": "<K>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<getProperty>", "dst": "<T[K]>", "type": "RETURNS"}, {"src": "<T[K]>", "dst": "<T>", "type": "DEPENDS_ON"}, {"src": "<T[K]>", "dst": "<K>", "type": "DEPENDS_ON"}, {"src": "<getProperty>", "dst": "<obj[key]>", "type": "RETURNS"}, {"src": "<obj[key]>", "dst": "<obj>", "type": "READS_FROM"}, {"src": "<obj[key]>", "dst": "<key>", "type": "READS_FROM"}, {"src": "<module>", "dst": "<pluck>", "type": "DECLARES"}, {"src": "<pluck>", "dst": "<T2>", "type": "CONTAINS"}, {"src": "<pluck>", "dst": "<K2>", "type": "CONTAINS"}, {"src": "<K2>", "dst": "<keyof T2>", "type": "CONSTRAINED_BY"}, {"src": "<keyof T2>", "dst": "<T2>", "type": "DEPENDS_ON"}, {"src": "<pluck>", "dst": "<items>", "type": "CONTAINS"}, {"src": "<pluck>", "dst": "<key2>", "type": "CONTAINS"}, {"src": "<items>", "dst": "<T2>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<key2>", "dst": "<K2>", "type": "HAS_TYPE", "metadata": {"originalType": "TYPED_AS"}}, {"src": "<pluck>", "dst": "<T[K][]>", "type": "RETURNS"}, {"src": "<T[K][]>", "dst": "<T2>", "type": "DEPENDS_ON"}, {"src": "<T[K][]>", "dst": "<K2>", "type": "DEPENDS_ON"}, {"src": "<pluck>", "dst": "<items.map(...)>", "type": "RETURNS"}, {"src": "<items.map(...)>", "dst": "<items>", "type": "CALLS"}, {"src": "<items.map(...)>", "dst": "<arrow-fn>", "type": "PASSES_ARGUMENT"}, {"src": "<arrow-fn>", "dst": "<item>", "type": "CONTAINS"}, {"src": "<arrow-fn>", "dst": "<item[key]>", "type": "RETURNS"}, {"src": "<item[key]>", "dst": "<item>", "type": "READS_FROM"}, {"src": "<item[key]>", "dst": "<key2>", "type": "READS_FROM"}], "rationale": "Two generic functions with keyof constraints. Type parameter K is constrained to be keys of T, ensuring type-safe property access. The constraint creates a dependency relationship between type parameters. [merge-map applied]", "implicitBehavior": ["TypeScript compiler enforces keyof constraint at compile time", "Indexed access type T[K] is resolved based on the constraint", "Type inference flows from constraint to return type"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-import-equals-require", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 726, "lineEnd": 732, "code": "// CJS-style import  emits: const CjsLib = require('./module')\n// import CjsLib = require('./module');\n// const instance = new CjsLib();\n// (commented out: requires actual CJS module; syntax is ExportAssignment / ImportEqualsDeclaration)\n\n// --- Getter and setter with different types (TS 4.3+) ---", "commentedOut": true}, "annotation": {"nodes": [{"type": "IMPORT", "id": "<import-equals>", "metadata": {"source": "./module", "importType": "import-equals", "cjsStyle": true}}, {"type": "VARIABLE", "id": "<CjsLib>", "metadata": {"kind": "const", "imported": true, "tsImportEquals": true}}, {"type": "CALL", "id": "<new CjsLib()>", "metadata": {"callType": "constructor"}}, {"type": "VARIABLE", "id": "<instance>", "metadata": {"kind": "const"}}], "edges": [{"src": "<module>", "dst": "<import-equals>", "type": "CONTAINS"}, {"src": "<import-equals>", "dst": "<CjsLib>", "type": "IMPORTS"}, {"src": "<module>", "dst": "<./module>", "type": "IMPORTS_FROM"}, {"src": "<module>", "dst": "<instance>", "type": "DECLARES"}, {"src": "<instance>", "dst": "<new CjsLib()>", "type": "ASSIGNED_FROM"}, {"src": "<new CjsLib()>", "dst": "<CjsLib>", "type": "CALLS"}], "rationale": "TypeScript import-equals syntax for CommonJS modules. Creates a binding equivalent to const assignment from require(), then instantiates the imported constructor. [merge-map applied]", "implicitBehavior": ["compiles to const CjsLib = require('./module')", "requires CommonJS module at runtime", "TypeScript-specific syntax for CJS interop"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-export-equals", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 717, "lineEnd": 724, "code": "// CJS-style export assignment  emits: module.exports = CjsLibrary\nclass CjsLibrary {\n  static VERSION = '1.0';\n  process(data: string): string { return data.toUpperCase(); }\n}\n// export = CjsLibrary;\n// (commented out: only one module export mode per file; shown for AST coverage)", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<CjsLibrary>"}, {"type": "PROPERTY", "id": "<CjsLibrary.VERSION>", "metadata": {"static": true}}, {"type": "LITERAL", "id": "<'1.0'>", "metadata": {"value": "1.0", "literalType": "string"}}, {"type": "METHOD", "id": "<CjsLibrary.process>", "metadata": {"kind": "method"}}, {"type": "PARAMETER", "id": "<data>", "metadata": {"type": "string"}}, {"type": "CALL", "id": "<data.toUpperCase()>", "metadata": {"callee": "toUpperCase"}}, {"type": "EXPORT", "id": "<export=CjsLibrary>", "metadata": {"exportType": "export=", "commented": true}}], "edges": [{"src": "<module>", "dst": "<CjsLibrary>", "type": "DECLARES"}, {"src": "<CjsLibrary>", "dst": "<CjsLibrary.VERSION>", "type": "CONTAINS"}, {"src": "<CjsLibrary.VERSION>", "dst": "<'1.0'>", "type": "ASSIGNED_FROM"}, {"src": "<CjsLibrary>", "dst": "<CjsLibrary.process>", "type": "CONTAINS"}, {"src": "<CjsLibrary.process>", "dst": "<data>", "type": "CONTAINS"}, {"src": "<CjsLibrary.process>", "dst": "<data.toUpperCase()>", "type": "RETURNS"}, {"src": "<data.toUpperCase()>", "dst": "<data>", "type": "CALLS_ON"}, {"src": "<export=CjsLibrary>", "dst": "<CjsLibrary>", "type": "EXPORTS"}], "rationale": "Class with static property and instance method. The commented export= would make the entire class the module's default export in CommonJS style. [merge-map applied]", "implicitBehavior": ["export= compiles to module.exports assignment", "TypeScript allows only one export= per module", "export= is mutually exclusive with ES6 export syntax"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-generic-default-prior-ref", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 666, "lineEnd": 679, "code": "function createGenericStore<\n  S extends object,\n  A extends object = {},\n  G extends Record<string, (state: S) => unknown> = {},\n>(config: { state: S; actions?: A; getters?: G }) {\n  return config;\n}\n\nfunction wrapInArray<T, R = T[]>(value: T): R {\n  return [value] as unknown as R;         // R defaults to T[]\n}\n\n// --- infer with constraints (TS 4.7+) ---", "commentedOut": false}, "annotation": {"nodes": [{"type": "FUNCTION", "id": "<createGenericStore>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<S>", "metadata": {"constraint": "object"}}, {"type": "TYPE_PARAMETER", "id": "<A>", "metadata": {"constraint": "object", "hasDefault": true}}, {"type": "TYPE_PARAMETER", "id": "<G>", "metadata": {"constraint": "Record<string, (state: S) => unknown>", "hasDefault": true}}, {"type": "LITERAL", "id": "<{}>", "metadata": {"value": "{}", "literalType": "object"}}, {"type": "LITERAL", "id": "<{}>", "metadata": {"value": "{}", "literalType": "object"}}, {"type": "PARAMETER", "id": "<config>", "metadata": {"type": "{ state: S; actions?: A; getters?: G }"}}, {"type": "FUNCTION", "id": "<wrapInArray>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T>"}, {"type": "TYPE_PARAMETER", "id": "<R>", "metadata": {"hasDefault": true, "defaultType": "T[]"}}, {"type": "PARAMETER", "id": "<value>", "metadata": {"type": "T"}}, {"type": "EXPRESSION", "id": "<[value] as unknown as R>", "metadata": {"operator": "type_assertion", "doubleAssertion": true}}, {"type": "EXPRESSION", "id": "<[value]>", "metadata": {"operator": "array_literal"}}], "edges": [{"src": "<module>", "dst": "<createGenericStore>", "type": "DECLARES"}, {"src": "<createGenericStore>", "dst": "<S>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<createGenericStore>", "dst": "<A>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<createGenericStore>", "dst": "<G>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<A>", "dst": "<{}>", "type": "DEFAULTS_TO"}, {"src": "<G>", "dst": "<{}>", "type": "DEFAULTS_TO"}, {"src": "<G>", "dst": "<S>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<createGenericStore>", "dst": "<config>", "type": "CONTAINS"}, {"src": "<config>", "dst": "<S>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<config>", "dst": "<A>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<config>", "dst": "<G>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<createGenericStore>", "dst": "<config>", "type": "RETURNS"}, {"src": "<module>", "dst": "<wrapInArray>", "type": "DECLARES"}, {"src": "<wrapInArray>", "dst": "<T>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<wrapInArray>", "dst": "<R>", "type": "HAS_TYPE_PARAMETER"}, {"src": "<R>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<wrapInArray>", "dst": "<value>", "type": "CONTAINS"}, {"src": "<value>", "dst": "<T>", "type": "HAS_TYPE", "metadata": {"originalType": "REFERENCES_TYPE"}}, {"src": "<wrapInArray>", "dst": "<[value] as unknown as R>", "type": "RETURNS"}, {"src": "<[value] as unknown as R>", "dst": "<[value]>", "type": "DERIVES_FROM", "metadata": {"originalType": "CASTS_FROM"}}, {"src": "<[value]>", "dst": "<value>", "type": "READS_FROM"}, {"src": "<[value] as unknown as R>", "dst": "<R>", "type": "DERIVES_FROM", "metadata": {"originalType": "CASTS_TO"}}], "rationale": "Two generic functions with type parameters that have defaults. The first has complex constraints and cross-references between type parameters. The second demonstrates default type parameter referencing another type parameter. [merge-map applied]", "implicitBehavior": ["Type parameter defaults are evaluated when not explicitly provided at call site", "Type constraints are enforced at compile time", "Double type assertion bypasses TypeScript's type checking for the intermediate cast"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-getter-setter-different-types", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 734, "lineEnd": 748, "code": "class SmartField {\n  #raw: string = '';\n\n  get value(): string {\n    return this.#raw;\n  }\n\n  // Setter accepts wider type than getter returns\n  set value(input: string | number) {\n    this.#raw = String(input);\n  }\n}\n\n// --- Inline type modifier on import/export specifiers (TS 4.5+) ---", "commentedOut": false}, "annotation": {"nodes": [{"type": "CLASS", "id": "<SmartField>"}, {"type": "PROPERTY", "id": "<SmartField.#raw>", "metadata": {"visibility": "private", "type": "string"}}, {"type": "LITERAL", "id": "<''>", "metadata": {"value": "", "literalType": "string"}}, {"type": "METHOD", "id": "<SmartField.value:getter>", "metadata": {"kind": "getter", "returnType": "string"}}, {"type": "METHOD", "id": "<SmartField.value:setter>", "metadata": {"kind": "setter", "parameterType": "string | number"}}, {"type": "PARAMETER", "id": "<input>", "metadata": {"type": "string | number"}}, {"type": "CALL", "id": "<String(input)>", "metadata": {"callee": "String"}}], "edges": [{"src": "<module>", "dst": "<SmartField>", "type": "DECLARES"}, {"src": "<SmartField>", "dst": "<SmartField.#raw>", "type": "CONTAINS"}, {"src": "<SmartField.#raw>", "dst": "<''>", "type": "ASSIGNED_FROM"}, {"src": "<SmartField>", "dst": "<SmartField.value:getter>", "type": "CONTAINS"}, {"src": "<SmartField>", "dst": "<SmartField.value:setter>", "type": "CONTAINS"}, {"src": "<SmartField.value:getter>", "dst": "<SmartField.#raw>", "type": "READS_FROM"}, {"src": "<SmartField.value:getter>", "dst": "<SmartField.#raw>", "type": "RETURNS"}, {"src": "<SmartField.value:setter>", "dst": "<input>", "type": "CONTAINS"}, {"src": "<String(input)>", "dst": "<String>", "type": "CALLS"}, {"src": "<String(input)>", "dst": "<input>", "type": "PASSES_ARGUMENT"}, {"src": "<SmartField.#raw>", "dst": "<String(input)>", "type": "ASSIGNED_FROM"}, {"src": "<SmartField.value:setter>", "dst": "<SmartField.#raw>", "type": "WRITES_TO"}], "rationale": "Class with private field and getter/setter pair. Getter returns string, setter accepts string|number union type and converts via String() constructor before assignment. [merge-map applied]", "implicitBehavior": ["TypeScript type checking enforces getter return type and setter parameter type", "Private field syntax creates truly private class member", "Type coercion through String() constructor"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-using-typed", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 695, "lineEnd": 701, "code": "// using with type annotations (TS extension of ES2025 Explicit Resource Management)\n// using handle: FileHandle = openFile('/tmp/data');\n// await using conn: DBConnection = await pool.connect();\n// for (using reader: Reader of getReaders()) { reader.process(); }\n\n// --- satisfies + as const combo ---", "commentedOut": true}, "annotation": {"nodes": [{"type": "VARIABLE", "id": "<handle>", "metadata": {"kind": "using", "typeAnnotation": "FileHandle", "resourceManaged": true}}, {"type": "TYPE_REFERENCE", "id": "<FileHandle>", "metadata": {"typeName": "FileHandle", "originalType": "TYPE_ANNOTATION"}}, {"type": "CALL", "id": "<openFile('/tmp/data')>", "metadata": {"callee": "openFile"}}, {"type": "LITERAL", "id": "<'/tmp/data'>", "metadata": {"value": "/tmp/data", "literalType": "string"}}, {"type": "VARIABLE", "id": "<conn>", "metadata": {"kind": "await using", "typeAnnotation": "DBConnection", "resourceManaged": true, "async": true}}, {"type": "TYPE_REFERENCE", "id": "<DBConnection>", "metadata": {"typeName": "DBConnection", "originalType": "TYPE_ANNOTATION"}}, {"type": "EXPRESSION", "id": "<await pool.connect()>", "metadata": {"async": true}}, {"type": "CALL", "id": "<pool.connect()>", "metadata": {"callee": "pool.connect"}}, {"type": "LOOP", "id": "<for-using>", "metadata": {"loopType": "for-using"}}, {"type": "VARIABLE", "id": "<reader>", "metadata": {"kind": "using", "typeAnnotation": "Reader", "resourceManaged": true}}, {"type": "TYPE_REFERENCE", "id": "<Reader>", "metadata": {"typeName": "Reader", "originalType": "TYPE_ANNOTATION"}}, {"type": "CALL", "id": "<getReaders()>", "metadata": {"callee": "getReaders"}}, {"type": "CALL", "id": "<reader.process()>", "metadata": {"callee": "reader.process"}}], "edges": [{"src": "<module>", "dst": "<handle>", "type": "DECLARES"}, {"src": "<handle>", "dst": "<FileHandle>", "type": "HAS_TYPE", "metadata": {"originalType": "HAS_TYPE_ANNOTATION"}}, {"src": "<handle>", "dst": "<openFile('/tmp/data')>", "type": "ASSIGNED_FROM"}, {"src": "<openFile('/tmp/data')>", "dst": "<openFile>", "type": "CALLS"}, {"src": "<openFile('/tmp/data')>", "dst": "<'/tmp/data'>", "type": "PASSES_ARGUMENT"}, {"src": "<module>", "dst": "<conn>", "type": "DECLARES"}, {"src": "<conn>", "dst": "<DBConnection>", "type": "HAS_TYPE", "metadata": {"originalType": "HAS_TYPE_ANNOTATION"}}, {"src": "<conn>", "dst": "<await pool.connect()>", "type": "ASSIGNED_FROM"}, {"src": "<await pool.connect()>", "dst": "<pool.connect()>", "type": "AWAITS"}, {"src": "<pool.connect()>", "dst": "<pool.connect>", "type": "CALLS"}, {"src": "<for-using>", "dst": "<getReaders()>", "type": "ITERATES_OVER"}, {"src": "<for-using>", "dst": "<reader>", "type": "CONTAINS"}, {"src": "<reader>", "dst": "<Reader>", "type": "HAS_TYPE", "metadata": {"originalType": "HAS_TYPE_ANNOTATION"}}, {"src": "<getReaders()>", "dst": "<getReaders>", "type": "CALLS"}, {"src": "<reader.process()>", "dst": "<reader.process>", "type": "CALLS"}, {"src": "<reader.process()>", "dst": "<reader>", "type": "READS_FROM"}], "rationale": "TypeScript-typed using declarations for explicit resource management. Each using variable has type annotations and automatic disposal semantics. [merge-map applied]", "implicitBehavior": ["using variables automatically call Symbol.dispose at end of scope", "await using variables automatically call Symbol.asyncDispose at end of scope", "for-using loop disposes reader after each iteration", "TypeScript enforces that assigned values implement Disposable/AsyncDisposable interfaces"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-inline-type-modifier", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 750, "lineEnd": 762, "code": "// Mixed value + type in single import:\n// import { Component, type Props, type State } from './ui';\n// Component  runtime import (IMPORTS_FROM edge)\n// Props, State  type-only (erased, NO runtime dependency)\n\n// Mixed value + type in single re-export:\n// export { handler, type HandlerConfig } from './handlers';\n\n// Contrast with import type (entire statement is type-only):\n// import type { OnlyTypes } from './types';\n\n// --- this parameter combined with destructuring ---", "commentedOut": true}, "annotation": {"nodes": [{"type": "IMPORT", "id": "<import-ui>", "metadata": {"source": "./ui", "mixed": true}}, {"type": "VARIABLE", "id": "<Component>", "metadata": {"imported": true, "runtime": true}}, {"type": "TYPE_ALIAS", "id": "<Props>", "metadata": {"imported": true, "typeOnly": true}}, {"type": "TYPE_ALIAS", "id": "<State>", "metadata": {"imported": true, "typeOnly": true}}, {"type": "EXPORT", "id": "<export-handlers>", "metadata": {"source": "./handlers", "mixed": true}}, {"type": "VARIABLE", "id": "<handler>", "metadata": {"reexported": true, "runtime": true}}, {"type": "TYPE_ALIAS", "id": "<HandlerConfig>", "metadata": {"reexported": true, "typeOnly": true}}, {"type": "IMPORT", "id": "<import-types>", "metadata": {"source": "./types", "typeOnly": true}}, {"type": "TYPE_ALIAS", "id": "<OnlyTypes>", "metadata": {"imported": true, "typeOnly": true}}], "edges": [{"src": "<module>", "dst": "<import-ui>", "type": "CONTAINS"}, {"src": "<import-ui>", "dst": "<Component>", "type": "IMPORTS"}, {"src": "<import-ui>", "dst": "<Props>", "type": "IMPORTS", "metadata": {"originalType": "IMPORTS_TYPE"}}, {"src": "<import-ui>", "dst": "<State>", "type": "IMPORTS", "metadata": {"originalType": "IMPORTS_TYPE"}}, {"src": "<module>", "dst": "<./ui>", "type": "IMPORTS_FROM"}, {"src": "<module>", "dst": "<export-handlers>", "type": "CONTAINS"}, {"src": "<export-handlers>", "dst": "<handler>", "type": "EXPORTS"}, {"src": "<export-handlers>", "dst": "<HandlerConfig>", "type": "EXPORTS", "metadata": {"originalType": "EXPORTS_TYPE"}}, {"src": "<module>", "dst": "<./handlers>", "type": "IMPORTS_FROM"}, {"src": "<module>", "dst": "<import-types>", "type": "CONTAINS"}, {"src": "<import-types>", "dst": "<OnlyTypes>", "type": "IMPORTS", "metadata": {"originalType": "IMPORTS_TYPE"}}], "rationale": "TypeScript inline type modifiers distinguish runtime vs compile-time dependencies within mixed import/export statements. Type-only imports create no runtime dependency edges. [merge-map applied]", "implicitBehavior": ["type-only imports are erased during compilation", "mixed statements create both runtime and type-only dependencies", "bundlers can tree-shake type-only imports safely"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-satisfies-as-const", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 703, "lineEnd": 715, "code": "const routes = {\n  home: '/',\n  about: '/about',\n  user: '/user/:id',\n} as const satisfies Record<string, string>;\n\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n} satisfies Record<string, string | number[]>;\n\n// --- TS CJS interop: export = / import = require() ---", "commentedOut": false}, "annotation": {"nodes": [{"type": "VARIABLE", "id": "<routes>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<routes:obj>", "metadata": {"asConst": true, "originalType": "OBJECT"}}, {"type": "PROPERTY", "id": "<routes:obj.home>", "metadata": {"key": "home"}}, {"type": "LITERAL", "id": "<'/'>", "metadata": {"value": "/", "literalType": "string"}}, {"type": "PROPERTY", "id": "<routes:obj.about>", "metadata": {"key": "about"}}, {"type": "LITERAL", "id": "<'/about'>", "metadata": {"value": "/about", "literalType": "string"}}, {"type": "PROPERTY", "id": "<routes:obj.user>", "metadata": {"key": "user"}}, {"type": "LITERAL", "id": "<'/user/:id'>", "metadata": {"value": "/user/:id", "literalType": "string"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, string>>", "metadata": {"constraintType": "satisfies", "originalType": "TYPE_CONSTRAINT"}}, {"type": "VARIABLE", "id": "<palette>", "metadata": {"kind": "const"}}, {"type": "LITERAL", "id": "<palette:obj>", "metadata": {"originalType": "OBJECT"}}, {"type": "PROPERTY", "id": "<palette:obj.red>", "metadata": {"key": "red"}}, {"type": "LITERAL", "id": "<[255, 0, 0]>", "metadata": {"originalType": "ARRAY"}}, {"type": "LITERAL", "id": "<255>", "metadata": {"value": 255, "literalType": "number"}}, {"type": "LITERAL", "id": "<0>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "LITERAL", "id": "<0_2>", "metadata": {"value": 0, "literalType": "number"}}, {"type": "PROPERTY", "id": "<palette:obj.green>", "metadata": {"key": "green"}}, {"type": "LITERAL", "id": "<'#00ff00'>", "metadata": {"value": "#00ff00", "literalType": "string"}}, {"type": "TYPE_REFERENCE", "id": "<Record<string, string | number[]>>", "metadata": {"constraintType": "satisfies", "originalType": "TYPE_CONSTRAINT"}}], "edges": [{"src": "<module>", "dst": "<routes>", "type": "DECLARES"}, {"src": "<routes>", "dst": "<routes:obj>", "type": "ASSIGNED_FROM"}, {"src": "<routes:obj>", "dst": "<Record<string, string>>", "type": "HAS_TYPE", "metadata": {"originalType": "SATISFIES_TYPE"}}, {"src": "<routes:obj>", "dst": "<routes:obj.home>", "type": "HAS_PROPERTY"}, {"src": "<routes:obj.home>", "dst": "<'/'>", "type": "ASSIGNED_FROM"}, {"src": "<routes:obj>", "dst": "<routes:obj.about>", "type": "HAS_PROPERTY"}, {"src": "<routes:obj.about>", "dst": "<'/about'>", "type": "ASSIGNED_FROM"}, {"src": "<routes:obj>", "dst": "<routes:obj.user>", "type": "HAS_PROPERTY"}, {"src": "<routes:obj.user>", "dst": "<'/user/:id'>", "type": "ASSIGNED_FROM"}, {"src": "<module>", "dst": "<palette>", "type": "DECLARES"}, {"src": "<palette>", "dst": "<palette:obj>", "type": "ASSIGNED_FROM"}, {"src": "<palette:obj>", "dst": "<Record<string, string | number[]>>", "type": "HAS_TYPE", "metadata": {"originalType": "SATISFIES_TYPE"}}, {"src": "<palette:obj>", "dst": "<palette:obj.red>", "type": "HAS_PROPERTY"}, {"src": "<palette:obj.red>", "dst": "<[255, 0, 0]>", "type": "ASSIGNED_FROM"}, {"src": "<[255, 0, 0]>", "dst": "<255>", "type": "HAS_ELEMENT"}, {"src": "<[255, 0, 0]>", "dst": "<0>", "type": "HAS_ELEMENT"}, {"src": "<[255, 0, 0]>", "dst": "<0_2>", "type": "HAS_ELEMENT"}, {"src": "<palette:obj>", "dst": "<palette:obj.green>", "type": "HAS_PROPERTY"}, {"src": "<palette:obj.green>", "dst": "<'#00ff00'>", "type": "ASSIGNED_FROM"}], "rationale": "TypeScript satisfies operator with as const assertion. First object uses both as const and satisfies for literal type preservation with type checking. Second object uses only satisfies for structural validation. [merge-map applied]", "implicitBehavior": ["as const assertion makes object properties readonly and literal types exact", "satisfies operator validates structure without widening types", "TypeScript compiler performs structural type checking at compile time"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
{"construct": {"id": "ts-specific::ts-infer-constrained", "file": "src/ts-specific.ts", "category": "ts-specific", "lineStart": 681, "lineEnd": 686, "code": "type FirstString<T> = T extends [infer S extends string, ...unknown[]] ? S : never;\ntype NumericKeys<T> = { [K in keyof T as K extends `${infer N extends number}` ? K : never]: T[K] };\ntype ParsePair<T> = T extends `${infer A extends number},${infer B extends number}` ? [A, B] : never;\n\n// --- Inline import() type expressions ---", "commentedOut": false}, "annotation": {"nodes": [{"type": "TYPE_ALIAS", "id": "<FirstString>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T1>", "metadata": {"name": "T"}}, {"type": "CONDITIONAL_TYPE", "id": "<FirstString:conditional>"}, {"type": "INFER_TYPE", "id": "<S>", "metadata": {"constraint": "string"}}, {"type": "TYPE_ALIAS", "id": "<[infer S extends string, ...unknown[]]>", "metadata": {"originalType": "TUPLE_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never1>", "metadata": {"value": "never"}}, {"type": "TYPE_ALIAS", "id": "<NumericKeys>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T2>", "metadata": {"name": "T"}}, {"type": "TYPE_ALIAS", "id": "<NumericKeys:mapped>", "metadata": {"originalType": "MAPPED_TYPE"}}, {"type": "TYPE_REFERENCE", "id": "<NumericKeys:remapping>", "metadata": {"originalType": "KEY_REMAPPING"}}, {"type": "INFER_TYPE", "id": "<N>", "metadata": {"constraint": "number"}}, {"type": "TYPE_REFERENCE", "id": "<${infer N extends number}>", "metadata": {"originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never2>", "metadata": {"value": "never"}}, {"type": "TYPE_ALIAS", "id": "<ParsePair>", "metadata": {"generic": true}}, {"type": "TYPE_PARAMETER", "id": "<T3>", "metadata": {"name": "T"}}, {"type": "CONDITIONAL_TYPE", "id": "<ParsePair:conditional>"}, {"type": "TYPE_REFERENCE", "id": "<${infer A extends number},${infer B extends number}>", "metadata": {"originalType": "TEMPLATE_LITERAL_TYPE"}}, {"type": "INFER_TYPE", "id": "<A>", "metadata": {"constraint": "number"}}, {"type": "INFER_TYPE", "id": "<B>", "metadata": {"constraint": "number"}}, {"type": "TYPE_ALIAS", "id": "<[A, B]>", "metadata": {"originalType": "TUPLE_TYPE"}}, {"type": "LITERAL_TYPE", "id": "<never3>", "metadata": {"value": "never"}}], "edges": [{"src": "<module>", "dst": "<FirstString>", "type": "DECLARES"}, {"src": "<FirstString>", "dst": "<T1>", "type": "CONTAINS"}, {"src": "<FirstString>", "dst": "<FirstString:conditional>", "type": "ASSIGNED_FROM"}, {"src": "<FirstString:conditional>", "dst": "<T1>", "type": "HAS_CONDITION", "metadata": {"originalType": "CHECKS_TYPE"}}, {"src": "<FirstString:conditional>", "dst": "<[infer S extends string, ...unknown[]]>", "type": "EXTENDS", "metadata": {"originalType": "EXTENDS_TYPE"}}, {"src": "<[infer S extends string, ...unknown[]]>", "dst": "<S>", "type": "INFERS"}, {"src": "<S>", "dst": "string", "type": "CONSTRAINED_BY"}, {"src": "<FirstString:conditional>", "dst": "<S>", "type": "HAS_CONSEQUENT"}, {"src": "<FirstString:conditional>", "dst": "<never1>", "type": "HAS_ALTERNATE"}, {"src": "<module>", "dst": "<NumericKeys>", "type": "DECLARES"}, {"src": "<NumericKeys>", "dst": "<T2>", "type": "CONTAINS"}, {"src": "<NumericKeys>", "dst": "<NumericKeys:mapped>", "type": "ASSIGNED_FROM"}, {"src": "<NumericKeys:mapped>", "dst": "<T2>", "type": "ITERATES_OVER", "metadata": {"originalType": "MAPS_OVER"}}, {"src": "<NumericKeys:mapped>", "dst": "<NumericKeys:remapping>", "type": "DERIVES_FROM", "metadata": {"originalType": "HAS_KEY_REMAPPING"}}, {"src": "<NumericKeys:remapping>", "dst": "<${infer N extends number}>", "type": "EXTENDS", "metadata": {"originalType": "EXTENDS_TYPE"}}, {"src": "<${infer N extends number}>", "dst": "<N>", "type": "INFERS"}, {"src": "<N>", "dst": "number", "type": "CONSTRAINED_BY"}, {"src": "<NumericKeys:remapping>", "dst": "<never2>", "type": "HAS_ALTERNATE"}, {"src": "<module>", "dst": "<ParsePair>", "type": "DECLARES"}, {"src": "<ParsePair>", "dst": "<T3>", "type": "CONTAINS"}, {"src": "<ParsePair>", "dst": "<ParsePair:conditional>", "type": "ASSIGNED_FROM"}, {"src": "<ParsePair:conditional>", "dst": "<T3>", "type": "HAS_CONDITION", "metadata": {"originalType": "CHECKS_TYPE"}}, {"src": "<ParsePair:conditional>", "dst": "<${infer A extends number},${infer B extends number}>", "type": "EXTENDS", "metadata": {"originalType": "EXTENDS_TYPE"}}, {"src": "<${infer A extends number},${infer B extends number}>", "dst": "<A>", "type": "INFERS"}, {"src": "<${infer A extends number},${infer B extends number}>", "dst": "<B>", "type": "INFERS"}, {"src": "<A>", "dst": "number", "type": "CONSTRAINED_BY"}, {"src": "<B>", "dst": "number", "type": "CONSTRAINED_BY"}, {"src": "<ParsePair:conditional>", "dst": "<[A, B]>", "type": "HAS_CONSEQUENT"}, {"src": "<[A, B]>", "dst": "<A>", "type": "CONTAINS"}, {"src": "<[A, B]>", "dst": "<B>", "type": "CONTAINS"}, {"src": "<ParsePair:conditional>", "dst": "<never3>", "type": "HAS_ALTERNATE"}], "rationale": "Three type aliases demonstrating constrained infer patterns. FirstString extracts first string from tuple, NumericKeys filters object keys to numeric ones, ParsePair parses comma-separated numbers from template literal. [merge-map applied]", "implicitBehavior": ["infer types are only valid within extends clauses of conditional types", "constraints on infer types are evaluated during type instantiation", "template literal type matching follows strict pattern rules"]}, "pass": 2, "annotatedAt": "2026-02-24T03:00:00.000Z"}
