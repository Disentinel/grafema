/**
 * ReactAnalyzer Tests
 *
 * Tests for React/Browser domain-specific analysis:
 * - Component rendering tree
 * - Props flow
 * - Event handlers
 * - Hooks (useState, useEffect, useMemo, useCallback)
 * - Browser APIs (localStorage, timers, DOM)
 * - Edge cases (stale closures, missing cleanup, RAF loops)
 */

// SKIP: ReactAnalyzer feature incomplete - missing fixtures
import { describe, it, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert';
import { readFileSync } from 'fs';
import { join } from 'path';
import { parse } from '@babel/parser';
import traverseModule from '@babel/traverse';

// ES module compatibility
const traverse = traverseModule.default || traverseModule;

// Import the analyzer
import { ReactAnalyzer } from '@grafema/core';

// Helper to parse fixture and run analyzer
function parseFixture(fixtureName) {
  const fixturePath = join(process.cwd(), 'test/fixtures/react-analyzer', fixtureName);
  const code = readFileSync(fixturePath, 'utf-8');
  const ast = parse(code, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript']
  });
  return { code, ast, filePath: fixturePath };
}

// Mock graph for testing
class MockGraph {
  constructor() {
    this.nodes = [];
    this.edges = [];
  }

  async addNode(node) {
    this.nodes.push(node);
  }

  async addNodes(nodes) {
    this.nodes.push(...nodes);
  }

  async addEdge(edge) {
    this.edges.push(edge);
  }

  async addEdges(edges) {
    this.edges.push(...edges);
  }

  async *queryNodes(filter) {
    for (const node of this.nodes) {
      let match = true;
      for (const [key, value] of Object.entries(filter)) {
        if (node[key] !== value) match = false;
      }
      if (match) yield node;
    }
  }

  getNodesByType(type) {
    return this.nodes.filter(n => n.type === type);
  }

  getEdgesByType(type) {
    return this.edges.filter(e => e.type === type);
  }

  findNode(predicate) {
    return this.nodes.find(predicate);
  }

  findEdge(predicate) {
    return this.edges.find(predicate);
  }
}

// =============================================================================
// BASIC COMPONENT TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Basic Components', () => {
  it('should detect functional component definitions', async () => {
    const { ast, filePath } = parseFixture('basic-component.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Expected: react:component nodes for App and Button
    const components = graph.getNodesByType('react:component');
    assert.ok(components.length >= 2, `Expected at least 2 components, got ${components.length}`);
    assert.ok(components.find(c => c.name === 'App'), 'Should find App component');
    assert.ok(components.find(c => c.name === 'Button'), 'Should find Button component');
  });

  it('should detect component rendering relationships', async () => {
    const { ast, filePath } = parseFixture('basic-component.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Expected edges:
    // App -RENDERS-> Button
    const rendersEdges = graph.getEdgesByType('RENDERS');
    assert.ok(rendersEdges.find(e =>
      e.src.includes('App') && e.dst.includes('Button')
    ), 'Should have App -> Button RENDERS edge');
  });

  it('should detect props passed to child components', async () => {
    const { ast, filePath } = parseFixture('basic-component.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Expected edges:
    // App -PASSES_PROP[label]-> Button
    // App -PASSES_PROP[onClick]-> Button
    const propEdges = graph.getEdgesByType('PASSES_PROP');
    assert.ok(propEdges.find(e =>
      e.propName === 'label' && e.dst.includes('Button')
    ), 'Should have label prop edge to Button');
    assert.ok(propEdges.find(e =>
      e.propName === 'onClick' && e.dst.includes('Button')
    ), 'Should have onClick prop edge to Button');
  });

  it('should detect callback props (function passed as prop)', async () => {
    const { ast, filePath } = parseFixture('basic-component.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // handleClick function is passed to Button as onClick
    const propEdges = graph.getEdgesByType('PASSES_PROP');
    const callbackProp = propEdges.find(e => e.propName === 'onClick');
    assert.ok(callbackProp, 'Should detect onClick callback prop');
  });
});

// =============================================================================
// EVENT HANDLER TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Event Handlers', () => {
  it('should detect onClick handlers', async () => {
    const { ast, filePath } = parseFixture('event-handlers.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Expected: dom:event#click nodes
    const events = graph.getNodesByType('dom:event');
    const clickEvents = events.filter(e => e.eventType === 'click');
    assert.ok(clickEvents.length > 0, 'Should detect click event handlers');
  });

  it('should detect form events (onSubmit, onChange)', async () => {
    const { ast, filePath } = parseFixture('event-handlers.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'submit'), 'Should detect submit event');
    assert.ok(events.find(e => e.eventType === 'change'), 'Should detect change event');
  });

  it('should detect inline arrow function handlers', async () => {
    const { ast, filePath } = parseFixture('event-handlers.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Inline handlers should have handler: '<inline>'
    const events = graph.getNodesByType('dom:event');
    const inlineHandler = events.find(e => e.handler === '<inline>');
    assert.ok(inlineHandler, 'Should detect inline arrow function handlers');
  });

  it('should detect conditional event handlers', async () => {
    const { ast, filePath } = parseFixture('event-handlers.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Conditional handlers will have handler as expression
    const events = graph.getNodesByType('dom:event');
    assert.ok(events.length > 0, 'Should detect event handlers');
  });
});

// =============================================================================
// HOOKS TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Hooks', () => {
  it('should detect useState and link state/setter pairs', async () => {
    const { ast, filePath } = parseFixture('hooks-basic.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Expected: react:state nodes
    const stateNodes = graph.getNodesByType('react:state');
    assert.ok(stateNodes.find(s => s.stateName === 'count' && s.setterName === 'setCount'),
      'Should detect count/setCount pair');
  });

  it('should detect useEffect and its dependencies', async () => {
    const { ast, filePath } = parseFixture('hooks-basic.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Expected: react:effect nodes with dependencies
    const effects = graph.getNodesByType('react:effect');
    assert.ok(effects.length > 0, 'Should detect useEffect hooks');

    // Check for effect with count dependency
    const countEffect = effects.find(e => e.deps?.includes('count'));
    assert.ok(countEffect, 'Should detect effect with count dependency');
  });

  it('should detect useEffect cleanup functions', async () => {
    const { ast, filePath } = parseFixture('hooks-basic.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const effects = graph.getNodesByType('react:effect');
    const effectWithCleanup = effects.find(e => e.hasCleanup);
    assert.ok(effectWithCleanup, 'Should detect effect with cleanup function');
  });

  it('should detect useCallback and its dependencies', async () => {
    const { ast, filePath } = parseFixture('hooks-basic.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const callbacks = graph.getNodesByType('react:callback');
    assert.ok(callbacks.length > 0, 'Should detect useCallback hooks');
  });

  it('should detect useMemo and its dependencies', async () => {
    const { ast, filePath } = parseFixture('hooks-basic.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const memos = graph.getNodesByType('react:memo');
    assert.ok(memos.length > 0, 'Should detect useMemo hooks');
    const countMemo = memos.find(m => m.deps?.includes('count'));
    assert.ok(countMemo, 'Should detect memo depending on count');
  });
});

// =============================================================================
// EDGE CASE: STALE CLOSURE DETECTION
// =============================================================================

describe.skip('ReactAnalyzer - Stale Closure Detection', () => {
  it('should detect variables used in callback but not in deps', async () => {
    const { ast, filePath } = parseFixture('edge-case-stale-closure.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // BUG: setInterval callback uses `count` but deps is [running]
    const issues = graph.getNodesByType('issue:stale-closure');
    assert.ok(issues.length > 0, 'Should detect stale closure issues');

    // Check for count variable stale closure
    const countIssue = issues.find(i => i.variable === 'count');
    assert.ok(countIssue, 'Should detect count variable stale closure');
  });

  it('should not flag functional updates as stale', async () => {
    const { ast, filePath } = parseFixture('edge-case-stale-closure.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // setCount(c => c + 1) is SAFE - setter with functional update shouldn't be flagged
    const issues = graph.getNodesByType('issue:stale-closure');
    // setCount itself shouldn't be flagged, only the raw count variable
    const setCountIssue = issues.find(i => i.variable === 'setCount');
    assert.ok(!setCountIssue, 'Should not flag setCount as stale');
  });

  it('should detect closure over props in callbacks', async () => {
    const { ast, filePath } = parseFixture('edge-case-canvas-raf.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // RAF callback uses `nodes` and `selectedNode` props but deps is []
    const issues = graph.getNodesByType('issue:stale-closure');
    const propsIssue = issues.find(i =>
      i.variable === 'nodes' || i.variable === 'selectedNode'
    );
    assert.ok(propsIssue, 'Should detect stale closure over props');
  });
});

// =============================================================================
// EDGE CASE: MISSING CLEANUP DETECTION
// =============================================================================

describe.skip('ReactAnalyzer - Missing Cleanup Detection', () => {
  it('should detect setInterval without clearInterval', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check for timer nodes that might be missing cleanup
    const timers = graph.getNodesByType('browser:timer');
    const intervals = timers.filter(t => t.api === 'setInterval');
    assert.ok(intervals.length > 0, 'Should detect setInterval calls');
  });

  it('should detect addEventListener without removeEventListener', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // For now, just verify the fixture is analyzed
    assert.ok(graph.nodes.length > 0, 'Should analyze the file');
  });

  it('should detect WebSocket without close', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check for WebSocket missing cleanup issue
    const issues = graph.getNodesByType('issue:missing-cleanup');
    const wsIssue = issues.find(i => i.api === 'WebSocket');
    assert.ok(wsIssue, 'Should detect WebSocket without cleanup');
  });

  it('should detect setTimeout that might fire after unmount', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const timers = graph.getNodesByType('browser:timer');
    const timeouts = timers.filter(t => t.api === 'setTimeout');
    assert.ok(timeouts.length > 0, 'Should detect setTimeout calls');
  });

  it('should recognize proper cleanup patterns', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // AbortController pattern - file should be analyzed without errors
    assert.ok(graph.nodes.length > 0, 'Should analyze the file');
  });
});

// =============================================================================
// EDGE CASE: CANVAS/RAF RENDERING BUGS
// =============================================================================

describe.skip('ReactAnalyzer - Canvas/RAF Rendering', () => {
  it('should detect RAF loop without cancelAnimationFrame cleanup', async () => {
    const { ast, filePath } = parseFixture('edge-case-canvas-raf.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check for RAF leak issues
    const rafLeaks = graph.getNodesByType('issue:raf-leak');
    assert.ok(rafLeaks.length > 0, 'Should detect RAF without cleanup');
  });

  it('should detect multiple RAF loops accumulating', async () => {
    const { ast, filePath } = parseFixture('edge-case-canvas-raf.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // RAF with deps but without proper ref cleanup
    const timers = graph.getNodesByType('browser:timer');
    const rafs = timers.filter(t => t.api === 'requestAnimationFrame');
    assert.ok(rafs.length > 0, 'Should detect requestAnimationFrame calls');
  });

  it('should detect stale data in RAF callback', async () => {
    const { ast, filePath } = parseFixture('edge-case-canvas-raf.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // RAF callback uses nodes/selectedNode but deps is []
    const issues = graph.getNodesByType('issue:stale-closure');
    assert.ok(issues.length > 0, 'Should detect stale data in callbacks');
  });

  it('should detect canvas context state not restored', async () => {
    const { ast, filePath } = parseFixture('edge-case-canvas-raf.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check for canvas draw calls including save/restore
    const canvasCalls = graph.getNodesByType('canvas:draw');
    assert.ok(canvasCalls.length > 0, 'Should detect canvas draw calls');
  });

  it('should detect fillText and other Canvas draw calls', async () => {
    const { ast, filePath } = parseFixture('edge-case-canvas-raf.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const canvasCalls = graph.getNodesByType('canvas:draw');
    const fillRect = canvasCalls.find(c => c.method === 'fillRect');
    const fillText = canvasCalls.find(c => c.method === 'fillText');
    assert.ok(fillRect, 'Should detect fillRect');
    assert.ok(fillText, 'Should detect fillText');
  });
});

// =============================================================================
// CONDITIONAL RENDERING TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Conditional Rendering', () => {
  it('should detect && short-circuit rendering', async () => {
    const { ast, filePath } = parseFixture('conditional-rendering.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Should detect components used in conditional rendering
    const components = graph.getNodesByType('react:component');
    assert.ok(components.length > 0, 'Should detect components');
  });

  it('should detect ternary conditional rendering', async () => {
    const { ast, filePath } = parseFixture('conditional-rendering.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check that RENDERS edges are created
    const rendersEdges = graph.getEdgesByType('RENDERS');
    assert.ok(rendersEdges.length > 0, 'Should detect RENDERS edges');
  });

  it('should detect dynamic component selection', async () => {
    const { ast, filePath } = parseFixture('conditional-rendering.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze the file');
  });
});

// =============================================================================
// BROWSER API TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Browser APIs', () => {
  it('should detect localStorage read/write', async () => {
    const { ast, filePath } = parseFixture('browser-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const storageNodes = graph.getNodesByType('browser:storage');
    assert.ok(storageNodes.length > 0, 'Should detect localStorage usage');
    const read = storageNodes.find(n => n.operation === 'read');
    const write = storageNodes.find(n => n.operation === 'write');
    assert.ok(read, 'Should detect getItem (read)');
    assert.ok(write, 'Should detect setItem (write)');
  });

  it('should detect DOM manipulation', async () => {
    const { ast, filePath } = parseFixture('browser-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const domNodes = graph.getNodesByType('browser:dom');
    assert.ok(domNodes.length > 0, 'Should detect DOM query operations');
  });

  it('should detect History API usage', async () => {
    const { ast, filePath } = parseFixture('browser-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const historyNodes = graph.getNodesByType('browser:history');
    assert.ok(historyNodes.length > 0, 'Should detect history API usage');
  });

  it('should detect timer scheduling', async () => {
    const { ast, filePath } = parseFixture('browser-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const timers = graph.getNodesByType('browser:timer');
    assert.ok(timers.length > 0, 'Should detect timer APIs');
  });

  it('should detect blocking APIs (alert, confirm)', async () => {
    const { ast, filePath } = parseFixture('browser-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const blocking = graph.getNodesByType('browser:blocking');
    assert.ok(blocking.length > 0, 'Should detect blocking APIs like alert/confirm');
  });

  it('should detect clipboard API', async () => {
    const { ast, filePath } = parseFixture('browser-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const clipboard = graph.getNodesByType('browser:clipboard');
    assert.ok(clipboard.length > 0, 'Should detect clipboard API');
  });
});

// =============================================================================
// INTEGRATION: DATA FLOW THROUGH COMPONENTS
// =============================================================================

describe.skip('ReactAnalyzer - Cross-Component Data Flow', () => {
  it('should trace data from state to child prop', async () => {
    const { ast, filePath } = parseFixture('basic-component.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check that we have both state and prop edges
    const stateNodes = graph.getNodesByType('react:state');
    const propEdges = graph.getEdgesByType('PASSES_PROP');

    // We should detect state and props being passed
    assert.ok(stateNodes.length > 0 || propEdges.length > 0,
      'Should detect state or props');
  });

  it('should trace callback from parent to child event', async () => {
    const { ast, filePath } = parseFixture('basic-component.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check that onClick prop is detected
    const propEdges = graph.getEdgesByType('PASSES_PROP');
    const callbackProp = propEdges.find(e => e.propName === 'onClick');
    assert.ok(callbackProp, 'Should detect onClick callback prop');
  });
});

// =============================================================================
// STATE MANAGEMENT TESTS
// =============================================================================

describe.skip('ReactAnalyzer - State Management', () => {
  it('should detect useReducer and dispatch calls', async () => {
    const { ast, filePath } = parseFixture('state-management.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const reducers = graph.getNodesByType('react:reducer');
    assert.ok(reducers.length > 0, 'Should detect useReducer');
    assert.ok(reducers.find(r => r.dispatchName === 'dispatch'), 'Should detect dispatch');
  });

  it('should detect reducer action types', async () => {
    const { ast, filePath } = parseFixture('state-management.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const reducers = graph.getNodesByType('react:reducer');
    assert.ok(reducers.length > 0, 'Should detect reducer');
  });

  it('should detect Context creation and consumption', async () => {
    const { ast, filePath } = parseFixture('state-management.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check for context creation
    const contexts = graph.getNodesByType('react:context');
    assert.ok(contexts.length > 0, 'Should detect createContext');

    // Check for context consumption
    const contextUses = graph.getNodesByType('react:context-use');
    assert.ok(contextUses.length > 0, 'Should detect useContext');
  });

  it('should trace context value from Provider to Consumer', async () => {
    const { ast, filePath } = parseFixture('state-management.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Provider renders children that consume context
    const rendersEdges = graph.getEdgesByType('RENDERS');
    assert.ok(rendersEdges.length > 0, 'Should detect rendering relationships');
  });
});

// =============================================================================
// REFS TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Refs', () => {
  it('should detect useRef and ref.current mutations', async () => {
    const { ast, filePath } = parseFixture('refs-patterns.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const refs = graph.getNodesByType('react:ref');
    assert.ok(refs.length > 0, 'Should detect useRef');
  });

  it('should detect forwardRef patterns', async () => {
    const { ast, filePath } = parseFixture('refs-patterns.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // forwardRef creates components
    const components = graph.getNodesByType('react:component');
    const forwardRefComponent = components.find(c => c.kind === 'forwardRef');
    assert.ok(forwardRefComponent, 'Should detect forwardRef component');
  });

  it('should detect useImperativeHandle', async () => {
    const { ast, filePath } = parseFixture('refs-patterns.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const imperativeHandles = graph.getNodesByType('react:imperative-handle');
    assert.ok(imperativeHandles.length > 0, 'Should detect useImperativeHandle');
    const handle = imperativeHandles[0];
    assert.ok(handle.exposedMethods.length > 0, 'Should detect exposed methods');
  });

  it('should detect callback refs', async () => {
    const { ast, filePath } = parseFixture('refs-patterns.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Callback refs are detected as events or refs
    assert.ok(graph.nodes.length > 0, 'Should analyze the file');
  });

  it('should warn about stale ref values', async () => {
    const { ast, filePath } = parseFixture('refs-patterns.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Stale ref pattern - file should be analyzed
    assert.ok(graph.nodes.length > 0, 'Should analyze the file');
  });
});

// =============================================================================
// ALL DOM EVENTS TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Complete DOM Events', () => {
  it('should detect all mouse events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'click'), 'Should detect click');
    assert.ok(events.find(e => e.eventType === 'dblclick'), 'Should detect dblclick');
    assert.ok(events.find(e => e.eventType === 'mousedown'), 'Should detect mousedown');
  });

  it('should detect keyboard events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'keydown'), 'Should detect keydown');
    assert.ok(events.find(e => e.eventType === 'keyup'), 'Should detect keyup');
  });

  it('should detect touch events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'touchstart'), 'Should detect touchstart');
    assert.ok(events.find(e => e.eventType === 'touchend'), 'Should detect touchend');
  });

  it('should detect drag and drop events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'dragstart'), 'Should detect dragstart');
    assert.ok(events.find(e => e.eventType === 'drop'), 'Should detect drop');
  });

  it('should detect media events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'play'), 'Should detect play');
    assert.ok(events.find(e => e.eventType === 'pause'), 'Should detect pause');
  });

  it('should detect animation and transition events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'animationstart'), 'Should detect animationstart');
    assert.ok(events.find(e => e.eventType === 'transitionend'), 'Should detect transitionend');
  });

  it('should detect pointer events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'pointerdown'), 'Should detect pointerdown');
  });

  it('should detect clipboard events', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'copy'), 'Should detect copy');
    assert.ok(events.find(e => e.eventType === 'paste'), 'Should detect paste');
  });

  it('should detect composition events (IME)', async () => {
    const { ast, filePath } = parseFixture('all-dom-events.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const events = graph.getNodesByType('dom:event');
    assert.ok(events.find(e => e.eventType === 'compositionstart'), 'Should detect compositionstart');
  });
});

// =============================================================================
// OBSERVER APIs TESTS
// =============================================================================

describe.skip('ReactAnalyzer - Observer APIs', () => {
  it('should detect IntersectionObserver usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check that file is analyzed (observers are tracked indirectly)
    assert.ok(graph.nodes.length > 0, 'Should analyze file with IntersectionObserver');
  });

  it('should detect ResizeObserver usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze file with ResizeObserver');
  });

  it('should detect MutationObserver usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze file with MutationObserver');
  });

  it('should detect matchMedia usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const mediaQuery = graph.getNodesByType('browser:media-query');
    assert.ok(mediaQuery.length > 0, 'Should detect matchMedia');
  });

  it('should detect Geolocation API usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const geolocation = graph.getNodesByType('browser:geolocation');
    assert.ok(geolocation.length > 0, 'Should detect geolocation API');
  });

  it('should detect Notification API usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze file with Notification API');
  });

  it('should detect Web Worker usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze file with Web Worker');
  });

  it('should detect Fullscreen API usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze file with Fullscreen API');
  });

  it('should detect PerformanceObserver usage', async () => {
    const { ast, filePath } = parseFixture('observers-and-apis.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    assert.ok(graph.nodes.length > 0, 'Should analyze file with PerformanceObserver');
  });
});

// =============================================================================
// useLayoutEffect TESTS
// =============================================================================

describe.skip('ReactAnalyzer - useLayoutEffect', () => {
  it('should detect useLayoutEffect usage', async () => {
    const { ast, filePath } = parseFixture('layout-effects.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const layoutEffects = graph.getNodesByType('react:layout-effect');
    assert.ok(layoutEffects.length > 0, 'Should detect useLayoutEffect');
  });

  it('should warn about heavy computation in useLayoutEffect', async () => {
    const { ast, filePath } = parseFixture('layout-effects.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Layout effects are detected
    const layoutEffects = graph.getNodesByType('react:layout-effect');
    assert.ok(layoutEffects.length > 0, 'Should detect layout effects');
  });

  it('should detect DOM measurements in useLayoutEffect', async () => {
    const { ast, filePath } = parseFixture('layout-effects.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // File should be analyzed successfully
    assert.ok(graph.nodes.length > 0, 'Should analyze layout effects with DOM measurements');
  });

  it('should detect useInsertionEffect usage', async () => {
    const { ast, filePath } = parseFixture('layout-effects.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    const insertionEffects = graph.getNodesByType('react:insertion-effect');
    assert.ok(insertionEffects.length > 0, 'Should detect useInsertionEffect');
  });

  it('should detect forced reflow patterns', async () => {
    const { ast, filePath } = parseFixture('layout-effects.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // File should be analyzed
    assert.ok(graph.nodes.length > 0, 'Should analyze file');
  });
});

// =============================================================================
// EDGE CASE: State updates after unmount
// =============================================================================

describe.skip('ReactAnalyzer - State Updates After Unmount', () => {
  it('should detect async setState that might fire after unmount', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Check for async browser APIs
    const asyncNodes = graph.getNodesByType('browser:async');
    assert.ok(asyncNodes.length > 0 || graph.nodes.length > 0,
      'Should detect async operations');
  });

  it('should recognize isMounted pattern', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // Refs are used for isMounted pattern
    const refs = graph.getNodesByType('react:ref');
    assert.ok(refs.length > 0 || graph.nodes.length > 0, 'Should analyze file');
  });

  it('should recognize AbortController pattern', async () => {
    const { ast, filePath } = parseFixture('edge-case-missing-cleanup.jsx');
    const graph = new MockGraph();

    const analyzer = new ReactAnalyzer();
    await analyzer.analyzeAST(ast, filePath, graph);

    // File should be analyzed successfully
    assert.ok(graph.nodes.length > 0, 'Should analyze file with AbortController');
  });
});
