//! Manifest chain + snapshot management for RFDB v2 storage.
//!
//! Implements Delta Lake transaction log pattern: immutable manifests +
//! cached index + atomic pointer swap = ACID commits with O(1) metadata
//! operations.
//!
//! # Storage Layout
//!
//! ```text
//! <name>.rfdb/
//! +-- current.json                  # Atomic pointer: {"version": 5}
//! +-- manifest_index.json           # Index: snapshot metadata + tag index + referenced segments
//! +-- manifests/
//! |   +-- 000001.json               # Manifest v1 (immutable after commit)
//! |   +-- 000002.json
//! |   +-- ...
//! +-- segments/
//! |   +-- seg_000001_nodes.seg      # Immutable segments
//! |   +-- seg_000001_edges.seg
//! |   +-- ...
//! +-- gc/                           # Segments pending deletion
//! ```
//!
//! # Commit Protocol
//!
//! 1. Write `manifests/{version:06}.json` (atomic: temp + fsync + rename)
//! 2. Update in-memory index
//! 3. Write `manifest_index.json` (atomic: temp + fsync + rename)
//! 4. Write `current.json` (atomic: temp + fsync + rename)
//! 5. Update in-memory cache
//!
//! Crash at any step leaves the database in a consistent state:
//! - Before step 4: old current pointer, old index (both valid)
//! - After step 4: new current pointer, new index (both valid)

use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicU64, Ordering};

use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};

use crate::error::{GraphError, Result};
use crate::storage_v2::types::{SegmentMeta, SegmentType};

// ── Durability Mode ────────────────────────────────────────────────

/// Durability mode for manifest writes.
///
/// Strict: Full fsync protocol (manifest + current pointer + directory).
///         Ensures crash safety at cost of ~5-10ms commit latency.
///
/// Relaxed: Skip fsync (OS buffers writes). Best-effort durability.
///          Faster commits (~1ms), but crash may lose recent commits.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum DurabilityMode {
    /// Fsync everything (safe default)
    #[default]
    Strict,
    /// Skip fsync (OS handles flush)
    Relaxed,
}

// ── Manifest ───────────────────────────────────────────────────────

/// Manifest: immutable snapshot descriptor.
///
/// Each manifest represents a consistent point-in-time view of the database.
/// Manifests are immutable after commit except for tags (which can be modified
/// atomically via separate write).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Manifest {
    /// Manifest version (sequential, monotonic, gaps allowed after crash recovery)
    pub version: u64,

    /// Creation timestamp (Unix epoch seconds)
    pub created_at: u64,

    /// Active node segments in this snapshot
    pub node_segments: Vec<SegmentDescriptor>,

    /// Active edge segments in this snapshot
    pub edge_segments: Vec<SegmentDescriptor>,

    /// Optional tags for snapshot identification.
    /// Empty HashMap = no tags. Common tags:
    /// - "analysis_run": "success" | "failed"
    /// - "commit_sha": git commit hash
    /// - "build_number": CI build identifier
    #[serde(default)]
    pub tags: HashMap<String, String>,

    /// Pre-computed aggregate statistics
    pub stats: ManifestStats,

    /// Previous manifest version (None for first manifest, v1)
    /// Enables chain traversal without directory scanning.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_version: Option<u64>,
}

// ── Segment Descriptor ─────────────────────────────────────────────

/// Segment descriptor: segment identity + zone map summary.
///
/// Bridges from ephemeral SegmentMeta (returned by writer) to serializable
/// manifest format. Includes zone map data for query planning without opening
/// segments.
///
/// File path is DERIVED at runtime from segment_id + shard_id + segment_type.
/// This enables sharding without manifest rewrites (T2.2).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct SegmentDescriptor {
    /// Unique segment ID (globally monotonic within database).
    /// Generated by ManifestStore::next_segment_id()
    pub segment_id: u64,

    /// Segment type (nodes or edges)
    pub segment_type: SegmentType,

    /// Optional shard ID (None = flat segments/ directory, Some(n) = segments/0n/).
    /// Phase 1: always None. T2.2 adds sharding.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_id: Option<u16>,

    /// Record count (nodes or edges)
    pub record_count: u64,

    /// File size in bytes
    pub byte_size: u64,

    /// Zone map: node types (empty for edge segments)
    #[serde(default, skip_serializing_if = "HashSet::is_empty")]
    pub node_types: HashSet<String>,

    /// Zone map: file paths (empty for edge segments)
    #[serde(default, skip_serializing_if = "HashSet::is_empty")]
    pub file_paths: HashSet<String>,

    /// Zone map: edge types (empty for node segments)
    #[serde(default, skip_serializing_if = "HashSet::is_empty")]
    pub edge_types: HashSet<String>,
}

impl SegmentDescriptor {
    /// Convert SegmentMeta (from writer) to SegmentDescriptor (for manifest).
    ///
    /// Called after segment writer finishes:
    /// ```ignore
    /// let meta = writer.finish(&mut file)?;
    /// let descriptor = SegmentDescriptor::from_meta(
    ///     store.next_segment_id(),
    ///     SegmentType::Nodes,
    ///     None, // shard_id (Phase 1: always None)
    ///     meta,
    /// );
    /// ```
    pub fn from_meta(
        segment_id: u64,
        segment_type: SegmentType,
        shard_id: Option<u16>,
        meta: SegmentMeta,
    ) -> Self {
        Self {
            segment_id,
            segment_type,
            shard_id,
            record_count: meta.record_count,
            byte_size: meta.byte_size,
            node_types: meta.node_types,
            file_paths: meta.file_paths,
            edge_types: meta.edge_types,
        }
    }

    /// Derive file path from segment_id, shard_id, segment_type.
    ///
    /// Phase 1: shard_id = None -> "segments/seg_000001_nodes.seg"
    /// T2.2: shard_id = Some(5) -> "segments/05/seg_000001_nodes.seg"
    pub fn file_path(&self, db_path: &Path) -> PathBuf {
        let type_suffix = match self.segment_type {
            SegmentType::Nodes => "nodes",
            SegmentType::Edges => "edges",
        };

        let filename = format!("seg_{:06}_{}.seg", self.segment_id, type_suffix);

        if let Some(shard_id) = self.shard_id {
            db_path
                .join("segments")
                .join(format!("{:02}", shard_id))
                .join(filename)
        } else {
            db_path.join("segments").join(filename)
        }
    }

    /// Derive relative path string for logging/debugging.
    pub fn relative_path(&self) -> String {
        let type_suffix = match self.segment_type {
            SegmentType::Nodes => "nodes",
            SegmentType::Edges => "edges",
        };
        let filename = format!("seg_{:06}_{}.seg", self.segment_id, type_suffix);

        if let Some(shard_id) = self.shard_id {
            format!("segments/{:02}/{}", shard_id, filename)
        } else {
            format!("segments/{}", filename)
        }
    }

    /// Check if segment might contain records matching filters.
    /// Returns true if zone maps indicate potential match (false = definite miss).
    pub fn may_contain(
        &self,
        node_type: Option<&str>,
        file_path: Option<&str>,
        edge_type: Option<&str>,
    ) -> bool {
        if let Some(nt) = node_type {
            if !self.node_types.is_empty() && !self.node_types.contains(nt) {
                return false;
            }
        }
        if let Some(fp) = file_path {
            if !self.file_paths.is_empty() && !self.file_paths.contains(fp) {
                return false;
            }
        }
        if let Some(et) = edge_type {
            if !self.edge_types.is_empty() && !self.edge_types.contains(et) {
                return false;
            }
        }
        true
    }
}

// ── Manifest Stats ─────────────────────────────────────────────────

/// Aggregate statistics for a manifest (sum of all segment descriptors).
///
/// Pre-computed to avoid scanning segment list on every query.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub struct ManifestStats {
    /// Total node count across all node segments
    pub total_nodes: u64,

    /// Total edge count across all edge segments
    pub total_edges: u64,

    /// Number of node segments
    pub node_segment_count: u32,

    /// Number of edge segments
    pub edge_segment_count: u32,
}

impl ManifestStats {
    /// Compute stats from segment descriptors.
    pub fn from_segments(
        node_segments: &[SegmentDescriptor],
        edge_segments: &[SegmentDescriptor],
    ) -> Self {
        Self {
            total_nodes: node_segments.iter().map(|s| s.record_count).sum(),
            total_edges: edge_segments.iter().map(|s| s.record_count).sum(),
            node_segment_count: node_segments.len() as u32,
            edge_segment_count: edge_segments.len() as u32,
        }
    }

    /// Validate stats match segment descriptors (debug builds only).
    #[cfg(debug_assertions)]
    pub fn validate(
        &self,
        node_segments: &[SegmentDescriptor],
        edge_segments: &[SegmentDescriptor],
    ) {
        let expected = Self::from_segments(node_segments, edge_segments);
        debug_assert_eq!(
            self.total_nodes, expected.total_nodes,
            "stats mismatch: total_nodes"
        );
        debug_assert_eq!(
            self.total_edges, expected.total_edges,
            "stats mismatch: total_edges"
        );
        debug_assert_eq!(
            self.node_segment_count, expected.node_segment_count,
            "stats mismatch: node_segment_count"
        );
        debug_assert_eq!(
            self.edge_segment_count, expected.edge_segment_count,
            "stats mismatch: edge_segment_count"
        );
    }
}

// ── Snapshot Info ──────────────────────────────────────────────────

/// Lightweight snapshot information for list operations.
///
/// Does NOT include full segment lists (saves memory when listing
/// thousands of snapshots).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct SnapshotInfo {
    pub version: u64,
    pub created_at: u64,
    pub tags: HashMap<String, String>,
    pub stats: ManifestStats,
}

impl SnapshotInfo {
    /// Extract snapshot info from full manifest.
    pub fn from_manifest(manifest: &Manifest) -> Self {
        Self {
            version: manifest.version,
            created_at: manifest.created_at,
            tags: manifest.tags.clone(),
            stats: manifest.stats,
        }
    }
}

// ── Manifest Index ─────────────────────────────────────────────────

/// ManifestIndex: cached metadata for all snapshots + tag index + GC
/// reference tracking.
///
/// Single-file index that eliminates O(N) operations:
/// - list_snapshots() -> O(1) (read index)
/// - find_snapshot() -> O(1) (tag index lookup)
/// - gc_collect() -> O(F) (scan segments/ dir, check referenced set)
///
/// Updated atomically during commit (written to manifest_index.json.tmp,
/// then renamed).
///
/// Pattern: Apache Iceberg's manifest list file.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ManifestIndex {
    /// Latest manifest version (redundant with current.json, but convenient)
    pub latest_version: u64,

    /// All snapshot metadata (sorted by version ascending).
    /// Contains version, created_at, tags, stats for every manifest ever created.
    pub snapshots: Vec<SnapshotInfo>,

    /// Tag index: tag_key -> tag_value -> version.
    /// Enables O(1) find_snapshot() lookup.
    #[serde(default)]
    pub tag_index: HashMap<String, HashMap<String, u64>>,

    /// All segment IDs referenced by ANY active manifest (union across all versions).
    /// Used by GC: segments NOT in this set are unreferenced -> safe to collect.
    pub referenced_segments: HashSet<u64>,
}

impl Default for ManifestIndex {
    fn default() -> Self {
        Self::new()
    }
}

impl ManifestIndex {
    /// Create empty index (for new database).
    pub fn new() -> Self {
        Self {
            latest_version: 0,
            snapshots: Vec::new(),
            tag_index: HashMap::new(),
            referenced_segments: HashSet::new(),
        }
    }

    /// Add snapshot to index (called during commit).
    ///
    /// Complexity: O(T + S) where T = tags, S = segments
    pub fn add_snapshot(&mut self, manifest: &Manifest) {
        self.snapshots.push(SnapshotInfo::from_manifest(manifest));

        for (key, value) in &manifest.tags {
            self.tag_index
                .entry(key.clone())
                .or_default()
                .insert(value.clone(), manifest.version);
        }

        for seg in manifest
            .node_segments
            .iter()
            .chain(manifest.edge_segments.iter())
        {
            self.referenced_segments.insert(seg.segment_id);
        }

        self.latest_version = manifest.version;
    }

    /// Remove old snapshot from index (called during manifest GC, not segment GC).
    ///
    /// Note: Phase 1 does NOT implement manifest GC (keep all manifests).
    /// This method included for completeness (T2.2 will use it).
    ///
    /// Complexity: O(M + T) where M = snapshots, T = tag entries
    pub fn remove_snapshot(&mut self, version: u64) {
        self.snapshots.retain(|info| info.version != version);

        for tag_values in self.tag_index.values_mut() {
            tag_values.retain(|_, v| *v != version);
        }
        self.tag_index.retain(|_, values| !values.is_empty());
    }

    /// Find snapshot by tag (O(1) lookup).
    pub fn find_by_tag(&self, tag_key: &str, tag_value: &str) -> Option<u64> {
        self.tag_index
            .get(tag_key)
            .and_then(|values| values.get(tag_value))
            .copied()
    }

    /// List snapshots (O(N) where N = matching snapshots).
    pub fn list_snapshots(&self, filter_tag: Option<&str>) -> Vec<SnapshotInfo> {
        if let Some(tag_key) = filter_tag {
            self.snapshots
                .iter()
                .filter(|info| info.tags.contains_key(tag_key))
                .cloned()
                .collect()
        } else {
            self.snapshots.clone()
        }
    }
}

// ── Current Pointer ────────────────────────────────────────────────

/// Atomic pointer to current manifest version.
///
/// Stored in `current.json` at database root. Updated via atomic rename
/// (write to `current.json.tmp`, then rename to `current.json`).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct CurrentPointer {
    /// Current manifest version
    pub version: u64,
}

impl CurrentPointer {
    pub fn new(version: u64) -> Self {
        Self { version }
    }

    /// Read current pointer from database root.
    pub fn read_from(db_path: &Path) -> Result<Self> {
        let path = db_path.join("current.json");
        read_json(&path)
    }

    /// Write current pointer atomically.
    /// Uses temp file + rename pattern for atomicity.
    pub fn write_to(&self, db_path: &Path, durability: DurabilityMode) -> Result<()> {
        let path = db_path.join("current.json");
        atomic_write_json(&path, self, durability)?;

        if durability == DurabilityMode::Strict {
            fsync_directory(db_path)?;
        }

        Ok(())
    }
}

// ── Snapshot Diff ──────────────────────────────────────────────────

/// Diff between two snapshots (from_version -> to_version).
///
/// Computed via HashSet-based set difference on segment IDs.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnapshotDiff {
    pub from_version: u64,
    pub to_version: u64,

    /// Node segments added in to_version (not in from_version)
    pub added_node_segments: Vec<SegmentDescriptor>,

    /// Node segments removed in to_version (in from_version, not in to_version)
    pub removed_node_segments: Vec<SegmentDescriptor>,

    /// Edge segments added in to_version
    pub added_edge_segments: Vec<SegmentDescriptor>,

    /// Edge segments removed in to_version
    pub removed_edge_segments: Vec<SegmentDescriptor>,

    /// Stats for from_version
    pub stats_from: ManifestStats,

    /// Stats for to_version
    pub stats_to: ManifestStats,
}

impl SnapshotDiff {
    /// Compute diff between two manifests.
    ///
    /// Algorithm: HashSet-based set difference.
    /// Complexity: O(S) where S = total segments in both manifests.
    pub fn compute(from: &Manifest, to: &Manifest) -> Self {
        let from_node_ids: HashSet<u64> = from
            .node_segments
            .iter()
            .map(|s| s.segment_id)
            .collect();
        let to_node_ids: HashSet<u64> =
            to.node_segments.iter().map(|s| s.segment_id).collect();

        let added_node_segments: Vec<SegmentDescriptor> = to
            .node_segments
            .iter()
            .filter(|s| !from_node_ids.contains(&s.segment_id))
            .cloned()
            .collect();

        let removed_node_segments: Vec<SegmentDescriptor> = from
            .node_segments
            .iter()
            .filter(|s| !to_node_ids.contains(&s.segment_id))
            .cloned()
            .collect();

        let from_edge_ids: HashSet<u64> = from
            .edge_segments
            .iter()
            .map(|s| s.segment_id)
            .collect();
        let to_edge_ids: HashSet<u64> =
            to.edge_segments.iter().map(|s| s.segment_id).collect();

        let added_edge_segments: Vec<SegmentDescriptor> = to
            .edge_segments
            .iter()
            .filter(|s| !from_edge_ids.contains(&s.segment_id))
            .cloned()
            .collect();

        let removed_edge_segments: Vec<SegmentDescriptor> = from
            .edge_segments
            .iter()
            .filter(|s| !to_edge_ids.contains(&s.segment_id))
            .cloned()
            .collect();

        Self {
            from_version: from.version,
            to_version: to.version,
            added_node_segments,
            removed_node_segments,
            added_edge_segments,
            removed_edge_segments,
            stats_from: from.stats,
            stats_to: to.stats,
        }
    }

    /// Number of segments changed (added + removed).
    pub fn change_count(&self) -> usize {
        self.added_node_segments.len()
            + self.removed_node_segments.len()
            + self.added_edge_segments.len()
            + self.removed_edge_segments.len()
    }

    /// Is this a no-op diff (no changes)?
    pub fn is_empty(&self) -> bool {
        self.change_count() == 0
    }
}

// ── Manifest Store ─────────────────────────────────────────────────

/// ManifestStore: manages manifest chain + index + current pointer +
/// segment ID allocation.
///
/// NOT `Send + Sync` by default (contains PathBuf, cached Manifest).
/// For multi-threaded access, wrap in `Arc<Mutex<ManifestStore>>`.
pub struct ManifestStore {
    /// Database root path (None for ephemeral databases)
    db_path: Option<PathBuf>,

    /// Current manifest (cached in memory)
    current: Manifest,

    /// Manifest index (cached in memory)
    index: ManifestIndex,

    /// Next segment ID to allocate (thread-safe atomic counter)
    next_segment_id: AtomicU64,

    /// Durability mode (Strict = fsync, Relaxed = no fsync)
    durability: DurabilityMode,
}

// ── ManifestStore: Constructors ────────────────────────────────────

impl ManifestStore {
    /// Open existing database with specified durability mode.
    ///
    /// Algorithm:
    /// 1. Read current.json -> get version
    /// 2. Load manifests/{version:06}.json
    /// 3. Load manifest_index.json
    /// 4. Validate index consistency (crash recovery)
    /// 5. Initialize next_segment_id = max(index.referenced_segments) + 1
    ///
    /// Complexity: O(S + I) where S = segments in current manifest, I = index size
    pub fn open_with_config(db_path: &Path, durability: DurabilityMode) -> Result<Self> {
        let current_pointer = CurrentPointer::read_from(db_path)?;
        let current = load_manifest_file(db_path, current_pointer.version)?;

        let index_path = db_path.join("manifest_index.json");
        let mut index: ManifestIndex = read_json(&index_path)?;

        // Validate index consistency (crash recovery).
        // If the index is out of sync with the current pointer (e.g., crash
        // happened after writing current.json but before writing index, or
        // vice versa), rebuild the index from the manifests/ directory.
        if index.latest_version != current_pointer.version {
            index = rebuild_index(db_path)?;
        }

        let max_segment_id = index.referenced_segments.iter().max().copied().unwrap_or(0);
        let next_segment_id = AtomicU64::new(max_segment_id + 1);

        Ok(Self {
            db_path: Some(db_path.to_path_buf()),
            current,
            index,
            next_segment_id,
            durability,
        })
    }

    /// Open existing database with default durability (Strict).
    pub fn open(db_path: &Path) -> Result<Self> {
        Self::open_with_config(db_path, DurabilityMode::Strict)
    }

    /// Create new database with specified durability mode.
    ///
    /// Creates directories, writes first manifest (v1), empty index, and
    /// current pointer.
    ///
    /// Complexity: O(1)
    pub fn create_with_config(db_path: &Path, durability: DurabilityMode) -> Result<Self> {
        if db_path.join("current.json").exists() {
            return Err(GraphError::InvalidFormat(
                "Database already exists at path".to_string(),
            ));
        }

        std::fs::create_dir_all(db_path.join("manifests"))?;
        std::fs::create_dir_all(db_path.join("segments"))?;
        std::fs::create_dir_all(db_path.join("gc"))?;

        let manifest = Manifest {
            version: 1,
            created_at: current_timestamp(),
            node_segments: Vec::new(),
            edge_segments: Vec::new(),
            tags: HashMap::new(),
            stats: ManifestStats {
                total_nodes: 0,
                total_edges: 0,
                node_segment_count: 0,
                edge_segment_count: 0,
            },
            parent_version: None,
        };

        let mut index = ManifestIndex::new();
        index.add_snapshot(&manifest);

        let manifest_path = manifest_file_path(db_path, 1);
        atomic_write_json(&manifest_path, &manifest, durability)?;

        let index_path = db_path.join("manifest_index.json");
        atomic_write_json(&index_path, &index, durability)?;

        let current_pointer = CurrentPointer::new(1);
        current_pointer.write_to(db_path, durability)?;

        Ok(Self {
            db_path: Some(db_path.to_path_buf()),
            current: manifest,
            index,
            next_segment_id: AtomicU64::new(1),
            durability,
        })
    }

    /// Create new database with default durability (Strict).
    pub fn create(db_path: &Path) -> Result<Self> {
        Self::create_with_config(db_path, DurabilityMode::Strict)
    }

    /// Create ephemeral store (in-memory, no disk writes).
    ///
    /// Used for unit tests, temporary analysis graphs, and query-only
    /// databases (no persistence).
    ///
    /// Complexity: O(1)
    pub fn ephemeral() -> Self {
        let manifest = Manifest {
            version: 1,
            created_at: current_timestamp(),
            node_segments: Vec::new(),
            edge_segments: Vec::new(),
            tags: HashMap::new(),
            stats: ManifestStats {
                total_nodes: 0,
                total_edges: 0,
                node_segment_count: 0,
                edge_segment_count: 0,
            },
            parent_version: None,
        };

        let mut index = ManifestIndex::new();
        index.add_snapshot(&manifest);

        Self {
            db_path: None,
            current: manifest,
            index,
            next_segment_id: AtomicU64::new(1),
            durability: DurabilityMode::Strict,
        }
    }
}

// ── ManifestStore: Core Operations ─────────────────────────────────

impl ManifestStore {
    /// Get current manifest (borrowed reference).
    ///
    /// Complexity: O(1) (cached in memory)
    pub fn current(&self) -> &Manifest {
        &self.current
    }

    /// Create new manifest (not yet committed).
    ///
    /// Constructs manifest with version = current.version + 1 and provided
    /// segments/tags. Does NOT write to disk or update self.current.
    ///
    /// Complexity: O(S) where S = total segments (for computing stats)
    pub fn create_manifest(
        &self,
        node_segments: Vec<SegmentDescriptor>,
        edge_segments: Vec<SegmentDescriptor>,
        tags: Option<HashMap<String, String>>,
    ) -> Result<Manifest> {
        let mut seen_ids = HashSet::new();
        for seg in node_segments.iter().chain(edge_segments.iter()) {
            if !seen_ids.insert(seg.segment_id) {
                return Err(GraphError::InvalidFormat(format!(
                    "Duplicate segment_id: {}",
                    seg.segment_id
                )));
            }
        }

        let version = self.current.version + 1;
        let stats = ManifestStats::from_segments(&node_segments, &edge_segments);

        Ok(Manifest {
            version,
            created_at: current_timestamp(),
            node_segments,
            edge_segments,
            tags: tags.unwrap_or_default(),
            stats,
            parent_version: Some(self.current.version),
        })
    }

    /// Atomically commit manifest version (swap current pointer).
    ///
    /// Write order:
    /// 1. Write manifest file
    /// 2. Update index in memory + write index file
    /// 3. Write current pointer (atomic commit marker)
    /// 4. Update in-memory cache
    ///
    /// If ephemeral: only update cache, no disk writes.
    ///
    /// Complexity: O(S + I) where S = segments in manifest, I = index size
    pub fn commit(&mut self, manifest: Manifest) -> Result<()> {
        if self.db_path.is_none() {
            self.index.add_snapshot(&manifest);
            self.current = manifest;
            return Ok(());
        }

        let db_path = self.db_path.as_ref().unwrap();

        if manifest.version != self.current.version + 1 {
            return Err(GraphError::InvalidFormat(format!(
                "Cannot commit version {} (current: {})",
                manifest.version, self.current.version
            )));
        }

        // 1. Write manifest file
        let manifest_path = manifest_file_path(db_path, manifest.version);
        atomic_write_json(&manifest_path, &manifest, self.durability)?;

        // 2. Update index in memory + write index file
        self.index.add_snapshot(&manifest);
        let index_path = db_path.join("manifest_index.json");
        atomic_write_json(&index_path, &self.index, self.durability)?;

        // 3. Write + rename current pointer
        let current_pointer = CurrentPointer::new(manifest.version);
        current_pointer.write_to(db_path, self.durability)?;

        // 4. Update cache
        self.current = manifest;

        Ok(())
    }

    /// Load specific manifest version from disk.
    ///
    /// Complexity: O(S) where S = segments in manifest (JSON deserialization)
    pub fn load_manifest(&self, version: u64) -> Result<Manifest> {
        if let Some(db_path) = &self.db_path {
            load_manifest_file(db_path, version)
        } else if version == self.current.version {
            Ok(self.current.clone())
        } else {
            Err(GraphError::InvalidFormat(format!(
                "Ephemeral database has no version {}",
                version
            )))
        }
    }

    /// Allocate next segment ID (thread-safe).
    ///
    /// Uses atomic fetch_add for lock-free concurrency.
    ///
    /// Complexity: O(1)
    pub fn next_segment_id(&self) -> u64 {
        self.next_segment_id.fetch_add(1, Ordering::SeqCst)
    }
}

// ── ManifestStore: Snapshot Operations ─────────────────────────────

impl ManifestStore {
    /// Find snapshot by tag (O(1) index lookup).
    pub fn find_snapshot(&self, tag_key: &str, tag_value: &str) -> Option<u64> {
        self.index.find_by_tag(tag_key, tag_value)
    }

    /// List all snapshots (optionally filtered by tag key).
    ///
    /// Complexity: O(N) where N = snapshots in index (in-memory filter)
    pub fn list_snapshots(&self, filter_tag: Option<&str>) -> Vec<SnapshotInfo> {
        self.index.list_snapshots(filter_tag)
    }

    /// Tag existing snapshot (modifies manifest file atomically, updates index).
    ///
    /// Tags are merged: new tags overwrite existing keys, other keys preserved.
    ///
    /// Complexity: O(S + I) where S = segments in manifest, I = index size
    pub fn tag_snapshot(
        &mut self,
        version: u64,
        tags: HashMap<String, String>,
    ) -> Result<()> {
        if self.db_path.is_none() {
            return Err(GraphError::InvalidFormat(
                "Cannot tag ephemeral snapshot".to_string(),
            ));
        }

        let db_path = self.db_path.as_ref().unwrap();
        let manifest_path = manifest_file_path(db_path, version);

        let mut manifest: Manifest = read_json(&manifest_path)?;

        for (key, value) in &tags {
            manifest.tags.insert(key.clone(), value.clone());
        }

        atomic_write_json(&manifest_path, &manifest, self.durability)?;

        for (key, value) in tags {
            self.index
                .tag_index
                .entry(key)
                .or_default()
                .insert(value, version);
        }

        let index_path = db_path.join("manifest_index.json");
        atomic_write_json(&index_path, &self.index, self.durability)?;

        if version == self.current.version {
            self.current = manifest;
        }

        Ok(())
    }

    /// Compute diff between two snapshots.
    ///
    /// Complexity: O(S) where S = total segments in both manifests
    pub fn diff_snapshots(
        &self,
        from_version: u64,
        to_version: u64,
    ) -> Result<SnapshotDiff> {
        let from = self.load_manifest(from_version)?;
        let to = self.load_manifest(to_version)?;
        Ok(SnapshotDiff::compute(&from, &to))
    }
}

// ── ManifestStore: Garbage Collection ──────────────────────────────

impl ManifestStore {
    /// Collect unreferenced segments (move to gc/ directory).
    ///
    /// Uses index.referenced_segments to determine live segments, then
    /// scans segments/ directory for files not in the referenced set.
    ///
    /// Safety: Two-phase GC (collect -> purge). If logic is wrong, files
    /// are in gc/ (recoverable), not deleted (permanent).
    ///
    /// Complexity: O(F) where F = files in segments/ directory
    pub fn gc_collect(&self) -> Result<Vec<String>> {
        if self.db_path.is_none() {
            return Ok(Vec::new());
        }

        let db_path = self.db_path.as_ref().unwrap();
        let segments_dir = db_path.join("segments");
        let gc_dir = db_path.join("gc");

        std::fs::create_dir_all(&gc_dir)?;

        let referenced_ids = &self.index.referenced_segments;
        let mut moved = Vec::new();

        for entry in std::fs::read_dir(&segments_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) != Some("seg") {
                continue;
            }

            if let Some(segment_id) =
                parse_segment_id_from_filename(path.file_name().unwrap().to_str().unwrap())
            {
                if !referenced_ids.contains(&segment_id) {
                    let filename = path.file_name().unwrap();
                    let gc_path = gc_dir.join(filename);
                    std::fs::rename(&path, &gc_path)?;
                    moved.push(gc_path.to_string_lossy().to_string());
                }
            }
        }

        Ok(moved)
    }

    /// Purge files from gc/ directory (permanent deletion).
    ///
    /// Complexity: O(F) where F = files in gc/
    pub fn gc_purge(&self) -> Result<usize> {
        if self.db_path.is_none() {
            return Ok(0);
        }

        let db_path = self.db_path.as_ref().unwrap();
        let gc_dir = db_path.join("gc");

        if !gc_dir.exists() {
            return Ok(0);
        }

        let mut deleted = 0;

        for entry in std::fs::read_dir(&gc_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) != Some("seg") {
                continue;
            }

            std::fs::remove_file(&path)?;
            deleted += 1;
        }

        Ok(deleted)
    }
}

// ── Helper Functions ───────────────────────────────────────────────

/// Write JSON to file atomically via temp file + rename.
///
/// Atomicity: Rename is atomic on POSIX (single syscall).
fn atomic_write_json<T: Serialize>(
    path: &Path,
    data: &T,
    durability: DurabilityMode,
) -> Result<()> {
    let temp_path = path.with_extension("tmp");

    let file = File::create(&temp_path)?;
    serde_json::to_writer_pretty(&file, data)?;

    if durability == DurabilityMode::Strict {
        file.sync_all()?;
    }

    std::fs::rename(&temp_path, path)?;

    Ok(())
}

/// Read and deserialize JSON from file.
fn read_json<T: DeserializeOwned>(path: &Path) -> Result<T> {
    let file = File::open(path)?;
    Ok(serde_json::from_reader(file)?)
}

/// Fsync directory to persist directory entry changes.
///
/// Required after rename operations on ext4/XFS to ensure directory
/// metadata is flushed to disk.
#[cfg(target_os = "linux")]
fn fsync_directory(path: &Path) -> Result<()> {
    let dir = File::open(path)?;
    dir.sync_all()?;
    Ok(())
}

/// No-op on macOS/Windows (directory metadata auto-persisted).
#[cfg(not(target_os = "linux"))]
fn fsync_directory(_path: &Path) -> Result<()> {
    Ok(())
}

/// Get manifest file path: {db_path}/manifests/{version:06}.json
fn manifest_file_path(db_path: &Path, version: u64) -> PathBuf {
    db_path
        .join("manifests")
        .join(format!("{:06}.json", version))
}

/// Load manifest file from disk with validation.
fn load_manifest_file(db_path: &Path, version: u64) -> Result<Manifest> {
    let path = manifest_file_path(db_path, version);
    let manifest: Manifest = read_json(&path)?;

    if manifest.version != version {
        return Err(GraphError::InvalidFormat(format!(
            "Manifest version mismatch: expected {}, got {}",
            version, manifest.version
        )));
    }

    #[cfg(debug_assertions)]
    manifest
        .stats
        .validate(&manifest.node_segments, &manifest.edge_segments);

    Ok(manifest)
}

/// Parse segment ID from filename: seg_000123_nodes.seg -> 123
fn parse_segment_id_from_filename(filename: &str) -> Option<u64> {
    let parts: Vec<&str> = filename.split('_').collect();
    if parts.len() >= 3 && parts[0] == "seg" {
        parts[1].parse::<u64>().ok()
    } else {
        None
    }
}

/// Rebuild ManifestIndex from manifests/ directory (crash recovery).
///
/// Scans all .json files in manifests/, loads each manifest, and rebuilds
/// the index from scratch. Writes the rebuilt index to disk.
///
/// Called when open_with_config() detects index.latest_version != current_pointer.version.
fn rebuild_index(db_path: &Path) -> Result<ManifestIndex> {
    let manifests_dir = db_path.join("manifests");
    let mut index = ManifestIndex::new();

    let mut versions: Vec<u64> = Vec::new();

    for entry in std::fs::read_dir(&manifests_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) != Some("json") {
            continue;
        }

        if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
            if let Ok(version) = stem.parse::<u64>() {
                versions.push(version);
            }
        }
    }

    // Sort ascending so index.snapshots are in version order
    versions.sort_unstable();

    for version in versions {
        let manifest = load_manifest_file(db_path, version)?;
        index.add_snapshot(&manifest);
    }

    // Persist rebuilt index
    let index_path = db_path.join("manifest_index.json");
    atomic_write_json(&index_path, &index, DurabilityMode::Strict)?;

    Ok(index)
}

/// Get current Unix timestamp (seconds since epoch).
fn current_timestamp() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

// ── Tests ──────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use tempfile::TempDir;

    // ── Helpers ────────────────────────────────────────────────────

    fn make_node_descriptor(id: u64, record_count: u64) -> SegmentDescriptor {
        SegmentDescriptor {
            segment_id: id,
            segment_type: SegmentType::Nodes,
            shard_id: None,
            record_count,
            byte_size: record_count * 100,
            node_types: HashSet::from(["FUNCTION".to_string()]),
            file_paths: HashSet::from(["src/main.rs".to_string()]),
            edge_types: HashSet::new(),
        }
    }

    fn make_edge_descriptor(id: u64, record_count: u64) -> SegmentDescriptor {
        SegmentDescriptor {
            segment_id: id,
            segment_type: SegmentType::Edges,
            shard_id: None,
            record_count,
            byte_size: record_count * 80,
            node_types: HashSet::new(),
            file_paths: HashSet::new(),
            edge_types: HashSet::from(["CALLS".to_string()]),
        }
    }

    // ── Phase 1: Data Structures + Serde ──────────────────────────

    #[test]
    fn test_manifest_serde_roundtrip() {
        let manifest = Manifest {
            version: 5,
            created_at: 1707826800,
            node_segments: vec![make_node_descriptor(1, 100)],
            edge_segments: vec![make_edge_descriptor(2, 50)],
            tags: HashMap::from([("commit_sha".to_string(), "abc123".to_string())]),
            stats: ManifestStats {
                total_nodes: 100,
                total_edges: 50,
                node_segment_count: 1,
                edge_segment_count: 1,
            },
            parent_version: Some(4),
        };

        let json = serde_json::to_string_pretty(&manifest).unwrap();
        let deserialized: Manifest = serde_json::from_str(&json).unwrap();
        assert_eq!(manifest, deserialized);
    }

    #[test]
    fn test_manifest_stats_computation() {
        let nodes = vec![make_node_descriptor(1, 100), make_node_descriptor(2, 200)];
        let edges = vec![make_edge_descriptor(3, 50)];

        let stats = ManifestStats::from_segments(&nodes, &edges);
        assert_eq!(stats.total_nodes, 300);
        assert_eq!(stats.total_edges, 50);
        assert_eq!(stats.node_segment_count, 2);
        assert_eq!(stats.edge_segment_count, 1);
    }

    #[test]
    fn test_segment_descriptor_from_meta() {
        let meta = SegmentMeta {
            record_count: 42,
            byte_size: 4200,
            segment_type: SegmentType::Nodes,
            node_types: HashSet::from(["CLASS".to_string()]),
            file_paths: HashSet::from(["lib.rs".to_string()]),
            edge_types: HashSet::new(),
        };

        let desc = SegmentDescriptor::from_meta(7, SegmentType::Nodes, None, meta);
        assert_eq!(desc.segment_id, 7);
        assert_eq!(desc.segment_type, SegmentType::Nodes);
        assert_eq!(desc.shard_id, None);
        assert_eq!(desc.record_count, 42);
        assert_eq!(desc.byte_size, 4200);
        assert!(desc.node_types.contains("CLASS"));
        assert!(desc.file_paths.contains("lib.rs"));
        assert!(desc.edge_types.is_empty());
    }

    #[test]
    fn test_segment_descriptor_file_path_flat() {
        let desc = make_node_descriptor(1, 100);
        let path = desc.file_path(Path::new("/db"));
        assert_eq!(path, PathBuf::from("/db/segments/seg_000001_nodes.seg"));
    }

    #[test]
    fn test_segment_descriptor_file_path_sharded() {
        let mut desc = make_node_descriptor(1, 100);
        desc.shard_id = Some(5);
        let path = desc.file_path(Path::new("/db"));
        assert_eq!(path, PathBuf::from("/db/segments/05/seg_000001_nodes.seg"));
    }

    #[test]
    fn test_segment_descriptor_file_path_edges() {
        let desc = make_edge_descriptor(3, 50);
        let path = desc.file_path(Path::new("/db"));
        assert_eq!(path, PathBuf::from("/db/segments/seg_000003_edges.seg"));
    }

    #[test]
    fn test_segment_descriptor_relative_path() {
        let desc = make_node_descriptor(1, 100);
        assert_eq!(desc.relative_path(), "segments/seg_000001_nodes.seg");

        let mut sharded = make_node_descriptor(1, 100);
        sharded.shard_id = Some(12);
        assert_eq!(sharded.relative_path(), "segments/12/seg_000001_nodes.seg");
    }

    #[test]
    fn test_segment_descriptor_may_contain() {
        let desc = SegmentDescriptor {
            segment_id: 1,
            segment_type: SegmentType::Nodes,
            shard_id: None,
            record_count: 100,
            byte_size: 1000,
            node_types: HashSet::from(["FUNCTION".to_string(), "CLASS".to_string()]),
            file_paths: HashSet::from(["src/main.rs".to_string()]),
            edge_types: HashSet::new(),
        };

        assert!(desc.may_contain(Some("FUNCTION"), None, None));
        assert!(desc.may_contain(Some("CLASS"), None, None));
        assert!(!desc.may_contain(Some("MODULE"), None, None));
        assert!(desc.may_contain(None, Some("src/main.rs"), None));
        assert!(!desc.may_contain(None, Some("src/lib.rs"), None));
        assert!(desc.may_contain(None, None, None));
        // Edge type filter on node segment (empty edge_types = no filter)
        assert!(desc.may_contain(None, None, Some("CALLS")));
    }

    #[test]
    fn test_manifest_index_add_snapshot() {
        let mut index = ManifestIndex::new();
        assert_eq!(index.latest_version, 0);
        assert!(index.snapshots.is_empty());

        let m1 = Manifest {
            version: 1,
            created_at: 100,
            node_segments: vec![make_node_descriptor(1, 10)],
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&[make_node_descriptor(1, 10)], &[]),
            parent_version: None,
        };
        index.add_snapshot(&m1);
        assert_eq!(index.latest_version, 1);
        assert_eq!(index.snapshots.len(), 1);
        assert!(index.referenced_segments.contains(&1));

        let m2 = Manifest {
            version: 2,
            created_at: 200,
            node_segments: vec![make_node_descriptor(1, 10), make_node_descriptor(2, 20)],
            edge_segments: vec![make_edge_descriptor(3, 5)],
            tags: HashMap::from([("tag".to_string(), "val".to_string())]),
            stats: ManifestStats::from_segments(
                &[make_node_descriptor(1, 10), make_node_descriptor(2, 20)],
                &[make_edge_descriptor(3, 5)],
            ),
            parent_version: Some(1),
        };
        index.add_snapshot(&m2);
        assert_eq!(index.latest_version, 2);
        assert_eq!(index.snapshots.len(), 2);
        assert!(index.referenced_segments.contains(&1));
        assert!(index.referenced_segments.contains(&2));
        assert!(index.referenced_segments.contains(&3));
    }

    #[test]
    fn test_manifest_index_find_by_tag() {
        let mut index = ManifestIndex::new();

        let m = Manifest {
            version: 5,
            created_at: 500,
            node_segments: vec![],
            edge_segments: vec![],
            tags: HashMap::from([("commit_sha".to_string(), "abc123".to_string())]),
            stats: ManifestStats::from_segments(&[], &[]),
            parent_version: Some(4),
        };
        index.add_snapshot(&m);

        assert_eq!(index.find_by_tag("commit_sha", "abc123"), Some(5));
        assert_eq!(index.find_by_tag("commit_sha", "other"), None);
        assert_eq!(index.find_by_tag("nonexistent", "abc123"), None);
    }

    #[test]
    fn test_manifest_index_list_snapshots() {
        let mut index = ManifestIndex::new();

        for v in 1..=3 {
            let tags = if v == 2 {
                HashMap::from([("release".to_string(), "v1.0".to_string())])
            } else {
                HashMap::new()
            };
            let m = Manifest {
                version: v,
                created_at: v * 100,
                node_segments: vec![],
                edge_segments: vec![],
                tags,
                stats: ManifestStats::from_segments(&[], &[]),
                parent_version: if v > 1 { Some(v - 1) } else { None },
            };
            index.add_snapshot(&m);
        }

        assert_eq!(index.list_snapshots(None).len(), 3);
        let filtered = index.list_snapshots(Some("release"));
        assert_eq!(filtered.len(), 1);
        assert_eq!(filtered[0].version, 2);
    }

    #[test]
    fn test_manifest_index_remove_snapshot() {
        let mut index = ManifestIndex::new();
        let m = Manifest {
            version: 1,
            created_at: 100,
            node_segments: vec![],
            edge_segments: vec![],
            tags: HashMap::from([("key".to_string(), "val".to_string())]),
            stats: ManifestStats::from_segments(&[], &[]),
            parent_version: None,
        };
        index.add_snapshot(&m);
        assert_eq!(index.snapshots.len(), 1);
        assert_eq!(index.find_by_tag("key", "val"), Some(1));

        index.remove_snapshot(1);
        assert!(index.snapshots.is_empty());
        assert_eq!(index.find_by_tag("key", "val"), None);
        assert!(index.tag_index.is_empty());
    }

    // ── Phase 2: File I/O Helpers ─────────────────────────────────

    #[test]
    fn test_atomic_write_json_strict_mode() {
        let dir = TempDir::new().unwrap();
        let path = dir.path().join("test.json");
        let data = CurrentPointer::new(42);
        atomic_write_json(&path, &data, DurabilityMode::Strict).unwrap();
        assert!(path.exists());
        let loaded: CurrentPointer = read_json(&path).unwrap();
        assert_eq!(loaded.version, 42);
    }

    #[test]
    fn test_atomic_write_json_relaxed_mode() {
        let dir = TempDir::new().unwrap();
        let path = dir.path().join("test.json");
        let data = CurrentPointer::new(99);
        atomic_write_json(&path, &data, DurabilityMode::Relaxed).unwrap();
        assert!(path.exists());
        let loaded: CurrentPointer = read_json(&path).unwrap();
        assert_eq!(loaded.version, 99);
    }

    #[test]
    fn test_read_json_missing_file() {
        let result: std::result::Result<CurrentPointer, _> =
            read_json(Path::new("/nonexistent/path/file.json"));
        assert!(result.is_err());
    }

    #[test]
    fn test_fsync_directory_no_error() {
        let dir = TempDir::new().unwrap();
        fsync_directory(dir.path()).unwrap();
    }

    #[test]
    fn test_parse_segment_id_from_filename() {
        assert_eq!(
            parse_segment_id_from_filename("seg_000123_nodes.seg"),
            Some(123)
        );
        assert_eq!(
            parse_segment_id_from_filename("seg_000001_edges.seg"),
            Some(1)
        );
        assert_eq!(
            parse_segment_id_from_filename("seg_999999_nodes.seg"),
            Some(999999)
        );
        assert_eq!(parse_segment_id_from_filename("not_a_segment.seg"), None);
        assert_eq!(parse_segment_id_from_filename("seg_abc_nodes.seg"), None);
        assert_eq!(parse_segment_id_from_filename(""), None);
    }

    #[test]
    fn test_durability_mode_default() {
        assert_eq!(DurabilityMode::default(), DurabilityMode::Strict);
    }

    // ── Phase 3: ManifestStore Core ───────────────────────────────

    #[test]
    fn test_manifest_store_ephemeral() {
        let store = ManifestStore::ephemeral();
        assert!(store.db_path.is_none());
        assert_eq!(store.current().version, 1);
        assert!(store.current().node_segments.is_empty());
    }

    #[test]
    fn test_manifest_store_create_new_database() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let store = ManifestStore::create(&db_path).unwrap();

        assert_eq!(store.current().version, 1);
        assert!(db_path.join("current.json").exists());
        assert!(db_path.join("manifests").join("000001.json").exists());
        assert!(db_path.join("manifest_index.json").exists());
        assert!(db_path.join("segments").exists());
        assert!(db_path.join("gc").exists());
    }

    #[test]
    fn test_manifest_store_create_writes_index() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        ManifestStore::create(&db_path).unwrap();

        let index: ManifestIndex =
            read_json(&db_path.join("manifest_index.json")).unwrap();
        assert_eq!(index.latest_version, 1);
        assert_eq!(index.snapshots.len(), 1);
        assert_eq!(index.snapshots[0].version, 1);
    }

    #[test]
    fn test_manifest_store_create_already_exists() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        ManifestStore::create(&db_path).unwrap();

        let result = ManifestStore::create(&db_path);
        assert!(result.is_err());
    }

    #[test]
    fn test_manifest_store_open_existing() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        {
            let _store = ManifestStore::create(&db_path).unwrap();
        }

        let store = ManifestStore::open(&db_path).unwrap();
        assert_eq!(store.current().version, 1);
    }

    #[test]
    fn test_manifest_store_open_loads_index() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        {
            let mut store = ManifestStore::create(&db_path).unwrap();
            let m = store
                .create_manifest(
                    vec![make_node_descriptor(1, 100)],
                    vec![],
                    None,
                )
                .unwrap();
            store.commit(m).unwrap();
        }

        let store = ManifestStore::open(&db_path).unwrap();
        let snapshots = store.list_snapshots(None);
        assert_eq!(snapshots.len(), 2);
        assert_eq!(snapshots[0].version, 1);
        assert_eq!(snapshots[1].version, 2);
    }

    #[test]
    fn test_manifest_store_commit_updates_index() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        let m = store
            .create_manifest(
                vec![make_node_descriptor(1, 50)],
                vec![make_edge_descriptor(2, 25)],
                None,
            )
            .unwrap();
        store.commit(m).unwrap();

        let snapshots = store.list_snapshots(None);
        assert_eq!(snapshots.len(), 2);
        assert_eq!(snapshots[1].stats.total_nodes, 50);
        assert_eq!(snapshots[1].stats.total_edges, 25);
    }

    #[test]
    fn test_manifest_store_commit_sequential() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 10)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();
        assert_eq!(store.current().version, 2);

        let m3 = store
            .create_manifest(
                vec![make_node_descriptor(1, 10), make_node_descriptor(2, 20)],
                vec![],
                None,
            )
            .unwrap();
        store.commit(m3).unwrap();
        assert_eq!(store.current().version, 3);
    }

    #[test]
    fn test_manifest_store_commit_monotonicity_check() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        // Manually construct a manifest with wrong version
        let bad_manifest = Manifest {
            version: 1, // same as current, should fail
            created_at: current_timestamp(),
            node_segments: vec![],
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&[], &[]),
            parent_version: None,
        };

        let result = store.commit(bad_manifest);
        assert!(result.is_err());
    }

    #[test]
    fn test_manifest_store_commit_duplicate_segment_id() {
        let store = ManifestStore::ephemeral();
        let result = store.create_manifest(
            vec![make_node_descriptor(1, 10), make_node_descriptor(1, 20)],
            vec![],
            None,
        );
        assert!(result.is_err());
    }

    #[test]
    fn test_manifest_store_load_manifest() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 42)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();

        let loaded_v1 = store.load_manifest(1).unwrap();
        assert_eq!(loaded_v1.version, 1);
        assert!(loaded_v1.node_segments.is_empty());

        let loaded_v2 = store.load_manifest(2).unwrap();
        assert_eq!(loaded_v2.version, 2);
        assert_eq!(loaded_v2.node_segments.len(), 1);
        assert_eq!(loaded_v2.node_segments[0].record_count, 42);
    }

    #[test]
    fn test_manifest_store_load_manifest_ephemeral() {
        let store = ManifestStore::ephemeral();
        let loaded = store.load_manifest(1).unwrap();
        assert_eq!(loaded.version, 1);

        let err = store.load_manifest(99);
        assert!(err.is_err());
    }

    #[test]
    fn test_manifest_store_next_segment_id_increments() {
        let store = ManifestStore::ephemeral();
        assert_eq!(store.next_segment_id(), 1);
        assert_eq!(store.next_segment_id(), 2);
        assert_eq!(store.next_segment_id(), 3);
    }

    // ── Phase 4: Snapshot Operations ──────────────────────────────

    #[test]
    fn test_find_snapshot_by_tag_via_index() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        let m2 = store
            .create_manifest(
                vec![make_node_descriptor(1, 10)],
                vec![],
                Some(HashMap::from([
                    ("commit_sha".to_string(), "abc123".to_string()),
                ])),
            )
            .unwrap();
        store.commit(m2).unwrap();

        assert_eq!(store.find_snapshot("commit_sha", "abc123"), Some(2));
        assert_eq!(store.find_snapshot("commit_sha", "other"), None);
        assert_eq!(store.find_snapshot("nonexistent", "abc123"), None);
    }

    #[test]
    fn test_find_snapshot_not_found() {
        let store = ManifestStore::ephemeral();
        assert_eq!(store.find_snapshot("key", "value"), None);
    }

    #[test]
    fn test_list_snapshots_all_via_index() {
        let mut store = ManifestStore::ephemeral();

        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 10)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();

        let m3 = store
            .create_manifest(vec![make_node_descriptor(2, 20)], vec![], None)
            .unwrap();
        store.commit(m3).unwrap();

        let all = store.list_snapshots(None);
        assert_eq!(all.len(), 3);
        assert_eq!(all[0].version, 1);
        assert_eq!(all[1].version, 2);
        assert_eq!(all[2].version, 3);
    }

    #[test]
    fn test_list_snapshots_filtered_by_tag() {
        let mut store = ManifestStore::ephemeral();

        let m2 = store
            .create_manifest(
                vec![],
                vec![],
                Some(HashMap::from([
                    ("release".to_string(), "v1.0".to_string()),
                ])),
            )
            .unwrap();
        store.commit(m2).unwrap();

        let m3 = store.create_manifest(vec![], vec![], None).unwrap();
        store.commit(m3).unwrap();

        let filtered = store.list_snapshots(Some("release"));
        assert_eq!(filtered.len(), 1);
        assert_eq!(filtered[0].version, 2);
    }

    #[test]
    fn test_tag_snapshot_updates_index() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        store
            .tag_snapshot(
                1,
                HashMap::from([("env".to_string(), "prod".to_string())]),
            )
            .unwrap();

        assert_eq!(store.find_snapshot("env", "prod"), Some(1));
        // Current manifest cache should be updated
        assert_eq!(
            store.current().tags.get("env").map(|s| s.as_str()),
            Some("prod")
        );
    }

    #[test]
    fn test_tag_snapshot_persists_after_reopen() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        {
            let mut store = ManifestStore::create(&db_path).unwrap();
            store
                .tag_snapshot(
                    1,
                    HashMap::from([("env".to_string(), "staging".to_string())]),
                )
                .unwrap();
        }

        let store = ManifestStore::open(&db_path).unwrap();
        assert_eq!(store.find_snapshot("env", "staging"), Some(1));
        assert_eq!(
            store.current().tags.get("env").map(|s| s.as_str()),
            Some("staging")
        );
    }

    #[test]
    fn test_tag_snapshot_ephemeral_errors() {
        let mut store = ManifestStore::ephemeral();
        let result = store.tag_snapshot(1, HashMap::from([("k".into(), "v".into())]));
        assert!(result.is_err());
    }

    // ── Phase 5: Diff Computation ─────────────────────────────────

    #[test]
    fn test_diff_empty_to_populated() {
        let from = Manifest {
            version: 1,
            created_at: 100,
            node_segments: vec![],
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&[], &[]),
            parent_version: None,
        };

        let to_nodes = vec![make_node_descriptor(1, 10), make_node_descriptor(2, 20)];
        let to_edges = vec![make_edge_descriptor(3, 5)];
        let to = Manifest {
            version: 2,
            created_at: 200,
            node_segments: to_nodes.clone(),
            edge_segments: to_edges.clone(),
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&to_nodes, &to_edges),
            parent_version: Some(1),
        };

        let diff = SnapshotDiff::compute(&from, &to);
        assert_eq!(diff.added_node_segments.len(), 2);
        assert_eq!(diff.removed_node_segments.len(), 0);
        assert_eq!(diff.added_edge_segments.len(), 1);
        assert_eq!(diff.removed_edge_segments.len(), 0);
        assert_eq!(diff.change_count(), 3);
        assert!(!diff.is_empty());
    }

    #[test]
    fn test_diff_same_version() {
        let nodes = vec![make_node_descriptor(1, 10)];
        let m = Manifest {
            version: 1,
            created_at: 100,
            node_segments: nodes.clone(),
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&nodes, &[]),
            parent_version: None,
        };

        let diff = SnapshotDiff::compute(&m, &m);
        assert!(diff.is_empty());
        assert_eq!(diff.change_count(), 0);
    }

    #[test]
    fn test_diff_mixed_changes() {
        let from_nodes = vec![make_node_descriptor(1, 10), make_node_descriptor(2, 20)];
        let from = Manifest {
            version: 1,
            created_at: 100,
            node_segments: from_nodes.clone(),
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&from_nodes, &[]),
            parent_version: None,
        };

        // Remove segment 2, add segments 3 and 4
        let to_nodes = vec![make_node_descriptor(1, 10), make_node_descriptor(3, 30)];
        let to_edges = vec![make_edge_descriptor(4, 15)];
        let to = Manifest {
            version: 2,
            created_at: 200,
            node_segments: to_nodes.clone(),
            edge_segments: to_edges.clone(),
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&to_nodes, &to_edges),
            parent_version: Some(1),
        };

        let diff = SnapshotDiff::compute(&from, &to);
        assert_eq!(diff.added_node_segments.len(), 1); // seg 3
        assert_eq!(diff.added_node_segments[0].segment_id, 3);
        assert_eq!(diff.removed_node_segments.len(), 1); // seg 2
        assert_eq!(diff.removed_node_segments[0].segment_id, 2);
        assert_eq!(diff.added_edge_segments.len(), 1); // seg 4
        assert_eq!(diff.removed_edge_segments.len(), 0);
    }

    #[test]
    fn test_diff_stats_match() {
        let from_nodes = vec![make_node_descriptor(1, 100)];
        let from = Manifest {
            version: 1,
            created_at: 100,
            node_segments: from_nodes.clone(),
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&from_nodes, &[]),
            parent_version: None,
        };

        let to_nodes = vec![make_node_descriptor(2, 200)];
        let to = Manifest {
            version: 2,
            created_at: 200,
            node_segments: to_nodes.clone(),
            edge_segments: vec![],
            tags: HashMap::new(),
            stats: ManifestStats::from_segments(&to_nodes, &[]),
            parent_version: Some(1),
        };

        let diff = SnapshotDiff::compute(&from, &to);
        assert_eq!(diff.stats_from.total_nodes, 100);
        assert_eq!(diff.stats_to.total_nodes, 200);
    }

    #[test]
    fn test_diff_snapshots_via_store() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 50)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();

        let diff = store.diff_snapshots(1, 2).unwrap();
        assert_eq!(diff.added_node_segments.len(), 1);
        assert_eq!(diff.removed_node_segments.len(), 0);
    }

    // ── Phase 6: Garbage Collection ───────────────────────────────

    #[test]
    fn test_gc_collect_unreferenced() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        // Commit v2 with segment 1
        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 10)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();

        // Commit v3 with segment 2 (segment 1 no longer referenced by current,
        // but still in index.referenced_segments because index tracks ALL)
        let m3 = store
            .create_manifest(vec![make_node_descriptor(2, 20)], vec![], None)
            .unwrap();
        store.commit(m3).unwrap();

        // Create fake segment files
        let seg_dir = db_path.join("segments");
        std::fs::write(seg_dir.join("seg_000001_nodes.seg"), b"data1").unwrap();
        std::fs::write(seg_dir.join("seg_000002_nodes.seg"), b"data2").unwrap();
        std::fs::write(seg_dir.join("seg_000099_nodes.seg"), b"orphan").unwrap();

        // seg 1 and 2 are referenced, seg 99 is not
        let moved = store.gc_collect().unwrap();
        assert_eq!(moved.len(), 1);
        assert!(moved[0].contains("seg_000099"));

        // Original should be gone, gc/ should have it
        assert!(!seg_dir.join("seg_000099_nodes.seg").exists());
        assert!(db_path.join("gc").join("seg_000099_nodes.seg").exists());
    }

    #[test]
    fn test_gc_collect_preserves_referenced() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let mut store = ManifestStore::create(&db_path).unwrap();

        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 10)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();

        let seg_dir = db_path.join("segments");
        std::fs::write(seg_dir.join("seg_000001_nodes.seg"), b"data1").unwrap();

        let moved = store.gc_collect().unwrap();
        assert!(moved.is_empty());
        assert!(seg_dir.join("seg_000001_nodes.seg").exists());
    }

    #[test]
    fn test_gc_purge_deletes_files() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");
        let store = ManifestStore::create(&db_path).unwrap();

        let gc_dir = db_path.join("gc");
        std::fs::write(gc_dir.join("seg_000001_nodes.seg"), b"old1").unwrap();
        std::fs::write(gc_dir.join("seg_000002_edges.seg"), b"old2").unwrap();
        std::fs::write(gc_dir.join("seg_000003_nodes.seg"), b"old3").unwrap();

        let deleted = store.gc_purge().unwrap();
        assert_eq!(deleted, 3);

        assert!(!gc_dir.join("seg_000001_nodes.seg").exists());
        assert!(!gc_dir.join("seg_000002_edges.seg").exists());
        assert!(!gc_dir.join("seg_000003_nodes.seg").exists());
    }

    #[test]
    fn test_gc_ephemeral_no_op() {
        let store = ManifestStore::ephemeral();
        assert!(store.gc_collect().unwrap().is_empty());
        assert_eq!(store.gc_purge().unwrap(), 0);
    }

    // ── Phase 7: Index Consistency ────────────────────────────────

    #[test]
    fn test_index_consistency_rebuild_on_open() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        // Create database and commit v2
        {
            let mut store = ManifestStore::create(&db_path).unwrap();
            let m2 = store
                .create_manifest(
                    vec![make_node_descriptor(1, 10)],
                    vec![],
                    Some(HashMap::from([
                        ("key".to_string(), "value".to_string()),
                    ])),
                )
                .unwrap();
            store.commit(m2).unwrap();
        }

        // Simulate crash: corrupt the index by writing an old version
        let stale_index = ManifestIndex {
            latest_version: 1, // out of sync with current.json (version 2)
            snapshots: vec![],
            tag_index: HashMap::new(),
            referenced_segments: HashSet::new(),
        };
        atomic_write_json(
            &db_path.join("manifest_index.json"),
            &stale_index,
            DurabilityMode::Relaxed,
        )
        .unwrap();

        // Open should detect inconsistency and rebuild
        let store = ManifestStore::open(&db_path).unwrap();
        assert_eq!(store.current().version, 2);

        // Rebuilt index should have both snapshots
        let snapshots = store.list_snapshots(None);
        assert_eq!(snapshots.len(), 2);

        // Tags should be recovered
        assert_eq!(store.find_snapshot("key", "value"), Some(2));

        // Referenced segments should be recovered
        assert!(store.index.referenced_segments.contains(&1));
    }

    #[test]
    fn test_current_pointer_roundtrip() {
        let dir = TempDir::new().unwrap();
        let ptr = CurrentPointer::new(42);
        ptr.write_to(dir.path(), DurabilityMode::Relaxed).unwrap();
        let loaded = CurrentPointer::read_from(dir.path()).unwrap();
        assert_eq!(loaded.version, 42);
    }

    #[test]
    fn test_snapshot_info_from_manifest() {
        let m = Manifest {
            version: 3,
            created_at: 300,
            node_segments: vec![make_node_descriptor(1, 100)],
            edge_segments: vec![],
            tags: HashMap::from([("env".to_string(), "test".to_string())]),
            stats: ManifestStats::from_segments(&[make_node_descriptor(1, 100)], &[]),
            parent_version: Some(2),
        };

        let info = SnapshotInfo::from_manifest(&m);
        assert_eq!(info.version, 3);
        assert_eq!(info.created_at, 300);
        assert_eq!(info.tags.get("env").map(|s| s.as_str()), Some("test"));
        assert_eq!(info.stats.total_nodes, 100);
    }

    #[test]
    fn test_manifest_file_path() {
        let path = manifest_file_path(Path::new("/db"), 42);
        assert_eq!(path, PathBuf::from("/db/manifests/000042.json"));

        let path = manifest_file_path(Path::new("/db"), 1);
        assert_eq!(path, PathBuf::from("/db/manifests/000001.json"));
    }

    #[test]
    fn test_ephemeral_commit_no_monotonicity_check() {
        // Ephemeral stores skip version monotonicity since there's no disk
        let mut store = ManifestStore::ephemeral();
        let m2 = store.create_manifest(vec![], vec![], None).unwrap();
        store.commit(m2).unwrap();
        assert_eq!(store.current().version, 2);

        let m3 = store.create_manifest(vec![], vec![], None).unwrap();
        store.commit(m3).unwrap();
        assert_eq!(store.current().version, 3);
    }

    #[test]
    fn test_next_segment_id_after_open() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        {
            let mut store = ManifestStore::create(&db_path).unwrap();
            let m2 = store
                .create_manifest(
                    vec![make_node_descriptor(5, 10)],
                    vec![make_edge_descriptor(10, 5)],
                    None,
                )
                .unwrap();
            store.commit(m2).unwrap();
        }

        let store = ManifestStore::open(&db_path).unwrap();
        // max referenced segment ID is 10, so next should be 11
        assert_eq!(store.next_segment_id(), 11);
        assert_eq!(store.next_segment_id(), 12);
    }

    // ── Integration: Crash Simulation ────────────────────────────

    #[test]
    fn test_crash_simulation_manifest_written_but_not_current() {
        // Simulate crash: manifest v2 written to disk, but current.json
        // still points to v1 (crash before current pointer update).
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        let mut store =
            ManifestStore::create_with_config(&db_path, DurabilityMode::Relaxed).unwrap();
        let m2 = store
            .create_manifest(
                vec![make_node_descriptor(1, 100)],
                vec![],
                Some(HashMap::from([("run".into(), "second".into())])),
            )
            .unwrap();
        store.commit(m2).unwrap();
        drop(store);

        // Now manually simulate crash: write manifest v3 file but
        // revert current.json back to v2
        let manifest_v3 = Manifest {
            version: 3,
            created_at: current_timestamp(),
            node_segments: vec![make_node_descriptor(2, 200)],
            edge_segments: vec![],
            tags: HashMap::from([("run".into(), "third".into())]),
            stats: ManifestStats::from_segments(
                &[make_node_descriptor(2, 200)],
                &[],
            ),
            parent_version: Some(2),
        };
        let manifest_path = manifest_file_path(&db_path, 3);
        atomic_write_json(&manifest_path, &manifest_v3, DurabilityMode::Relaxed).unwrap();

        // current.json still points to v2 (crash before pointer update)
        // index may or may not be updated — doesn't matter, consistency
        // check on open() will fix it.

        // Reopen — must succeed, pointing to v2
        let store = ManifestStore::open(&db_path).unwrap();
        assert_eq!(store.current().version, 2);
        assert_eq!(store.current().node_segments.len(), 1);
        assert_eq!(store.current().node_segments[0].segment_id, 1);
    }

    #[test]
    fn test_crash_simulation_index_written_but_not_current() {
        // Simulate crash: index updated to v3, but current.json still
        // points to v2. On reopen, index must be rebuilt to match v2.
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        let mut store =
            ManifestStore::create_with_config(&db_path, DurabilityMode::Relaxed).unwrap();
        let m2 = store
            .create_manifest(vec![make_node_descriptor(1, 100)], vec![], None)
            .unwrap();
        store.commit(m2).unwrap();
        drop(store);

        // Corrupt index: set latest_version to 3 (ahead of current=2)
        let index_path = db_path.join("manifest_index.json");
        let mut index: ManifestIndex = read_json(&index_path).unwrap();
        index.latest_version = 3;
        atomic_write_json(&index_path, &index, DurabilityMode::Relaxed).unwrap();

        // Reopen — should detect mismatch and rebuild
        let store = ManifestStore::open(&db_path).unwrap();
        assert_eq!(store.current().version, 2);

        // Index should be rebuilt correctly
        let snapshots = store.list_snapshots(None);
        assert_eq!(snapshots.len(), 2); // v1 + v2
        assert_eq!(snapshots[0].version, 1);
        assert_eq!(snapshots[1].version, 2);
    }

    #[test]
    fn test_crash_simulation_current_json_always_valid() {
        // Verify that no matter what state the DB is in after a partial
        // commit, current.json always points to a valid manifest.
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        let mut store =
            ManifestStore::create_with_config(&db_path, DurabilityMode::Relaxed).unwrap();

        // Commit 5 versions successfully
        for i in 0..5 {
            let m = store
                .create_manifest(
                    vec![make_node_descriptor(i + 1, (i + 1) * 10)],
                    vec![],
                    None,
                )
                .unwrap();
            store.commit(m).unwrap();
        }
        assert_eq!(store.current().version, 6);
        drop(store);

        // current.json always points to a loadable manifest
        let pointer = CurrentPointer::read_from(&db_path).unwrap();
        let manifest = load_manifest_file(&db_path, pointer.version).unwrap();
        assert_eq!(manifest.version, pointer.version);

        // Reopen succeeds
        let store = ManifestStore::open(&db_path).unwrap();
        assert_eq!(store.current().version, 6);
    }

    // ── Integration: Concurrent Reader Isolation ─────────────────

    #[test]
    fn test_concurrent_reader_isolation() {
        // Reader loads manifest v1. Writer commits v2. Reader still
        // sees v1 (snapshot isolation via immutable files).
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        let mut store =
            ManifestStore::create_with_config(&db_path, DurabilityMode::Relaxed).unwrap();
        let m2 = store
            .create_manifest(
                vec![make_node_descriptor(1, 100)],
                vec![],
                None,
            )
            .unwrap();
        store.commit(m2).unwrap();
        drop(store);

        // "Reader" opens DB, gets snapshot of v2
        let reader_path = db_path.clone();
        let reader_handle = std::thread::spawn(move || {
            let reader_store = ManifestStore::open(&reader_path).unwrap();
            let snapshot_version = reader_store.current().version;
            let snapshot_nodes = reader_store.current().stats.total_nodes;

            // Sleep to let writer commit
            std::thread::sleep(std::time::Duration::from_millis(50));

            // Reader still sees its original snapshot
            let reloaded = reader_store.load_manifest(snapshot_version).unwrap();
            assert_eq!(reloaded.version, snapshot_version);
            assert_eq!(reloaded.stats.total_nodes, snapshot_nodes);

            snapshot_version
        });

        // Give reader time to open
        std::thread::sleep(std::time::Duration::from_millis(10));

        // "Writer" opens same DB and commits v3
        let mut writer_store = ManifestStore::open(&db_path).unwrap();
        let m3 = writer_store
            .create_manifest(
                vec![make_node_descriptor(2, 200), make_node_descriptor(3, 300)],
                vec![],
                None,
            )
            .unwrap();
        writer_store.commit(m3).unwrap();
        assert_eq!(writer_store.current().version, 3);

        // Reader completes — it should have seen v2 (its snapshot)
        let reader_version = reader_handle.join().unwrap();
        assert_eq!(reader_version, 2);

        // Writer sees v3
        assert_eq!(writer_store.current().version, 3);
    }

    #[test]
    fn test_concurrent_manifest_files_immutable() {
        // Verify that committing a new version doesn't modify old
        // manifest files (immutability guarantee).
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.rfdb");

        let mut store =
            ManifestStore::create_with_config(&db_path, DurabilityMode::Relaxed).unwrap();

        // Commit v2
        let m2 = store
            .create_manifest(
                vec![make_node_descriptor(1, 100)],
                vec![],
                None,
            )
            .unwrap();
        store.commit(m2).unwrap();

        // Read v1 manifest file content
        let v1_before: Manifest =
            read_json(&manifest_file_path(&db_path, 1)).unwrap();

        // Commit v3
        let m3 = store
            .create_manifest(
                vec![make_node_descriptor(2, 200)],
                vec![],
                None,
            )
            .unwrap();
        store.commit(m3).unwrap();

        // v1 manifest file must be unchanged
        let v1_after: Manifest =
            read_json(&manifest_file_path(&db_path, 1)).unwrap();
        assert_eq!(v1_before, v1_after);

        // v2 manifest file must be unchanged
        let v2_loaded: Manifest =
            read_json(&manifest_file_path(&db_path, 2)).unwrap();
        assert_eq!(v2_loaded.version, 2);
        assert_eq!(v2_loaded.node_segments[0].segment_id, 1);
    }
}
