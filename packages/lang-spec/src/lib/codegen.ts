/**
 * TypeScript code generation utilities for plugin scaffolding.
 *
 * Generates:
 * - ANALYSIS plugin class (walk-phase nodes and edges)
 * - ENRICHMENT plugin classes (post-file and post-project edges)
 * - Test file scaffolds using node:test
 */

import type {
  Rule,
  TestCase,
  GeneratedPluginFile,
} from '../types.js';

/**
 * Generate an ANALYSIS plugin class that handles walk-phase nodes and edges.
 */
export function generateAnalysisPlugin(
  language: string,
  rules: Rule[],
  walkEdgeTypes: string[],
  walkNodeTypes: string[],
): { code: string; pluginFile: GeneratedPluginFile } {
  const className = capitalize(language) + 'Analyzer';
  const fileName = `${language}-analyzer.ts`;

  const ruleLines = rules.map((rule) => {
    const condStr = JSON.stringify(rule.conditions);
    const nodesStr = JSON.stringify(rule.emitNodes);
    const edgesStr = JSON.stringify(rule.emitEdges);
    return `    // Derived from: ${rule.derivedFrom.join(', ')}\n` +
      `    { astNodeType: ${JSON.stringify(rule.astNodeType)}, conditions: ${condStr}, emitNodes: ${nodesStr}, emitEdges: ${edgesStr} },`;
  }).join('\n');

  const code = `/**
 * ${className} — Generated ANALYSIS plugin for ${language}
 *
 * Auto-generated by @grafema/lang-spec stage 10.
 * Handles walk-phase graph creation during AST traversal.
 *
 * Creates: ${walkNodeTypes.join(', ')} (nodes)
 * Creates: ${walkEdgeTypes.join(', ')} (edges)
 */

import type { Plugin, PluginMetadata, PluginContext } from '@grafema/types';

interface RuleCondition {
  field: string;
  op: 'eq' | 'neq' | 'in' | 'exists' | 'not_exists';
  value?: unknown;
}

interface AnalysisRule {
  astNodeType: string;
  conditions: RuleCondition[];
  emitNodes: Array<{ type: string; idTemplate: string; metadataMap: Record<string, string> }>;
  emitEdges: Array<{ type: string; srcRef: string; dstRef: string; phase: string }>;
}

const RULES: AnalysisRule[] = [
${ruleLines}
];

export class ${className} implements Plugin {
  readonly metadata: PluginMetadata = {
    name: '${language}-analyzer',
    version: '0.1.0',
    phase: 'ANALYSIS',
    creates: {
      nodes: ${JSON.stringify(walkNodeTypes)},
      edges: ${JSON.stringify(walkEdgeTypes)},
    },
  };

  async execute(context: PluginContext): Promise<void> {
    for (const rule of RULES) {
      void rule;
    }
    void context;
  }
}
`;

  return {
    code,
    pluginFile: {
      path: fileName,
      className,
      phase: 'ANALYSIS',
      createsNodes: walkNodeTypes,
      createsEdges: walkEdgeTypes,
      dependencies: ['@grafema/types'],
      consumes: [],
      produces: walkNodeTypes,
    },
  };
}

/**
 * Generate an ENRICHMENT plugin class for post-file or post-project edges.
 */
export function generateEnrichmentPlugin(
  language: string,
  phase: 'post-file' | 'post-project',
  edgeTypes: string[],
  nodeTypesConsumed: string[],
): { code: string; pluginFile: GeneratedPluginFile } {
  const suffix = phase === 'post-file' ? 'PostFileEnricher' : 'PostProjectEnricher';
  const className = capitalize(language) + suffix;
  const fileName = phase === 'post-file'
    ? `${language}-post-file-enricher.ts`
    : `${language}-post-project-enricher.ts`;

  const edgeComments = edgeTypes.map((et) =>
    `    // ${et}: resolve references and create edges`,
  ).join('\n');

  const code = `/**
 * ${className} — Generated ENRICHMENT plugin for ${language}
 *
 * Auto-generated by @grafema/lang-spec stage 10.
 * Handles ${phase} edge creation after initial AST traversal.
 *
 * Consumes: ${nodeTypesConsumed.join(', ')} (nodes)
 * Creates: ${edgeTypes.join(', ')} (edges)
 */

import type { Plugin, PluginMetadata, PluginContext } from '@grafema/types';

export class ${className} implements Plugin {
  readonly metadata: PluginMetadata = {
    name: '${language}-${phase}-enricher',
    version: '0.1.0',
    phase: 'ENRICHMENT',
    consumes: ${JSON.stringify(nodeTypesConsumed)},
    produces: ${JSON.stringify(edgeTypes)},
    creates: {
      nodes: [],
      edges: ${JSON.stringify(edgeTypes)},
    },
  };

  async execute(context: PluginContext): Promise<void> {
${edgeComments}
    void context;
  }
}
`;

  return {
    code,
    pluginFile: {
      path: fileName,
      className,
      phase: 'ENRICHMENT',
      createsNodes: [],
      createsEdges: edgeTypes,
      dependencies: ['@grafema/types'],
      consumes: nodeTypesConsumed,
      produces: edgeTypes,
    },
  };
}

/**
 * Generate a test file for walk-phase test cases using node:test.
 */
export function generateWalkTests(
  language: string,
  cases: TestCase[],
): string {
  const className = capitalize(language) + 'Analyzer';
  const walkCases = cases.filter(
    (c) => c.expectedEdges.walk.length > 0 || c.expectedNodes.length > 0,
  );

  const testBlocks = walkCases.map((tc) => {
    const nodeAssertions = tc.expectedNodes.map((n) =>
      `    // Expect node: ${n.type} ${n.id}`,
    ).join('\n');

    const edgeAssertions = tc.expectedEdges.walk.map((e) =>
      `    // Expect edge: ${e.src} -[${e.type}]-> ${e.dst}`,
    ).join('\n');

    return `  test('${escapeTestName(tc.constructId)}', () => {
    const code = ${JSON.stringify(tc.code)};
${nodeAssertions}
${edgeAssertions}
    void code;
  });`;
  }).join('\n\n');

  return `/**
 * Walk-phase tests for ${className}
 *
 * Auto-generated by @grafema/lang-spec stage 10.
 * ${walkCases.length} test cases from annotated corpus.
 */

import { describe, test } from 'node:test';

describe('${className} — walk phase', () => {
${testBlocks}
});
`;
}

/**
 * Generate a test file for enrichment-phase test cases using node:test.
 */
export function generateEnrichmentTests(
  language: string,
  cases: TestCase[],
): string {
  const postFileCases = cases.filter((c) => c.expectedEdges.postFile.length > 0);
  const postProjectCases = cases.filter((c) => c.expectedEdges.postProject.length > 0);

  const postFileBlocks = postFileCases.map((tc) => {
    const edgeAssertions = tc.expectedEdges.postFile.map((e) =>
      `    // Expect edge: ${e.src} -[${e.type}]-> ${e.dst}`,
    ).join('\n');

    return `  test('${escapeTestName(tc.constructId)}', () => {
    const code = ${JSON.stringify(tc.code)};
${edgeAssertions}
    void code;
  });`;
  }).join('\n\n');

  const postProjectBlocks = postProjectCases.map((tc) => {
    const edgeAssertions = tc.expectedEdges.postProject.map((e) =>
      `    // Expect edge: ${e.src} -[${e.type}]-> ${e.dst}`,
    ).join('\n');

    return `  test('${escapeTestName(tc.constructId)}', () => {
    const code = ${JSON.stringify(tc.code)};
${edgeAssertions}
    void code;
  });`;
  }).join('\n\n');

  return `/**
 * Enrichment-phase tests for ${language}
 *
 * Auto-generated by @grafema/lang-spec stage 10.
 * ${postFileCases.length} post-file cases, ${postProjectCases.length} post-project cases.
 */

import { describe, test } from 'node:test';

describe('${capitalize(language)} post-file enrichment', () => {
${postFileBlocks}
});

describe('${capitalize(language)} post-project enrichment', () => {
${postProjectBlocks}
});
`;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function escapeTestName(name: string): string {
  return name.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}
